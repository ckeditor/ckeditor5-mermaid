import { Command as S2, Plugin as C2, toWidget as Lj, uid as Rj, global as Mj, WidgetToolbarRepository as K7, ButtonView as Nb } from "ckeditor5";
var X5 = {
  name: "mermaid",
  version: "11.12.2",
  description: "Markdown-ish syntax for generating flowcharts, mindmaps, sequence diagrams, class diagrams, gantt charts, git graphs and more.",
  type: "module",
  module: "./dist/mermaid.core.mjs",
  types: "./dist/mermaid.d.ts",
  exports: {
    ".": {
      types: "./dist/mermaid.d.ts",
      import: "./dist/mermaid.core.mjs",
      default: "./dist/mermaid.core.mjs"
    },
    "./*": "./*"
  },
  keywords: [
    "diagram",
    "markdown",
    "flowchart",
    "sequence diagram",
    "gantt",
    "class diagram",
    "git graph",
    "mindmap",
    "packet diagram",
    "c4 diagram",
    "er diagram",
    "pie chart",
    "pie diagram",
    "quadrant chart",
    "requirement diagram",
    "graph"
  ],
  scripts: {
    clean: "rimraf dist",
    dev: "pnpm -w dev",
    "docs:code": "typedoc src/defaultConfig.ts src/config.ts src/mermaid.ts && prettier --write ./src/docs/config/setup",
    "docs:build": "rimraf ../../docs && pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts",
    "docs:verify": "pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts --verify",
    "docs:pre:vitepress": "pnpm --filter ./src/docs prefetch && rimraf src/vitepress && pnpm docs:code && tsx scripts/docs.cli.mts --vitepress && pnpm --filter ./src/vitepress install --no-frozen-lockfile --ignore-scripts",
    "docs:build:vitepress": "pnpm docs:pre:vitepress && (cd src/vitepress && pnpm run build) && cpy --flat src/docs/landing/ ./src/vitepress/.vitepress/dist/landing",
    "docs:dev": 'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev" "tsx scripts/docs.cli.mts --watch --vitepress"',
    "docs:dev:docker": 'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev:docker" "tsx scripts/docs.cli.mts --watch --vitepress"',
    "docs:serve": "pnpm docs:build:vitepress && vitepress serve src/vitepress",
    "docs:spellcheck": 'cspell "src/docs/**/*.md"',
    "docs:release-version": "tsx scripts/update-release-version.mts",
    "docs:verify-version": "tsx scripts/update-release-version.mts --verify",
    "types:build-config": "tsx scripts/create-types-from-json-schema.mts",
    "types:verify-config": "tsx scripts/create-types-from-json-schema.mts --verify",
    checkCircle: "npx madge --circular ./src",
    prepublishOnly: "pnpm docs:verify-version"
  },
  repository: {
    type: "git",
    url: "https://github.com/mermaid-js/mermaid"
  },
  author: "Knut Sveidqvist",
  license: "MIT",
  standard: {
    ignore: [
      "**/parser/*.js",
      "dist/**/*.js",
      "cypress/**/*.js"
    ],
    globals: [
      "page"
    ]
  },
  dependencies: {
    "@braintree/sanitize-url": "^7.1.1",
    "@iconify/utils": "^3.0.1",
    "@mermaid-js/parser": "workspace:^",
    "@types/d3": "^7.4.3",
    cytoscape: "^3.29.3",
    "cytoscape-cose-bilkent": "^4.1.0",
    "cytoscape-fcose": "^2.2.0",
    d3: "^7.9.0",
    "d3-sankey": "^0.12.3",
    "dagre-d3-es": "7.0.13",
    dayjs: "^1.11.18",
    dompurify: "^3.2.5",
    katex: "^0.16.22",
    khroma: "^2.1.0",
    "lodash-es": "^4.17.21",
    marked: "^16.2.1",
    roughjs: "^4.6.6",
    stylis: "^4.3.6",
    "ts-dedent": "^2.2.0",
    uuid: "^11.1.0"
  },
  devDependencies: {
    "@adobe/jsonschema2md": "^8.0.5",
    "@iconify/types": "^2.0.0",
    "@types/cytoscape": "^3.21.9",
    "@types/cytoscape-fcose": "^2.2.4",
    "@types/d3-sankey": "^0.12.4",
    "@types/d3-scale": "^4.0.9",
    "@types/d3-scale-chromatic": "^3.1.0",
    "@types/d3-selection": "^3.0.11",
    "@types/d3-shape": "^3.1.7",
    "@types/jsdom": "^21.1.7",
    "@types/katex": "^0.16.7",
    "@types/lodash-es": "^4.17.12",
    "@types/micromatch": "^4.0.9",
    "@types/stylis": "^4.2.7",
    "@types/uuid": "^10.0.0",
    ajv: "^8.17.1",
    canvas: "^3.1.2",
    chokidar: "3.6.0",
    concurrently: "^9.1.2",
    "csstree-validator": "^4.0.1",
    globby: "^14.1.0",
    jison: "^0.4.18",
    "js-base64": "^3.7.8",
    jsdom: "^26.1.0",
    "json-schema-to-typescript": "^15.0.4",
    micromatch: "^4.0.8",
    "path-browserify": "^1.0.1",
    prettier: "^3.5.3",
    remark: "^15.0.1",
    "remark-frontmatter": "^5.0.0",
    "remark-gfm": "^4.0.1",
    rimraf: "^6.0.1",
    "start-server-and-test": "^2.0.13",
    "type-fest": "^4.35.0",
    typedoc: "^0.28.12",
    "typedoc-plugin-markdown": "^4.8.1",
    typescript: "~5.7.3",
    "unist-util-flatmap": "^1.0.0",
    "unist-util-visit": "^5.0.0",
    vitepress: "^1.6.4",
    "vitepress-plugin-search": "1.0.4-alpha.22"
  },
  files: [
    "dist/",
    "README.md"
  ],
  publishConfig: {
    access: "public"
  }
};
function $u(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var gm = { exports: {} }, Nj = gm.exports, Z7;
function Ij() {
  return Z7 || (Z7 = 1, (function(t, e) {
    (function(r, n) {
      t.exports = n();
    })(Nj, (function() {
      var r = 1e3, n = 6e4, i = 36e5, a = "millisecond", s = "second", o = "minute", l = "hour", u = "day", h = "week", d = "month", f = "quarter", p = "year", g = "date", m = "Invalid Date", v = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, b = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(S) {
        var M = ["th", "st", "nd", "rd"], N = S % 100;
        return "[" + S + (M[(N - 20) % 10] || M[N] || M[0]) + "]";
      } }, w = function(S, M, N) {
        var D = String(S);
        return !D || D.length >= M ? S : "" + Array(M + 1 - D.length).join(N) + S;
      }, T = { s: w, z: function(S) {
        var M = -S.utcOffset(), N = Math.abs(M), D = Math.floor(N / 60), I = N % 60;
        return (M <= 0 ? "+" : "-") + w(D, 2, "0") + ":" + w(I, 2, "0");
      }, m: function S(M, N) {
        if (M.date() < N.date()) return -S(N, M);
        var D = 12 * (N.year() - M.year()) + (N.month() - M.month()), I = M.clone().add(D, d), B = N - I < 0, z = M.clone().add(D + (B ? -1 : 1), d);
        return +(-(D + (N - I) / (B ? I - z : z - I)) || 0);
      }, a: function(S) {
        return S < 0 ? Math.ceil(S) || 0 : Math.floor(S);
      }, p: function(S) {
        return { M: d, y: p, w: h, d: u, D: g, h: l, m: o, s, ms: a, Q: f }[S] || String(S || "").toLowerCase().replace(/s$/, "");
      }, u: function(S) {
        return S === void 0;
      } }, E = "en", L = {};
      L[E] = b;
      var k = "$isDayjsObject", C = function(S) {
        return S instanceof O || !(!S || !S[k]);
      }, A = function S(M, N, D) {
        var I;
        if (!M) return E;
        if (typeof M == "string") {
          var B = M.toLowerCase();
          L[B] && (I = B), N && (L[B] = N, I = B);
          var z = M.split("-");
          if (!I && z.length > 1) return S(z[0]);
        } else {
          var F = M.name;
          L[F] = M, I = F;
        }
        return !D && I && (E = I), I || !D && E;
      }, R = function(S, M) {
        if (C(S)) return S.clone();
        var N = typeof M == "object" ? M : {};
        return N.date = S, N.args = arguments, new O(N);
      }, _ = T;
      _.l = A, _.i = C, _.w = function(S, M) {
        return R(S, { locale: M.$L, utc: M.$u, x: M.$x, $offset: M.$offset });
      };
      var O = (function() {
        function S(N) {
          this.$L = A(N.locale, null, !0), this.parse(N), this.$x = this.$x || N.x || {}, this[k] = !0;
        }
        var M = S.prototype;
        return M.parse = function(N) {
          this.$d = (function(D) {
            var I = D.date, B = D.utc;
            if (I === null) return /* @__PURE__ */ new Date(NaN);
            if (_.u(I)) return /* @__PURE__ */ new Date();
            if (I instanceof Date) return new Date(I);
            if (typeof I == "string" && !/Z$/i.test(I)) {
              var z = I.match(v);
              if (z) {
                var F = z[2] - 1 || 0, V = (z[7] || "0").substring(0, 3);
                return B ? new Date(Date.UTC(z[1], F, z[3] || 1, z[4] || 0, z[5] || 0, z[6] || 0, V)) : new Date(z[1], F, z[3] || 1, z[4] || 0, z[5] || 0, z[6] || 0, V);
              }
            }
            return new Date(I);
          })(N), this.init();
        }, M.init = function() {
          var N = this.$d;
          this.$y = N.getFullYear(), this.$M = N.getMonth(), this.$D = N.getDate(), this.$W = N.getDay(), this.$H = N.getHours(), this.$m = N.getMinutes(), this.$s = N.getSeconds(), this.$ms = N.getMilliseconds();
        }, M.$utils = function() {
          return _;
        }, M.isValid = function() {
          return this.$d.toString() !== m;
        }, M.isSame = function(N, D) {
          var I = R(N);
          return this.startOf(D) <= I && I <= this.endOf(D);
        }, M.isAfter = function(N, D) {
          return R(N) < this.startOf(D);
        }, M.isBefore = function(N, D) {
          return this.endOf(D) < R(N);
        }, M.$g = function(N, D, I) {
          return _.u(N) ? this[D] : this.set(I, N);
        }, M.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, M.valueOf = function() {
          return this.$d.getTime();
        }, M.startOf = function(N, D) {
          var I = this, B = !!_.u(D) || D, z = _.p(N), F = function(K, Z) {
            var X = _.w(I.$u ? Date.UTC(I.$y, Z, K) : new Date(I.$y, Z, K), I);
            return B ? X : X.endOf(u);
          }, V = function(K, Z) {
            return _.w(I.toDate()[K].apply(I.toDate("s"), (B ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Z)), I);
          }, H = this.$W, J = this.$M, q = this.$D, ae = "set" + (this.$u ? "UTC" : "");
          switch (z) {
            case p:
              return B ? F(1, 0) : F(31, 11);
            case d:
              return B ? F(1, J) : F(0, J + 1);
            case h:
              var re = this.$locale().weekStart || 0, pe = (H < re ? H + 7 : H) - re;
              return F(B ? q - pe : q + (6 - pe), J);
            case u:
            case g:
              return V(ae + "Hours", 0);
            case l:
              return V(ae + "Minutes", 1);
            case o:
              return V(ae + "Seconds", 2);
            case s:
              return V(ae + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, M.endOf = function(N) {
          return this.startOf(N, !1);
        }, M.$set = function(N, D) {
          var I, B = _.p(N), z = "set" + (this.$u ? "UTC" : ""), F = (I = {}, I[u] = z + "Date", I[g] = z + "Date", I[d] = z + "Month", I[p] = z + "FullYear", I[l] = z + "Hours", I[o] = z + "Minutes", I[s] = z + "Seconds", I[a] = z + "Milliseconds", I)[B], V = B === u ? this.$D + (D - this.$W) : D;
          if (B === d || B === p) {
            var H = this.clone().set(g, 1);
            H.$d[F](V), H.init(), this.$d = H.set(g, Math.min(this.$D, H.daysInMonth())).$d;
          } else F && this.$d[F](V);
          return this.init(), this;
        }, M.set = function(N, D) {
          return this.clone().$set(N, D);
        }, M.get = function(N) {
          return this[_.p(N)]();
        }, M.add = function(N, D) {
          var I, B = this;
          N = Number(N);
          var z = _.p(D), F = function(J) {
            var q = R(B);
            return _.w(q.date(q.date() + Math.round(J * N)), B);
          };
          if (z === d) return this.set(d, this.$M + N);
          if (z === p) return this.set(p, this.$y + N);
          if (z === u) return F(1);
          if (z === h) return F(7);
          var V = (I = {}, I[o] = n, I[l] = i, I[s] = r, I)[z] || 1, H = this.$d.getTime() + N * V;
          return _.w(H, this);
        }, M.subtract = function(N, D) {
          return this.add(-1 * N, D);
        }, M.format = function(N) {
          var D = this, I = this.$locale();
          if (!this.isValid()) return I.invalidDate || m;
          var B = N || "YYYY-MM-DDTHH:mm:ssZ", z = _.z(this), F = this.$H, V = this.$m, H = this.$M, J = I.weekdays, q = I.months, ae = I.meridiem, re = function(Z, X, Y, ee) {
            return Z && (Z[X] || Z(D, B)) || Y[X].slice(0, ee);
          }, pe = function(Z) {
            return _.s(F % 12 || 12, Z, "0");
          }, K = ae || function(Z, X, Y) {
            var ee = Z < 12 ? "AM" : "PM";
            return Y ? ee.toLowerCase() : ee;
          };
          return B.replace(y, (function(Z, X) {
            return X || (function(Y) {
              switch (Y) {
                case "YY":
                  return String(D.$y).slice(-2);
                case "YYYY":
                  return _.s(D.$y, 4, "0");
                case "M":
                  return H + 1;
                case "MM":
                  return _.s(H + 1, 2, "0");
                case "MMM":
                  return re(I.monthsShort, H, q, 3);
                case "MMMM":
                  return re(q, H);
                case "D":
                  return D.$D;
                case "DD":
                  return _.s(D.$D, 2, "0");
                case "d":
                  return String(D.$W);
                case "dd":
                  return re(I.weekdaysMin, D.$W, J, 2);
                case "ddd":
                  return re(I.weekdaysShort, D.$W, J, 3);
                case "dddd":
                  return J[D.$W];
                case "H":
                  return String(F);
                case "HH":
                  return _.s(F, 2, "0");
                case "h":
                  return pe(1);
                case "hh":
                  return pe(2);
                case "a":
                  return K(F, V, !0);
                case "A":
                  return K(F, V, !1);
                case "m":
                  return String(V);
                case "mm":
                  return _.s(V, 2, "0");
                case "s":
                  return String(D.$s);
                case "ss":
                  return _.s(D.$s, 2, "0");
                case "SSS":
                  return _.s(D.$ms, 3, "0");
                case "Z":
                  return z;
              }
              return null;
            })(Z) || z.replace(":", "");
          }));
        }, M.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, M.diff = function(N, D, I) {
          var B, z = this, F = _.p(D), V = R(N), H = (V.utcOffset() - this.utcOffset()) * n, J = this - V, q = function() {
            return _.m(z, V);
          };
          switch (F) {
            case p:
              B = q() / 12;
              break;
            case d:
              B = q();
              break;
            case f:
              B = q() / 3;
              break;
            case h:
              B = (J - H) / 6048e5;
              break;
            case u:
              B = (J - H) / 864e5;
              break;
            case l:
              B = J / i;
              break;
            case o:
              B = J / n;
              break;
            case s:
              B = J / r;
              break;
            default:
              B = J;
          }
          return I ? B : _.a(B);
        }, M.daysInMonth = function() {
          return this.endOf(d).$D;
        }, M.$locale = function() {
          return L[this.$L];
        }, M.locale = function(N, D) {
          if (!N) return this.$L;
          var I = this.clone(), B = A(N, D, !0);
          return B && (I.$L = B), I;
        }, M.clone = function() {
          return _.w(this.$d, this);
        }, M.toDate = function() {
          return new Date(this.valueOf());
        }, M.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, M.toISOString = function() {
          return this.$d.toISOString();
        }, M.toString = function() {
          return this.$d.toUTCString();
        }, S;
      })(), P = O.prototype;
      return R.prototype = P, [["$ms", a], ["$s", s], ["$m", o], ["$H", l], ["$W", u], ["$M", d], ["$y", p], ["$D", g]].forEach((function(S) {
        P[S[1]] = function(M) {
          return this.$g(M, S[0], S[1]);
        };
      })), R.extend = function(S, M) {
        return S.$i || (S(M, O, R), S.$i = !0), R;
      }, R.locale = A, R.isDayjs = C, R.unix = function(S) {
        return R(1e3 * S);
      }, R.en = L[E], R.Ls = L, R.p = {}, R;
    }));
  })(gm)), gm.exports;
}
var Dj = Ij();
const Xn = /* @__PURE__ */ $u(Dj);
var yI = Object.defineProperty, x = (t, e) => yI(t, "name", { value: e, configurable: !0 }), A2 = (t, e) => {
  for (var r in e)
    yI(t, r, { get: e[r], enumerable: !0 });
}, Eo = {
  trace: 0,
  debug: 1,
  info: 2,
  warn: 3,
  error: 4,
  fatal: 5
}, ie = {
  trace: /* @__PURE__ */ x((...t) => {
  }, "trace"),
  debug: /* @__PURE__ */ x((...t) => {
  }, "debug"),
  info: /* @__PURE__ */ x((...t) => {
  }, "info"),
  warn: /* @__PURE__ */ x((...t) => {
  }, "warn"),
  error: /* @__PURE__ */ x((...t) => {
  }, "error"),
  fatal: /* @__PURE__ */ x((...t) => {
  }, "fatal")
}, nE = /* @__PURE__ */ x(function(t = "fatal") {
  let e = Eo.fatal;
  typeof t == "string" ? t.toLowerCase() in Eo && (e = Eo[t]) : typeof t == "number" && (e = t), ie.trace = () => {
  }, ie.debug = () => {
  }, ie.info = () => {
  }, ie.warn = () => {
  }, ie.error = () => {
  }, ie.fatal = () => {
  }, e <= Eo.fatal && (ie.fatal = console.error ? console.error.bind(console, Pa("FATAL"), "color: orange") : console.log.bind(console, "\x1B[35m", Pa("FATAL"))), e <= Eo.error && (ie.error = console.error ? console.error.bind(console, Pa("ERROR"), "color: orange") : console.log.bind(console, "\x1B[31m", Pa("ERROR"))), e <= Eo.warn && (ie.warn = console.warn ? console.warn.bind(console, Pa("WARN"), "color: orange") : console.log.bind(console, "\x1B[33m", Pa("WARN"))), e <= Eo.info && (ie.info = console.info ? console.info.bind(console, Pa("INFO"), "color: lightblue") : console.log.bind(console, "\x1B[34m", Pa("INFO"))), e <= Eo.debug && (ie.debug = console.debug ? console.debug.bind(console, Pa("DEBUG"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", Pa("DEBUG"))), e <= Eo.trace && (ie.trace = console.debug ? console.debug.bind(console, Pa("TRACE"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", Pa("TRACE")));
}, "setLogLevel"), Pa = /* @__PURE__ */ x((t) => `%c${Xn().format("ss.SSS")} : ${t} : `, "format");
const mm = {
  /* CLAMP */
  min: {
    r: 0,
    g: 0,
    b: 0,
    s: 0,
    l: 0,
    a: 0
  },
  max: {
    r: 255,
    g: 255,
    b: 255,
    h: 360,
    s: 100,
    l: 100,
    a: 1
  },
  clamp: {
    r: (t) => t >= 255 ? 255 : t < 0 ? 0 : t,
    g: (t) => t >= 255 ? 255 : t < 0 ? 0 : t,
    b: (t) => t >= 255 ? 255 : t < 0 ? 0 : t,
    h: (t) => t % 360,
    s: (t) => t >= 100 ? 100 : t < 0 ? 0 : t,
    l: (t) => t >= 100 ? 100 : t < 0 ? 0 : t,
    a: (t) => t >= 1 ? 1 : t < 0 ? 0 : t
  },
  /* CONVERSION */
  //SOURCE: https://planetcalc.com/7779
  toLinear: (t) => {
    const e = t / 255;
    return t > 0.03928 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92;
  },
  //SOURCE: https://gist.github.com/mjackson/5311256
  hue2rgb: (t, e, r) => (r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? t + (e - t) * 6 * r : r < 1 / 2 ? e : r < 2 / 3 ? t + (e - t) * (2 / 3 - r) * 6 : t),
  hsl2rgb: ({ h: t, s: e, l: r }, n) => {
    if (!e)
      return r * 2.55;
    t /= 360, e /= 100, r /= 100;
    const i = r < 0.5 ? r * (1 + e) : r + e - r * e, a = 2 * r - i;
    switch (n) {
      case "r":
        return mm.hue2rgb(a, i, t + 1 / 3) * 255;
      case "g":
        return mm.hue2rgb(a, i, t) * 255;
      case "b":
        return mm.hue2rgb(a, i, t - 1 / 3) * 255;
    }
  },
  rgb2hsl: ({ r: t, g: e, b: r }, n) => {
    t /= 255, e /= 255, r /= 255;
    const i = Math.max(t, e, r), a = Math.min(t, e, r), s = (i + a) / 2;
    if (n === "l")
      return s * 100;
    if (i === a)
      return 0;
    const o = i - a, l = s > 0.5 ? o / (2 - i - a) : o / (i + a);
    if (n === "s")
      return l * 100;
    switch (i) {
      case t:
        return ((e - r) / o + (e < r ? 6 : 0)) * 60;
      case e:
        return ((r - t) / o + 2) * 60;
      case r:
        return ((t - e) / o + 4) * 60;
      default:
        return -1;
    }
  }
}, Oj = {
  /* API */
  clamp: (t, e, r) => e > r ? Math.min(e, Math.max(r, t)) : Math.min(r, Math.max(e, t)),
  round: (t) => Math.round(t * 1e10) / 1e10
}, Pj = {
  /* API */
  dec2hex: (t) => {
    const e = Math.round(t).toString(16);
    return e.length > 1 ? e : `0${e}`;
  }
}, jt = {
  channel: mm,
  lang: Oj,
  unit: Pj
}, kl = {};
for (let t = 0; t <= 255; t++)
  kl[t] = jt.unit.dec2hex(t);
const vi = {
  ALL: 0,
  RGB: 1,
  HSL: 2
};
let Bj = class {
  constructor() {
    this.type = vi.ALL;
  }
  /* API */
  get() {
    return this.type;
  }
  set(e) {
    if (this.type && this.type !== e)
      throw new Error("Cannot change both RGB and HSL channels at the same time");
    this.type = e;
  }
  reset() {
    this.type = vi.ALL;
  }
  is(e) {
    return this.type === e;
  }
};
class Fj {
  /* CONSTRUCTOR */
  constructor(e, r) {
    this.color = r, this.changed = !1, this.data = e, this.type = new Bj();
  }
  /* API */
  set(e, r) {
    return this.color = r, this.changed = !1, this.data = e, this.type.type = vi.ALL, this;
  }
  /* HELPERS */
  _ensureHSL() {
    const e = this.data, { h: r, s: n, l: i } = e;
    r === void 0 && (e.h = jt.channel.rgb2hsl(e, "h")), n === void 0 && (e.s = jt.channel.rgb2hsl(e, "s")), i === void 0 && (e.l = jt.channel.rgb2hsl(e, "l"));
  }
  _ensureRGB() {
    const e = this.data, { r, g: n, b: i } = e;
    r === void 0 && (e.r = jt.channel.hsl2rgb(e, "r")), n === void 0 && (e.g = jt.channel.hsl2rgb(e, "g")), i === void 0 && (e.b = jt.channel.hsl2rgb(e, "b"));
  }
  /* GETTERS */
  get r() {
    const e = this.data, r = e.r;
    return !this.type.is(vi.HSL) && r !== void 0 ? r : (this._ensureHSL(), jt.channel.hsl2rgb(e, "r"));
  }
  get g() {
    const e = this.data, r = e.g;
    return !this.type.is(vi.HSL) && r !== void 0 ? r : (this._ensureHSL(), jt.channel.hsl2rgb(e, "g"));
  }
  get b() {
    const e = this.data, r = e.b;
    return !this.type.is(vi.HSL) && r !== void 0 ? r : (this._ensureHSL(), jt.channel.hsl2rgb(e, "b"));
  }
  get h() {
    const e = this.data, r = e.h;
    return !this.type.is(vi.RGB) && r !== void 0 ? r : (this._ensureRGB(), jt.channel.rgb2hsl(e, "h"));
  }
  get s() {
    const e = this.data, r = e.s;
    return !this.type.is(vi.RGB) && r !== void 0 ? r : (this._ensureRGB(), jt.channel.rgb2hsl(e, "s"));
  }
  get l() {
    const e = this.data, r = e.l;
    return !this.type.is(vi.RGB) && r !== void 0 ? r : (this._ensureRGB(), jt.channel.rgb2hsl(e, "l"));
  }
  get a() {
    return this.data.a;
  }
  /* SETTERS */
  set r(e) {
    this.type.set(vi.RGB), this.changed = !0, this.data.r = e;
  }
  set g(e) {
    this.type.set(vi.RGB), this.changed = !0, this.data.g = e;
  }
  set b(e) {
    this.type.set(vi.RGB), this.changed = !0, this.data.b = e;
  }
  set h(e) {
    this.type.set(vi.HSL), this.changed = !0, this.data.h = e;
  }
  set s(e) {
    this.type.set(vi.HSL), this.changed = !0, this.data.s = e;
  }
  set l(e) {
    this.type.set(vi.HSL), this.changed = !0, this.data.l = e;
  }
  set a(e) {
    this.changed = !0, this.data.a = e;
  }
}
const _2 = new Fj({ r: 0, g: 0, b: 0, a: 0 }, "transparent"), Wh = {
  /* VARIABLES */
  re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,
  /* API */
  parse: (t) => {
    if (t.charCodeAt(0) !== 35)
      return;
    const e = t.match(Wh.re);
    if (!e)
      return;
    const r = e[1], n = parseInt(r, 16), i = r.length, a = i % 4 === 0, s = i > 4, o = s ? 1 : 17, l = s ? 8 : 4, u = a ? 0 : -1, h = s ? 255 : 15;
    return _2.set({
      r: (n >> l * (u + 3) & h) * o,
      g: (n >> l * (u + 2) & h) * o,
      b: (n >> l * (u + 1) & h) * o,
      a: a ? (n & h) * o / 255 : 1
    }, t);
  },
  stringify: (t) => {
    const { r: e, g: r, b: n, a: i } = t;
    return i < 1 ? `#${kl[Math.round(e)]}${kl[Math.round(r)]}${kl[Math.round(n)]}${kl[Math.round(i * 255)]}` : `#${kl[Math.round(e)]}${kl[Math.round(r)]}${kl[Math.round(n)]}`;
  }
}, tu = {
  /* VARIABLES */
  re: /^hsla?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(?:deg|grad|rad|turn)?)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(%)?))?\s*?\)$/i,
  hueRe: /^(.+?)(deg|grad|rad|turn)$/i,
  /* HELPERS */
  _hue2deg: (t) => {
    const e = t.match(tu.hueRe);
    if (e) {
      const [, r, n] = e;
      switch (n) {
        case "grad":
          return jt.channel.clamp.h(parseFloat(r) * 0.9);
        case "rad":
          return jt.channel.clamp.h(parseFloat(r) * 180 / Math.PI);
        case "turn":
          return jt.channel.clamp.h(parseFloat(r) * 360);
      }
    }
    return jt.channel.clamp.h(parseFloat(t));
  },
  /* API */
  parse: (t) => {
    const e = t.charCodeAt(0);
    if (e !== 104 && e !== 72)
      return;
    const r = t.match(tu.re);
    if (!r)
      return;
    const [, n, i, a, s, o] = r;
    return _2.set({
      h: tu._hue2deg(n),
      s: jt.channel.clamp.s(parseFloat(i)),
      l: jt.channel.clamp.l(parseFloat(a)),
      a: s ? jt.channel.clamp.a(o ? parseFloat(s) / 100 : parseFloat(s)) : 1
    }, t);
  },
  stringify: (t) => {
    const { h: e, s: r, l: n, a: i } = t;
    return i < 1 ? `hsla(${jt.lang.round(e)}, ${jt.lang.round(r)}%, ${jt.lang.round(n)}%, ${i})` : `hsl(${jt.lang.round(e)}, ${jt.lang.round(r)}%, ${jt.lang.round(n)}%)`;
  }
}, q0 = {
  /* VARIABLES */
  colors: {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyanaqua: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    transparent: "#00000000",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  },
  /* API */
  parse: (t) => {
    t = t.toLowerCase();
    const e = q0.colors[t];
    if (e)
      return Wh.parse(e);
  },
  stringify: (t) => {
    const e = Wh.stringify(t);
    for (const r in q0.colors)
      if (q0.colors[r] === e)
        return r;
  }
}, Uf = {
  /* VARIABLES */
  re: /^rgba?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?)))?\s*?\)$/i,
  /* API */
  parse: (t) => {
    const e = t.charCodeAt(0);
    if (e !== 114 && e !== 82)
      return;
    const r = t.match(Uf.re);
    if (!r)
      return;
    const [, n, i, a, s, o, l, u, h] = r;
    return _2.set({
      r: jt.channel.clamp.r(i ? parseFloat(n) * 2.55 : parseFloat(n)),
      g: jt.channel.clamp.g(s ? parseFloat(a) * 2.55 : parseFloat(a)),
      b: jt.channel.clamp.b(l ? parseFloat(o) * 2.55 : parseFloat(o)),
      a: u ? jt.channel.clamp.a(h ? parseFloat(u) / 100 : parseFloat(u)) : 1
    }, t);
  },
  stringify: (t) => {
    const { r: e, g: r, b: n, a: i } = t;
    return i < 1 ? `rgba(${jt.lang.round(e)}, ${jt.lang.round(r)}, ${jt.lang.round(n)}, ${jt.lang.round(i)})` : `rgb(${jt.lang.round(e)}, ${jt.lang.round(r)}, ${jt.lang.round(n)})`;
  }
}, Ss = {
  /* VARIABLES */
  format: {
    keyword: q0,
    hex: Wh,
    rgb: Uf,
    rgba: Uf,
    hsl: tu,
    hsla: tu
  },
  /* API */
  parse: (t) => {
    if (typeof t != "string")
      return t;
    const e = Wh.parse(t) || Uf.parse(t) || tu.parse(t) || q0.parse(t);
    if (e)
      return e;
    throw new Error(`Unsupported color format: "${t}"`);
  },
  stringify: (t) => !t.changed && t.color ? t.color : t.type.is(vi.HSL) || t.data.r === void 0 ? tu.stringify(t) : t.a < 1 || !Number.isInteger(t.r) || !Number.isInteger(t.g) || !Number.isInteger(t.b) ? Uf.stringify(t) : Wh.stringify(t)
}, xI = (t, e) => {
  const r = Ss.parse(t);
  for (const n in e)
    r[n] = jt.channel.clamp[n](e[n]);
  return Ss.stringify(r);
}, Fl = (t, e, r = 0, n = 1) => {
  if (typeof t != "number")
    return xI(t, { a: e });
  const i = _2.set({
    r: jt.channel.clamp.r(t),
    g: jt.channel.clamp.g(e),
    b: jt.channel.clamp.b(r),
    a: jt.channel.clamp.a(n)
  });
  return Ss.stringify(i);
}, iE = (t, e) => jt.lang.round(Ss.parse(t)[e]), $j = (t) => {
  const { r: e, g: r, b: n } = Ss.parse(t), i = 0.2126 * jt.channel.toLinear(e) + 0.7152 * jt.channel.toLinear(r) + 0.0722 * jt.channel.toLinear(n);
  return jt.lang.round(i);
}, zj = (t) => $j(t) >= 0.5, hc = (t) => !zj(t), bI = (t, e, r) => {
  const n = Ss.parse(t), i = n[e], a = jt.channel.clamp[e](i + r);
  return i !== a && (n[e] = a), Ss.stringify(n);
}, At = (t, e) => bI(t, "l", e), It = (t, e) => bI(t, "l", -e), Ie = (t, e) => {
  const r = Ss.parse(t), n = {};
  for (const i in e)
    e[i] && (n[i] = r[i] + e[i]);
  return xI(t, n);
}, Gj = (t, e, r = 50) => {
  const { r: n, g: i, b: a, a: s } = Ss.parse(t), { r: o, g: l, b: u, a: h } = Ss.parse(e), d = r / 100, f = d * 2 - 1, p = s - h, m = ((f * p === -1 ? f : (f + p) / (1 + f * p)) + 1) / 2, v = 1 - m, y = n * m + o * v, b = i * m + l * v, w = a * m + u * v, T = s * d + h * (1 - d);
  return Fl(y, b, w, T);
}, yt = (t, e = 100) => {
  const r = Ss.parse(t);
  return r.r = 255 - r.r, r.g = 255 - r.g, r.b = 255 - r.b, Gj(r, t, e);
};
const {
  entries: wI,
  setPrototypeOf: Q7,
  isFrozen: Vj,
  getPrototypeOf: Uj,
  getOwnPropertyDescriptor: Hj
} = Object;
let {
  freeze: Vi,
  seal: Za,
  create: j5
} = Object, {
  apply: K5,
  construct: Z5
} = typeof Reflect < "u" && Reflect;
Vi || (Vi = function(e) {
  return e;
});
Za || (Za = function(e) {
  return e;
});
K5 || (K5 = function(e, r) {
  for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), a = 2; a < n; a++)
    i[a - 2] = arguments[a];
  return e.apply(r, i);
});
Z5 || (Z5 = function(e) {
  for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)
    n[i - 1] = arguments[i];
  return new e(...n);
});
const t1 = Ui(Array.prototype.forEach), qj = Ui(Array.prototype.lastIndexOf), J7 = Ui(Array.prototype.pop), ff = Ui(Array.prototype.push), Wj = Ui(Array.prototype.splice), vm = Ui(String.prototype.toLowerCase), Ib = Ui(String.prototype.toString), Db = Ui(String.prototype.match), pf = Ui(String.prototype.replace), Yj = Ui(String.prototype.indexOf), Xj = Ui(String.prototype.trim), ls = Ui(Object.prototype.hasOwnProperty), Ri = Ui(RegExp.prototype.test), gf = jj(TypeError);
function Ui(t) {
  return function(e) {
    e instanceof RegExp && (e.lastIndex = 0);
    for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)
      n[i - 1] = arguments[i];
    return K5(t, e, n);
  };
}
function jj(t) {
  return function() {
    for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++)
      r[n] = arguments[n];
    return Z5(t, r);
  };
}
function ir(t, e) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : vm;
  Q7 && Q7(t, null);
  let n = e.length;
  for (; n--; ) {
    let i = e[n];
    if (typeof i == "string") {
      const a = r(i);
      a !== i && (Vj(e) || (e[n] = a), i = a);
    }
    t[i] = !0;
  }
  return t;
}
function Kj(t) {
  for (let e = 0; e < t.length; e++)
    ls(t, e) || (t[e] = null);
  return t;
}
function Fs(t) {
  const e = j5(null);
  for (const [r, n] of wI(t))
    ls(t, r) && (Array.isArray(n) ? e[r] = Kj(n) : n && typeof n == "object" && n.constructor === Object ? e[r] = Fs(n) : e[r] = n);
  return e;
}
function mf(t, e) {
  for (; t !== null; ) {
    const n = Hj(t, e);
    if (n) {
      if (n.get)
        return Ui(n.get);
      if (typeof n.value == "function")
        return Ui(n.value);
    }
    t = Uj(t);
  }
  function r() {
    return null;
  }
  return r;
}
const eC = Vi(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), Ob = Vi(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), Pb = Vi(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), Zj = Vi(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), Bb = Vi(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), Qj = Vi(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), tC = Vi(["#text"]), rC = Vi(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), Fb = Vi(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), nC = Vi(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), r1 = Vi(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), Jj = Za(/\{\{[\w\W]*|[\w\W]*\}\}/gm), eK = Za(/<%[\w\W]*|[\w\W]*%>/gm), tK = Za(/\$\{[\w\W]*/gm), rK = Za(/^data-[\-\w.\u00B7-\uFFFF]+$/), nK = Za(/^aria-[\-\w]+$/), TI = Za(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), iK = Za(/^(?:\w+script|data):/i), aK = Za(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), EI = Za(/^html$/i), sK = Za(/^[a-z][.\w]*(-[.\w]+)+$/i);
var iC = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: nK,
  ATTR_WHITESPACE: aK,
  CUSTOM_ELEMENT: sK,
  DATA_ATTR: rK,
  DOCTYPE_NAME: EI,
  ERB_EXPR: eK,
  IS_ALLOWED_URI: TI,
  IS_SCRIPT_OR_DATA: iK,
  MUSTACHE_EXPR: Jj,
  TMPLIT_EXPR: tK
});
const vf = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, oK = function() {
  return typeof window > "u" ? null : window;
}, lK = function(e, r) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let n = null;
  const i = "data-tt-policy-suffix";
  r && r.hasAttribute(i) && (n = r.getAttribute(i));
  const a = "dompurify" + (n ? "#" + n : "");
  try {
    return e.createPolicy(a, {
      createHTML(s) {
        return s;
      },
      createScriptURL(s) {
        return s;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + a + " could not be created."), null;
  }
}, aC = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function kI() {
  let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : oK();
  const e = (dt) => kI(dt);
  if (e.version = "3.3.1", e.removed = [], !t || !t.document || t.document.nodeType !== vf.document || !t.Element)
    return e.isSupported = !1, e;
  let {
    document: r
  } = t;
  const n = r, i = n.currentScript, {
    DocumentFragment: a,
    HTMLTemplateElement: s,
    Node: o,
    Element: l,
    NodeFilter: u,
    NamedNodeMap: h = t.NamedNodeMap || t.MozNamedAttrMap,
    HTMLFormElement: d,
    DOMParser: f,
    trustedTypes: p
  } = t, g = l.prototype, m = mf(g, "cloneNode"), v = mf(g, "remove"), y = mf(g, "nextSibling"), b = mf(g, "childNodes"), w = mf(g, "parentNode");
  if (typeof s == "function") {
    const dt = r.createElement("template");
    dt.content && dt.content.ownerDocument && (r = dt.content.ownerDocument);
  }
  let T, E = "";
  const {
    implementation: L,
    createNodeIterator: k,
    createDocumentFragment: C,
    getElementsByTagName: A
  } = r, {
    importNode: R
  } = n;
  let _ = aC();
  e.isSupported = typeof wI == "function" && typeof w == "function" && L && L.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: O,
    ERB_EXPR: P,
    TMPLIT_EXPR: S,
    DATA_ATTR: M,
    ARIA_ATTR: N,
    IS_SCRIPT_OR_DATA: D,
    ATTR_WHITESPACE: I,
    CUSTOM_ELEMENT: B
  } = iC;
  let {
    IS_ALLOWED_URI: z
  } = iC, F = null;
  const V = ir({}, [...eC, ...Ob, ...Pb, ...Bb, ...tC]);
  let H = null;
  const J = ir({}, [...rC, ...Fb, ...nC, ...r1]);
  let q = Object.seal(j5(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), ae = null, re = null;
  const pe = Object.seal(j5(null, {
    tagCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    }
  }));
  let K = !0, Z = !0, X = !1, Y = !0, ee = !1, j = !0, fe = !1, te = !1, Ae = !1, W = !1, De = !1, ue = !1, ze = !0, Ge = !1;
  const Ve = "user-content-";
  let ke = !0, Oe = !1, Se = {}, _e = null;
  const $e = ir({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let me = null;
  const Ne = ir({}, ["audio", "video", "img", "source", "image", "track"]);
  let Q = null;
  const ce = ir({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), $ = "http://www.w3.org/1998/Math/MathML", oe = "http://www.w3.org/2000/svg", se = "http://www.w3.org/1999/xhtml";
  let ge = se, he = !1, be = null;
  const Ce = ir({}, [$, oe, se], Ib);
  let Te = ir({}, ["mi", "mo", "mn", "ms", "mtext"]), Me = ir({}, ["annotation-xml"]);
  const Xe = ir({}, ["title", "style", "font", "a", "script"]);
  let We = null;
  const Ke = ["application/xhtml+xml", "text/html"], Ze = "text/html";
  let Pe = null, He = null;
  const ht = r.createElement("form"), st = function(Ee) {
    return Ee instanceof RegExp || Ee instanceof Function;
  }, Ue = function() {
    let Ee = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(He && He === Ee)) {
      if ((!Ee || typeof Ee != "object") && (Ee = {}), Ee = Fs(Ee), We = // eslint-disable-next-line unicorn/prefer-includes
      Ke.indexOf(Ee.PARSER_MEDIA_TYPE) === -1 ? Ze : Ee.PARSER_MEDIA_TYPE, Pe = We === "application/xhtml+xml" ? Ib : vm, F = ls(Ee, "ALLOWED_TAGS") ? ir({}, Ee.ALLOWED_TAGS, Pe) : V, H = ls(Ee, "ALLOWED_ATTR") ? ir({}, Ee.ALLOWED_ATTR, Pe) : J, be = ls(Ee, "ALLOWED_NAMESPACES") ? ir({}, Ee.ALLOWED_NAMESPACES, Ib) : Ce, Q = ls(Ee, "ADD_URI_SAFE_ATTR") ? ir(Fs(ce), Ee.ADD_URI_SAFE_ATTR, Pe) : ce, me = ls(Ee, "ADD_DATA_URI_TAGS") ? ir(Fs(Ne), Ee.ADD_DATA_URI_TAGS, Pe) : Ne, _e = ls(Ee, "FORBID_CONTENTS") ? ir({}, Ee.FORBID_CONTENTS, Pe) : $e, ae = ls(Ee, "FORBID_TAGS") ? ir({}, Ee.FORBID_TAGS, Pe) : Fs({}), re = ls(Ee, "FORBID_ATTR") ? ir({}, Ee.FORBID_ATTR, Pe) : Fs({}), Se = ls(Ee, "USE_PROFILES") ? Ee.USE_PROFILES : !1, K = Ee.ALLOW_ARIA_ATTR !== !1, Z = Ee.ALLOW_DATA_ATTR !== !1, X = Ee.ALLOW_UNKNOWN_PROTOCOLS || !1, Y = Ee.ALLOW_SELF_CLOSE_IN_ATTR !== !1, ee = Ee.SAFE_FOR_TEMPLATES || !1, j = Ee.SAFE_FOR_XML !== !1, fe = Ee.WHOLE_DOCUMENT || !1, W = Ee.RETURN_DOM || !1, De = Ee.RETURN_DOM_FRAGMENT || !1, ue = Ee.RETURN_TRUSTED_TYPE || !1, Ae = Ee.FORCE_BODY || !1, ze = Ee.SANITIZE_DOM !== !1, Ge = Ee.SANITIZE_NAMED_PROPS || !1, ke = Ee.KEEP_CONTENT !== !1, Oe = Ee.IN_PLACE || !1, z = Ee.ALLOWED_URI_REGEXP || TI, ge = Ee.NAMESPACE || se, Te = Ee.MATHML_TEXT_INTEGRATION_POINTS || Te, Me = Ee.HTML_INTEGRATION_POINTS || Me, q = Ee.CUSTOM_ELEMENT_HANDLING || {}, Ee.CUSTOM_ELEMENT_HANDLING && st(Ee.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (q.tagNameCheck = Ee.CUSTOM_ELEMENT_HANDLING.tagNameCheck), Ee.CUSTOM_ELEMENT_HANDLING && st(Ee.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (q.attributeNameCheck = Ee.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), Ee.CUSTOM_ELEMENT_HANDLING && typeof Ee.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (q.allowCustomizedBuiltInElements = Ee.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), ee && (Z = !1), De && (W = !0), Se && (F = ir({}, tC), H = [], Se.html === !0 && (ir(F, eC), ir(H, rC)), Se.svg === !0 && (ir(F, Ob), ir(H, Fb), ir(H, r1)), Se.svgFilters === !0 && (ir(F, Pb), ir(H, Fb), ir(H, r1)), Se.mathMl === !0 && (ir(F, Bb), ir(H, nC), ir(H, r1))), Ee.ADD_TAGS && (typeof Ee.ADD_TAGS == "function" ? pe.tagCheck = Ee.ADD_TAGS : (F === V && (F = Fs(F)), ir(F, Ee.ADD_TAGS, Pe))), Ee.ADD_ATTR && (typeof Ee.ADD_ATTR == "function" ? pe.attributeCheck = Ee.ADD_ATTR : (H === J && (H = Fs(H)), ir(H, Ee.ADD_ATTR, Pe))), Ee.ADD_URI_SAFE_ATTR && ir(Q, Ee.ADD_URI_SAFE_ATTR, Pe), Ee.FORBID_CONTENTS && (_e === $e && (_e = Fs(_e)), ir(_e, Ee.FORBID_CONTENTS, Pe)), Ee.ADD_FORBID_CONTENTS && (_e === $e && (_e = Fs(_e)), ir(_e, Ee.ADD_FORBID_CONTENTS, Pe)), ke && (F["#text"] = !0), fe && ir(F, ["html", "head", "body"]), F.table && (ir(F, ["tbody"]), delete ae.tbody), Ee.TRUSTED_TYPES_POLICY) {
        if (typeof Ee.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw gf('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof Ee.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw gf('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        T = Ee.TRUSTED_TYPES_POLICY, E = T.createHTML("");
      } else
        T === void 0 && (T = lK(p, i)), T !== null && typeof E == "string" && (E = T.createHTML(""));
      Vi && Vi(Ee), He = Ee;
    }
  }, Et = ir({}, [...Ob, ...Pb, ...Zj]), qe = ir({}, [...Bb, ...Qj]), rt = function(Ee) {
    let Je = w(Ee);
    (!Je || !Je.tagName) && (Je = {
      namespaceURI: ge,
      tagName: "template"
    });
    const bt = vm(Ee.tagName), sr = vm(Je.tagName);
    return be[Ee.namespaceURI] ? Ee.namespaceURI === oe ? Je.namespaceURI === se ? bt === "svg" : Je.namespaceURI === $ ? bt === "svg" && (sr === "annotation-xml" || Te[sr]) : !!Et[bt] : Ee.namespaceURI === $ ? Je.namespaceURI === se ? bt === "math" : Je.namespaceURI === oe ? bt === "math" && Me[sr] : !!qe[bt] : Ee.namespaceURI === se ? Je.namespaceURI === oe && !Me[sr] || Je.namespaceURI === $ && !Te[sr] ? !1 : !qe[bt] && (Xe[bt] || !Et[bt]) : !!(We === "application/xhtml+xml" && be[Ee.namespaceURI]) : !1;
  }, ct = function(Ee) {
    ff(e.removed, {
      element: Ee
    });
    try {
      w(Ee).removeChild(Ee);
    } catch {
      v(Ee);
    }
  }, ut = function(Ee, Je) {
    try {
      ff(e.removed, {
        attribute: Je.getAttributeNode(Ee),
        from: Je
      });
    } catch {
      ff(e.removed, {
        attribute: null,
        from: Je
      });
    }
    if (Je.removeAttribute(Ee), Ee === "is")
      if (W || De)
        try {
          ct(Je);
        } catch {
        }
      else
        try {
          Je.setAttribute(Ee, "");
        } catch {
        }
  }, nt = function(Ee) {
    let Je = null, bt = null;
    if (Ae)
      Ee = "<remove></remove>" + Ee;
    else {
      const cr = Db(Ee, /^[\r\n\t ]+/);
      bt = cr && cr[0];
    }
    We === "application/xhtml+xml" && ge === se && (Ee = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Ee + "</body></html>");
    const sr = T ? T.createHTML(Ee) : Ee;
    if (ge === se)
      try {
        Je = new f().parseFromString(sr, We);
      } catch {
      }
    if (!Je || !Je.documentElement) {
      Je = L.createDocument(ge, "template", null);
      try {
        Je.documentElement.innerHTML = he ? E : sr;
      } catch {
      }
    }
    const Ur = Je.body || Je.documentElement;
    return Ee && bt && Ur.insertBefore(r.createTextNode(bt), Ur.childNodes[0] || null), ge === se ? A.call(Je, fe ? "html" : "body")[0] : fe ? Je.documentElement : Ur;
  }, xt = function(Ee) {
    return k.call(
      Ee.ownerDocument || Ee,
      Ee,
      // eslint-disable-next-line no-bitwise
      u.SHOW_ELEMENT | u.SHOW_COMMENT | u.SHOW_TEXT | u.SHOW_PROCESSING_INSTRUCTION | u.SHOW_CDATA_SECTION,
      null
    );
  }, Qt = function(Ee) {
    return Ee instanceof d && (typeof Ee.nodeName != "string" || typeof Ee.textContent != "string" || typeof Ee.removeChild != "function" || !(Ee.attributes instanceof h) || typeof Ee.removeAttribute != "function" || typeof Ee.setAttribute != "function" || typeof Ee.namespaceURI != "string" || typeof Ee.insertBefore != "function" || typeof Ee.hasChildNodes != "function");
  }, Dt = function(Ee) {
    return typeof o == "function" && Ee instanceof o;
  };
  function rr(dt, Ee, Je) {
    t1(dt, (bt) => {
      bt.call(e, Ee, Je, He);
    });
  }
  const xr = function(Ee) {
    let Je = null;
    if (rr(_.beforeSanitizeElements, Ee, null), Qt(Ee))
      return ct(Ee), !0;
    const bt = Pe(Ee.nodeName);
    if (rr(_.uponSanitizeElement, Ee, {
      tagName: bt,
      allowedTags: F
    }), j && Ee.hasChildNodes() && !Dt(Ee.firstElementChild) && Ri(/<[/\w!]/g, Ee.innerHTML) && Ri(/<[/\w!]/g, Ee.textContent) || Ee.nodeType === vf.progressingInstruction || j && Ee.nodeType === vf.comment && Ri(/<[/\w]/g, Ee.data))
      return ct(Ee), !0;
    if (!(pe.tagCheck instanceof Function && pe.tagCheck(bt)) && (!F[bt] || ae[bt])) {
      if (!ae[bt] && Ht(bt) && (q.tagNameCheck instanceof RegExp && Ri(q.tagNameCheck, bt) || q.tagNameCheck instanceof Function && q.tagNameCheck(bt)))
        return !1;
      if (ke && !_e[bt]) {
        const sr = w(Ee) || Ee.parentNode, Ur = b(Ee) || Ee.childNodes;
        if (Ur && sr) {
          const cr = Ur.length;
          for (let Xr = cr - 1; Xr >= 0; --Xr) {
            const gi = m(Ur[Xr], !0);
            gi.__removalCount = (Ee.__removalCount || 0) + 1, sr.insertBefore(gi, y(Ee));
          }
        }
      }
      return ct(Ee), !0;
    }
    return Ee instanceof l && !rt(Ee) || (bt === "noscript" || bt === "noembed" || bt === "noframes") && Ri(/<\/no(script|embed|frames)/i, Ee.innerHTML) ? (ct(Ee), !0) : (ee && Ee.nodeType === vf.text && (Je = Ee.textContent, t1([O, P, S], (sr) => {
      Je = pf(Je, sr, " ");
    }), Ee.textContent !== Je && (ff(e.removed, {
      element: Ee.cloneNode()
    }), Ee.textContent = Je)), rr(_.afterSanitizeElements, Ee, null), !1);
  }, nr = function(Ee, Je, bt) {
    if (ze && (Je === "id" || Je === "name") && (bt in r || bt in ht))
      return !1;
    if (!(Z && !re[Je] && Ri(M, Je))) {
      if (!(K && Ri(N, Je))) {
        if (!(pe.attributeCheck instanceof Function && pe.attributeCheck(Je, Ee))) {
          if (!H[Je] || re[Je]) {
            if (
              // First condition does a very basic check if a) it's basically a valid custom element tagname AND
              // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
              !(Ht(Ee) && (q.tagNameCheck instanceof RegExp && Ri(q.tagNameCheck, Ee) || q.tagNameCheck instanceof Function && q.tagNameCheck(Ee)) && (q.attributeNameCheck instanceof RegExp && Ri(q.attributeNameCheck, Je) || q.attributeNameCheck instanceof Function && q.attributeNameCheck(Je, Ee)) || // Alternative, second condition checks if it's an `is`-attribute, AND
              // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              Je === "is" && q.allowCustomizedBuiltInElements && (q.tagNameCheck instanceof RegExp && Ri(q.tagNameCheck, bt) || q.tagNameCheck instanceof Function && q.tagNameCheck(bt)))
            ) return !1;
          } else if (!Q[Je]) {
            if (!Ri(z, pf(bt, I, ""))) {
              if (!((Je === "src" || Je === "xlink:href" || Je === "href") && Ee !== "script" && Yj(bt, "data:") === 0 && me[Ee])) {
                if (!(X && !Ri(D, pf(bt, I, "")))) {
                  if (bt)
                    return !1;
                }
              }
            }
          }
        }
      }
    }
    return !0;
  }, Ht = function(Ee) {
    return Ee !== "annotation-xml" && Db(Ee, B);
  }, lr = function(Ee) {
    rr(_.beforeSanitizeAttributes, Ee, null);
    const {
      attributes: Je
    } = Ee;
    if (!Je || Qt(Ee))
      return;
    const bt = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: H,
      forceKeepAttr: void 0
    };
    let sr = Je.length;
    for (; sr--; ) {
      const Ur = Je[sr], {
        name: cr,
        namespaceURI: Xr,
        value: gi
      } = Ur, bn = Pe(cr), wn = gi;
      let ft = cr === "value" ? wn : Xj(wn);
      if (bt.attrName = bn, bt.attrValue = ft, bt.keepAttr = !0, bt.forceKeepAttr = void 0, rr(_.uponSanitizeAttribute, Ee, bt), ft = bt.attrValue, Ge && (bn === "id" || bn === "name") && (ut(cr, Ee), ft = Ve + ft), j && Ri(/((--!?|])>)|<\/(style|title|textarea)/i, ft)) {
        ut(cr, Ee);
        continue;
      }
      if (bn === "attributename" && Db(ft, "href")) {
        ut(cr, Ee);
        continue;
      }
      if (bt.forceKeepAttr)
        continue;
      if (!bt.keepAttr) {
        ut(cr, Ee);
        continue;
      }
      if (!Y && Ri(/\/>/i, ft)) {
        ut(cr, Ee);
        continue;
      }
      ee && t1([O, P, S], (lt) => {
        ft = pf(ft, lt, " ");
      });
      const wt = Pe(Ee.nodeName);
      if (!nr(wt, bn, ft)) {
        ut(cr, Ee);
        continue;
      }
      if (T && typeof p == "object" && typeof p.getAttributeType == "function" && !Xr)
        switch (p.getAttributeType(wt, bn)) {
          case "TrustedHTML": {
            ft = T.createHTML(ft);
            break;
          }
          case "TrustedScriptURL": {
            ft = T.createScriptURL(ft);
            break;
          }
        }
      if (ft !== wn)
        try {
          Xr ? Ee.setAttributeNS(Xr, cr, ft) : Ee.setAttribute(cr, ft), Qt(Ee) ? ct(Ee) : J7(e.removed);
        } catch {
          ut(cr, Ee);
        }
    }
    rr(_.afterSanitizeAttributes, Ee, null);
  }, sn = function dt(Ee) {
    let Je = null;
    const bt = xt(Ee);
    for (rr(_.beforeSanitizeShadowDOM, Ee, null); Je = bt.nextNode(); )
      rr(_.uponSanitizeShadowNode, Je, null), xr(Je), lr(Je), Je.content instanceof a && dt(Je.content);
    rr(_.afterSanitizeShadowDOM, Ee, null);
  };
  return e.sanitize = function(dt) {
    let Ee = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Je = null, bt = null, sr = null, Ur = null;
    if (he = !dt, he && (dt = "<!-->"), typeof dt != "string" && !Dt(dt))
      if (typeof dt.toString == "function") {
        if (dt = dt.toString(), typeof dt != "string")
          throw gf("dirty is not a string, aborting");
      } else
        throw gf("toString is not a function");
    if (!e.isSupported)
      return dt;
    if (te || Ue(Ee), e.removed = [], typeof dt == "string" && (Oe = !1), Oe) {
      if (dt.nodeName) {
        const gi = Pe(dt.nodeName);
        if (!F[gi] || ae[gi])
          throw gf("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (dt instanceof o)
      Je = nt("<!---->"), bt = Je.ownerDocument.importNode(dt, !0), bt.nodeType === vf.element && bt.nodeName === "BODY" || bt.nodeName === "HTML" ? Je = bt : Je.appendChild(bt);
    else {
      if (!W && !ee && !fe && // eslint-disable-next-line unicorn/prefer-includes
      dt.indexOf("<") === -1)
        return T && ue ? T.createHTML(dt) : dt;
      if (Je = nt(dt), !Je)
        return W ? null : ue ? E : "";
    }
    Je && Ae && ct(Je.firstChild);
    const cr = xt(Oe ? dt : Je);
    for (; sr = cr.nextNode(); )
      xr(sr), lr(sr), sr.content instanceof a && sn(sr.content);
    if (Oe)
      return dt;
    if (W) {
      if (De)
        for (Ur = C.call(Je.ownerDocument); Je.firstChild; )
          Ur.appendChild(Je.firstChild);
      else
        Ur = Je;
      return (H.shadowroot || H.shadowrootmode) && (Ur = R.call(n, Ur, !0)), Ur;
    }
    let Xr = fe ? Je.outerHTML : Je.innerHTML;
    return fe && F["!doctype"] && Je.ownerDocument && Je.ownerDocument.doctype && Je.ownerDocument.doctype.name && Ri(EI, Je.ownerDocument.doctype.name) && (Xr = "<!DOCTYPE " + Je.ownerDocument.doctype.name + `>
` + Xr), ee && t1([O, P, S], (gi) => {
      Xr = pf(Xr, gi, " ");
    }), T && ue ? T.createHTML(Xr) : Xr;
  }, e.setConfig = function() {
    let dt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Ue(dt), te = !0;
  }, e.clearConfig = function() {
    He = null, te = !1;
  }, e.isValidAttribute = function(dt, Ee, Je) {
    He || Ue({});
    const bt = Pe(dt), sr = Pe(Ee);
    return nr(bt, sr, Je);
  }, e.addHook = function(dt, Ee) {
    typeof Ee == "function" && ff(_[dt], Ee);
  }, e.removeHook = function(dt, Ee) {
    if (Ee !== void 0) {
      const Je = qj(_[dt], Ee);
      return Je === -1 ? void 0 : Wj(_[dt], Je, 1)[0];
    }
    return J7(_[dt]);
  }, e.removeHooks = function(dt) {
    _[dt] = [];
  }, e.removeAllHooks = function() {
    _ = aC();
  }, e;
}
var ud = kI(), SI = /^-{3}\s*[\n\r](.*?)[\n\r]-{3}\s*[\n\r]+/s, W0 = /%{2}{\s*(?:(\w+)\s*:|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi, cK = /\s*%%.*\n/gm, CI = class extends Error {
  static {
    x(this, "UnknownDiagramError");
  }
  constructor(t) {
    super(t), this.name = "UnknownDiagramError";
  }
}, du = {}, aE = /* @__PURE__ */ x(function(t, e) {
  t = t.replace(SI, "").replace(W0, "").replace(cK, `
`);
  for (const [r, { detector: n }] of Object.entries(du))
    if (n(t, e))
      return r;
  throw new CI(
    `No diagram type detected matching given configuration for text: ${t}`
  );
}, "detectType"), Q5 = /* @__PURE__ */ x((...t) => {
  for (const { id: e, detector: r, loader: n } of t)
    AI(e, r, n);
}, "registerLazyLoadedDiagrams"), AI = /* @__PURE__ */ x((t, e, r) => {
  du[t] && ie.warn(`Detector with key ${t} already exists. Overwriting.`), du[t] = { detector: e, loader: r }, ie.debug(`Detector with key ${t} added${r ? " with loader" : ""}`);
}, "addDetector"), uK = /* @__PURE__ */ x((t) => du[t].loader, "getDiagramLoader"), J5 = /* @__PURE__ */ x((t, e, { depth: r = 2, clobber: n = !1 } = {}) => {
  const i = { depth: r, clobber: n };
  return Array.isArray(e) && !Array.isArray(t) ? (e.forEach((a) => J5(t, a, i)), t) : Array.isArray(e) && Array.isArray(t) ? (e.forEach((a) => {
    t.includes(a) || t.push(a);
  }), t) : t === void 0 || r <= 0 ? t != null && typeof t == "object" && typeof e == "object" ? Object.assign(t, e) : e : (e !== void 0 && typeof t == "object" && typeof e == "object" && Object.keys(e).forEach((a) => {
    typeof e[a] == "object" && (t[a] === void 0 || typeof t[a] == "object") ? (t[a] === void 0 && (t[a] = Array.isArray(e[a]) ? [] : {}), t[a] = J5(t[a], e[a], { depth: r - 1, clobber: n })) : (n || typeof t[a] != "object" && typeof e[a] != "object") && (t[a] = e[a]);
  }), t);
}, "assignWithDepth"), mn = J5, L2 = "#ffffff", R2 = "#f2f2f2", Pi = /* @__PURE__ */ x((t, e) => e ? Ie(t, { s: -40, l: 10 }) : Ie(t, { s: -40, l: -10 }), "mkBorder"), hK = class {
  static {
    x(this, "Theme");
  }
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#fff4dd", this.noteBkgColor = "#fff5ad", this.noteTextColor = "#333", this.THEME_COLOR_LIMIT = 12, this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px";
  }
  updateColors() {
    if (this.primaryTextColor = this.primaryTextColor || (this.darkMode ? "#eee" : "#333"), this.secondaryColor = this.secondaryColor || Ie(this.primaryColor, { h: -120 }), this.tertiaryColor = this.tertiaryColor || Ie(this.primaryColor, { h: 180, l: 5 }), this.primaryBorderColor = this.primaryBorderColor || Pi(this.primaryColor, this.darkMode), this.secondaryBorderColor = this.secondaryBorderColor || Pi(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = this.tertiaryBorderColor || Pi(this.tertiaryColor, this.darkMode), this.noteBorderColor = this.noteBorderColor || Pi(this.noteBkgColor, this.darkMode), this.noteBkgColor = this.noteBkgColor || "#fff5ad", this.noteTextColor = this.noteTextColor || "#333", this.secondaryTextColor = this.secondaryTextColor || yt(this.secondaryColor), this.tertiaryTextColor = this.tertiaryTextColor || yt(this.tertiaryColor), this.lineColor = this.lineColor || yt(this.background), this.arrowheadColor = this.arrowheadColor || yt(this.background), this.textColor = this.textColor || this.primaryTextColor, this.border2 = this.border2 || this.tertiaryBorderColor, this.nodeBkg = this.nodeBkg || this.primaryColor, this.mainBkg = this.mainBkg || this.primaryColor, this.nodeBorder = this.nodeBorder || this.primaryBorderColor, this.clusterBkg = this.clusterBkg || this.tertiaryColor, this.clusterBorder = this.clusterBorder || this.tertiaryBorderColor, this.defaultLinkColor = this.defaultLinkColor || this.lineColor, this.titleColor = this.titleColor || this.tertiaryTextColor, this.edgeLabelBackground = this.edgeLabelBackground || (this.darkMode ? It(this.secondaryColor, 30) : this.secondaryColor), this.nodeTextColor = this.nodeTextColor || this.primaryTextColor, this.actorBorder = this.actorBorder || this.primaryBorderColor, this.actorBkg = this.actorBkg || this.mainBkg, this.actorTextColor = this.actorTextColor || this.primaryTextColor, this.actorLineColor = this.actorLineColor || this.actorBorder, this.labelBoxBkgColor = this.labelBoxBkgColor || this.actorBkg, this.signalColor = this.signalColor || this.textColor, this.signalTextColor = this.signalTextColor || this.textColor, this.labelBoxBorderColor = this.labelBoxBorderColor || this.actorBorder, this.labelTextColor = this.labelTextColor || this.actorTextColor, this.loopTextColor = this.loopTextColor || this.actorTextColor, this.activationBorderColor = this.activationBorderColor || It(this.secondaryColor, 10), this.activationBkgColor = this.activationBkgColor || this.secondaryColor, this.sequenceNumberColor = this.sequenceNumberColor || yt(this.lineColor), this.sectionBkgColor = this.sectionBkgColor || this.tertiaryColor, this.altSectionBkgColor = this.altSectionBkgColor || "white", this.sectionBkgColor = this.sectionBkgColor || this.secondaryColor, this.sectionBkgColor2 = this.sectionBkgColor2 || this.primaryColor, this.excludeBkgColor = this.excludeBkgColor || "#eeeeee", this.taskBorderColor = this.taskBorderColor || this.primaryBorderColor, this.taskBkgColor = this.taskBkgColor || this.primaryColor, this.activeTaskBorderColor = this.activeTaskBorderColor || this.primaryColor, this.activeTaskBkgColor = this.activeTaskBkgColor || At(this.primaryColor, 23), this.gridColor = this.gridColor || "lightgrey", this.doneTaskBkgColor = this.doneTaskBkgColor || "lightgrey", this.doneTaskBorderColor = this.doneTaskBorderColor || "grey", this.critBorderColor = this.critBorderColor || "#ff8888", this.critBkgColor = this.critBkgColor || "red", this.todayLineColor = this.todayLineColor || "red", this.vertLineColor = this.vertLineColor || "navy", this.taskTextColor = this.taskTextColor || this.textColor, this.taskTextOutsideColor = this.taskTextOutsideColor || this.textColor, this.taskTextLightColor = this.taskTextLightColor || this.textColor, this.taskTextColor = this.taskTextColor || this.primaryTextColor, this.taskTextDarkColor = this.taskTextDarkColor || this.textColor, this.taskTextClickableColor = this.taskTextClickableColor || "#003163", this.personBorder = this.personBorder || this.primaryBorderColor, this.personBkg = this.personBkg || this.mainBkg, this.darkMode ? (this.rowOdd = this.rowOdd || It(this.mainBkg, 5) || "#ffffff", this.rowEven = this.rowEven || It(this.mainBkg, 10)) : (this.rowOdd = this.rowOdd || At(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || At(this.mainBkg, 5)), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || this.tertiaryColor, this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.nodeBorder, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.specialStateColor = this.lineColor, this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || Ie(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || Ie(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || Ie(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || Ie(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || Ie(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || Ie(this.primaryColor, { h: 210, l: 150 }), this.cScale9 = this.cScale9 || Ie(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || Ie(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || Ie(this.primaryColor, { h: 330 }), this.darkMode)
      for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
        this["cScale" + e] = It(this["cScale" + e], 75);
    else
      for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
        this["cScale" + e] = It(this["cScale" + e], 25);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleInv" + e] = this["cScaleInv" + e] || yt(this["cScale" + e]);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this.darkMode ? this["cScalePeer" + e] = this["cScalePeer" + e] || At(this["cScale" + e], 10) : this["cScalePeer" + e] = this["cScalePeer" + e] || It(this["cScale" + e], 10);
    this.scaleLabelColor = this.scaleLabelColor || this.labelTextColor;
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleLabel" + e] = this["cScaleLabel" + e] || this.scaleLabelColor;
    const t = this.darkMode ? -4 : -1;
    for (let e = 0; e < 5; e++)
      this["surface" + e] = this["surface" + e] || Ie(this.mainBkg, { h: 180, s: -15, l: t * (5 + e * 3) }), this["surfacePeer" + e] = this["surfacePeer" + e] || Ie(this.mainBkg, { h: 180, s: -15, l: t * (8 + e * 3) });
    this.classText = this.classText || this.textColor, this.fillType0 = this.fillType0 || this.primaryColor, this.fillType1 = this.fillType1 || this.secondaryColor, this.fillType2 = this.fillType2 || Ie(this.primaryColor, { h: 64 }), this.fillType3 = this.fillType3 || Ie(this.secondaryColor, { h: 64 }), this.fillType4 = this.fillType4 || Ie(this.primaryColor, { h: -64 }), this.fillType5 = this.fillType5 || Ie(this.secondaryColor, { h: -64 }), this.fillType6 = this.fillType6 || Ie(this.primaryColor, { h: 128 }), this.fillType7 = this.fillType7 || Ie(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || this.tertiaryColor, this.pie4 = this.pie4 || Ie(this.primaryColor, { l: -10 }), this.pie5 = this.pie5 || Ie(this.secondaryColor, { l: -10 }), this.pie6 = this.pie6 || Ie(this.tertiaryColor, { l: -10 }), this.pie7 = this.pie7 || Ie(this.primaryColor, { h: 60, l: -10 }), this.pie8 = this.pie8 || Ie(this.primaryColor, { h: -60, l: -10 }), this.pie9 = this.pie9 || Ie(this.primaryColor, { h: 120, l: 0 }), this.pie10 = this.pie10 || Ie(this.primaryColor, { h: 60, l: -20 }), this.pie11 = this.pie11 || Ie(this.primaryColor, { h: -60, l: -20 }), this.pie12 = this.pie12 || Ie(this.primaryColor, { h: 120, l: -10 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.radar = {
      axisColor: this.radar?.axisColor || this.lineColor,
      axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
      axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
      curveOpacity: this.radar?.curveOpacity || 0.5,
      curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
      graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
      graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
      graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
      legendBoxSize: this.radar?.legendBoxSize || 12,
      legendFontSize: this.radar?.legendFontSize || 12
    }, this.archEdgeColor = this.archEdgeColor || "#777", this.archEdgeArrowColor = this.archEdgeArrowColor || "#777", this.archEdgeWidth = this.archEdgeWidth || "3", this.archGroupBorderColor = this.archGroupBorderColor || "#000", this.archGroupBorderWidth = this.archGroupBorderWidth || "2px", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || Ie(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || Ie(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || Ie(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || Ie(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || Ie(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || Ie(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || hc(this.quadrant1Fill) ? At(this.quadrant1Fill) : It(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
      backgroundColor: this.xyChart?.backgroundColor || this.background,
      titleColor: this.xyChart?.titleColor || this.primaryTextColor,
      xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
      xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
      xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
      xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
      yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
      yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
      yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
      yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
      plotColorPalette: this.xyChart?.plotColorPalette || "#FFF4DD,#FFD8B1,#FFA07A,#ECEFF1,#D6DBDF,#C3E0A8,#FFB6A4,#FFD74D,#738FA7,#FFFFF0"
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? It(this.secondaryColor, 30) : this.secondaryColor), this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || Ie(this.primaryColor, { h: -30 }), this.git4 = this.git4 || Ie(this.primaryColor, { h: -60 }), this.git5 = this.git5 || Ie(this.primaryColor, { h: -90 }), this.git6 = this.git6 || Ie(this.primaryColor, { h: 60 }), this.git7 = this.git7 || Ie(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = At(this.git0, 25), this.git1 = At(this.git1, 25), this.git2 = At(this.git2, 25), this.git3 = At(this.git3, 25), this.git4 = At(this.git4, 25), this.git5 = At(this.git5, 25), this.git6 = At(this.git6, 25), this.git7 = At(this.git7, 25)) : (this.git0 = It(this.git0, 25), this.git1 = It(this.git1, 25), this.git2 = It(this.git2, 25), this.git3 = It(this.git3, 25), this.git4 = It(this.git4, 25), this.git5 = It(this.git5, 25), this.git6 = It(this.git6, 25), this.git7 = It(this.git7, 25)), this.gitInv0 = this.gitInv0 || yt(this.git0), this.gitInv1 = this.gitInv1 || yt(this.git1), this.gitInv2 = this.gitInv2 || yt(this.git2), this.gitInv3 = this.gitInv3 || yt(this.git3), this.gitInv4 = this.gitInv4 || yt(this.git4), this.gitInv5 = this.gitInv5 || yt(this.git5), this.gitInv6 = this.gitInv6 || yt(this.git6), this.gitInv7 = this.gitInv7 || yt(this.git7), this.branchLabelColor = this.branchLabelColor || (this.darkMode ? "black" : this.labelTextColor), this.gitBranchLabel0 = this.gitBranchLabel0 || this.branchLabelColor, this.gitBranchLabel1 = this.gitBranchLabel1 || this.branchLabelColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.branchLabelColor, this.gitBranchLabel3 = this.gitBranchLabel3 || this.branchLabelColor, this.gitBranchLabel4 = this.gitBranchLabel4 || this.branchLabelColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.branchLabelColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.branchLabelColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.branchLabelColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || L2, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || R2;
  }
  calculate(t) {
    if (typeof t != "object") {
      this.updateColors();
      return;
    }
    const e = Object.keys(t);
    e.forEach((r) => {
      this[r] = t[r];
    }), this.updateColors(), e.forEach((r) => {
      this[r] = t[r];
    });
  }
}, dK = /* @__PURE__ */ x((t) => {
  const e = new hK();
  return e.calculate(t), e;
}, "getThemeVariables"), fK = class {
  static {
    x(this, "Theme");
  }
  constructor() {
    this.background = "#333", this.primaryColor = "#1f2020", this.secondaryColor = At(this.primaryColor, 16), this.tertiaryColor = Ie(this.primaryColor, { h: -160 }), this.primaryBorderColor = yt(this.background), this.secondaryBorderColor = Pi(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = Pi(this.tertiaryColor, this.darkMode), this.primaryTextColor = yt(this.primaryColor), this.secondaryTextColor = yt(this.secondaryColor), this.tertiaryTextColor = yt(this.tertiaryColor), this.lineColor = yt(this.background), this.textColor = yt(this.background), this.mainBkg = "#1f2020", this.secondBkg = "calculated", this.mainContrastColor = "lightgrey", this.darkTextColor = At(yt("#323D47"), 10), this.lineColor = "calculated", this.border1 = "#ccc", this.border2 = Fl(255, 255, 255, 0.25), this.arrowheadColor = "calculated", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.labelBackground = "#181818", this.textColor = "#ccc", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "#F9FFFE", this.edgeLabelBackground = "calculated", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "calculated", this.actorLineColor = "calculated", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "calculated", this.activationBkgColor = "calculated", this.sequenceNumberColor = "black", this.sectionBkgColor = It("#EAE8D9", 30), this.altSectionBkgColor = "calculated", this.sectionBkgColor2 = "#EAE8D9", this.excludeBkgColor = It(this.sectionBkgColor, 10), this.taskBorderColor = Fl(255, 255, 255, 70), this.taskBkgColor = "calculated", this.taskTextColor = "calculated", this.taskTextLightColor = "calculated", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = Fl(255, 255, 255, 50), this.activeTaskBkgColor = "#81B1DB", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "grey", this.critBorderColor = "#E83737", this.critBkgColor = "#E83737", this.taskTextDarkColor = "calculated", this.todayLineColor = "#DB5757", this.vertLineColor = "#00BFFF", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = this.rowOdd || At(this.mainBkg, 5) || "#ffffff", this.rowEven = this.rowEven || It(this.mainBkg, 10), this.labelColor = "calculated", this.errorBkgColor = "#a44141", this.errorTextColor = "#ddd";
  }
  updateColors() {
    this.secondBkg = At(this.mainBkg, 16), this.lineColor = this.mainContrastColor, this.arrowheadColor = this.mainContrastColor, this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.edgeLabelBackground = At(this.labelBackground, 25), this.actorBorder = this.border1, this.actorBkg = this.mainBkg, this.actorTextColor = this.mainContrastColor, this.actorLineColor = this.actorBorder, this.signalColor = this.mainContrastColor, this.signalTextColor = this.mainContrastColor, this.labelBoxBkgColor = this.actorBkg, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.mainContrastColor, this.loopTextColor = this.mainContrastColor, this.noteBorderColor = this.secondaryBorderColor, this.noteBkgColor = this.secondBkg, this.noteTextColor = this.secondaryTextColor, this.activationBorderColor = this.border1, this.activationBkgColor = this.secondBkg, this.altSectionBkgColor = this.background, this.taskBkgColor = At(this.mainBkg, 23), this.taskTextColor = this.darkTextColor, this.taskTextLightColor = this.mainContrastColor, this.taskTextOutsideColor = this.taskTextLightColor, this.gridColor = this.mainContrastColor, this.doneTaskBkgColor = this.mainContrastColor, this.taskTextDarkColor = this.darkTextColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#555", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = "#f4f4f4", this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = Ie(this.primaryColor, { h: 64 }), this.fillType3 = Ie(this.secondaryColor, { h: 64 }), this.fillType4 = Ie(this.primaryColor, { h: -64 }), this.fillType5 = Ie(this.secondaryColor, { h: -64 }), this.fillType6 = Ie(this.primaryColor, { h: 128 }), this.fillType7 = Ie(this.secondaryColor, { h: 128 }), this.cScale1 = this.cScale1 || "#0b0000", this.cScale2 = this.cScale2 || "#4d1037", this.cScale3 = this.cScale3 || "#3f5258", this.cScale4 = this.cScale4 || "#4f2f1b", this.cScale5 = this.cScale5 || "#6e0a0a", this.cScale6 = this.cScale6 || "#3b0048", this.cScale7 = this.cScale7 || "#995a01", this.cScale8 = this.cScale8 || "#154706", this.cScale9 = this.cScale9 || "#161722", this.cScale10 = this.cScale10 || "#00296f", this.cScale11 = this.cScale11 || "#01629c", this.cScale12 = this.cScale12 || "#010029", this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || Ie(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || Ie(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || Ie(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || Ie(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || Ie(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || Ie(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || Ie(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || Ie(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || Ie(this.primaryColor, { h: 330 });
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScaleInv" + t] = this["cScaleInv" + t] || yt(this["cScale" + t]);
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScalePeer" + t] = this["cScalePeer" + t] || At(this["cScale" + t], 10);
    for (let t = 0; t < 5; t++)
      this["surface" + t] = this["surface" + t] || Ie(this.mainBkg, { h: 30, s: -30, l: -(-10 + t * 4) }), this["surfacePeer" + t] = this["surfacePeer" + t] || Ie(this.mainBkg, { h: 30, s: -30, l: -(-7 + t * 4) });
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScaleLabel" + t] = this["cScaleLabel" + t] || this.scaleLabelColor;
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["pie" + t] = this["cScale" + t];
    this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || Ie(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || Ie(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || Ie(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || Ie(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || Ie(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || Ie(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || hc(this.quadrant1Fill) ? At(this.quadrant1Fill) : It(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
      backgroundColor: this.xyChart?.backgroundColor || this.background,
      titleColor: this.xyChart?.titleColor || this.primaryTextColor,
      xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
      xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
      xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
      xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
      yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
      yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
      yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
      yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
      plotColorPalette: this.xyChart?.plotColorPalette || "#3498db,#2ecc71,#e74c3c,#f1c40f,#bdc3c7,#ffffff,#34495e,#9b59b6,#1abc9c,#e67e22"
    }, this.packet = {
      startByteColor: this.primaryTextColor,
      endByteColor: this.primaryTextColor,
      labelColor: this.primaryTextColor,
      titleColor: this.primaryTextColor,
      blockStrokeColor: this.primaryTextColor,
      blockFillColor: this.background
    }, this.radar = {
      axisColor: this.radar?.axisColor || this.lineColor,
      axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
      axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
      curveOpacity: this.radar?.curveOpacity || 0.5,
      curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
      graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
      graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
      graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
      legendBoxSize: this.radar?.legendBoxSize || 12,
      legendFontSize: this.radar?.legendFontSize || 12
    }, this.classText = this.primaryTextColor, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? It(this.secondaryColor, 30) : this.secondaryColor), this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = At(this.secondaryColor, 20), this.git1 = At(this.pie2 || this.secondaryColor, 20), this.git2 = At(this.pie3 || this.tertiaryColor, 20), this.git3 = At(this.pie4 || Ie(this.primaryColor, { h: -30 }), 20), this.git4 = At(this.pie5 || Ie(this.primaryColor, { h: -60 }), 20), this.git5 = At(this.pie6 || Ie(this.primaryColor, { h: -90 }), 10), this.git6 = At(this.pie7 || Ie(this.primaryColor, { h: 60 }), 10), this.git7 = At(this.pie8 || Ie(this.primaryColor, { h: 120 }), 20), this.gitInv0 = this.gitInv0 || yt(this.git0), this.gitInv1 = this.gitInv1 || yt(this.git1), this.gitInv2 = this.gitInv2 || yt(this.git2), this.gitInv3 = this.gitInv3 || yt(this.git3), this.gitInv4 = this.gitInv4 || yt(this.git4), this.gitInv5 = this.gitInv5 || yt(this.git5), this.gitInv6 = this.gitInv6 || yt(this.git6), this.gitInv7 = this.gitInv7 || yt(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || yt(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || yt(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || At(this.background, 12), this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || At(this.background, 2), this.nodeBorder = this.nodeBorder || "#999";
  }
  calculate(t) {
    if (typeof t != "object") {
      this.updateColors();
      return;
    }
    const e = Object.keys(t);
    e.forEach((r) => {
      this[r] = t[r];
    }), this.updateColors(), e.forEach((r) => {
      this[r] = t[r];
    });
  }
}, pK = /* @__PURE__ */ x((t) => {
  const e = new fK();
  return e.calculate(t), e;
}, "getThemeVariables"), gK = class {
  static {
    x(this, "Theme");
  }
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#ECECFF", this.secondaryColor = Ie(this.primaryColor, { h: 120 }), this.secondaryColor = "#ffffde", this.tertiaryColor = Ie(this.primaryColor, { h: -160 }), this.primaryBorderColor = Pi(this.primaryColor, this.darkMode), this.secondaryBorderColor = Pi(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = Pi(this.tertiaryColor, this.darkMode), this.primaryTextColor = yt(this.primaryColor), this.secondaryTextColor = yt(this.secondaryColor), this.tertiaryTextColor = yt(this.tertiaryColor), this.lineColor = yt(this.background), this.textColor = yt(this.background), this.background = "white", this.mainBkg = "#ECECFF", this.secondBkg = "#ffffde", this.lineColor = "#333333", this.border1 = "#9370DB", this.border2 = "#aaaa33", this.arrowheadColor = "#333333", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.labelBackground = "rgba(232,232,232, 0.8)", this.textColor = "#333", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "calculated", this.edgeLabelBackground = "calculated", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "black", this.actorLineColor = "calculated", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "calculated", this.altSectionBkgColor = "calculated", this.sectionBkgColor2 = "calculated", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "calculated", this.taskTextLightColor = "calculated", this.taskTextColor = this.taskTextLightColor, this.taskTextDarkColor = "calculated", this.taskTextOutsideColor = this.taskTextDarkColor, this.taskTextClickableColor = "calculated", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "calculated", this.critBorderColor = "calculated", this.critBkgColor = "calculated", this.todayLineColor = "calculated", this.vertLineColor = "calculated", this.sectionBkgColor = Fl(102, 102, 255, 0.49), this.altSectionBkgColor = "white", this.sectionBkgColor2 = "#fff400", this.taskBorderColor = "#534fbc", this.taskBkgColor = "#8a90dd", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "black", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "#534fbc", this.activeTaskBkgColor = "#bfc7ff", this.gridColor = "lightgrey", this.doneTaskBkgColor = "lightgrey", this.doneTaskBorderColor = "grey", this.critBorderColor = "#ff8888", this.critBkgColor = "red", this.todayLineColor = "red", this.vertLineColor = "navy", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = "calculated", this.rowEven = "calculated", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222", this.updateColors();
  }
  updateColors() {
    this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || Ie(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || Ie(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || Ie(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || Ie(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || Ie(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || Ie(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || Ie(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || Ie(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || Ie(this.primaryColor, { h: 330 }), this.cScalePeer1 = this.cScalePeer1 || It(this.secondaryColor, 45), this.cScalePeer2 = this.cScalePeer2 || It(this.tertiaryColor, 40);
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScale" + t] = It(this["cScale" + t], 10), this["cScalePeer" + t] = this["cScalePeer" + t] || It(this["cScale" + t], 25);
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScaleInv" + t] = this["cScaleInv" + t] || Ie(this["cScale" + t], { h: 180 });
    for (let t = 0; t < 5; t++)
      this["surface" + t] = this["surface" + t] || Ie(this.mainBkg, { h: 30, l: -(5 + t * 5) }), this["surfacePeer" + t] = this["surfacePeer" + t] || Ie(this.mainBkg, { h: 30, l: -(7 + t * 5) });
    if (this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor, this.labelTextColor !== "calculated") {
      this.cScaleLabel0 = this.cScaleLabel0 || yt(this.labelTextColor), this.cScaleLabel3 = this.cScaleLabel3 || yt(this.labelTextColor);
      for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
        this["cScaleLabel" + t] = this["cScaleLabel" + t] || this.labelTextColor;
    }
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.titleColor = this.textColor, this.edgeLabelBackground = this.labelBackground, this.actorBorder = At(this.border1, 23), this.actorBkg = this.mainBkg, this.labelBoxBkgColor = this.actorBkg, this.signalColor = this.textColor, this.signalTextColor = this.textColor, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.actorTextColor, this.loopTextColor = this.actorTextColor, this.noteBorderColor = this.border2, this.noteTextColor = this.actorTextColor, this.actorLineColor = this.actorBorder, this.taskTextColor = this.taskTextLightColor, this.taskTextOutsideColor = this.taskTextDarkColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.rowOdd = this.rowOdd || At(this.primaryColor, 75) || "#ffffff", this.rowEven = this.rowEven || At(this.primaryColor, 1), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f0f0f0", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.nodeBorder, this.specialStateColor = this.lineColor, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = Ie(this.primaryColor, { h: 64 }), this.fillType3 = Ie(this.secondaryColor, { h: 64 }), this.fillType4 = Ie(this.primaryColor, { h: -64 }), this.fillType5 = Ie(this.secondaryColor, { h: -64 }), this.fillType6 = Ie(this.primaryColor, { h: 128 }), this.fillType7 = Ie(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || Ie(this.tertiaryColor, { l: -40 }), this.pie4 = this.pie4 || Ie(this.primaryColor, { l: -10 }), this.pie5 = this.pie5 || Ie(this.secondaryColor, { l: -30 }), this.pie6 = this.pie6 || Ie(this.tertiaryColor, { l: -20 }), this.pie7 = this.pie7 || Ie(this.primaryColor, { h: 60, l: -20 }), this.pie8 = this.pie8 || Ie(this.primaryColor, { h: -60, l: -40 }), this.pie9 = this.pie9 || Ie(this.primaryColor, { h: 120, l: -40 }), this.pie10 = this.pie10 || Ie(this.primaryColor, { h: 60, l: -40 }), this.pie11 = this.pie11 || Ie(this.primaryColor, { h: -90, l: -40 }), this.pie12 = this.pie12 || Ie(this.primaryColor, { h: 120, l: -30 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || Ie(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || Ie(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || Ie(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || Ie(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || Ie(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || Ie(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || hc(this.quadrant1Fill) ? At(this.quadrant1Fill) : It(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.radar = {
      axisColor: this.radar?.axisColor || this.lineColor,
      axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
      axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
      curveOpacity: this.radar?.curveOpacity || 0.5,
      curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
      graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
      graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
      graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
      legendBoxSize: this.radar?.legendBoxSize || 12,
      legendFontSize: this.radar?.legendFontSize || 12
    }, this.xyChart = {
      backgroundColor: this.xyChart?.backgroundColor || this.background,
      titleColor: this.xyChart?.titleColor || this.primaryTextColor,
      xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
      xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
      xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
      xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
      yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
      yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
      yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
      yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
      plotColorPalette: this.xyChart?.plotColorPalette || "#ECECFF,#8493A6,#FFC3A0,#DCDDE1,#B8E994,#D1A36F,#C3CDE6,#FFB6C1,#496078,#F8F3E3"
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.labelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || Ie(this.primaryColor, { h: -30 }), this.git4 = this.git4 || Ie(this.primaryColor, { h: -60 }), this.git5 = this.git5 || Ie(this.primaryColor, { h: -90 }), this.git6 = this.git6 || Ie(this.primaryColor, { h: 60 }), this.git7 = this.git7 || Ie(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = At(this.git0, 25), this.git1 = At(this.git1, 25), this.git2 = At(this.git2, 25), this.git3 = At(this.git3, 25), this.git4 = At(this.git4, 25), this.git5 = At(this.git5, 25), this.git6 = At(this.git6, 25), this.git7 = At(this.git7, 25)) : (this.git0 = It(this.git0, 25), this.git1 = It(this.git1, 25), this.git2 = It(this.git2, 25), this.git3 = It(this.git3, 25), this.git4 = It(this.git4, 25), this.git5 = It(this.git5, 25), this.git6 = It(this.git6, 25), this.git7 = It(this.git7, 25)), this.gitInv0 = this.gitInv0 || It(yt(this.git0), 25), this.gitInv1 = this.gitInv1 || yt(this.git1), this.gitInv2 = this.gitInv2 || yt(this.git2), this.gitInv3 = this.gitInv3 || yt(this.git3), this.gitInv4 = this.gitInv4 || yt(this.git4), this.gitInv5 = this.gitInv5 || yt(this.git5), this.gitInv6 = this.gitInv6 || yt(this.git6), this.gitInv7 = this.gitInv7 || yt(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || yt(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || yt(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || L2, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || R2;
  }
  calculate(t) {
    if (Object.keys(this).forEach((r) => {
      this[r] === "calculated" && (this[r] = void 0);
    }), typeof t != "object") {
      this.updateColors();
      return;
    }
    const e = Object.keys(t);
    e.forEach((r) => {
      this[r] = t[r];
    }), this.updateColors(), e.forEach((r) => {
      this[r] = t[r];
    });
  }
}, M2 = /* @__PURE__ */ x((t) => {
  const e = new gK();
  return e.calculate(t), e;
}, "getThemeVariables"), mK = class {
  static {
    x(this, "Theme");
  }
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#cde498", this.secondaryColor = "#cdffb2", this.background = "white", this.mainBkg = "#cde498", this.secondBkg = "#cdffb2", this.lineColor = "green", this.border1 = "#13540c", this.border2 = "#6eaa49", this.arrowheadColor = "green", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.tertiaryColor = At("#cde498", 10), this.primaryBorderColor = Pi(this.primaryColor, this.darkMode), this.secondaryBorderColor = Pi(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = Pi(this.tertiaryColor, this.darkMode), this.primaryTextColor = yt(this.primaryColor), this.secondaryTextColor = yt(this.secondaryColor), this.tertiaryTextColor = yt(this.primaryColor), this.lineColor = yt(this.background), this.textColor = yt(this.background), this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "#333", this.edgeLabelBackground = "#e8e8e8", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "black", this.actorLineColor = "calculated", this.signalColor = "#333", this.signalTextColor = "#333", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "#326932", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "#6eaa49", this.altSectionBkgColor = "white", this.sectionBkgColor2 = "#6eaa49", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "#487e3a", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "black", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "lightgrey", this.doneTaskBkgColor = "lightgrey", this.doneTaskBorderColor = "grey", this.critBorderColor = "#ff8888", this.critBkgColor = "red", this.todayLineColor = "red", this.vertLineColor = "#00BFFF", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222";
  }
  updateColors() {
    this.actorBorder = It(this.mainBkg, 20), this.actorBkg = this.mainBkg, this.labelBoxBkgColor = this.actorBkg, this.labelTextColor = this.actorTextColor, this.loopTextColor = this.actorTextColor, this.noteBorderColor = this.border2, this.noteTextColor = this.actorTextColor, this.actorLineColor = this.actorBorder, this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || Ie(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || Ie(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || Ie(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || Ie(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || Ie(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || Ie(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || Ie(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || Ie(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || Ie(this.primaryColor, { h: 330 }), this.cScalePeer1 = this.cScalePeer1 || It(this.secondaryColor, 45), this.cScalePeer2 = this.cScalePeer2 || It(this.tertiaryColor, 40);
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScale" + t] = It(this["cScale" + t], 10), this["cScalePeer" + t] = this["cScalePeer" + t] || It(this["cScale" + t], 25);
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScaleInv" + t] = this["cScaleInv" + t] || Ie(this["cScale" + t], { h: 180 });
    this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScaleLabel" + t] = this["cScaleLabel" + t] || this.scaleLabelColor;
    for (let t = 0; t < 5; t++)
      this["surface" + t] = this["surface" + t] || Ie(this.mainBkg, { h: 30, s: -30, l: -(5 + t * 5) }), this["surfacePeer" + t] = this["surfacePeer" + t] || Ie(this.mainBkg, { h: 30, s: -30, l: -(8 + t * 5) });
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.taskBorderColor = this.border1, this.taskTextColor = this.taskTextLightColor, this.taskTextOutsideColor = this.taskTextDarkColor, this.activeTaskBorderColor = this.taskBorderColor, this.activeTaskBkgColor = this.mainBkg, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.rowOdd = this.rowOdd || At(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || At(this.mainBkg, 20), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f0f0f0", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = this.lineColor, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = Ie(this.primaryColor, { h: 64 }), this.fillType3 = Ie(this.secondaryColor, { h: 64 }), this.fillType4 = Ie(this.primaryColor, { h: -64 }), this.fillType5 = Ie(this.secondaryColor, { h: -64 }), this.fillType6 = Ie(this.primaryColor, { h: 128 }), this.fillType7 = Ie(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || this.tertiaryColor, this.pie4 = this.pie4 || Ie(this.primaryColor, { l: -30 }), this.pie5 = this.pie5 || Ie(this.secondaryColor, { l: -30 }), this.pie6 = this.pie6 || Ie(this.tertiaryColor, { h: 40, l: -40 }), this.pie7 = this.pie7 || Ie(this.primaryColor, { h: 60, l: -10 }), this.pie8 = this.pie8 || Ie(this.primaryColor, { h: -60, l: -10 }), this.pie9 = this.pie9 || Ie(this.primaryColor, { h: 120, l: 0 }), this.pie10 = this.pie10 || Ie(this.primaryColor, { h: 60, l: -50 }), this.pie11 = this.pie11 || Ie(this.primaryColor, { h: -60, l: -50 }), this.pie12 = this.pie12 || Ie(this.primaryColor, { h: 120, l: -50 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || Ie(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || Ie(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || Ie(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || Ie(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || Ie(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || Ie(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || hc(this.quadrant1Fill) ? At(this.quadrant1Fill) : It(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.packet = {
      startByteColor: this.primaryTextColor,
      endByteColor: this.primaryTextColor,
      labelColor: this.primaryTextColor,
      titleColor: this.primaryTextColor,
      blockStrokeColor: this.primaryTextColor,
      blockFillColor: this.mainBkg
    }, this.radar = {
      axisColor: this.radar?.axisColor || this.lineColor,
      axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
      axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
      curveOpacity: this.radar?.curveOpacity || 0.5,
      curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
      graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
      graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
      graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
      legendBoxSize: this.radar?.legendBoxSize || 12,
      legendFontSize: this.radar?.legendFontSize || 12
    }, this.xyChart = {
      backgroundColor: this.xyChart?.backgroundColor || this.background,
      titleColor: this.xyChart?.titleColor || this.primaryTextColor,
      xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
      xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
      xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
      xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
      yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
      yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
      yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
      yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
      plotColorPalette: this.xyChart?.plotColorPalette || "#CDE498,#FF6B6B,#A0D2DB,#D7BDE2,#F0F0F0,#FFC3A0,#7FD8BE,#FF9A8B,#FAF3E0,#FFF176"
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || Ie(this.primaryColor, { h: -30 }), this.git4 = this.git4 || Ie(this.primaryColor, { h: -60 }), this.git5 = this.git5 || Ie(this.primaryColor, { h: -90 }), this.git6 = this.git6 || Ie(this.primaryColor, { h: 60 }), this.git7 = this.git7 || Ie(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = At(this.git0, 25), this.git1 = At(this.git1, 25), this.git2 = At(this.git2, 25), this.git3 = At(this.git3, 25), this.git4 = At(this.git4, 25), this.git5 = At(this.git5, 25), this.git6 = At(this.git6, 25), this.git7 = At(this.git7, 25)) : (this.git0 = It(this.git0, 25), this.git1 = It(this.git1, 25), this.git2 = It(this.git2, 25), this.git3 = It(this.git3, 25), this.git4 = It(this.git4, 25), this.git5 = It(this.git5, 25), this.git6 = It(this.git6, 25), this.git7 = It(this.git7, 25)), this.gitInv0 = this.gitInv0 || yt(this.git0), this.gitInv1 = this.gitInv1 || yt(this.git1), this.gitInv2 = this.gitInv2 || yt(this.git2), this.gitInv3 = this.gitInv3 || yt(this.git3), this.gitInv4 = this.gitInv4 || yt(this.git4), this.gitInv5 = this.gitInv5 || yt(this.git5), this.gitInv6 = this.gitInv6 || yt(this.git6), this.gitInv7 = this.gitInv7 || yt(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || yt(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || yt(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || L2, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || R2;
  }
  calculate(t) {
    if (typeof t != "object") {
      this.updateColors();
      return;
    }
    const e = Object.keys(t);
    e.forEach((r) => {
      this[r] = t[r];
    }), this.updateColors(), e.forEach((r) => {
      this[r] = t[r];
    });
  }
}, vK = /* @__PURE__ */ x((t) => {
  const e = new mK();
  return e.calculate(t), e;
}, "getThemeVariables"), yK = class {
  static {
    x(this, "Theme");
  }
  constructor() {
    this.primaryColor = "#eee", this.contrast = "#707070", this.secondaryColor = At(this.contrast, 55), this.background = "#ffffff", this.tertiaryColor = Ie(this.primaryColor, { h: -160 }), this.primaryBorderColor = Pi(this.primaryColor, this.darkMode), this.secondaryBorderColor = Pi(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = Pi(this.tertiaryColor, this.darkMode), this.primaryTextColor = yt(this.primaryColor), this.secondaryTextColor = yt(this.secondaryColor), this.tertiaryTextColor = yt(this.tertiaryColor), this.lineColor = yt(this.background), this.textColor = yt(this.background), this.mainBkg = "#eee", this.secondBkg = "calculated", this.lineColor = "#666", this.border1 = "#999", this.border2 = "calculated", this.note = "#ffa", this.text = "#333", this.critical = "#d42", this.done = "#bbb", this.arrowheadColor = "#333333", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "calculated", this.edgeLabelBackground = "white", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "calculated", this.actorLineColor = this.actorBorder, this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "calculated", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "calculated", this.altSectionBkgColor = "white", this.sectionBkgColor2 = "calculated", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "calculated", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "calculated", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "calculated", this.critBkgColor = "calculated", this.critBorderColor = "calculated", this.todayLineColor = "calculated", this.vertLineColor = "calculated", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = this.rowOdd || At(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || "#f4f4f4", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222";
  }
  updateColors() {
    this.secondBkg = At(this.contrast, 55), this.border2 = this.contrast, this.actorBorder = At(this.border1, 23), this.actorBkg = this.mainBkg, this.actorTextColor = this.text, this.actorLineColor = this.actorBorder, this.signalColor = this.text, this.signalTextColor = this.text, this.labelBoxBkgColor = this.actorBkg, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.text, this.loopTextColor = this.text, this.noteBorderColor = "#999", this.noteBkgColor = "#666", this.noteTextColor = "#fff", this.cScale0 = this.cScale0 || "#555", this.cScale1 = this.cScale1 || "#F4F4F4", this.cScale2 = this.cScale2 || "#555", this.cScale3 = this.cScale3 || "#BBB", this.cScale4 = this.cScale4 || "#777", this.cScale5 = this.cScale5 || "#999", this.cScale6 = this.cScale6 || "#DDD", this.cScale7 = this.cScale7 || "#FFF", this.cScale8 = this.cScale8 || "#DDD", this.cScale9 = this.cScale9 || "#BBB", this.cScale10 = this.cScale10 || "#999", this.cScale11 = this.cScale11 || "#777";
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScaleInv" + t] = this["cScaleInv" + t] || yt(this["cScale" + t]);
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this.darkMode ? this["cScalePeer" + t] = this["cScalePeer" + t] || At(this["cScale" + t], 10) : this["cScalePeer" + t] = this["cScalePeer" + t] || It(this["cScale" + t], 10);
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor), this.cScaleLabel0 = this.cScaleLabel0 || this.cScale1, this.cScaleLabel2 = this.cScaleLabel2 || this.cScale1;
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScaleLabel" + t] = this["cScaleLabel" + t] || this.scaleLabelColor;
    for (let t = 0; t < 5; t++)
      this["surface" + t] = this["surface" + t] || Ie(this.mainBkg, { l: -(5 + t * 5) }), this["surfacePeer" + t] = this["surfacePeer" + t] || Ie(this.mainBkg, { l: -(8 + t * 5) });
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.titleColor = this.text, this.sectionBkgColor = At(this.contrast, 30), this.sectionBkgColor2 = At(this.contrast, 30), this.taskBorderColor = It(this.contrast, 10), this.taskBkgColor = this.contrast, this.taskTextColor = this.taskTextLightColor, this.taskTextDarkColor = this.text, this.taskTextOutsideColor = this.taskTextDarkColor, this.activeTaskBorderColor = this.taskBorderColor, this.activeTaskBkgColor = this.mainBkg, this.gridColor = At(this.border1, 30), this.doneTaskBkgColor = this.done, this.doneTaskBorderColor = this.lineColor, this.critBkgColor = this.critical, this.critBorderColor = It(this.critBkgColor, 10), this.todayLineColor = this.critBkgColor, this.vertLineColor = this.critBkgColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.transitionColor = this.transitionColor || "#000", this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f4f4f4", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.stateBorder = this.stateBorder || "#000", this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = "#222", this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = Ie(this.primaryColor, { h: 64 }), this.fillType3 = Ie(this.secondaryColor, { h: 64 }), this.fillType4 = Ie(this.primaryColor, { h: -64 }), this.fillType5 = Ie(this.secondaryColor, { h: -64 }), this.fillType6 = Ie(this.primaryColor, { h: 128 }), this.fillType7 = Ie(this.secondaryColor, { h: 128 });
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["pie" + t] = this["cScale" + t];
    this.pie12 = this.pie0, this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || Ie(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || Ie(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || Ie(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || Ie(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || Ie(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || Ie(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || hc(this.quadrant1Fill) ? At(this.quadrant1Fill) : It(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
      backgroundColor: this.xyChart?.backgroundColor || this.background,
      titleColor: this.xyChart?.titleColor || this.primaryTextColor,
      xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
      xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
      xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
      xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
      yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
      yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
      yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
      yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
      plotColorPalette: this.xyChart?.plotColorPalette || "#EEE,#6BB8E4,#8ACB88,#C7ACD6,#E8DCC2,#FFB2A8,#FFF380,#7E8D91,#FFD8B1,#FAF3E0"
    }, this.radar = {
      axisColor: this.radar?.axisColor || this.lineColor,
      axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
      axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
      curveOpacity: this.radar?.curveOpacity || 0.5,
      curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
      graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
      graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
      graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
      legendBoxSize: this.radar?.legendBoxSize || 12,
      legendFontSize: this.radar?.legendFontSize || 12
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = It(this.pie1, 25) || this.primaryColor, this.git1 = this.pie2 || this.secondaryColor, this.git2 = this.pie3 || this.tertiaryColor, this.git3 = this.pie4 || Ie(this.primaryColor, { h: -30 }), this.git4 = this.pie5 || Ie(this.primaryColor, { h: -60 }), this.git5 = this.pie6 || Ie(this.primaryColor, { h: -90 }), this.git6 = this.pie7 || Ie(this.primaryColor, { h: 60 }), this.git7 = this.pie8 || Ie(this.primaryColor, { h: 120 }), this.gitInv0 = this.gitInv0 || yt(this.git0), this.gitInv1 = this.gitInv1 || yt(this.git1), this.gitInv2 = this.gitInv2 || yt(this.git2), this.gitInv3 = this.gitInv3 || yt(this.git3), this.gitInv4 = this.gitInv4 || yt(this.git4), this.gitInv5 = this.gitInv5 || yt(this.git5), this.gitInv6 = this.gitInv6 || yt(this.git6), this.gitInv7 = this.gitInv7 || yt(this.git7), this.branchLabelColor = this.branchLabelColor || this.labelTextColor, this.gitBranchLabel0 = this.branchLabelColor, this.gitBranchLabel1 = "white", this.gitBranchLabel2 = this.branchLabelColor, this.gitBranchLabel3 = "white", this.gitBranchLabel4 = this.branchLabelColor, this.gitBranchLabel5 = this.branchLabelColor, this.gitBranchLabel6 = this.branchLabelColor, this.gitBranchLabel7 = this.branchLabelColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || L2, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || R2;
  }
  calculate(t) {
    if (typeof t != "object") {
      this.updateColors();
      return;
    }
    const e = Object.keys(t);
    e.forEach((r) => {
      this[r] = t[r];
    }), this.updateColors(), e.forEach((r) => {
      this[r] = t[r];
    });
  }
}, xK = /* @__PURE__ */ x((t) => {
  const e = new yK();
  return e.calculate(t), e;
}, "getThemeVariables"), Ho = {
  base: {
    getThemeVariables: dK
  },
  dark: {
    getThemeVariables: pK
  },
  default: {
    getThemeVariables: M2
  },
  forest: {
    getThemeVariables: vK
  },
  neutral: {
    getThemeVariables: xK
  }
}, Ds = {
  flowchart: {
    useMaxWidth: !0,
    titleTopMargin: 25,
    subGraphTitleMargin: {
      top: 0,
      bottom: 0
    },
    diagramPadding: 8,
    htmlLabels: !0,
    nodeSpacing: 50,
    rankSpacing: 50,
    curve: "basis",
    padding: 15,
    defaultRenderer: "dagre-wrapper",
    wrappingWidth: 200,
    inheritDir: !1
  },
  sequence: {
    useMaxWidth: !0,
    hideUnusedParticipants: !1,
    activationWidth: 10,
    diagramMarginX: 50,
    diagramMarginY: 10,
    actorMargin: 50,
    width: 150,
    height: 65,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    mirrorActors: !0,
    forceMenus: !1,
    bottomMarginAdj: 1,
    rightAngles: !1,
    showSequenceNumbers: !1,
    actorFontSize: 14,
    actorFontFamily: '"Open Sans", sans-serif',
    actorFontWeight: 400,
    noteFontSize: 14,
    noteFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    noteFontWeight: 400,
    noteAlign: "center",
    messageFontSize: 16,
    messageFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    messageFontWeight: 400,
    wrap: !1,
    wrapPadding: 10,
    labelBoxWidth: 50,
    labelBoxHeight: 20
  },
  gantt: {
    useMaxWidth: !0,
    titleTopMargin: 25,
    barHeight: 20,
    barGap: 4,
    topPadding: 50,
    rightPadding: 75,
    leftPadding: 75,
    gridLineStartPadding: 35,
    fontSize: 11,
    sectionFontSize: 11,
    numberSectionStyles: 4,
    axisFormat: "%Y-%m-%d",
    topAxis: !1,
    displayMode: "",
    weekday: "sunday"
  },
  journey: {
    useMaxWidth: !0,
    diagramMarginX: 50,
    diagramMarginY: 10,
    leftMargin: 150,
    maxLabelWidth: 360,
    width: 150,
    height: 50,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    bottomMarginAdj: 1,
    rightAngles: !1,
    taskFontSize: 14,
    taskFontFamily: '"Open Sans", sans-serif',
    taskMargin: 50,
    activationWidth: 10,
    textPlacement: "fo",
    actorColours: [
      "#8FBC8F",
      "#7CFC00",
      "#00FFFF",
      "#20B2AA",
      "#B0E0E6",
      "#FFFFE0"
    ],
    sectionFills: [
      "#191970",
      "#8B008B",
      "#4B0082",
      "#2F4F4F",
      "#800000",
      "#8B4513",
      "#00008B"
    ],
    sectionColours: [
      "#fff"
    ],
    titleColor: "",
    titleFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    titleFontSize: "4ex"
  },
  class: {
    useMaxWidth: !0,
    titleTopMargin: 25,
    arrowMarkerAbsolute: !1,
    dividerMargin: 10,
    padding: 5,
    textHeight: 10,
    defaultRenderer: "dagre-wrapper",
    htmlLabels: !1,
    hideEmptyMembersBox: !1
  },
  state: {
    useMaxWidth: !0,
    titleTopMargin: 25,
    dividerMargin: 10,
    sizeUnit: 5,
    padding: 8,
    textHeight: 10,
    titleShift: -15,
    noteMargin: 10,
    forkWidth: 70,
    forkHeight: 7,
    miniPadding: 2,
    fontSizeFactor: 5.02,
    fontSize: 24,
    labelHeight: 16,
    edgeLengthFactor: "20",
    compositTitleSize: 35,
    radius: 5,
    defaultRenderer: "dagre-wrapper"
  },
  er: {
    useMaxWidth: !0,
    titleTopMargin: 25,
    diagramPadding: 20,
    layoutDirection: "TB",
    minEntityWidth: 100,
    minEntityHeight: 75,
    entityPadding: 15,
    nodeSpacing: 140,
    rankSpacing: 80,
    stroke: "gray",
    fill: "honeydew",
    fontSize: 12
  },
  pie: {
    useMaxWidth: !0,
    textPosition: 0.75
  },
  quadrantChart: {
    useMaxWidth: !0,
    chartWidth: 500,
    chartHeight: 500,
    titleFontSize: 20,
    titlePadding: 10,
    quadrantPadding: 5,
    xAxisLabelPadding: 5,
    yAxisLabelPadding: 5,
    xAxisLabelFontSize: 16,
    yAxisLabelFontSize: 16,
    quadrantLabelFontSize: 16,
    quadrantTextTopPadding: 5,
    pointTextPadding: 5,
    pointLabelFontSize: 12,
    pointRadius: 5,
    xAxisPosition: "top",
    yAxisPosition: "left",
    quadrantInternalBorderStrokeWidth: 1,
    quadrantExternalBorderStrokeWidth: 2
  },
  xyChart: {
    useMaxWidth: !0,
    width: 700,
    height: 500,
    titleFontSize: 20,
    titlePadding: 10,
    showDataLabel: !1,
    showTitle: !0,
    xAxis: {
      $ref: "#/$defs/XYChartAxisConfig",
      showLabel: !0,
      labelFontSize: 14,
      labelPadding: 5,
      showTitle: !0,
      titleFontSize: 16,
      titlePadding: 5,
      showTick: !0,
      tickLength: 5,
      tickWidth: 2,
      showAxisLine: !0,
      axisLineWidth: 2
    },
    yAxis: {
      $ref: "#/$defs/XYChartAxisConfig",
      showLabel: !0,
      labelFontSize: 14,
      labelPadding: 5,
      showTitle: !0,
      titleFontSize: 16,
      titlePadding: 5,
      showTick: !0,
      tickLength: 5,
      tickWidth: 2,
      showAxisLine: !0,
      axisLineWidth: 2
    },
    chartOrientation: "vertical",
    plotReservedSpacePercent: 50
  },
  requirement: {
    useMaxWidth: !0,
    rect_fill: "#f9f9f9",
    text_color: "#333",
    rect_border_size: "0.5px",
    rect_border_color: "#bbb",
    rect_min_width: 200,
    rect_min_height: 200,
    fontSize: 14,
    rect_padding: 10,
    line_height: 20
  },
  mindmap: {
    useMaxWidth: !0,
    padding: 10,
    maxNodeWidth: 200,
    layoutAlgorithm: "cose-bilkent"
  },
  kanban: {
    useMaxWidth: !0,
    padding: 8,
    sectionWidth: 200,
    ticketBaseUrl: ""
  },
  timeline: {
    useMaxWidth: !0,
    diagramMarginX: 50,
    diagramMarginY: 10,
    leftMargin: 150,
    width: 150,
    height: 50,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    bottomMarginAdj: 1,
    rightAngles: !1,
    taskFontSize: 14,
    taskFontFamily: '"Open Sans", sans-serif',
    taskMargin: 50,
    activationWidth: 10,
    textPlacement: "fo",
    actorColours: [
      "#8FBC8F",
      "#7CFC00",
      "#00FFFF",
      "#20B2AA",
      "#B0E0E6",
      "#FFFFE0"
    ],
    sectionFills: [
      "#191970",
      "#8B008B",
      "#4B0082",
      "#2F4F4F",
      "#800000",
      "#8B4513",
      "#00008B"
    ],
    sectionColours: [
      "#fff"
    ],
    disableMulticolor: !1
  },
  gitGraph: {
    useMaxWidth: !0,
    titleTopMargin: 25,
    diagramPadding: 8,
    nodeLabel: {
      width: 75,
      height: 100,
      x: -25,
      y: 0
    },
    mainBranchName: "main",
    mainBranchOrder: 0,
    showCommitLabel: !0,
    showBranches: !0,
    rotateCommitLabel: !0,
    parallelCommits: !1,
    arrowMarkerAbsolute: !1
  },
  c4: {
    useMaxWidth: !0,
    diagramMarginX: 50,
    diagramMarginY: 10,
    c4ShapeMargin: 50,
    c4ShapePadding: 20,
    width: 216,
    height: 60,
    boxMargin: 10,
    c4ShapeInRow: 4,
    nextLinePaddingX: 0,
    c4BoundaryInRow: 2,
    personFontSize: 14,
    personFontFamily: '"Open Sans", sans-serif',
    personFontWeight: "normal",
    external_personFontSize: 14,
    external_personFontFamily: '"Open Sans", sans-serif',
    external_personFontWeight: "normal",
    systemFontSize: 14,
    systemFontFamily: '"Open Sans", sans-serif',
    systemFontWeight: "normal",
    external_systemFontSize: 14,
    external_systemFontFamily: '"Open Sans", sans-serif',
    external_systemFontWeight: "normal",
    system_dbFontSize: 14,
    system_dbFontFamily: '"Open Sans", sans-serif',
    system_dbFontWeight: "normal",
    external_system_dbFontSize: 14,
    external_system_dbFontFamily: '"Open Sans", sans-serif',
    external_system_dbFontWeight: "normal",
    system_queueFontSize: 14,
    system_queueFontFamily: '"Open Sans", sans-serif',
    system_queueFontWeight: "normal",
    external_system_queueFontSize: 14,
    external_system_queueFontFamily: '"Open Sans", sans-serif',
    external_system_queueFontWeight: "normal",
    boundaryFontSize: 14,
    boundaryFontFamily: '"Open Sans", sans-serif',
    boundaryFontWeight: "normal",
    messageFontSize: 12,
    messageFontFamily: '"Open Sans", sans-serif',
    messageFontWeight: "normal",
    containerFontSize: 14,
    containerFontFamily: '"Open Sans", sans-serif',
    containerFontWeight: "normal",
    external_containerFontSize: 14,
    external_containerFontFamily: '"Open Sans", sans-serif',
    external_containerFontWeight: "normal",
    container_dbFontSize: 14,
    container_dbFontFamily: '"Open Sans", sans-serif',
    container_dbFontWeight: "normal",
    external_container_dbFontSize: 14,
    external_container_dbFontFamily: '"Open Sans", sans-serif',
    external_container_dbFontWeight: "normal",
    container_queueFontSize: 14,
    container_queueFontFamily: '"Open Sans", sans-serif',
    container_queueFontWeight: "normal",
    external_container_queueFontSize: 14,
    external_container_queueFontFamily: '"Open Sans", sans-serif',
    external_container_queueFontWeight: "normal",
    componentFontSize: 14,
    componentFontFamily: '"Open Sans", sans-serif',
    componentFontWeight: "normal",
    external_componentFontSize: 14,
    external_componentFontFamily: '"Open Sans", sans-serif',
    external_componentFontWeight: "normal",
    component_dbFontSize: 14,
    component_dbFontFamily: '"Open Sans", sans-serif',
    component_dbFontWeight: "normal",
    external_component_dbFontSize: 14,
    external_component_dbFontFamily: '"Open Sans", sans-serif',
    external_component_dbFontWeight: "normal",
    component_queueFontSize: 14,
    component_queueFontFamily: '"Open Sans", sans-serif',
    component_queueFontWeight: "normal",
    external_component_queueFontSize: 14,
    external_component_queueFontFamily: '"Open Sans", sans-serif',
    external_component_queueFontWeight: "normal",
    wrap: !0,
    wrapPadding: 10,
    person_bg_color: "#08427B",
    person_border_color: "#073B6F",
    external_person_bg_color: "#686868",
    external_person_border_color: "#8A8A8A",
    system_bg_color: "#1168BD",
    system_border_color: "#3C7FC0",
    system_db_bg_color: "#1168BD",
    system_db_border_color: "#3C7FC0",
    system_queue_bg_color: "#1168BD",
    system_queue_border_color: "#3C7FC0",
    external_system_bg_color: "#999999",
    external_system_border_color: "#8A8A8A",
    external_system_db_bg_color: "#999999",
    external_system_db_border_color: "#8A8A8A",
    external_system_queue_bg_color: "#999999",
    external_system_queue_border_color: "#8A8A8A",
    container_bg_color: "#438DD5",
    container_border_color: "#3C7FC0",
    container_db_bg_color: "#438DD5",
    container_db_border_color: "#3C7FC0",
    container_queue_bg_color: "#438DD5",
    container_queue_border_color: "#3C7FC0",
    external_container_bg_color: "#B3B3B3",
    external_container_border_color: "#A6A6A6",
    external_container_db_bg_color: "#B3B3B3",
    external_container_db_border_color: "#A6A6A6",
    external_container_queue_bg_color: "#B3B3B3",
    external_container_queue_border_color: "#A6A6A6",
    component_bg_color: "#85BBF0",
    component_border_color: "#78A8D8",
    component_db_bg_color: "#85BBF0",
    component_db_border_color: "#78A8D8",
    component_queue_bg_color: "#85BBF0",
    component_queue_border_color: "#78A8D8",
    external_component_bg_color: "#CCCCCC",
    external_component_border_color: "#BFBFBF",
    external_component_db_bg_color: "#CCCCCC",
    external_component_db_border_color: "#BFBFBF",
    external_component_queue_bg_color: "#CCCCCC",
    external_component_queue_border_color: "#BFBFBF"
  },
  sankey: {
    useMaxWidth: !0,
    width: 600,
    height: 400,
    linkColor: "gradient",
    nodeAlignment: "justify",
    showValues: !0,
    prefix: "",
    suffix: ""
  },
  block: {
    useMaxWidth: !0,
    padding: 8
  },
  packet: {
    useMaxWidth: !0,
    rowHeight: 32,
    bitWidth: 32,
    bitsPerRow: 32,
    showBits: !0,
    paddingX: 5,
    paddingY: 5
  },
  architecture: {
    useMaxWidth: !0,
    padding: 40,
    iconSize: 80,
    fontSize: 16
  },
  radar: {
    useMaxWidth: !0,
    width: 600,
    height: 600,
    marginTop: 50,
    marginRight: 50,
    marginBottom: 50,
    marginLeft: 50,
    axisScaleFactor: 1,
    axisLabelFactor: 1.05,
    curveTension: 0.17
  },
  theme: "default",
  look: "classic",
  handDrawnSeed: 0,
  layout: "dagre",
  maxTextSize: 5e4,
  maxEdges: 500,
  darkMode: !1,
  fontFamily: '"trebuchet ms", verdana, arial, sans-serif;',
  logLevel: 5,
  securityLevel: "strict",
  startOnLoad: !0,
  arrowMarkerAbsolute: !1,
  secure: [
    "secure",
    "securityLevel",
    "startOnLoad",
    "maxTextSize",
    "suppressErrorRendering",
    "maxEdges"
  ],
  legacyMathML: !1,
  forceLegacyMathML: !1,
  deterministicIds: !1,
  fontSize: 16,
  markdownAutoWrap: !0,
  suppressErrorRendering: !1
}, _I = {
  ...Ds,
  // Set, even though they're `undefined` so that `configKeys` finds these keys
  // TODO: Should we replace these with `null` so that they can go in the JSON Schema?
  deterministicIDSeed: void 0,
  elk: {
    // mergeEdges is needed here to be considered
    mergeEdges: !1,
    nodePlacementStrategy: "BRANDES_KOEPF",
    forceNodeModelOrder: !1,
    considerModelOrder: "NODES_AND_EDGES"
  },
  themeCSS: void 0,
  // add non-JSON default config values
  themeVariables: Ho.default.getThemeVariables(),
  sequence: {
    ...Ds.sequence,
    messageFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    }, "messageFont"),
    noteFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.noteFontFamily,
        fontSize: this.noteFontSize,
        fontWeight: this.noteFontWeight
      };
    }, "noteFont"),
    actorFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.actorFontFamily,
        fontSize: this.actorFontSize,
        fontWeight: this.actorFontWeight
      };
    }, "actorFont")
  },
  class: {
    hideEmptyMembersBox: !1
  },
  gantt: {
    ...Ds.gantt,
    tickInterval: void 0,
    useWidth: void 0
    // can probably be removed since `configKeys` already includes this
  },
  c4: {
    ...Ds.c4,
    useWidth: void 0,
    personFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.personFontFamily,
        fontSize: this.personFontSize,
        fontWeight: this.personFontWeight
      };
    }, "personFont"),
    flowchart: {
      ...Ds.flowchart,
      inheritDir: !1
      // default to legacy behavior
    },
    external_personFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.external_personFontFamily,
        fontSize: this.external_personFontSize,
        fontWeight: this.external_personFontWeight
      };
    }, "external_personFont"),
    systemFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.systemFontFamily,
        fontSize: this.systemFontSize,
        fontWeight: this.systemFontWeight
      };
    }, "systemFont"),
    external_systemFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.external_systemFontFamily,
        fontSize: this.external_systemFontSize,
        fontWeight: this.external_systemFontWeight
      };
    }, "external_systemFont"),
    system_dbFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.system_dbFontFamily,
        fontSize: this.system_dbFontSize,
        fontWeight: this.system_dbFontWeight
      };
    }, "system_dbFont"),
    external_system_dbFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.external_system_dbFontFamily,
        fontSize: this.external_system_dbFontSize,
        fontWeight: this.external_system_dbFontWeight
      };
    }, "external_system_dbFont"),
    system_queueFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.system_queueFontFamily,
        fontSize: this.system_queueFontSize,
        fontWeight: this.system_queueFontWeight
      };
    }, "system_queueFont"),
    external_system_queueFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.external_system_queueFontFamily,
        fontSize: this.external_system_queueFontSize,
        fontWeight: this.external_system_queueFontWeight
      };
    }, "external_system_queueFont"),
    containerFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.containerFontFamily,
        fontSize: this.containerFontSize,
        fontWeight: this.containerFontWeight
      };
    }, "containerFont"),
    external_containerFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.external_containerFontFamily,
        fontSize: this.external_containerFontSize,
        fontWeight: this.external_containerFontWeight
      };
    }, "external_containerFont"),
    container_dbFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.container_dbFontFamily,
        fontSize: this.container_dbFontSize,
        fontWeight: this.container_dbFontWeight
      };
    }, "container_dbFont"),
    external_container_dbFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.external_container_dbFontFamily,
        fontSize: this.external_container_dbFontSize,
        fontWeight: this.external_container_dbFontWeight
      };
    }, "external_container_dbFont"),
    container_queueFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.container_queueFontFamily,
        fontSize: this.container_queueFontSize,
        fontWeight: this.container_queueFontWeight
      };
    }, "container_queueFont"),
    external_container_queueFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.external_container_queueFontFamily,
        fontSize: this.external_container_queueFontSize,
        fontWeight: this.external_container_queueFontWeight
      };
    }, "external_container_queueFont"),
    componentFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.componentFontFamily,
        fontSize: this.componentFontSize,
        fontWeight: this.componentFontWeight
      };
    }, "componentFont"),
    external_componentFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.external_componentFontFamily,
        fontSize: this.external_componentFontSize,
        fontWeight: this.external_componentFontWeight
      };
    }, "external_componentFont"),
    component_dbFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.component_dbFontFamily,
        fontSize: this.component_dbFontSize,
        fontWeight: this.component_dbFontWeight
      };
    }, "component_dbFont"),
    external_component_dbFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.external_component_dbFontFamily,
        fontSize: this.external_component_dbFontSize,
        fontWeight: this.external_component_dbFontWeight
      };
    }, "external_component_dbFont"),
    component_queueFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.component_queueFontFamily,
        fontSize: this.component_queueFontSize,
        fontWeight: this.component_queueFontWeight
      };
    }, "component_queueFont"),
    external_component_queueFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.external_component_queueFontFamily,
        fontSize: this.external_component_queueFontSize,
        fontWeight: this.external_component_queueFontWeight
      };
    }, "external_component_queueFont"),
    boundaryFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.boundaryFontFamily,
        fontSize: this.boundaryFontSize,
        fontWeight: this.boundaryFontWeight
      };
    }, "boundaryFont"),
    messageFont: /* @__PURE__ */ x(function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    }, "messageFont")
  },
  pie: {
    ...Ds.pie,
    useWidth: 984
  },
  xyChart: {
    ...Ds.xyChart,
    useWidth: void 0
  },
  requirement: {
    ...Ds.requirement,
    useWidth: void 0
  },
  packet: {
    ...Ds.packet
  },
  radar: {
    ...Ds.radar
  },
  treemap: {
    useMaxWidth: !0,
    padding: 10,
    diagramPadding: 8,
    showValues: !0,
    nodeWidth: 100,
    nodeHeight: 40,
    borderWidth: 1,
    valueFontSize: 12,
    labelFontSize: 14,
    valueFormat: ","
  }
}, LI = /* @__PURE__ */ x((t, e = "") => Object.keys(t).reduce((r, n) => Array.isArray(t[n]) ? r : typeof t[n] == "object" && t[n] !== null ? [...r, e + n, ...LI(t[n], "")] : [...r, e + n], []), "keyify"), bK = new Set(LI(_I, "")), ur = _I, kv = /* @__PURE__ */ x((t) => {
  if (ie.debug("sanitizeDirective called with", t), !(typeof t != "object" || t == null)) {
    if (Array.isArray(t)) {
      t.forEach((e) => kv(e));
      return;
    }
    for (const e of Object.keys(t)) {
      if (ie.debug("Checking key", e), e.startsWith("__") || e.includes("proto") || e.includes("constr") || !bK.has(e) || t[e] == null) {
        ie.debug("sanitize deleting key: ", e), delete t[e];
        continue;
      }
      if (typeof t[e] == "object") {
        ie.debug("sanitizing object", e), kv(t[e]);
        continue;
      }
      const r = ["themeCSS", "fontFamily", "altFontFamily"];
      for (const n of r)
        e.includes(n) && (ie.debug("sanitizing css option", e), t[e] = wK(t[e]));
    }
    if (t.themeVariables)
      for (const e of Object.keys(t.themeVariables)) {
        const r = t.themeVariables[e];
        r?.match && !r.match(/^[\d "#%(),.;A-Za-z]+$/) && (t.themeVariables[e] = "");
      }
    ie.debug("After sanitization", t);
  }
}, "sanitizeDirective"), wK = /* @__PURE__ */ x((t) => {
  let e = 0, r = 0;
  for (const n of t) {
    if (e < r)
      return "{ /* ERROR: Unbalanced CSS */ }";
    n === "{" ? e++ : n === "}" && r++;
  }
  return e !== r ? "{ /* ERROR: Unbalanced CSS */ }" : t;
}, "sanitizeCss"), hd = Object.freeze(ur), ra = mn({}, hd), Sv, fu = [], Y0 = mn({}, hd), N2 = /* @__PURE__ */ x((t, e) => {
  let r = mn({}, t), n = {};
  for (const i of e)
    NI(i), n = mn(n, i);
  if (r = mn(r, n), n.theme && n.theme in Ho) {
    const i = mn({}, Sv), a = mn(
      i.themeVariables || {},
      n.themeVariables
    );
    r.theme && r.theme in Ho && (r.themeVariables = Ho[r.theme].getThemeVariables(a));
  }
  return Y0 = r, II(Y0), Y0;
}, "updateCurrentConfig"), TK = /* @__PURE__ */ x((t) => (ra = mn({}, hd), ra = mn(ra, t), t.theme && Ho[t.theme] && (ra.themeVariables = Ho[t.theme].getThemeVariables(t.themeVariables)), N2(ra, fu), ra), "setSiteConfig"), EK = /* @__PURE__ */ x((t) => {
  Sv = mn({}, t);
}, "saveConfigFromInitialize"), kK = /* @__PURE__ */ x((t) => (ra = mn(ra, t), N2(ra, fu), ra), "updateSiteConfig"), RI = /* @__PURE__ */ x(() => mn({}, ra), "getSiteConfig"), MI = /* @__PURE__ */ x((t) => (II(t), mn(Y0, t), pr()), "setConfig"), pr = /* @__PURE__ */ x(() => mn({}, Y0), "getConfig"), NI = /* @__PURE__ */ x((t) => {
  t && (["secure", ...ra.secure ?? []].forEach((e) => {
    Object.hasOwn(t, e) && (ie.debug(`Denied attempt to modify a secure key ${e}`, t[e]), delete t[e]);
  }), Object.keys(t).forEach((e) => {
    e.startsWith("__") && delete t[e];
  }), Object.keys(t).forEach((e) => {
    typeof t[e] == "string" && (t[e].includes("<") || t[e].includes(">") || t[e].includes("url(data:")) && delete t[e], typeof t[e] == "object" && NI(t[e]);
  }));
}, "sanitize"), SK = /* @__PURE__ */ x((t) => {
  kv(t), t.fontFamily && !t.themeVariables?.fontFamily && (t.themeVariables = {
    ...t.themeVariables,
    fontFamily: t.fontFamily
  }), fu.push(t), N2(ra, fu);
}, "addDirective"), Cv = /* @__PURE__ */ x((t = ra) => {
  fu = [], N2(t, fu);
}, "reset"), CK = {
  LAZY_LOAD_DEPRECATED: "The configuration options lazyLoadedDiagrams and loadExternalDiagramsAtStartup are deprecated. Please use registerExternalDiagrams instead."
}, sC = {}, AK = /* @__PURE__ */ x((t) => {
  sC[t] || (ie.warn(CK[t]), sC[t] = !0);
}, "issueWarning"), II = /* @__PURE__ */ x((t) => {
  t && (t.lazyLoadedDiagrams || t.loadExternalDiagramsAtStartup) && AK("LAZY_LOAD_DEPRECATED");
}, "checkConfig"), _K = /* @__PURE__ */ x(() => {
  let t = {};
  Sv && (t = mn(t, Sv));
  for (const e of fu)
    t = mn(t, e);
  return t;
}, "getUserDefinedConfig"), qd = /<br\s*\/?>/gi, LK = /* @__PURE__ */ x((t) => t ? PI(t).replace(/\\n/g, "#br#").split("#br#") : [""], "getRows"), RK = /* @__PURE__ */ (() => {
  let t = !1;
  return () => {
    t || (DI(), t = !0);
  };
})();
function DI() {
  const t = "data-temp-href-target";
  ud.addHook("beforeSanitizeAttributes", (e) => {
    e.tagName === "A" && e.hasAttribute("target") && e.setAttribute(t, e.getAttribute("target") ?? "");
  }), ud.addHook("afterSanitizeAttributes", (e) => {
    e.tagName === "A" && e.hasAttribute(t) && (e.setAttribute("target", e.getAttribute(t) ?? ""), e.removeAttribute(t), e.getAttribute("target") === "_blank" && e.setAttribute("rel", "noopener"));
  });
}
x(DI, "setupDompurifyHooks");
var OI = /* @__PURE__ */ x((t) => (RK(), ud.sanitize(t)), "removeScript"), oC = /* @__PURE__ */ x((t, e) => {
  if (e.flowchart?.htmlLabels !== !1) {
    const r = e.securityLevel;
    r === "antiscript" || r === "strict" ? t = OI(t) : r !== "loose" && (t = PI(t), t = t.replace(/</g, "&lt;").replace(/>/g, "&gt;"), t = t.replace(/=/g, "&equals;"), t = DK(t));
  }
  return t;
}, "sanitizeMore"), dr = /* @__PURE__ */ x((t, e) => t && (e.dompurifyConfig ? t = ud.sanitize(oC(t, e), e.dompurifyConfig).toString() : t = ud.sanitize(oC(t, e), {
  FORBID_TAGS: ["style"]
}).toString(), t), "sanitizeText"), MK = /* @__PURE__ */ x((t, e) => typeof t == "string" ? dr(t, e) : t.flat().map((r) => dr(r, e)), "sanitizeTextOrArray"), NK = /* @__PURE__ */ x((t) => qd.test(t), "hasBreaks"), IK = /* @__PURE__ */ x((t) => t.split(qd), "splitBreaks"), DK = /* @__PURE__ */ x((t) => t.replace(/#br#/g, "<br/>"), "placeholderToBreak"), PI = /* @__PURE__ */ x((t) => t.replace(qd, "#br#"), "breakToPlaceholder"), I2 = /* @__PURE__ */ x((t) => {
  let e = "";
  return t && (e = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, e = CSS.escape(e)), e;
}, "getUrl"), Nr = /* @__PURE__ */ x((t) => !(t === !1 || ["false", "null", "0"].includes(String(t).trim().toLowerCase())), "evaluate"), OK = /* @__PURE__ */ x(function(...t) {
  const e = t.filter((r) => !isNaN(r));
  return Math.max(...e);
}, "getMax"), PK = /* @__PURE__ */ x(function(...t) {
  const e = t.filter((r) => !isNaN(r));
  return Math.min(...e);
}, "getMin"), Sl = /* @__PURE__ */ x(function(t) {
  const e = t.split(/(,)/), r = [];
  for (let n = 0; n < e.length; n++) {
    let i = e[n];
    if (i === "," && n > 0 && n + 1 < e.length) {
      const a = e[n - 1], s = e[n + 1];
      BK(a, s) && (i = a + "," + s, n++, r.pop());
    }
    r.push(FK(i));
  }
  return r.join("");
}, "parseGenericTypes"), ew = /* @__PURE__ */ x((t, e) => Math.max(0, t.split(e).length - 1), "countOccurrence"), BK = /* @__PURE__ */ x((t, e) => {
  const r = ew(t, "~"), n = ew(e, "~");
  return r === 1 && n === 1;
}, "shouldCombineSets"), FK = /* @__PURE__ */ x((t) => {
  const e = ew(t, "~");
  let r = !1;
  if (e <= 1)
    return t;
  e % 2 !== 0 && t.startsWith("~") && (t = t.substring(1), r = !0);
  const n = [...t];
  let i = n.indexOf("~"), a = n.lastIndexOf("~");
  for (; i !== -1 && a !== -1 && i !== a; )
    n[i] = "<", n[a] = ">", i = n.indexOf("~"), a = n.lastIndexOf("~");
  return r && n.unshift("~"), n.join("");
}, "processSet"), lC = /* @__PURE__ */ x(() => window.MathMLElement !== void 0, "isMathMLSupported"), tw = /\$\$(.*)\$\$/g, un = /* @__PURE__ */ x((t) => (t.match(tw)?.length ?? 0) > 0, "hasKatex"), ag = /* @__PURE__ */ x(async (t, e) => {
  const r = document.createElement("div");
  r.innerHTML = await sg(t, e), r.id = "katex-temp", r.style.visibility = "hidden", r.style.position = "absolute", r.style.top = "0", document.querySelector("body")?.insertAdjacentElement("beforeend", r);
  const i = { width: r.clientWidth, height: r.clientHeight };
  return r.remove(), i;
}, "calculateMathMLDimensions"), $K = /* @__PURE__ */ x(async (t, e) => {
  if (!un(t))
    return t;
  if (!(lC() || e.legacyMathML || e.forceLegacyMathML))
    return t.replace(tw, "MathML is unsupported in this environment.");
  {
    const { default: r } = await Promise.resolve().then(() => q0e), n = e.forceLegacyMathML || !lC() && e.legacyMathML ? "htmlAndMathml" : "mathml";
    return t.split(qd).map(
      (i) => un(i) ? `<div style="display: flex; align-items: center; justify-content: center; white-space: nowrap;">${i}</div>` : `<div>${i}</div>`
    ).join("").replace(
      tw,
      (i, a) => r.renderToString(a, {
        throwOnError: !0,
        displayMode: !0,
        output: n
      }).replace(/\n/g, " ").replace(/<annotation.*<\/annotation>/g, "")
    );
  }
}, "renderKatexUnsanitized"), sg = /* @__PURE__ */ x(async (t, e) => dr(await $K(t, e), e), "renderKatexSanitized"), at = {
  getRows: LK,
  sanitizeText: dr,
  sanitizeTextOrArray: MK,
  hasBreaks: NK,
  splitBreaks: IK,
  lineBreakRegex: qd,
  removeScript: OI,
  getUrl: I2,
  evaluate: Nr,
  getMax: OK,
  getMin: PK
}, zK = /* @__PURE__ */ x(function(t, e) {
  for (let r of e)
    t.attr(r[0], r[1]);
}, "d3Attrs"), GK = /* @__PURE__ */ x(function(t, e, r) {
  let n = /* @__PURE__ */ new Map();
  return r ? (n.set("width", "100%"), n.set("style", `max-width: ${e}px;`)) : (n.set("height", t), n.set("width", e)), n;
}, "calculateSvgSizeAttrs"), Xi = /* @__PURE__ */ x(function(t, e, r, n) {
  const i = GK(e, r, n);
  zK(t, i);
}, "configureSvgSize"), og = /* @__PURE__ */ x(function(t, e, r, n) {
  const i = e.node().getBBox(), a = i.width, s = i.height;
  ie.info(`SVG bounds: ${a}x${s}`, i);
  let o = 0, l = 0;
  ie.info(`Graph bounds: ${o}x${l}`, t), o = a + r * 2, l = s + r * 2, ie.info(`Calculated bounds: ${o}x${l}`), Xi(e, l, o, n);
  const u = `${i.x - r} ${i.y - r} ${i.width + 2 * r} ${i.height + 2 * r}`;
  e.attr("viewBox", u);
}, "setupGraphViewbox"), ym = {}, VK = /* @__PURE__ */ x((t, e, r) => {
  let n = "";
  return t in ym && ym[t] ? n = ym[t](r) : ie.warn(`No theme found for ${t}`), ` & {
    font-family: ${r.fontFamily};
    font-size: ${r.fontSize};
    fill: ${r.textColor}
  }
  @keyframes edge-animation-frame {
    from {
      stroke-dashoffset: 0;
    }
  }
  @keyframes dash {
    to {
      stroke-dashoffset: 0;
    }
  }
  & .edge-animation-slow {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 50s linear infinite;
    stroke-linecap: round;
  }
  & .edge-animation-fast {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 20s linear infinite;
    stroke-linecap: round;
  }
  /* Classes common for multiple diagrams */

  & .error-icon {
    fill: ${r.errorBkgColor};
  }
  & .error-text {
    fill: ${r.errorTextColor};
    stroke: ${r.errorTextColor};
  }

  & .edge-thickness-normal {
    stroke-width: 1px;
  }
  & .edge-thickness-thick {
    stroke-width: 3.5px
  }
  & .edge-pattern-solid {
    stroke-dasharray: 0;
  }
  & .edge-thickness-invisible {
    stroke-width: 0;
    fill: none;
  }
  & .edge-pattern-dashed{
    stroke-dasharray: 3;
  }
  .edge-pattern-dotted {
    stroke-dasharray: 2;
  }

  & .marker {
    fill: ${r.lineColor};
    stroke: ${r.lineColor};
  }
  & .marker.cross {
    stroke: ${r.lineColor};
  }

  & svg {
    font-family: ${r.fontFamily};
    font-size: ${r.fontSize};
  }
   & p {
    margin: 0
   }

  ${n}

  ${e}
`;
}, "getStyles"), UK = /* @__PURE__ */ x((t, e) => {
  e !== void 0 && (ym[t] = e);
}, "addStylesForDiagram"), HK = VK, sE = {};
A2(sE, {
  clear: () => _n,
  getAccDescription: () => Un,
  getAccTitle: () => Gn,
  getDiagramTitle: () => Ln,
  setAccDescription: () => Vn,
  setAccTitle: () => Cn,
  setDiagramTitle: () => Zn
});
var oE = "", lE = "", cE = "", uE = /* @__PURE__ */ x((t) => dr(t, pr()), "sanitizeText"), _n = /* @__PURE__ */ x(() => {
  oE = "", cE = "", lE = "";
}, "clear"), Cn = /* @__PURE__ */ x((t) => {
  oE = uE(t).replace(/^\s+/g, "");
}, "setAccTitle"), Gn = /* @__PURE__ */ x(() => oE, "getAccTitle"), Vn = /* @__PURE__ */ x((t) => {
  cE = uE(t).replace(/\n\s+/g, `
`);
}, "setAccDescription"), Un = /* @__PURE__ */ x(() => cE, "getAccDescription"), Zn = /* @__PURE__ */ x((t) => {
  lE = uE(t);
}, "setDiagramTitle"), Ln = /* @__PURE__ */ x(() => lE, "getDiagramTitle"), cC = ie, qK = nE, we = pr, rw = MI, BI = hd, hE = /* @__PURE__ */ x((t) => dr(t, we()), "sanitizeText"), FI = og, WK = /* @__PURE__ */ x(() => sE, "getCommonDb"), Av = {}, _v = /* @__PURE__ */ x((t, e, r) => {
  Av[t] && cC.warn(`Diagram with id ${t} already registered. Overwriting.`), Av[t] = e, r && AI(t, r), UK(t, e.styles), e.injectUtils?.(
    cC,
    qK,
    we,
    hE,
    FI,
    WK(),
    () => {
    }
  );
}, "registerDiagram"), nw = /* @__PURE__ */ x((t) => {
  if (t in Av)
    return Av[t];
  throw new YK(t);
}, "getDiagram"), YK = class extends Error {
  static {
    x(this, "DiagramNotFoundError");
  }
  constructor(t) {
    super(`Diagram ${t} not found.`);
  }
};
function xm(t, e) {
  return t == null || e == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function XK(t, e) {
  return t == null || e == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function dE(t) {
  let e, r, n;
  t.length !== 2 ? (e = xm, r = (o, l) => xm(t(o), l), n = (o, l) => t(o) - l) : (e = t === xm || t === XK ? t : jK, r = t, n = t);
  function i(o, l, u = 0, h = o.length) {
    if (u < h) {
      if (e(l, l) !== 0) return h;
      do {
        const d = u + h >>> 1;
        r(o[d], l) < 0 ? u = d + 1 : h = d;
      } while (u < h);
    }
    return u;
  }
  function a(o, l, u = 0, h = o.length) {
    if (u < h) {
      if (e(l, l) !== 0) return h;
      do {
        const d = u + h >>> 1;
        r(o[d], l) <= 0 ? u = d + 1 : h = d;
      } while (u < h);
    }
    return u;
  }
  function s(o, l, u = 0, h = o.length) {
    const d = i(o, l, u, h - 1);
    return d > u && n(o[d - 1], l) > -n(o[d], l) ? d - 1 : d;
  }
  return { left: i, center: s, right: a };
}
function jK() {
  return 0;
}
function KK(t) {
  return t === null ? NaN : +t;
}
const ZK = dE(xm), QK = ZK.right;
dE(KK).center;
class uC extends Map {
  constructor(e, r = tZ) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: r } }), e != null) for (const [n, i] of e) this.set(n, i);
  }
  get(e) {
    return super.get(hC(this, e));
  }
  has(e) {
    return super.has(hC(this, e));
  }
  set(e, r) {
    return super.set(JK(this, e), r);
  }
  delete(e) {
    return super.delete(eZ(this, e));
  }
}
function hC({ _intern: t, _key: e }, r) {
  const n = e(r);
  return t.has(n) ? t.get(n) : r;
}
function JK({ _intern: t, _key: e }, r) {
  const n = e(r);
  return t.has(n) ? t.get(n) : (t.set(n, r), r);
}
function eZ({ _intern: t, _key: e }, r) {
  const n = e(r);
  return t.has(n) && (r = t.get(n), t.delete(n)), r;
}
function tZ(t) {
  return t !== null && typeof t == "object" ? t.valueOf() : t;
}
const rZ = Math.sqrt(50), nZ = Math.sqrt(10), iZ = Math.sqrt(2);
function Lv(t, e, r) {
  const n = (e - t) / Math.max(0, r), i = Math.floor(Math.log10(n)), a = n / Math.pow(10, i), s = a >= rZ ? 10 : a >= nZ ? 5 : a >= iZ ? 2 : 1;
  let o, l, u;
  return i < 0 ? (u = Math.pow(10, -i) / s, o = Math.round(t * u), l = Math.round(e * u), o / u < t && ++o, l / u > e && --l, u = -u) : (u = Math.pow(10, i) * s, o = Math.round(t / u), l = Math.round(e / u), o * u < t && ++o, l * u > e && --l), l < o && 0.5 <= r && r < 2 ? Lv(t, e, r * 2) : [o, l, u];
}
function aZ(t, e, r) {
  if (e = +e, t = +t, r = +r, !(r > 0)) return [];
  if (t === e) return [t];
  const n = e < t, [i, a, s] = n ? Lv(e, t, r) : Lv(t, e, r);
  if (!(a >= i)) return [];
  const o = a - i + 1, l = new Array(o);
  if (n)
    if (s < 0) for (let u = 0; u < o; ++u) l[u] = (a - u) / -s;
    else for (let u = 0; u < o; ++u) l[u] = (a - u) * s;
  else if (s < 0) for (let u = 0; u < o; ++u) l[u] = (i + u) / -s;
  else for (let u = 0; u < o; ++u) l[u] = (i + u) * s;
  return l;
}
function iw(t, e, r) {
  return e = +e, t = +t, r = +r, Lv(t, e, r)[2];
}
function aw(t, e, r) {
  e = +e, t = +t, r = +r;
  const n = e < t, i = n ? iw(e, t, r) : iw(t, e, r);
  return (n ? -1 : 1) * (i < 0 ? 1 / -i : i);
}
function sZ(t, e) {
  let r;
  if (e === void 0)
    for (const n of t)
      n != null && (r < n || r === void 0 && n >= n) && (r = n);
  else {
    let n = -1;
    for (let i of t)
      (i = e(i, ++n, t)) != null && (r < i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function oZ(t, e) {
  let r;
  if (e === void 0)
    for (const n of t)
      n != null && (r > n || r === void 0 && n >= n) && (r = n);
  else {
    let n = -1;
    for (let i of t)
      (i = e(i, ++n, t)) != null && (r > i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function lZ(t, e, r) {
  t = +t, e = +e, r = (i = arguments.length) < 2 ? (e = t, t = 0, 1) : i < 3 ? 1 : +r;
  for (var n = -1, i = Math.max(0, Math.ceil((e - t) / r)) | 0, a = new Array(i); ++n < i; )
    a[n] = t + n * r;
  return a;
}
function cZ(t) {
  return t;
}
var bm = 1, $b = 2, sw = 3, n1 = 4, dC = 1e-6;
function uZ(t) {
  return "translate(" + t + ",0)";
}
function hZ(t) {
  return "translate(0," + t + ")";
}
function dZ(t) {
  return (e) => +t(e);
}
function fZ(t, e) {
  return e = Math.max(0, t.bandwidth() - e * 2) / 2, t.round() && (e = Math.round(e)), (r) => +t(r) + e;
}
function pZ() {
  return !this.__axis;
}
function $I(t, e) {
  var r = [], n = null, i = null, a = 6, s = 6, o = 3, l = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5, u = t === bm || t === n1 ? -1 : 1, h = t === n1 || t === $b ? "x" : "y", d = t === bm || t === sw ? uZ : hZ;
  function f(p) {
    var g = n ?? (e.ticks ? e.ticks.apply(e, r) : e.domain()), m = i ?? (e.tickFormat ? e.tickFormat.apply(e, r) : cZ), v = Math.max(a, 0) + o, y = e.range(), b = +y[0] + l, w = +y[y.length - 1] + l, T = (e.bandwidth ? fZ : dZ)(e.copy(), l), E = p.selection ? p.selection() : p, L = E.selectAll(".domain").data([null]), k = E.selectAll(".tick").data(g, e).order(), C = k.exit(), A = k.enter().append("g").attr("class", "tick"), R = k.select("line"), _ = k.select("text");
    L = L.merge(L.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), k = k.merge(A), R = R.merge(A.append("line").attr("stroke", "currentColor").attr(h + "2", u * a)), _ = _.merge(A.append("text").attr("fill", "currentColor").attr(h, u * v).attr("dy", t === bm ? "0em" : t === sw ? "0.71em" : "0.32em")), p !== E && (L = L.transition(p), k = k.transition(p), R = R.transition(p), _ = _.transition(p), C = C.transition(p).attr("opacity", dC).attr("transform", function(O) {
      return isFinite(O = T(O)) ? d(O + l) : this.getAttribute("transform");
    }), A.attr("opacity", dC).attr("transform", function(O) {
      var P = this.parentNode.__axis;
      return d((P && isFinite(P = P(O)) ? P : T(O)) + l);
    })), C.remove(), L.attr("d", t === n1 || t === $b ? s ? "M" + u * s + "," + b + "H" + l + "V" + w + "H" + u * s : "M" + l + "," + b + "V" + w : s ? "M" + b + "," + u * s + "V" + l + "H" + w + "V" + u * s : "M" + b + "," + l + "H" + w), k.attr("opacity", 1).attr("transform", function(O) {
      return d(T(O) + l);
    }), R.attr(h + "2", u * a), _.attr(h, u * v).text(m), E.filter(pZ).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", t === $b ? "start" : t === n1 ? "end" : "middle"), E.each(function() {
      this.__axis = T;
    });
  }
  return f.scale = function(p) {
    return arguments.length ? (e = p, f) : e;
  }, f.ticks = function() {
    return r = Array.from(arguments), f;
  }, f.tickArguments = function(p) {
    return arguments.length ? (r = p == null ? [] : Array.from(p), f) : r.slice();
  }, f.tickValues = function(p) {
    return arguments.length ? (n = p == null ? null : Array.from(p), f) : n && n.slice();
  }, f.tickFormat = function(p) {
    return arguments.length ? (i = p, f) : i;
  }, f.tickSize = function(p) {
    return arguments.length ? (a = s = +p, f) : a;
  }, f.tickSizeInner = function(p) {
    return arguments.length ? (a = +p, f) : a;
  }, f.tickSizeOuter = function(p) {
    return arguments.length ? (s = +p, f) : s;
  }, f.tickPadding = function(p) {
    return arguments.length ? (o = +p, f) : o;
  }, f.offset = function(p) {
    return arguments.length ? (l = +p, f) : l;
  }, f;
}
function gZ(t) {
  return $I(bm, t);
}
function mZ(t) {
  return $I(sw, t);
}
var vZ = { value: () => {
} };
function zI() {
  for (var t = 0, e = arguments.length, r = {}, n; t < e; ++t) {
    if (!(n = arguments[t] + "") || n in r || /[\s.]/.test(n)) throw new Error("illegal type: " + n);
    r[n] = [];
  }
  return new wm(r);
}
function wm(t) {
  this._ = t;
}
function yZ(t, e) {
  return t.trim().split(/^|\s+/).map(function(r) {
    var n = "", i = r.indexOf(".");
    if (i >= 0 && (n = r.slice(i + 1), r = r.slice(0, i)), r && !e.hasOwnProperty(r)) throw new Error("unknown type: " + r);
    return { type: r, name: n };
  });
}
wm.prototype = zI.prototype = {
  constructor: wm,
  on: function(t, e) {
    var r = this._, n = yZ(t + "", r), i, a = -1, s = n.length;
    if (arguments.length < 2) {
      for (; ++a < s; ) if ((i = (t = n[a]).type) && (i = xZ(r[i], t.name))) return i;
      return;
    }
    if (e != null && typeof e != "function") throw new Error("invalid callback: " + e);
    for (; ++a < s; )
      if (i = (t = n[a]).type) r[i] = fC(r[i], t.name, e);
      else if (e == null) for (i in r) r[i] = fC(r[i], t.name, null);
    return this;
  },
  copy: function() {
    var t = {}, e = this._;
    for (var r in e) t[r] = e[r].slice();
    return new wm(t);
  },
  call: function(t, e) {
    if ((i = arguments.length - 2) > 0) for (var r = new Array(i), n = 0, i, a; n < i; ++n) r[n] = arguments[n + 2];
    if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    for (a = this._[t], n = 0, i = a.length; n < i; ++n) a[n].value.apply(e, r);
  },
  apply: function(t, e, r) {
    if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    for (var n = this._[t], i = 0, a = n.length; i < a; ++i) n[i].value.apply(e, r);
  }
};
function xZ(t, e) {
  for (var r = 0, n = t.length, i; r < n; ++r)
    if ((i = t[r]).name === e)
      return i.value;
}
function fC(t, e, r) {
  for (var n = 0, i = t.length; n < i; ++n)
    if (t[n].name === e) {
      t[n] = vZ, t = t.slice(0, n).concat(t.slice(n + 1));
      break;
    }
  return r != null && t.push({ name: e, value: r }), t;
}
var ow = "http://www.w3.org/1999/xhtml";
const pC = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: ow,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function D2(t) {
  var e = t += "", r = e.indexOf(":");
  return r >= 0 && (e = t.slice(0, r)) !== "xmlns" && (t = t.slice(r + 1)), pC.hasOwnProperty(e) ? { space: pC[e], local: t } : t;
}
function bZ(t) {
  return function() {
    var e = this.ownerDocument, r = this.namespaceURI;
    return r === ow && e.documentElement.namespaceURI === ow ? e.createElement(t) : e.createElementNS(r, t);
  };
}
function wZ(t) {
  return function() {
    return this.ownerDocument.createElementNS(t.space, t.local);
  };
}
function GI(t) {
  var e = D2(t);
  return (e.local ? wZ : bZ)(e);
}
function TZ() {
}
function fE(t) {
  return t == null ? TZ : function() {
    return this.querySelector(t);
  };
}
function EZ(t) {
  typeof t != "function" && (t = fE(t));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var a = e[i], s = a.length, o = n[i] = new Array(s), l, u, h = 0; h < s; ++h)
      (l = a[h]) && (u = t.call(l, l.__data__, h, a)) && ("__data__" in l && (u.__data__ = l.__data__), o[h] = u);
  return new Sa(n, this._parents);
}
function kZ(t) {
  return t == null ? [] : Array.isArray(t) ? t : Array.from(t);
}
function SZ() {
  return [];
}
function VI(t) {
  return t == null ? SZ : function() {
    return this.querySelectorAll(t);
  };
}
function CZ(t) {
  return function() {
    return kZ(t.apply(this, arguments));
  };
}
function AZ(t) {
  typeof t == "function" ? t = CZ(t) : t = VI(t);
  for (var e = this._groups, r = e.length, n = [], i = [], a = 0; a < r; ++a)
    for (var s = e[a], o = s.length, l, u = 0; u < o; ++u)
      (l = s[u]) && (n.push(t.call(l, l.__data__, u, s)), i.push(l));
  return new Sa(n, i);
}
function UI(t) {
  return function() {
    return this.matches(t);
  };
}
function HI(t) {
  return function(e) {
    return e.matches(t);
  };
}
var _Z = Array.prototype.find;
function LZ(t) {
  return function() {
    return _Z.call(this.children, t);
  };
}
function RZ() {
  return this.firstElementChild;
}
function MZ(t) {
  return this.select(t == null ? RZ : LZ(typeof t == "function" ? t : HI(t)));
}
var NZ = Array.prototype.filter;
function IZ() {
  return Array.from(this.children);
}
function DZ(t) {
  return function() {
    return NZ.call(this.children, t);
  };
}
function OZ(t) {
  return this.selectAll(t == null ? IZ : DZ(typeof t == "function" ? t : HI(t)));
}
function PZ(t) {
  typeof t != "function" && (t = UI(t));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var a = e[i], s = a.length, o = n[i] = [], l, u = 0; u < s; ++u)
      (l = a[u]) && t.call(l, l.__data__, u, a) && o.push(l);
  return new Sa(n, this._parents);
}
function qI(t) {
  return new Array(t.length);
}
function BZ() {
  return new Sa(this._enter || this._groups.map(qI), this._parents);
}
function Rv(t, e) {
  this.ownerDocument = t.ownerDocument, this.namespaceURI = t.namespaceURI, this._next = null, this._parent = t, this.__data__ = e;
}
Rv.prototype = {
  constructor: Rv,
  appendChild: function(t) {
    return this._parent.insertBefore(t, this._next);
  },
  insertBefore: function(t, e) {
    return this._parent.insertBefore(t, e);
  },
  querySelector: function(t) {
    return this._parent.querySelector(t);
  },
  querySelectorAll: function(t) {
    return this._parent.querySelectorAll(t);
  }
};
function FZ(t) {
  return function() {
    return t;
  };
}
function $Z(t, e, r, n, i, a) {
  for (var s = 0, o, l = e.length, u = a.length; s < u; ++s)
    (o = e[s]) ? (o.__data__ = a[s], n[s] = o) : r[s] = new Rv(t, a[s]);
  for (; s < l; ++s)
    (o = e[s]) && (i[s] = o);
}
function zZ(t, e, r, n, i, a, s) {
  var o, l, u = /* @__PURE__ */ new Map(), h = e.length, d = a.length, f = new Array(h), p;
  for (o = 0; o < h; ++o)
    (l = e[o]) && (f[o] = p = s.call(l, l.__data__, o, e) + "", u.has(p) ? i[o] = l : u.set(p, l));
  for (o = 0; o < d; ++o)
    p = s.call(t, a[o], o, a) + "", (l = u.get(p)) ? (n[o] = l, l.__data__ = a[o], u.delete(p)) : r[o] = new Rv(t, a[o]);
  for (o = 0; o < h; ++o)
    (l = e[o]) && u.get(f[o]) === l && (i[o] = l);
}
function GZ(t) {
  return t.__data__;
}
function VZ(t, e) {
  if (!arguments.length) return Array.from(this, GZ);
  var r = e ? zZ : $Z, n = this._parents, i = this._groups;
  typeof t != "function" && (t = FZ(t));
  for (var a = i.length, s = new Array(a), o = new Array(a), l = new Array(a), u = 0; u < a; ++u) {
    var h = n[u], d = i[u], f = d.length, p = UZ(t.call(h, h && h.__data__, u, n)), g = p.length, m = o[u] = new Array(g), v = s[u] = new Array(g), y = l[u] = new Array(f);
    r(h, d, m, v, y, p, e);
    for (var b = 0, w = 0, T, E; b < g; ++b)
      if (T = m[b]) {
        for (b >= w && (w = b + 1); !(E = v[w]) && ++w < g; ) ;
        T._next = E || null;
      }
  }
  return s = new Sa(s, n), s._enter = o, s._exit = l, s;
}
function UZ(t) {
  return typeof t == "object" && "length" in t ? t : Array.from(t);
}
function HZ() {
  return new Sa(this._exit || this._groups.map(qI), this._parents);
}
function qZ(t, e, r) {
  var n = this.enter(), i = this, a = this.exit();
  return typeof t == "function" ? (n = t(n), n && (n = n.selection())) : n = n.append(t + ""), e != null && (i = e(i), i && (i = i.selection())), r == null ? a.remove() : r(a), n && i ? n.merge(i).order() : i;
}
function WZ(t) {
  for (var e = t.selection ? t.selection() : t, r = this._groups, n = e._groups, i = r.length, a = n.length, s = Math.min(i, a), o = new Array(i), l = 0; l < s; ++l)
    for (var u = r[l], h = n[l], d = u.length, f = o[l] = new Array(d), p, g = 0; g < d; ++g)
      (p = u[g] || h[g]) && (f[g] = p);
  for (; l < i; ++l)
    o[l] = r[l];
  return new Sa(o, this._parents);
}
function YZ() {
  for (var t = this._groups, e = -1, r = t.length; ++e < r; )
    for (var n = t[e], i = n.length - 1, a = n[i], s; --i >= 0; )
      (s = n[i]) && (a && s.compareDocumentPosition(a) ^ 4 && a.parentNode.insertBefore(s, a), a = s);
  return this;
}
function XZ(t) {
  t || (t = jZ);
  function e(d, f) {
    return d && f ? t(d.__data__, f.__data__) : !d - !f;
  }
  for (var r = this._groups, n = r.length, i = new Array(n), a = 0; a < n; ++a) {
    for (var s = r[a], o = s.length, l = i[a] = new Array(o), u, h = 0; h < o; ++h)
      (u = s[h]) && (l[h] = u);
    l.sort(e);
  }
  return new Sa(i, this._parents).order();
}
function jZ(t, e) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function KZ() {
  var t = arguments[0];
  return arguments[0] = this, t.apply(null, arguments), this;
}
function ZZ() {
  return Array.from(this);
}
function QZ() {
  for (var t = this._groups, e = 0, r = t.length; e < r; ++e)
    for (var n = t[e], i = 0, a = n.length; i < a; ++i) {
      var s = n[i];
      if (s) return s;
    }
  return null;
}
function JZ() {
  let t = 0;
  for (const e of this) ++t;
  return t;
}
function eQ() {
  return !this.node();
}
function tQ(t) {
  for (var e = this._groups, r = 0, n = e.length; r < n; ++r)
    for (var i = e[r], a = 0, s = i.length, o; a < s; ++a)
      (o = i[a]) && t.call(o, o.__data__, a, i);
  return this;
}
function rQ(t) {
  return function() {
    this.removeAttribute(t);
  };
}
function nQ(t) {
  return function() {
    this.removeAttributeNS(t.space, t.local);
  };
}
function iQ(t, e) {
  return function() {
    this.setAttribute(t, e);
  };
}
function aQ(t, e) {
  return function() {
    this.setAttributeNS(t.space, t.local, e);
  };
}
function sQ(t, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? this.removeAttribute(t) : this.setAttribute(t, r);
  };
}
function oQ(t, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? this.removeAttributeNS(t.space, t.local) : this.setAttributeNS(t.space, t.local, r);
  };
}
function lQ(t, e) {
  var r = D2(t);
  if (arguments.length < 2) {
    var n = this.node();
    return r.local ? n.getAttributeNS(r.space, r.local) : n.getAttribute(r);
  }
  return this.each((e == null ? r.local ? nQ : rQ : typeof e == "function" ? r.local ? oQ : sQ : r.local ? aQ : iQ)(r, e));
}
function WI(t) {
  return t.ownerDocument && t.ownerDocument.defaultView || t.document && t || t.defaultView;
}
function cQ(t) {
  return function() {
    this.style.removeProperty(t);
  };
}
function uQ(t, e, r) {
  return function() {
    this.style.setProperty(t, e, r);
  };
}
function hQ(t, e, r) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.style.removeProperty(t) : this.style.setProperty(t, n, r);
  };
}
function dQ(t, e, r) {
  return arguments.length > 1 ? this.each((e == null ? cQ : typeof e == "function" ? hQ : uQ)(t, e, r ?? "")) : dd(this.node(), t);
}
function dd(t, e) {
  return t.style.getPropertyValue(e) || WI(t).getComputedStyle(t, null).getPropertyValue(e);
}
function fQ(t) {
  return function() {
    delete this[t];
  };
}
function pQ(t, e) {
  return function() {
    this[t] = e;
  };
}
function gQ(t, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? delete this[t] : this[t] = r;
  };
}
function mQ(t, e) {
  return arguments.length > 1 ? this.each((e == null ? fQ : typeof e == "function" ? gQ : pQ)(t, e)) : this.node()[t];
}
function YI(t) {
  return t.trim().split(/^|\s+/);
}
function pE(t) {
  return t.classList || new XI(t);
}
function XI(t) {
  this._node = t, this._names = YI(t.getAttribute("class") || "");
}
XI.prototype = {
  add: function(t) {
    var e = this._names.indexOf(t);
    e < 0 && (this._names.push(t), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(t) {
    var e = this._names.indexOf(t);
    e >= 0 && (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(t) {
    return this._names.indexOf(t) >= 0;
  }
};
function jI(t, e) {
  for (var r = pE(t), n = -1, i = e.length; ++n < i; ) r.add(e[n]);
}
function KI(t, e) {
  for (var r = pE(t), n = -1, i = e.length; ++n < i; ) r.remove(e[n]);
}
function vQ(t) {
  return function() {
    jI(this, t);
  };
}
function yQ(t) {
  return function() {
    KI(this, t);
  };
}
function xQ(t, e) {
  return function() {
    (e.apply(this, arguments) ? jI : KI)(this, t);
  };
}
function bQ(t, e) {
  var r = YI(t + "");
  if (arguments.length < 2) {
    for (var n = pE(this.node()), i = -1, a = r.length; ++i < a; ) if (!n.contains(r[i])) return !1;
    return !0;
  }
  return this.each((typeof e == "function" ? xQ : e ? vQ : yQ)(r, e));
}
function wQ() {
  this.textContent = "";
}
function TQ(t) {
  return function() {
    this.textContent = t;
  };
}
function EQ(t) {
  return function() {
    var e = t.apply(this, arguments);
    this.textContent = e ?? "";
  };
}
function kQ(t) {
  return arguments.length ? this.each(t == null ? wQ : (typeof t == "function" ? EQ : TQ)(t)) : this.node().textContent;
}
function SQ() {
  this.innerHTML = "";
}
function CQ(t) {
  return function() {
    this.innerHTML = t;
  };
}
function AQ(t) {
  return function() {
    var e = t.apply(this, arguments);
    this.innerHTML = e ?? "";
  };
}
function _Q(t) {
  return arguments.length ? this.each(t == null ? SQ : (typeof t == "function" ? AQ : CQ)(t)) : this.node().innerHTML;
}
function LQ() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function RQ() {
  return this.each(LQ);
}
function MQ() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function NQ() {
  return this.each(MQ);
}
function IQ(t) {
  var e = typeof t == "function" ? t : GI(t);
  return this.select(function() {
    return this.appendChild(e.apply(this, arguments));
  });
}
function DQ() {
  return null;
}
function OQ(t, e) {
  var r = typeof t == "function" ? t : GI(t), n = e == null ? DQ : typeof e == "function" ? e : fE(e);
  return this.select(function() {
    return this.insertBefore(r.apply(this, arguments), n.apply(this, arguments) || null);
  });
}
function PQ() {
  var t = this.parentNode;
  t && t.removeChild(this);
}
function BQ() {
  return this.each(PQ);
}
function FQ() {
  var t = this.cloneNode(!1), e = this.parentNode;
  return e ? e.insertBefore(t, this.nextSibling) : t;
}
function $Q() {
  var t = this.cloneNode(!0), e = this.parentNode;
  return e ? e.insertBefore(t, this.nextSibling) : t;
}
function zQ(t) {
  return this.select(t ? $Q : FQ);
}
function GQ(t) {
  return arguments.length ? this.property("__data__", t) : this.node().__data__;
}
function VQ(t) {
  return function(e) {
    t.call(this, e, this.__data__);
  };
}
function UQ(t) {
  return t.trim().split(/^|\s+/).map(function(e) {
    var r = "", n = e.indexOf(".");
    return n >= 0 && (r = e.slice(n + 1), e = e.slice(0, n)), { type: e, name: r };
  });
}
function HQ(t) {
  return function() {
    var e = this.__on;
    if (e) {
      for (var r = 0, n = -1, i = e.length, a; r < i; ++r)
        a = e[r], (!t.type || a.type === t.type) && a.name === t.name ? this.removeEventListener(a.type, a.listener, a.options) : e[++n] = a;
      ++n ? e.length = n : delete this.__on;
    }
  };
}
function qQ(t, e, r) {
  return function() {
    var n = this.__on, i, a = VQ(e);
    if (n) {
      for (var s = 0, o = n.length; s < o; ++s)
        if ((i = n[s]).type === t.type && i.name === t.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = a, i.options = r), i.value = e;
          return;
        }
    }
    this.addEventListener(t.type, a, r), i = { type: t.type, name: t.name, value: e, listener: a, options: r }, n ? n.push(i) : this.__on = [i];
  };
}
function WQ(t, e, r) {
  var n = UQ(t + ""), i, a = n.length, s;
  if (arguments.length < 2) {
    var o = this.node().__on;
    if (o) {
      for (var l = 0, u = o.length, h; l < u; ++l)
        for (i = 0, h = o[l]; i < a; ++i)
          if ((s = n[i]).type === h.type && s.name === h.name)
            return h.value;
    }
    return;
  }
  for (o = e ? qQ : HQ, i = 0; i < a; ++i) this.each(o(n[i], e, r));
  return this;
}
function ZI(t, e, r) {
  var n = WI(t), i = n.CustomEvent;
  typeof i == "function" ? i = new i(e, r) : (i = n.document.createEvent("Event"), r ? (i.initEvent(e, r.bubbles, r.cancelable), i.detail = r.detail) : i.initEvent(e, !1, !1)), t.dispatchEvent(i);
}
function YQ(t, e) {
  return function() {
    return ZI(this, t, e);
  };
}
function XQ(t, e) {
  return function() {
    return ZI(this, t, e.apply(this, arguments));
  };
}
function jQ(t, e) {
  return this.each((typeof e == "function" ? XQ : YQ)(t, e));
}
function* KQ() {
  for (var t = this._groups, e = 0, r = t.length; e < r; ++e)
    for (var n = t[e], i = 0, a = n.length, s; i < a; ++i)
      (s = n[i]) && (yield s);
}
var QI = [null];
function Sa(t, e) {
  this._groups = t, this._parents = e;
}
function lg() {
  return new Sa([[document.documentElement]], QI);
}
function ZQ() {
  return this;
}
Sa.prototype = lg.prototype = {
  constructor: Sa,
  select: EZ,
  selectAll: AZ,
  selectChild: MZ,
  selectChildren: OZ,
  filter: PZ,
  data: VZ,
  enter: BZ,
  exit: HZ,
  join: qZ,
  merge: WZ,
  selection: ZQ,
  order: YZ,
  sort: XZ,
  call: KZ,
  nodes: ZZ,
  node: QZ,
  size: JZ,
  empty: eQ,
  each: tQ,
  attr: lQ,
  style: dQ,
  property: mQ,
  classed: bQ,
  text: kQ,
  html: _Q,
  raise: RQ,
  lower: NQ,
  append: IQ,
  insert: OQ,
  remove: BQ,
  clone: zQ,
  datum: GQ,
  on: WQ,
  dispatch: jQ,
  [Symbol.iterator]: KQ
};
function Qe(t) {
  return typeof t == "string" ? new Sa([[document.querySelector(t)]], [document.documentElement]) : new Sa([[t]], QI);
}
function cg(t, e, r) {
  t.prototype = e.prototype = r, r.constructor = t;
}
function O2(t, e) {
  var r = Object.create(t.prototype);
  for (var n in e) r[n] = e[n];
  return r;
}
function zu() {
}
var op = 0.7, Mv = 1 / op, Yh = "\\s*([+-]?\\d+)\\s*", lp = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", eo = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", QQ = /^#([0-9a-f]{3,8})$/, JQ = new RegExp(`^rgb\\(${Yh},${Yh},${Yh}\\)$`), eJ = new RegExp(`^rgb\\(${eo},${eo},${eo}\\)$`), tJ = new RegExp(`^rgba\\(${Yh},${Yh},${Yh},${lp}\\)$`), rJ = new RegExp(`^rgba\\(${eo},${eo},${eo},${lp}\\)$`), nJ = new RegExp(`^hsl\\(${lp},${eo},${eo}\\)$`), iJ = new RegExp(`^hsla\\(${lp},${eo},${eo},${lp}\\)$`), gC = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
cg(zu, pu, {
  copy(t) {
    return Object.assign(new this.constructor(), this, t);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: mC,
  // Deprecated! Use color.formatHex.
  formatHex: mC,
  formatHex8: aJ,
  formatHsl: sJ,
  formatRgb: vC,
  toString: vC
});
function mC() {
  return this.rgb().formatHex();
}
function aJ() {
  return this.rgb().formatHex8();
}
function sJ() {
  return eD(this).formatHsl();
}
function vC() {
  return this.rgb().formatRgb();
}
function pu(t) {
  var e, r;
  return t = (t + "").trim().toLowerCase(), (e = QQ.exec(t)) ? (r = e[1].length, e = parseInt(e[1], 16), r === 6 ? yC(e) : r === 3 ? new wi(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : r === 8 ? i1(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : r === 4 ? i1(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = JQ.exec(t)) ? new wi(e[1], e[2], e[3], 1) : (e = eJ.exec(t)) ? new wi(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = tJ.exec(t)) ? i1(e[1], e[2], e[3], e[4]) : (e = rJ.exec(t)) ? i1(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = nJ.exec(t)) ? wC(e[1], e[2] / 100, e[3] / 100, 1) : (e = iJ.exec(t)) ? wC(e[1], e[2] / 100, e[3] / 100, e[4]) : gC.hasOwnProperty(t) ? yC(gC[t]) : t === "transparent" ? new wi(NaN, NaN, NaN, 0) : null;
}
function yC(t) {
  return new wi(t >> 16 & 255, t >> 8 & 255, t & 255, 1);
}
function i1(t, e, r, n) {
  return n <= 0 && (t = e = r = NaN), new wi(t, e, r, n);
}
function JI(t) {
  return t instanceof zu || (t = pu(t)), t ? (t = t.rgb(), new wi(t.r, t.g, t.b, t.opacity)) : new wi();
}
function lw(t, e, r, n) {
  return arguments.length === 1 ? JI(t) : new wi(t, e, r, n ?? 1);
}
function wi(t, e, r, n) {
  this.r = +t, this.g = +e, this.b = +r, this.opacity = +n;
}
cg(wi, lw, O2(zu, {
  brighter(t) {
    return t = t == null ? Mv : Math.pow(Mv, t), new wi(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? op : Math.pow(op, t), new wi(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new wi(uu(this.r), uu(this.g), uu(this.b), Nv(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: xC,
  // Deprecated! Use color.formatHex.
  formatHex: xC,
  formatHex8: oJ,
  formatRgb: bC,
  toString: bC
}));
function xC() {
  return `#${ru(this.r)}${ru(this.g)}${ru(this.b)}`;
}
function oJ() {
  return `#${ru(this.r)}${ru(this.g)}${ru(this.b)}${ru((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function bC() {
  const t = Nv(this.opacity);
  return `${t === 1 ? "rgb(" : "rgba("}${uu(this.r)}, ${uu(this.g)}, ${uu(this.b)}${t === 1 ? ")" : `, ${t})`}`;
}
function Nv(t) {
  return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
}
function uu(t) {
  return Math.max(0, Math.min(255, Math.round(t) || 0));
}
function ru(t) {
  return t = uu(t), (t < 16 ? "0" : "") + t.toString(16);
}
function wC(t, e, r, n) {
  return n <= 0 ? t = e = r = NaN : r <= 0 || r >= 1 ? t = e = NaN : e <= 0 && (t = NaN), new gs(t, e, r, n);
}
function eD(t) {
  if (t instanceof gs) return new gs(t.h, t.s, t.l, t.opacity);
  if (t instanceof zu || (t = pu(t)), !t) return new gs();
  if (t instanceof gs) return t;
  t = t.rgb();
  var e = t.r / 255, r = t.g / 255, n = t.b / 255, i = Math.min(e, r, n), a = Math.max(e, r, n), s = NaN, o = a - i, l = (a + i) / 2;
  return o ? (e === a ? s = (r - n) / o + (r < n) * 6 : r === a ? s = (n - e) / o + 2 : s = (e - r) / o + 4, o /= l < 0.5 ? a + i : 2 - a - i, s *= 60) : o = l > 0 && l < 1 ? 0 : s, new gs(s, o, l, t.opacity);
}
function lJ(t, e, r, n) {
  return arguments.length === 1 ? eD(t) : new gs(t, e, r, n ?? 1);
}
function gs(t, e, r, n) {
  this.h = +t, this.s = +e, this.l = +r, this.opacity = +n;
}
cg(gs, lJ, O2(zu, {
  brighter(t) {
    return t = t == null ? Mv : Math.pow(Mv, t), new gs(this.h, this.s, this.l * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? op : Math.pow(op, t), new gs(this.h, this.s, this.l * t, this.opacity);
  },
  rgb() {
    var t = this.h % 360 + (this.h < 0) * 360, e = isNaN(t) || isNaN(this.s) ? 0 : this.s, r = this.l, n = r + (r < 0.5 ? r : 1 - r) * e, i = 2 * r - n;
    return new wi(
      zb(t >= 240 ? t - 240 : t + 120, i, n),
      zb(t, i, n),
      zb(t < 120 ? t + 240 : t - 120, i, n),
      this.opacity
    );
  },
  clamp() {
    return new gs(TC(this.h), a1(this.s), a1(this.l), Nv(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const t = Nv(this.opacity);
    return `${t === 1 ? "hsl(" : "hsla("}${TC(this.h)}, ${a1(this.s) * 100}%, ${a1(this.l) * 100}%${t === 1 ? ")" : `, ${t})`}`;
  }
}));
function TC(t) {
  return t = (t || 0) % 360, t < 0 ? t + 360 : t;
}
function a1(t) {
  return Math.max(0, Math.min(1, t || 0));
}
function zb(t, e, r) {
  return (t < 60 ? e + (r - e) * t / 60 : t < 180 ? r : t < 240 ? e + (r - e) * (240 - t) / 60 : e) * 255;
}
const cJ = Math.PI / 180, uJ = 180 / Math.PI, Iv = 18, tD = 0.96422, rD = 1, nD = 0.82521, iD = 4 / 29, Xh = 6 / 29, aD = 3 * Xh * Xh, hJ = Xh * Xh * Xh;
function sD(t) {
  if (t instanceof to) return new to(t.l, t.a, t.b, t.opacity);
  if (t instanceof Fo) return oD(t);
  t instanceof wi || (t = JI(t));
  var e = Hb(t.r), r = Hb(t.g), n = Hb(t.b), i = Gb((0.2225045 * e + 0.7168786 * r + 0.0606169 * n) / rD), a, s;
  return e === r && r === n ? a = s = i : (a = Gb((0.4360747 * e + 0.3850649 * r + 0.1430804 * n) / tD), s = Gb((0.0139322 * e + 0.0971045 * r + 0.7141733 * n) / nD)), new to(116 * i - 16, 500 * (a - i), 200 * (i - s), t.opacity);
}
function dJ(t, e, r, n) {
  return arguments.length === 1 ? sD(t) : new to(t, e, r, n ?? 1);
}
function to(t, e, r, n) {
  this.l = +t, this.a = +e, this.b = +r, this.opacity = +n;
}
cg(to, dJ, O2(zu, {
  brighter(t) {
    return new to(this.l + Iv * (t ?? 1), this.a, this.b, this.opacity);
  },
  darker(t) {
    return new to(this.l - Iv * (t ?? 1), this.a, this.b, this.opacity);
  },
  rgb() {
    var t = (this.l + 16) / 116, e = isNaN(this.a) ? t : t + this.a / 500, r = isNaN(this.b) ? t : t - this.b / 200;
    return e = tD * Vb(e), t = rD * Vb(t), r = nD * Vb(r), new wi(
      Ub(3.1338561 * e - 1.6168667 * t - 0.4906146 * r),
      Ub(-0.9787684 * e + 1.9161415 * t + 0.033454 * r),
      Ub(0.0719453 * e - 0.2289914 * t + 1.4052427 * r),
      this.opacity
    );
  }
}));
function Gb(t) {
  return t > hJ ? Math.pow(t, 1 / 3) : t / aD + iD;
}
function Vb(t) {
  return t > Xh ? t * t * t : aD * (t - iD);
}
function Ub(t) {
  return 255 * (t <= 31308e-7 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - 0.055);
}
function Hb(t) {
  return (t /= 255) <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
}
function fJ(t) {
  if (t instanceof Fo) return new Fo(t.h, t.c, t.l, t.opacity);
  if (t instanceof to || (t = sD(t)), t.a === 0 && t.b === 0) return new Fo(NaN, 0 < t.l && t.l < 100 ? 0 : NaN, t.l, t.opacity);
  var e = Math.atan2(t.b, t.a) * uJ;
  return new Fo(e < 0 ? e + 360 : e, Math.sqrt(t.a * t.a + t.b * t.b), t.l, t.opacity);
}
function cw(t, e, r, n) {
  return arguments.length === 1 ? fJ(t) : new Fo(t, e, r, n ?? 1);
}
function Fo(t, e, r, n) {
  this.h = +t, this.c = +e, this.l = +r, this.opacity = +n;
}
function oD(t) {
  if (isNaN(t.h)) return new to(t.l, 0, 0, t.opacity);
  var e = t.h * cJ;
  return new to(t.l, Math.cos(e) * t.c, Math.sin(e) * t.c, t.opacity);
}
cg(Fo, cw, O2(zu, {
  brighter(t) {
    return new Fo(this.h, this.c, this.l + Iv * (t ?? 1), this.opacity);
  },
  darker(t) {
    return new Fo(this.h, this.c, this.l - Iv * (t ?? 1), this.opacity);
  },
  rgb() {
    return oD(this).rgb();
  }
}));
const P2 = (t) => () => t;
function lD(t, e) {
  return function(r) {
    return t + r * e;
  };
}
function pJ(t, e, r) {
  return t = Math.pow(t, r), e = Math.pow(e, r) - t, r = 1 / r, function(n) {
    return Math.pow(t + n * e, r);
  };
}
function gJ(t, e) {
  var r = e - t;
  return r ? lD(t, r > 180 || r < -180 ? r - 360 * Math.round(r / 360) : r) : P2(isNaN(t) ? e : t);
}
function mJ(t) {
  return (t = +t) == 1 ? X0 : function(e, r) {
    return r - e ? pJ(e, r, t) : P2(isNaN(e) ? r : e);
  };
}
function X0(t, e) {
  var r = e - t;
  return r ? lD(t, r) : P2(isNaN(t) ? e : t);
}
const Dv = (function t(e) {
  var r = mJ(e);
  function n(i, a) {
    var s = r((i = lw(i)).r, (a = lw(a)).r), o = r(i.g, a.g), l = r(i.b, a.b), u = X0(i.opacity, a.opacity);
    return function(h) {
      return i.r = s(h), i.g = o(h), i.b = l(h), i.opacity = u(h), i + "";
    };
  }
  return n.gamma = t, n;
})(1);
function vJ(t, e) {
  e || (e = []);
  var r = t ? Math.min(e.length, t.length) : 0, n = e.slice(), i;
  return function(a) {
    for (i = 0; i < r; ++i) n[i] = t[i] * (1 - a) + e[i] * a;
    return n;
  };
}
function yJ(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function xJ(t, e) {
  var r = e ? e.length : 0, n = t ? Math.min(r, t.length) : 0, i = new Array(n), a = new Array(r), s;
  for (s = 0; s < n; ++s) i[s] = gE(t[s], e[s]);
  for (; s < r; ++s) a[s] = e[s];
  return function(o) {
    for (s = 0; s < n; ++s) a[s] = i[s](o);
    return a;
  };
}
function bJ(t, e) {
  var r = /* @__PURE__ */ new Date();
  return t = +t, e = +e, function(n) {
    return r.setTime(t * (1 - n) + e * n), r;
  };
}
function ds(t, e) {
  return t = +t, e = +e, function(r) {
    return t * (1 - r) + e * r;
  };
}
function wJ(t, e) {
  var r = {}, n = {}, i;
  (t === null || typeof t != "object") && (t = {}), (e === null || typeof e != "object") && (e = {});
  for (i in e)
    i in t ? r[i] = gE(t[i], e[i]) : n[i] = e[i];
  return function(a) {
    for (i in r) n[i] = r[i](a);
    return n;
  };
}
var uw = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, qb = new RegExp(uw.source, "g");
function TJ(t) {
  return function() {
    return t;
  };
}
function EJ(t) {
  return function(e) {
    return t(e) + "";
  };
}
function cD(t, e) {
  var r = uw.lastIndex = qb.lastIndex = 0, n, i, a, s = -1, o = [], l = [];
  for (t = t + "", e = e + ""; (n = uw.exec(t)) && (i = qb.exec(e)); )
    (a = i.index) > r && (a = e.slice(r, a), o[s] ? o[s] += a : o[++s] = a), (n = n[0]) === (i = i[0]) ? o[s] ? o[s] += i : o[++s] = i : (o[++s] = null, l.push({ i: s, x: ds(n, i) })), r = qb.lastIndex;
  return r < e.length && (a = e.slice(r), o[s] ? o[s] += a : o[++s] = a), o.length < 2 ? l[0] ? EJ(l[0].x) : TJ(e) : (e = l.length, function(u) {
    for (var h = 0, d; h < e; ++h) o[(d = l[h]).i] = d.x(u);
    return o.join("");
  });
}
function gE(t, e) {
  var r = typeof e, n;
  return e == null || r === "boolean" ? P2(e) : (r === "number" ? ds : r === "string" ? (n = pu(e)) ? (e = n, Dv) : cD : e instanceof pu ? Dv : e instanceof Date ? bJ : yJ(e) ? vJ : Array.isArray(e) ? xJ : typeof e.valueOf != "function" && typeof e.toString != "function" || isNaN(e) ? wJ : ds)(t, e);
}
function kJ(t, e) {
  return t = +t, e = +e, function(r) {
    return Math.round(t * (1 - r) + e * r);
  };
}
var EC = 180 / Math.PI, hw = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function uD(t, e, r, n, i, a) {
  var s, o, l;
  return (s = Math.sqrt(t * t + e * e)) && (t /= s, e /= s), (l = t * r + e * n) && (r -= t * l, n -= e * l), (o = Math.sqrt(r * r + n * n)) && (r /= o, n /= o, l /= o), t * n < e * r && (t = -t, e = -e, l = -l, s = -s), {
    translateX: i,
    translateY: a,
    rotate: Math.atan2(e, t) * EC,
    skewX: Math.atan(l) * EC,
    scaleX: s,
    scaleY: o
  };
}
var s1;
function SJ(t) {
  const e = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(t + "");
  return e.isIdentity ? hw : uD(e.a, e.b, e.c, e.d, e.e, e.f);
}
function CJ(t) {
  return t == null || (s1 || (s1 = document.createElementNS("http://www.w3.org/2000/svg", "g")), s1.setAttribute("transform", t), !(t = s1.transform.baseVal.consolidate())) ? hw : (t = t.matrix, uD(t.a, t.b, t.c, t.d, t.e, t.f));
}
function hD(t, e, r, n) {
  function i(u) {
    return u.length ? u.pop() + " " : "";
  }
  function a(u, h, d, f, p, g) {
    if (u !== d || h !== f) {
      var m = p.push("translate(", null, e, null, r);
      g.push({ i: m - 4, x: ds(u, d) }, { i: m - 2, x: ds(h, f) });
    } else (d || f) && p.push("translate(" + d + e + f + r);
  }
  function s(u, h, d, f) {
    u !== h ? (u - h > 180 ? h += 360 : h - u > 180 && (u += 360), f.push({ i: d.push(i(d) + "rotate(", null, n) - 2, x: ds(u, h) })) : h && d.push(i(d) + "rotate(" + h + n);
  }
  function o(u, h, d, f) {
    u !== h ? f.push({ i: d.push(i(d) + "skewX(", null, n) - 2, x: ds(u, h) }) : h && d.push(i(d) + "skewX(" + h + n);
  }
  function l(u, h, d, f, p, g) {
    if (u !== d || h !== f) {
      var m = p.push(i(p) + "scale(", null, ",", null, ")");
      g.push({ i: m - 4, x: ds(u, d) }, { i: m - 2, x: ds(h, f) });
    } else (d !== 1 || f !== 1) && p.push(i(p) + "scale(" + d + "," + f + ")");
  }
  return function(u, h) {
    var d = [], f = [];
    return u = t(u), h = t(h), a(u.translateX, u.translateY, h.translateX, h.translateY, d, f), s(u.rotate, h.rotate, d, f), o(u.skewX, h.skewX, d, f), l(u.scaleX, u.scaleY, h.scaleX, h.scaleY, d, f), u = h = null, function(p) {
      for (var g = -1, m = f.length, v; ++g < m; ) d[(v = f[g]).i] = v.x(p);
      return d.join("");
    };
  };
}
var AJ = hD(SJ, "px, ", "px)", "deg)"), _J = hD(CJ, ", ", ")", ")");
function LJ(t) {
  return function(e, r) {
    var n = t((e = cw(e)).h, (r = cw(r)).h), i = X0(e.c, r.c), a = X0(e.l, r.l), s = X0(e.opacity, r.opacity);
    return function(o) {
      return e.h = n(o), e.c = i(o), e.l = a(o), e.opacity = s(o), e + "";
    };
  };
}
const RJ = LJ(gJ);
var fd = 0, Hf = 0, yf = 0, dD = 1e3, Ov, qf, Pv = 0, gu = 0, B2 = 0, cp = typeof performance == "object" && performance.now ? performance : Date, fD = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(t) {
  setTimeout(t, 17);
};
function mE() {
  return gu || (fD(MJ), gu = cp.now() + B2);
}
function MJ() {
  gu = 0;
}
function Bv() {
  this._call = this._time = this._next = null;
}
Bv.prototype = pD.prototype = {
  constructor: Bv,
  restart: function(t, e, r) {
    if (typeof t != "function") throw new TypeError("callback is not a function");
    r = (r == null ? mE() : +r) + (e == null ? 0 : +e), !this._next && qf !== this && (qf ? qf._next = this : Ov = this, qf = this), this._call = t, this._time = r, dw();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, dw());
  }
};
function pD(t, e, r) {
  var n = new Bv();
  return n.restart(t, e, r), n;
}
function NJ() {
  mE(), ++fd;
  for (var t = Ov, e; t; )
    (e = gu - t._time) >= 0 && t._call.call(void 0, e), t = t._next;
  --fd;
}
function kC() {
  gu = (Pv = cp.now()) + B2, fd = Hf = 0;
  try {
    NJ();
  } finally {
    fd = 0, DJ(), gu = 0;
  }
}
function IJ() {
  var t = cp.now(), e = t - Pv;
  e > dD && (B2 -= e, Pv = t);
}
function DJ() {
  for (var t, e = Ov, r, n = 1 / 0; e; )
    e._call ? (n > e._time && (n = e._time), t = e, e = e._next) : (r = e._next, e._next = null, e = t ? t._next = r : Ov = r);
  qf = t, dw(n);
}
function dw(t) {
  if (!fd) {
    Hf && (Hf = clearTimeout(Hf));
    var e = t - gu;
    e > 24 ? (t < 1 / 0 && (Hf = setTimeout(kC, t - cp.now() - B2)), yf && (yf = clearInterval(yf))) : (yf || (Pv = cp.now(), yf = setInterval(IJ, dD)), fd = 1, fD(kC));
  }
}
function SC(t, e, r) {
  var n = new Bv();
  return e = e == null ? 0 : +e, n.restart((i) => {
    n.stop(), t(i + e);
  }, e, r), n;
}
var OJ = zI("start", "end", "cancel", "interrupt"), PJ = [], gD = 0, CC = 1, fw = 2, Tm = 3, AC = 4, pw = 5, Em = 6;
function F2(t, e, r, n, i, a) {
  var s = t.__transition;
  if (!s) t.__transition = {};
  else if (r in s) return;
  BJ(t, r, {
    name: e,
    index: n,
    // For context during callback.
    group: i,
    // For context during callback.
    on: OJ,
    tween: PJ,
    time: a.time,
    delay: a.delay,
    duration: a.duration,
    ease: a.ease,
    timer: null,
    state: gD
  });
}
function vE(t, e) {
  var r = Rs(t, e);
  if (r.state > gD) throw new Error("too late; already scheduled");
  return r;
}
function co(t, e) {
  var r = Rs(t, e);
  if (r.state > Tm) throw new Error("too late; already running");
  return r;
}
function Rs(t, e) {
  var r = t.__transition;
  if (!r || !(r = r[e])) throw new Error("transition not found");
  return r;
}
function BJ(t, e, r) {
  var n = t.__transition, i;
  n[e] = r, r.timer = pD(a, 0, r.time);
  function a(u) {
    r.state = CC, r.timer.restart(s, r.delay, r.time), r.delay <= u && s(u - r.delay);
  }
  function s(u) {
    var h, d, f, p;
    if (r.state !== CC) return l();
    for (h in n)
      if (p = n[h], p.name === r.name) {
        if (p.state === Tm) return SC(s);
        p.state === AC ? (p.state = Em, p.timer.stop(), p.on.call("interrupt", t, t.__data__, p.index, p.group), delete n[h]) : +h < e && (p.state = Em, p.timer.stop(), p.on.call("cancel", t, t.__data__, p.index, p.group), delete n[h]);
      }
    if (SC(function() {
      r.state === Tm && (r.state = AC, r.timer.restart(o, r.delay, r.time), o(u));
    }), r.state = fw, r.on.call("start", t, t.__data__, r.index, r.group), r.state === fw) {
      for (r.state = Tm, i = new Array(f = r.tween.length), h = 0, d = -1; h < f; ++h)
        (p = r.tween[h].value.call(t, t.__data__, r.index, r.group)) && (i[++d] = p);
      i.length = d + 1;
    }
  }
  function o(u) {
    for (var h = u < r.duration ? r.ease.call(null, u / r.duration) : (r.timer.restart(l), r.state = pw, 1), d = -1, f = i.length; ++d < f; )
      i[d].call(t, h);
    r.state === pw && (r.on.call("end", t, t.__data__, r.index, r.group), l());
  }
  function l() {
    r.state = Em, r.timer.stop(), delete n[e];
    for (var u in n) return;
    delete t.__transition;
  }
}
function FJ(t, e) {
  var r = t.__transition, n, i, a = !0, s;
  if (r) {
    e = e == null ? null : e + "";
    for (s in r) {
      if ((n = r[s]).name !== e) {
        a = !1;
        continue;
      }
      i = n.state > fw && n.state < pw, n.state = Em, n.timer.stop(), n.on.call(i ? "interrupt" : "cancel", t, t.__data__, n.index, n.group), delete r[s];
    }
    a && delete t.__transition;
  }
}
function $J(t) {
  return this.each(function() {
    FJ(this, t);
  });
}
function zJ(t, e) {
  var r, n;
  return function() {
    var i = co(this, t), a = i.tween;
    if (a !== r) {
      n = r = a;
      for (var s = 0, o = n.length; s < o; ++s)
        if (n[s].name === e) {
          n = n.slice(), n.splice(s, 1);
          break;
        }
    }
    i.tween = n;
  };
}
function GJ(t, e, r) {
  var n, i;
  if (typeof r != "function") throw new Error();
  return function() {
    var a = co(this, t), s = a.tween;
    if (s !== n) {
      i = (n = s).slice();
      for (var o = { name: e, value: r }, l = 0, u = i.length; l < u; ++l)
        if (i[l].name === e) {
          i[l] = o;
          break;
        }
      l === u && i.push(o);
    }
    a.tween = i;
  };
}
function VJ(t, e) {
  var r = this._id;
  if (t += "", arguments.length < 2) {
    for (var n = Rs(this.node(), r).tween, i = 0, a = n.length, s; i < a; ++i)
      if ((s = n[i]).name === t)
        return s.value;
    return null;
  }
  return this.each((e == null ? zJ : GJ)(r, t, e));
}
function yE(t, e, r) {
  var n = t._id;
  return t.each(function() {
    var i = co(this, n);
    (i.value || (i.value = {}))[e] = r.apply(this, arguments);
  }), function(i) {
    return Rs(i, n).value[e];
  };
}
function mD(t, e) {
  var r;
  return (typeof e == "number" ? ds : e instanceof pu ? Dv : (r = pu(e)) ? (e = r, Dv) : cD)(t, e);
}
function UJ(t) {
  return function() {
    this.removeAttribute(t);
  };
}
function HJ(t) {
  return function() {
    this.removeAttributeNS(t.space, t.local);
  };
}
function qJ(t, e, r) {
  var n, i = r + "", a;
  return function() {
    var s = this.getAttribute(t);
    return s === i ? null : s === n ? a : a = e(n = s, r);
  };
}
function WJ(t, e, r) {
  var n, i = r + "", a;
  return function() {
    var s = this.getAttributeNS(t.space, t.local);
    return s === i ? null : s === n ? a : a = e(n = s, r);
  };
}
function YJ(t, e, r) {
  var n, i, a;
  return function() {
    var s, o = r(this), l;
    return o == null ? void this.removeAttribute(t) : (s = this.getAttribute(t), l = o + "", s === l ? null : s === n && l === i ? a : (i = l, a = e(n = s, o)));
  };
}
function XJ(t, e, r) {
  var n, i, a;
  return function() {
    var s, o = r(this), l;
    return o == null ? void this.removeAttributeNS(t.space, t.local) : (s = this.getAttributeNS(t.space, t.local), l = o + "", s === l ? null : s === n && l === i ? a : (i = l, a = e(n = s, o)));
  };
}
function jJ(t, e) {
  var r = D2(t), n = r === "transform" ? _J : mD;
  return this.attrTween(t, typeof e == "function" ? (r.local ? XJ : YJ)(r, n, yE(this, "attr." + t, e)) : e == null ? (r.local ? HJ : UJ)(r) : (r.local ? WJ : qJ)(r, n, e));
}
function KJ(t, e) {
  return function(r) {
    this.setAttribute(t, e.call(this, r));
  };
}
function ZJ(t, e) {
  return function(r) {
    this.setAttributeNS(t.space, t.local, e.call(this, r));
  };
}
function QJ(t, e) {
  var r, n;
  function i() {
    var a = e.apply(this, arguments);
    return a !== n && (r = (n = a) && ZJ(t, a)), r;
  }
  return i._value = e, i;
}
function JJ(t, e) {
  var r, n;
  function i() {
    var a = e.apply(this, arguments);
    return a !== n && (r = (n = a) && KJ(t, a)), r;
  }
  return i._value = e, i;
}
function eee(t, e) {
  var r = "attr." + t;
  if (arguments.length < 2) return (r = this.tween(r)) && r._value;
  if (e == null) return this.tween(r, null);
  if (typeof e != "function") throw new Error();
  var n = D2(t);
  return this.tween(r, (n.local ? QJ : JJ)(n, e));
}
function tee(t, e) {
  return function() {
    vE(this, t).delay = +e.apply(this, arguments);
  };
}
function ree(t, e) {
  return e = +e, function() {
    vE(this, t).delay = e;
  };
}
function nee(t) {
  var e = this._id;
  return arguments.length ? this.each((typeof t == "function" ? tee : ree)(e, t)) : Rs(this.node(), e).delay;
}
function iee(t, e) {
  return function() {
    co(this, t).duration = +e.apply(this, arguments);
  };
}
function aee(t, e) {
  return e = +e, function() {
    co(this, t).duration = e;
  };
}
function see(t) {
  var e = this._id;
  return arguments.length ? this.each((typeof t == "function" ? iee : aee)(e, t)) : Rs(this.node(), e).duration;
}
function oee(t, e) {
  if (typeof e != "function") throw new Error();
  return function() {
    co(this, t).ease = e;
  };
}
function lee(t) {
  var e = this._id;
  return arguments.length ? this.each(oee(e, t)) : Rs(this.node(), e).ease;
}
function cee(t, e) {
  return function() {
    var r = e.apply(this, arguments);
    if (typeof r != "function") throw new Error();
    co(this, t).ease = r;
  };
}
function uee(t) {
  if (typeof t != "function") throw new Error();
  return this.each(cee(this._id, t));
}
function hee(t) {
  typeof t != "function" && (t = UI(t));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var a = e[i], s = a.length, o = n[i] = [], l, u = 0; u < s; ++u)
      (l = a[u]) && t.call(l, l.__data__, u, a) && o.push(l);
  return new Ko(n, this._parents, this._name, this._id);
}
function dee(t) {
  if (t._id !== this._id) throw new Error();
  for (var e = this._groups, r = t._groups, n = e.length, i = r.length, a = Math.min(n, i), s = new Array(n), o = 0; o < a; ++o)
    for (var l = e[o], u = r[o], h = l.length, d = s[o] = new Array(h), f, p = 0; p < h; ++p)
      (f = l[p] || u[p]) && (d[p] = f);
  for (; o < n; ++o)
    s[o] = e[o];
  return new Ko(s, this._parents, this._name, this._id);
}
function fee(t) {
  return (t + "").trim().split(/^|\s+/).every(function(e) {
    var r = e.indexOf(".");
    return r >= 0 && (e = e.slice(0, r)), !e || e === "start";
  });
}
function pee(t, e, r) {
  var n, i, a = fee(e) ? vE : co;
  return function() {
    var s = a(this, t), o = s.on;
    o !== n && (i = (n = o).copy()).on(e, r), s.on = i;
  };
}
function gee(t, e) {
  var r = this._id;
  return arguments.length < 2 ? Rs(this.node(), r).on.on(t) : this.each(pee(r, t, e));
}
function mee(t) {
  return function() {
    var e = this.parentNode;
    for (var r in this.__transition) if (+r !== t) return;
    e && e.removeChild(this);
  };
}
function vee() {
  return this.on("end.remove", mee(this._id));
}
function yee(t) {
  var e = this._name, r = this._id;
  typeof t != "function" && (t = fE(t));
  for (var n = this._groups, i = n.length, a = new Array(i), s = 0; s < i; ++s)
    for (var o = n[s], l = o.length, u = a[s] = new Array(l), h, d, f = 0; f < l; ++f)
      (h = o[f]) && (d = t.call(h, h.__data__, f, o)) && ("__data__" in h && (d.__data__ = h.__data__), u[f] = d, F2(u[f], e, r, f, u, Rs(h, r)));
  return new Ko(a, this._parents, e, r);
}
function xee(t) {
  var e = this._name, r = this._id;
  typeof t != "function" && (t = VI(t));
  for (var n = this._groups, i = n.length, a = [], s = [], o = 0; o < i; ++o)
    for (var l = n[o], u = l.length, h, d = 0; d < u; ++d)
      if (h = l[d]) {
        for (var f = t.call(h, h.__data__, d, l), p, g = Rs(h, r), m = 0, v = f.length; m < v; ++m)
          (p = f[m]) && F2(p, e, r, m, f, g);
        a.push(f), s.push(h);
      }
  return new Ko(a, s, e, r);
}
var bee = lg.prototype.constructor;
function wee() {
  return new bee(this._groups, this._parents);
}
function Tee(t, e) {
  var r, n, i;
  return function() {
    var a = dd(this, t), s = (this.style.removeProperty(t), dd(this, t));
    return a === s ? null : a === r && s === n ? i : i = e(r = a, n = s);
  };
}
function vD(t) {
  return function() {
    this.style.removeProperty(t);
  };
}
function Eee(t, e, r) {
  var n, i = r + "", a;
  return function() {
    var s = dd(this, t);
    return s === i ? null : s === n ? a : a = e(n = s, r);
  };
}
function kee(t, e, r) {
  var n, i, a;
  return function() {
    var s = dd(this, t), o = r(this), l = o + "";
    return o == null && (l = o = (this.style.removeProperty(t), dd(this, t))), s === l ? null : s === n && l === i ? a : (i = l, a = e(n = s, o));
  };
}
function See(t, e) {
  var r, n, i, a = "style." + e, s = "end." + a, o;
  return function() {
    var l = co(this, t), u = l.on, h = l.value[a] == null ? o || (o = vD(e)) : void 0;
    (u !== r || i !== h) && (n = (r = u).copy()).on(s, i = h), l.on = n;
  };
}
function Cee(t, e, r) {
  var n = (t += "") == "transform" ? AJ : mD;
  return e == null ? this.styleTween(t, Tee(t, n)).on("end.style." + t, vD(t)) : typeof e == "function" ? this.styleTween(t, kee(t, n, yE(this, "style." + t, e))).each(See(this._id, t)) : this.styleTween(t, Eee(t, n, e), r).on("end.style." + t, null);
}
function Aee(t, e, r) {
  return function(n) {
    this.style.setProperty(t, e.call(this, n), r);
  };
}
function _ee(t, e, r) {
  var n, i;
  function a() {
    var s = e.apply(this, arguments);
    return s !== i && (n = (i = s) && Aee(t, s, r)), n;
  }
  return a._value = e, a;
}
function Lee(t, e, r) {
  var n = "style." + (t += "");
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (e == null) return this.tween(n, null);
  if (typeof e != "function") throw new Error();
  return this.tween(n, _ee(t, e, r ?? ""));
}
function Ree(t) {
  return function() {
    this.textContent = t;
  };
}
function Mee(t) {
  return function() {
    var e = t(this);
    this.textContent = e ?? "";
  };
}
function Nee(t) {
  return this.tween("text", typeof t == "function" ? Mee(yE(this, "text", t)) : Ree(t == null ? "" : t + ""));
}
function Iee(t) {
  return function(e) {
    this.textContent = t.call(this, e);
  };
}
function Dee(t) {
  var e, r;
  function n() {
    var i = t.apply(this, arguments);
    return i !== r && (e = (r = i) && Iee(i)), e;
  }
  return n._value = t, n;
}
function Oee(t) {
  var e = "text";
  if (arguments.length < 1) return (e = this.tween(e)) && e._value;
  if (t == null) return this.tween(e, null);
  if (typeof t != "function") throw new Error();
  return this.tween(e, Dee(t));
}
function Pee() {
  for (var t = this._name, e = this._id, r = yD(), n = this._groups, i = n.length, a = 0; a < i; ++a)
    for (var s = n[a], o = s.length, l, u = 0; u < o; ++u)
      if (l = s[u]) {
        var h = Rs(l, e);
        F2(l, t, r, u, s, {
          time: h.time + h.delay + h.duration,
          delay: 0,
          duration: h.duration,
          ease: h.ease
        });
      }
  return new Ko(n, this._parents, t, r);
}
function Bee() {
  var t, e, r = this, n = r._id, i = r.size();
  return new Promise(function(a, s) {
    var o = { value: s }, l = { value: function() {
      --i === 0 && a();
    } };
    r.each(function() {
      var u = co(this, n), h = u.on;
      h !== t && (e = (t = h).copy(), e._.cancel.push(o), e._.interrupt.push(o), e._.end.push(l)), u.on = e;
    }), i === 0 && a();
  });
}
var Fee = 0;
function Ko(t, e, r, n) {
  this._groups = t, this._parents = e, this._name = r, this._id = n;
}
function yD() {
  return ++Fee;
}
var ko = lg.prototype;
Ko.prototype = {
  constructor: Ko,
  select: yee,
  selectAll: xee,
  selectChild: ko.selectChild,
  selectChildren: ko.selectChildren,
  filter: hee,
  merge: dee,
  selection: wee,
  transition: Pee,
  call: ko.call,
  nodes: ko.nodes,
  node: ko.node,
  size: ko.size,
  empty: ko.empty,
  each: ko.each,
  on: gee,
  attr: jJ,
  attrTween: eee,
  style: Cee,
  styleTween: Lee,
  text: Nee,
  textTween: Oee,
  remove: vee,
  tween: VJ,
  delay: nee,
  duration: see,
  ease: lee,
  easeVarying: uee,
  end: Bee,
  [Symbol.iterator]: ko[Symbol.iterator]
};
function $ee(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
var zee = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: $ee
};
function Gee(t, e) {
  for (var r; !(r = t.__transition) || !(r = r[e]); )
    if (!(t = t.parentNode))
      throw new Error(`transition ${e} not found`);
  return r;
}
function Vee(t) {
  var e, r;
  t instanceof Ko ? (e = t._id, t = t._name) : (e = yD(), (r = zee).time = mE(), t = t == null ? null : t + "");
  for (var n = this._groups, i = n.length, a = 0; a < i; ++a)
    for (var s = n[a], o = s.length, l, u = 0; u < o; ++u)
      (l = s[u]) && F2(l, t, e, u, s, r || Gee(l, e));
  return new Ko(n, this._parents, t, e);
}
lg.prototype.interrupt = $J;
lg.prototype.transition = Vee;
const gw = Math.PI, mw = 2 * gw, Hc = 1e-6, Uee = mw - Hc;
function xD(t) {
  this._ += t[0];
  for (let e = 1, r = t.length; e < r; ++e)
    this._ += arguments[e] + t[e];
}
function Hee(t) {
  let e = Math.floor(t);
  if (!(e >= 0)) throw new Error(`invalid digits: ${t}`);
  if (e > 15) return xD;
  const r = 10 ** e;
  return function(n) {
    this._ += n[0];
    for (let i = 1, a = n.length; i < a; ++i)
      this._ += Math.round(arguments[i] * r) / r + n[i];
  };
}
let qee = class {
  constructor(e) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = e == null ? xD : Hee(e);
  }
  moveTo(e, r) {
    this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +r}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(e, r) {
    this._append`L${this._x1 = +e},${this._y1 = +r}`;
  }
  quadraticCurveTo(e, r, n, i) {
    this._append`Q${+e},${+r},${this._x1 = +n},${this._y1 = +i}`;
  }
  bezierCurveTo(e, r, n, i, a, s) {
    this._append`C${+e},${+r},${+n},${+i},${this._x1 = +a},${this._y1 = +s}`;
  }
  arcTo(e, r, n, i, a) {
    if (e = +e, r = +r, n = +n, i = +i, a = +a, a < 0) throw new Error(`negative radius: ${a}`);
    let s = this._x1, o = this._y1, l = n - e, u = i - r, h = s - e, d = o - r, f = h * h + d * d;
    if (this._x1 === null)
      this._append`M${this._x1 = e},${this._y1 = r}`;
    else if (f > Hc) if (!(Math.abs(d * l - u * h) > Hc) || !a)
      this._append`L${this._x1 = e},${this._y1 = r}`;
    else {
      let p = n - s, g = i - o, m = l * l + u * u, v = p * p + g * g, y = Math.sqrt(m), b = Math.sqrt(f), w = a * Math.tan((gw - Math.acos((m + f - v) / (2 * y * b))) / 2), T = w / b, E = w / y;
      Math.abs(T - 1) > Hc && this._append`L${e + T * h},${r + T * d}`, this._append`A${a},${a},0,0,${+(d * p > h * g)},${this._x1 = e + E * l},${this._y1 = r + E * u}`;
    }
  }
  arc(e, r, n, i, a, s) {
    if (e = +e, r = +r, n = +n, s = !!s, n < 0) throw new Error(`negative radius: ${n}`);
    let o = n * Math.cos(i), l = n * Math.sin(i), u = e + o, h = r + l, d = 1 ^ s, f = s ? i - a : a - i;
    this._x1 === null ? this._append`M${u},${h}` : (Math.abs(this._x1 - u) > Hc || Math.abs(this._y1 - h) > Hc) && this._append`L${u},${h}`, n && (f < 0 && (f = f % mw + mw), f > Uee ? this._append`A${n},${n},0,1,${d},${e - o},${r - l}A${n},${n},0,1,${d},${this._x1 = u},${this._y1 = h}` : f > Hc && this._append`A${n},${n},0,${+(f >= gw)},${d},${this._x1 = e + n * Math.cos(a)},${this._y1 = r + n * Math.sin(a)}`);
  }
  rect(e, r, n, i) {
    this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +r}h${n = +n}v${+i}h${-n}Z`;
  }
  toString() {
    return this._;
  }
};
function Wee(t) {
  return Math.abs(t = Math.round(t)) >= 1e21 ? t.toLocaleString("en").replace(/,/g, "") : t.toString(10);
}
function Fv(t, e) {
  if ((r = (t = e ? t.toExponential(e - 1) : t.toExponential()).indexOf("e")) < 0) return null;
  var r, n = t.slice(0, r);
  return [
    n.length > 1 ? n[0] + n.slice(2) : n,
    +t.slice(r + 1)
  ];
}
function pd(t) {
  return t = Fv(Math.abs(t)), t ? t[1] : NaN;
}
function Yee(t, e) {
  return function(r, n) {
    for (var i = r.length, a = [], s = 0, o = t[0], l = 0; i > 0 && o > 0 && (l + o + 1 > n && (o = Math.max(1, n - l)), a.push(r.substring(i -= o, i + o)), !((l += o + 1) > n)); )
      o = t[s = (s + 1) % t.length];
    return a.reverse().join(e);
  };
}
function Xee(t) {
  return function(e) {
    return e.replace(/[0-9]/g, function(r) {
      return t[+r];
    });
  };
}
var jee = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function $v(t) {
  if (!(e = jee.exec(t))) throw new Error("invalid format: " + t);
  var e;
  return new xE({
    fill: e[1],
    align: e[2],
    sign: e[3],
    symbol: e[4],
    zero: e[5],
    width: e[6],
    comma: e[7],
    precision: e[8] && e[8].slice(1),
    trim: e[9],
    type: e[10]
  });
}
$v.prototype = xE.prototype;
function xE(t) {
  this.fill = t.fill === void 0 ? " " : t.fill + "", this.align = t.align === void 0 ? ">" : t.align + "", this.sign = t.sign === void 0 ? "-" : t.sign + "", this.symbol = t.symbol === void 0 ? "" : t.symbol + "", this.zero = !!t.zero, this.width = t.width === void 0 ? void 0 : +t.width, this.comma = !!t.comma, this.precision = t.precision === void 0 ? void 0 : +t.precision, this.trim = !!t.trim, this.type = t.type === void 0 ? "" : t.type + "";
}
xE.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function Kee(t) {
  e: for (var e = t.length, r = 1, n = -1, i; r < e; ++r)
    switch (t[r]) {
      case ".":
        n = i = r;
        break;
      case "0":
        n === 0 && (n = r), i = r;
        break;
      default:
        if (!+t[r]) break e;
        n > 0 && (n = 0);
        break;
    }
  return n > 0 ? t.slice(0, n) + t.slice(i + 1) : t;
}
var bD;
function Zee(t, e) {
  var r = Fv(t, e);
  if (!r) return t + "";
  var n = r[0], i = r[1], a = i - (bD = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, s = n.length;
  return a === s ? n : a > s ? n + new Array(a - s + 1).join("0") : a > 0 ? n.slice(0, a) + "." + n.slice(a) : "0." + new Array(1 - a).join("0") + Fv(t, Math.max(0, e + a - 1))[0];
}
function _C(t, e) {
  var r = Fv(t, e);
  if (!r) return t + "";
  var n = r[0], i = r[1];
  return i < 0 ? "0." + new Array(-i).join("0") + n : n.length > i + 1 ? n.slice(0, i + 1) + "." + n.slice(i + 1) : n + new Array(i - n.length + 2).join("0");
}
const LC = {
  "%": (t, e) => (t * 100).toFixed(e),
  b: (t) => Math.round(t).toString(2),
  c: (t) => t + "",
  d: Wee,
  e: (t, e) => t.toExponential(e),
  f: (t, e) => t.toFixed(e),
  g: (t, e) => t.toPrecision(e),
  o: (t) => Math.round(t).toString(8),
  p: (t, e) => _C(t * 100, e),
  r: _C,
  s: Zee,
  X: (t) => Math.round(t).toString(16).toUpperCase(),
  x: (t) => Math.round(t).toString(16)
};
function RC(t) {
  return t;
}
var MC = Array.prototype.map, NC = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function Qee(t) {
  var e = t.grouping === void 0 || t.thousands === void 0 ? RC : Yee(MC.call(t.grouping, Number), t.thousands + ""), r = t.currency === void 0 ? "" : t.currency[0] + "", n = t.currency === void 0 ? "" : t.currency[1] + "", i = t.decimal === void 0 ? "." : t.decimal + "", a = t.numerals === void 0 ? RC : Xee(MC.call(t.numerals, String)), s = t.percent === void 0 ? "%" : t.percent + "", o = t.minus === void 0 ? "" : t.minus + "", l = t.nan === void 0 ? "NaN" : t.nan + "";
  function u(d) {
    d = $v(d);
    var f = d.fill, p = d.align, g = d.sign, m = d.symbol, v = d.zero, y = d.width, b = d.comma, w = d.precision, T = d.trim, E = d.type;
    E === "n" ? (b = !0, E = "g") : LC[E] || (w === void 0 && (w = 12), T = !0, E = "g"), (v || f === "0" && p === "=") && (v = !0, f = "0", p = "=");
    var L = m === "$" ? r : m === "#" && /[boxX]/.test(E) ? "0" + E.toLowerCase() : "", k = m === "$" ? n : /[%p]/.test(E) ? s : "", C = LC[E], A = /[defgprs%]/.test(E);
    w = w === void 0 ? 6 : /[gprs]/.test(E) ? Math.max(1, Math.min(21, w)) : Math.max(0, Math.min(20, w));
    function R(_) {
      var O = L, P = k, S, M, N;
      if (E === "c")
        P = C(_) + P, _ = "";
      else {
        _ = +_;
        var D = _ < 0 || 1 / _ < 0;
        if (_ = isNaN(_) ? l : C(Math.abs(_), w), T && (_ = Kee(_)), D && +_ == 0 && g !== "+" && (D = !1), O = (D ? g === "(" ? g : o : g === "-" || g === "(" ? "" : g) + O, P = (E === "s" ? NC[8 + bD / 3] : "") + P + (D && g === "(" ? ")" : ""), A) {
          for (S = -1, M = _.length; ++S < M; )
            if (N = _.charCodeAt(S), 48 > N || N > 57) {
              P = (N === 46 ? i + _.slice(S + 1) : _.slice(S)) + P, _ = _.slice(0, S);
              break;
            }
        }
      }
      b && !v && (_ = e(_, 1 / 0));
      var I = O.length + _.length + P.length, B = I < y ? new Array(y - I + 1).join(f) : "";
      switch (b && v && (_ = e(B + _, B.length ? y - P.length : 1 / 0), B = ""), p) {
        case "<":
          _ = O + _ + P + B;
          break;
        case "=":
          _ = O + B + _ + P;
          break;
        case "^":
          _ = B.slice(0, I = B.length >> 1) + O + _ + P + B.slice(I);
          break;
        default:
          _ = B + O + _ + P;
          break;
      }
      return a(_);
    }
    return R.toString = function() {
      return d + "";
    }, R;
  }
  function h(d, f) {
    var p = u((d = $v(d), d.type = "f", d)), g = Math.max(-8, Math.min(8, Math.floor(pd(f) / 3))) * 3, m = Math.pow(10, -g), v = NC[8 + g / 3];
    return function(y) {
      return p(m * y) + v;
    };
  }
  return {
    format: u,
    formatPrefix: h
  };
}
var o1, jc, wD;
Jee({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function Jee(t) {
  return o1 = Qee(t), jc = o1.format, wD = o1.formatPrefix, o1;
}
function ete(t) {
  return Math.max(0, -pd(Math.abs(t)));
}
function tte(t, e) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(pd(e) / 3))) * 3 - pd(Math.abs(t)));
}
function rte(t, e) {
  return t = Math.abs(t), e = Math.abs(e) - t, Math.max(0, pd(e) - pd(t)) + 1;
}
function nte(t) {
  var e = 0, r = t.children, n = r && r.length;
  if (!n) e = 1;
  else for (; --n >= 0; ) e += r[n].value;
  t.value = e;
}
function ite() {
  return this.eachAfter(nte);
}
function ate(t, e) {
  let r = -1;
  for (const n of this)
    t.call(e, n, ++r, this);
  return this;
}
function ste(t, e) {
  for (var r = this, n = [r], i, a, s = -1; r = n.pop(); )
    if (t.call(e, r, ++s, this), i = r.children)
      for (a = i.length - 1; a >= 0; --a)
        n.push(i[a]);
  return this;
}
function ote(t, e) {
  for (var r = this, n = [r], i = [], a, s, o, l = -1; r = n.pop(); )
    if (i.push(r), a = r.children)
      for (s = 0, o = a.length; s < o; ++s)
        n.push(a[s]);
  for (; r = i.pop(); )
    t.call(e, r, ++l, this);
  return this;
}
function lte(t, e) {
  let r = -1;
  for (const n of this)
    if (t.call(e, n, ++r, this))
      return n;
}
function cte(t) {
  return this.eachAfter(function(e) {
    for (var r = +t(e.data) || 0, n = e.children, i = n && n.length; --i >= 0; ) r += n[i].value;
    e.value = r;
  });
}
function ute(t) {
  return this.eachBefore(function(e) {
    e.children && e.children.sort(t);
  });
}
function hte(t) {
  for (var e = this, r = dte(e, t), n = [e]; e !== r; )
    e = e.parent, n.push(e);
  for (var i = n.length; t !== r; )
    n.splice(i, 0, t), t = t.parent;
  return n;
}
function dte(t, e) {
  if (t === e) return t;
  var r = t.ancestors(), n = e.ancestors(), i = null;
  for (t = r.pop(), e = n.pop(); t === e; )
    i = t, t = r.pop(), e = n.pop();
  return i;
}
function fte() {
  for (var t = this, e = [t]; t = t.parent; )
    e.push(t);
  return e;
}
function pte() {
  return Array.from(this);
}
function gte() {
  var t = [];
  return this.eachBefore(function(e) {
    e.children || t.push(e);
  }), t;
}
function mte() {
  var t = this, e = [];
  return t.each(function(r) {
    r !== t && e.push({ source: r.parent, target: r });
  }), e;
}
function* vte() {
  var t = this, e, r = [t], n, i, a;
  do
    for (e = r.reverse(), r = []; t = e.pop(); )
      if (yield t, n = t.children)
        for (i = 0, a = n.length; i < a; ++i)
          r.push(n[i]);
  while (r.length);
}
function bE(t, e) {
  t instanceof Map ? (t = [void 0, t], e === void 0 && (e = bte)) : e === void 0 && (e = xte);
  for (var r = new zv(t), n, i = [r], a, s, o, l; n = i.pop(); )
    if ((s = e(n.data)) && (l = (s = Array.from(s)).length))
      for (n.children = s, o = l - 1; o >= 0; --o)
        i.push(a = s[o] = new zv(s[o])), a.parent = n, a.depth = n.depth + 1;
  return r.eachBefore(Tte);
}
function yte() {
  return bE(this).eachBefore(wte);
}
function xte(t) {
  return t.children;
}
function bte(t) {
  return Array.isArray(t) ? t[1] : null;
}
function wte(t) {
  t.data.value !== void 0 && (t.value = t.data.value), t.data = t.data.data;
}
function Tte(t) {
  var e = 0;
  do
    t.height = e;
  while ((t = t.parent) && t.height < ++e);
}
function zv(t) {
  this.data = t, this.depth = this.height = 0, this.parent = null;
}
zv.prototype = bE.prototype = {
  constructor: zv,
  count: ite,
  each: ate,
  eachAfter: ote,
  eachBefore: ste,
  find: lte,
  sum: cte,
  sort: ute,
  path: hte,
  ancestors: fte,
  descendants: pte,
  leaves: gte,
  links: mte,
  copy: yte,
  [Symbol.iterator]: vte
};
function Ete(t) {
  if (typeof t != "function") throw new Error();
  return t;
}
function xf() {
  return 0;
}
function bf(t) {
  return function() {
    return t;
  };
}
function kte(t) {
  t.x0 = Math.round(t.x0), t.y0 = Math.round(t.y0), t.x1 = Math.round(t.x1), t.y1 = Math.round(t.y1);
}
function Ste(t, e, r, n, i) {
  for (var a = t.children, s, o = -1, l = a.length, u = t.value && (n - e) / t.value; ++o < l; )
    s = a[o], s.y0 = r, s.y1 = i, s.x0 = e, s.x1 = e += s.value * u;
}
function Cte(t, e, r, n, i) {
  for (var a = t.children, s, o = -1, l = a.length, u = t.value && (i - r) / t.value; ++o < l; )
    s = a[o], s.x0 = e, s.x1 = n, s.y0 = r, s.y1 = r += s.value * u;
}
var Ate = (1 + Math.sqrt(5)) / 2;
function _te(t, e, r, n, i, a) {
  for (var s = [], o = e.children, l, u, h = 0, d = 0, f = o.length, p, g, m = e.value, v, y, b, w, T, E, L; h < f; ) {
    p = i - r, g = a - n;
    do
      v = o[d++].value;
    while (!v && d < f);
    for (y = b = v, E = Math.max(g / p, p / g) / (m * t), L = v * v * E, T = Math.max(b / L, L / y); d < f; ++d) {
      if (v += u = o[d].value, u < y && (y = u), u > b && (b = u), L = v * v * E, w = Math.max(b / L, L / y), w > T) {
        v -= u;
        break;
      }
      T = w;
    }
    s.push(l = { value: v, dice: p < g, children: o.slice(h, d) }), l.dice ? Ste(l, r, n, i, m ? n += g * v / m : a) : Cte(l, r, n, m ? r += p * v / m : i, a), m -= v, h = d;
  }
  return s;
}
const Lte = (function t(e) {
  function r(n, i, a, s, o) {
    _te(e, n, i, a, s, o);
  }
  return r.ratio = function(n) {
    return t((n = +n) > 1 ? n : 1);
  }, r;
})(Ate);
function Rte() {
  var t = Lte, e = !1, r = 1, n = 1, i = [0], a = xf, s = xf, o = xf, l = xf, u = xf;
  function h(f) {
    return f.x0 = f.y0 = 0, f.x1 = r, f.y1 = n, f.eachBefore(d), i = [0], e && f.eachBefore(kte), f;
  }
  function d(f) {
    var p = i[f.depth], g = f.x0 + p, m = f.y0 + p, v = f.x1 - p, y = f.y1 - p;
    v < g && (g = v = (g + v) / 2), y < m && (m = y = (m + y) / 2), f.x0 = g, f.y0 = m, f.x1 = v, f.y1 = y, f.children && (p = i[f.depth + 1] = a(f) / 2, g += u(f) - p, m += s(f) - p, v -= o(f) - p, y -= l(f) - p, v < g && (g = v = (g + v) / 2), y < m && (m = y = (m + y) / 2), t(f, g, m, v, y));
  }
  return h.round = function(f) {
    return arguments.length ? (e = !!f, h) : e;
  }, h.size = function(f) {
    return arguments.length ? (r = +f[0], n = +f[1], h) : [r, n];
  }, h.tile = function(f) {
    return arguments.length ? (t = Ete(f), h) : t;
  }, h.padding = function(f) {
    return arguments.length ? h.paddingInner(f).paddingOuter(f) : h.paddingInner();
  }, h.paddingInner = function(f) {
    return arguments.length ? (a = typeof f == "function" ? f : bf(+f), h) : a;
  }, h.paddingOuter = function(f) {
    return arguments.length ? h.paddingTop(f).paddingRight(f).paddingBottom(f).paddingLeft(f) : h.paddingTop();
  }, h.paddingTop = function(f) {
    return arguments.length ? (s = typeof f == "function" ? f : bf(+f), h) : s;
  }, h.paddingRight = function(f) {
    return arguments.length ? (o = typeof f == "function" ? f : bf(+f), h) : o;
  }, h.paddingBottom = function(f) {
    return arguments.length ? (l = typeof f == "function" ? f : bf(+f), h) : l;
  }, h.paddingLeft = function(f) {
    return arguments.length ? (u = typeof f == "function" ? f : bf(+f), h) : u;
  }, h;
}
function $2(t, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(t);
      break;
    default:
      this.range(e).domain(t);
      break;
  }
  return this;
}
const IC = /* @__PURE__ */ Symbol("implicit");
function hu() {
  var t = new uC(), e = [], r = [], n = IC;
  function i(a) {
    let s = t.get(a);
    if (s === void 0) {
      if (n !== IC) return n;
      t.set(a, s = e.push(a) - 1);
    }
    return r[s % r.length];
  }
  return i.domain = function(a) {
    if (!arguments.length) return e.slice();
    e = [], t = new uC();
    for (const s of a)
      t.has(s) || t.set(s, e.push(s) - 1);
    return i;
  }, i.range = function(a) {
    return arguments.length ? (r = Array.from(a), i) : r.slice();
  }, i.unknown = function(a) {
    return arguments.length ? (n = a, i) : n;
  }, i.copy = function() {
    return hu(e, r).unknown(n);
  }, $2.apply(i, arguments), i;
}
function vw() {
  var t = hu().unknown(void 0), e = t.domain, r = t.range, n = 0, i = 1, a, s, o = !1, l = 0, u = 0, h = 0.5;
  delete t.unknown;
  function d() {
    var f = e().length, p = i < n, g = p ? i : n, m = p ? n : i;
    a = (m - g) / Math.max(1, f - l + u * 2), o && (a = Math.floor(a)), g += (m - g - a * (f - l)) * h, s = a * (1 - l), o && (g = Math.round(g), s = Math.round(s));
    var v = lZ(f).map(function(y) {
      return g + a * y;
    });
    return r(p ? v.reverse() : v);
  }
  return t.domain = function(f) {
    return arguments.length ? (e(f), d()) : e();
  }, t.range = function(f) {
    return arguments.length ? ([n, i] = f, n = +n, i = +i, d()) : [n, i];
  }, t.rangeRound = function(f) {
    return [n, i] = f, n = +n, i = +i, o = !0, d();
  }, t.bandwidth = function() {
    return s;
  }, t.step = function() {
    return a;
  }, t.round = function(f) {
    return arguments.length ? (o = !!f, d()) : o;
  }, t.padding = function(f) {
    return arguments.length ? (l = Math.min(1, u = +f), d()) : l;
  }, t.paddingInner = function(f) {
    return arguments.length ? (l = Math.min(1, f), d()) : l;
  }, t.paddingOuter = function(f) {
    return arguments.length ? (u = +f, d()) : u;
  }, t.align = function(f) {
    return arguments.length ? (h = Math.max(0, Math.min(1, f)), d()) : h;
  }, t.copy = function() {
    return vw(e(), [n, i]).round(o).paddingInner(l).paddingOuter(u).align(h);
  }, $2.apply(d(), arguments);
}
function Mte(t) {
  return function() {
    return t;
  };
}
function Nte(t) {
  return +t;
}
var DC = [0, 1];
function Bh(t) {
  return t;
}
function yw(t, e) {
  return (e -= t = +t) ? function(r) {
    return (r - t) / e;
  } : Mte(isNaN(e) ? NaN : 0.5);
}
function Ite(t, e) {
  var r;
  return t > e && (r = t, t = e, e = r), function(n) {
    return Math.max(t, Math.min(e, n));
  };
}
function Dte(t, e, r) {
  var n = t[0], i = t[1], a = e[0], s = e[1];
  return i < n ? (n = yw(i, n), a = r(s, a)) : (n = yw(n, i), a = r(a, s)), function(o) {
    return a(n(o));
  };
}
function Ote(t, e, r) {
  var n = Math.min(t.length, e.length) - 1, i = new Array(n), a = new Array(n), s = -1;
  for (t[n] < t[0] && (t = t.slice().reverse(), e = e.slice().reverse()); ++s < n; )
    i[s] = yw(t[s], t[s + 1]), a[s] = r(e[s], e[s + 1]);
  return function(o) {
    var l = QK(t, o, 1, n) - 1;
    return a[l](i[l](o));
  };
}
function TD(t, e) {
  return e.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown());
}
function Pte() {
  var t = DC, e = DC, r = gE, n, i, a, s = Bh, o, l, u;
  function h() {
    var f = Math.min(t.length, e.length);
    return s !== Bh && (s = Ite(t[0], t[f - 1])), o = f > 2 ? Ote : Dte, l = u = null, d;
  }
  function d(f) {
    return f == null || isNaN(f = +f) ? a : (l || (l = o(t.map(n), e, r)))(n(s(f)));
  }
  return d.invert = function(f) {
    return s(i((u || (u = o(e, t.map(n), ds)))(f)));
  }, d.domain = function(f) {
    return arguments.length ? (t = Array.from(f, Nte), h()) : t.slice();
  }, d.range = function(f) {
    return arguments.length ? (e = Array.from(f), h()) : e.slice();
  }, d.rangeRound = function(f) {
    return e = Array.from(f), r = kJ, h();
  }, d.clamp = function(f) {
    return arguments.length ? (s = f ? !0 : Bh, h()) : s !== Bh;
  }, d.interpolate = function(f) {
    return arguments.length ? (r = f, h()) : r;
  }, d.unknown = function(f) {
    return arguments.length ? (a = f, d) : a;
  }, function(f, p) {
    return n = f, i = p, h();
  };
}
function ED() {
  return Pte()(Bh, Bh);
}
function Bte(t, e, r, n) {
  var i = aw(t, e, r), a;
  switch (n = $v(n ?? ",f"), n.type) {
    case "s": {
      var s = Math.max(Math.abs(t), Math.abs(e));
      return n.precision == null && !isNaN(a = tte(i, s)) && (n.precision = a), wD(n, s);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      n.precision == null && !isNaN(a = rte(i, Math.max(Math.abs(t), Math.abs(e)))) && (n.precision = a - (n.type === "e"));
      break;
    }
    case "f":
    case "%": {
      n.precision == null && !isNaN(a = ete(i)) && (n.precision = a - (n.type === "%") * 2);
      break;
    }
  }
  return jc(n);
}
function Fte(t) {
  var e = t.domain;
  return t.ticks = function(r) {
    var n = e();
    return aZ(n[0], n[n.length - 1], r ?? 10);
  }, t.tickFormat = function(r, n) {
    var i = e();
    return Bte(i[0], i[i.length - 1], r ?? 10, n);
  }, t.nice = function(r) {
    r == null && (r = 10);
    var n = e(), i = 0, a = n.length - 1, s = n[i], o = n[a], l, u, h = 10;
    for (o < s && (u = s, s = o, o = u, u = i, i = a, a = u); h-- > 0; ) {
      if (u = iw(s, o, r), u === l)
        return n[i] = s, n[a] = o, e(n);
      if (u > 0)
        s = Math.floor(s / u) * u, o = Math.ceil(o / u) * u;
      else if (u < 0)
        s = Math.ceil(s * u) / u, o = Math.floor(o * u) / u;
      else
        break;
      l = u;
    }
    return t;
  }, t;
}
function gd() {
  var t = ED();
  return t.copy = function() {
    return TD(t, gd());
  }, $2.apply(t, arguments), Fte(t);
}
function $te(t, e) {
  t = t.slice();
  var r = 0, n = t.length - 1, i = t[r], a = t[n], s;
  return a < i && (s = r, r = n, n = s, s = i, i = a, a = s), t[r] = e.floor(i), t[n] = e.ceil(a), t;
}
const Wb = /* @__PURE__ */ new Date(), Yb = /* @__PURE__ */ new Date();
function Hn(t, e, r, n) {
  function i(a) {
    return t(a = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+a)), a;
  }
  return i.floor = (a) => (t(a = /* @__PURE__ */ new Date(+a)), a), i.ceil = (a) => (t(a = new Date(a - 1)), e(a, 1), t(a), a), i.round = (a) => {
    const s = i(a), o = i.ceil(a);
    return a - s < o - a ? s : o;
  }, i.offset = (a, s) => (e(a = /* @__PURE__ */ new Date(+a), s == null ? 1 : Math.floor(s)), a), i.range = (a, s, o) => {
    const l = [];
    if (a = i.ceil(a), o = o == null ? 1 : Math.floor(o), !(a < s) || !(o > 0)) return l;
    let u;
    do
      l.push(u = /* @__PURE__ */ new Date(+a)), e(a, o), t(a);
    while (u < a && a < s);
    return l;
  }, i.filter = (a) => Hn((s) => {
    if (s >= s) for (; t(s), !a(s); ) s.setTime(s - 1);
  }, (s, o) => {
    if (s >= s)
      if (o < 0) for (; ++o <= 0; )
        for (; e(s, -1), !a(s); )
          ;
      else for (; --o >= 0; )
        for (; e(s, 1), !a(s); )
          ;
  }), r && (i.count = (a, s) => (Wb.setTime(+a), Yb.setTime(+s), t(Wb), t(Yb), Math.floor(r(Wb, Yb))), i.every = (a) => (a = Math.floor(a), !isFinite(a) || !(a > 0) ? null : a > 1 ? i.filter(n ? (s) => n(s) % a === 0 : (s) => i.count(0, s) % a === 0) : i)), i;
}
const md = Hn(() => {
}, (t, e) => {
  t.setTime(+t + e);
}, (t, e) => e - t);
md.every = (t) => (t = Math.floor(t), !isFinite(t) || !(t > 0) ? null : t > 1 ? Hn((e) => {
  e.setTime(Math.floor(e / t) * t);
}, (e, r) => {
  e.setTime(+e + r * t);
}, (e, r) => (r - e) / t) : md);
md.range;
const $o = 1e3, Wa = $o * 60, zo = Wa * 60, Zo = zo * 24, wE = Zo * 7, OC = Zo * 30, Xb = Zo * 365, Rl = Hn((t) => {
  t.setTime(t - t.getMilliseconds());
}, (t, e) => {
  t.setTime(+t + e * $o);
}, (t, e) => (e - t) / $o, (t) => t.getUTCSeconds());
Rl.range;
const up = Hn((t) => {
  t.setTime(t - t.getMilliseconds() - t.getSeconds() * $o);
}, (t, e) => {
  t.setTime(+t + e * Wa);
}, (t, e) => (e - t) / Wa, (t) => t.getMinutes());
up.range;
const zte = Hn((t) => {
  t.setUTCSeconds(0, 0);
}, (t, e) => {
  t.setTime(+t + e * Wa);
}, (t, e) => (e - t) / Wa, (t) => t.getUTCMinutes());
zte.range;
const hp = Hn((t) => {
  t.setTime(t - t.getMilliseconds() - t.getSeconds() * $o - t.getMinutes() * Wa);
}, (t, e) => {
  t.setTime(+t + e * zo);
}, (t, e) => (e - t) / zo, (t) => t.getHours());
hp.range;
const Gte = Hn((t) => {
  t.setUTCMinutes(0, 0, 0);
}, (t, e) => {
  t.setTime(+t + e * zo);
}, (t, e) => (e - t) / zo, (t) => t.getUTCHours());
Gte.range;
const mu = Hn(
  (t) => t.setHours(0, 0, 0, 0),
  (t, e) => t.setDate(t.getDate() + e),
  (t, e) => (e - t - (e.getTimezoneOffset() - t.getTimezoneOffset()) * Wa) / Zo,
  (t) => t.getDate() - 1
);
mu.range;
const TE = Hn((t) => {
  t.setUTCHours(0, 0, 0, 0);
}, (t, e) => {
  t.setUTCDate(t.getUTCDate() + e);
}, (t, e) => (e - t) / Zo, (t) => t.getUTCDate() - 1);
TE.range;
const Vte = Hn((t) => {
  t.setUTCHours(0, 0, 0, 0);
}, (t, e) => {
  t.setUTCDate(t.getUTCDate() + e);
}, (t, e) => (e - t) / Zo, (t) => Math.floor(t / Zo));
Vte.range;
function Gu(t) {
  return Hn((e) => {
    e.setDate(e.getDate() - (e.getDay() + 7 - t) % 7), e.setHours(0, 0, 0, 0);
  }, (e, r) => {
    e.setDate(e.getDate() + r * 7);
  }, (e, r) => (r - e - (r.getTimezoneOffset() - e.getTimezoneOffset()) * Wa) / wE);
}
const ug = Gu(0), dp = Gu(1), kD = Gu(2), SD = Gu(3), vu = Gu(4), CD = Gu(5), AD = Gu(6);
ug.range;
dp.range;
kD.range;
SD.range;
vu.range;
CD.range;
AD.range;
function Vu(t) {
  return Hn((e) => {
    e.setUTCDate(e.getUTCDate() - (e.getUTCDay() + 7 - t) % 7), e.setUTCHours(0, 0, 0, 0);
  }, (e, r) => {
    e.setUTCDate(e.getUTCDate() + r * 7);
  }, (e, r) => (r - e) / wE);
}
const _D = Vu(0), Gv = Vu(1), Ute = Vu(2), Hte = Vu(3), vd = Vu(4), qte = Vu(5), Wte = Vu(6);
_D.range;
Gv.range;
Ute.range;
Hte.range;
vd.range;
qte.range;
Wte.range;
const fp = Hn((t) => {
  t.setDate(1), t.setHours(0, 0, 0, 0);
}, (t, e) => {
  t.setMonth(t.getMonth() + e);
}, (t, e) => e.getMonth() - t.getMonth() + (e.getFullYear() - t.getFullYear()) * 12, (t) => t.getMonth());
fp.range;
const Yte = Hn((t) => {
  t.setUTCDate(1), t.setUTCHours(0, 0, 0, 0);
}, (t, e) => {
  t.setUTCMonth(t.getUTCMonth() + e);
}, (t, e) => e.getUTCMonth() - t.getUTCMonth() + (e.getUTCFullYear() - t.getUTCFullYear()) * 12, (t) => t.getUTCMonth());
Yte.range;
const Qo = Hn((t) => {
  t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, e) => {
  t.setFullYear(t.getFullYear() + e);
}, (t, e) => e.getFullYear() - t.getFullYear(), (t) => t.getFullYear());
Qo.every = (t) => !isFinite(t = Math.floor(t)) || !(t > 0) ? null : Hn((e) => {
  e.setFullYear(Math.floor(e.getFullYear() / t) * t), e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, r) => {
  e.setFullYear(e.getFullYear() + r * t);
});
Qo.range;
const yu = Hn((t) => {
  t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, e) => {
  t.setUTCFullYear(t.getUTCFullYear() + e);
}, (t, e) => e.getUTCFullYear() - t.getUTCFullYear(), (t) => t.getUTCFullYear());
yu.every = (t) => !isFinite(t = Math.floor(t)) || !(t > 0) ? null : Hn((e) => {
  e.setUTCFullYear(Math.floor(e.getUTCFullYear() / t) * t), e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, r) => {
  e.setUTCFullYear(e.getUTCFullYear() + r * t);
});
yu.range;
function Xte(t, e, r, n, i, a) {
  const s = [
    [Rl, 1, $o],
    [Rl, 5, 5 * $o],
    [Rl, 15, 15 * $o],
    [Rl, 30, 30 * $o],
    [a, 1, Wa],
    [a, 5, 5 * Wa],
    [a, 15, 15 * Wa],
    [a, 30, 30 * Wa],
    [i, 1, zo],
    [i, 3, 3 * zo],
    [i, 6, 6 * zo],
    [i, 12, 12 * zo],
    [n, 1, Zo],
    [n, 2, 2 * Zo],
    [r, 1, wE],
    [e, 1, OC],
    [e, 3, 3 * OC],
    [t, 1, Xb]
  ];
  function o(u, h, d) {
    const f = h < u;
    f && ([u, h] = [h, u]);
    const p = d && typeof d.range == "function" ? d : l(u, h, d), g = p ? p.range(u, +h + 1) : [];
    return f ? g.reverse() : g;
  }
  function l(u, h, d) {
    const f = Math.abs(h - u) / d, p = dE(([, , v]) => v).right(s, f);
    if (p === s.length) return t.every(aw(u / Xb, h / Xb, d));
    if (p === 0) return md.every(Math.max(aw(u, h, d), 1));
    const [g, m] = s[f / s[p - 1][2] < s[p][2] / f ? p - 1 : p];
    return g.every(m);
  }
  return [o, l];
}
const [jte, Kte] = Xte(Qo, fp, ug, mu, hp, up);
function jb(t) {
  if (0 <= t.y && t.y < 100) {
    var e = new Date(-1, t.m, t.d, t.H, t.M, t.S, t.L);
    return e.setFullYear(t.y), e;
  }
  return new Date(t.y, t.m, t.d, t.H, t.M, t.S, t.L);
}
function Kb(t) {
  if (0 <= t.y && t.y < 100) {
    var e = new Date(Date.UTC(-1, t.m, t.d, t.H, t.M, t.S, t.L));
    return e.setUTCFullYear(t.y), e;
  }
  return new Date(Date.UTC(t.y, t.m, t.d, t.H, t.M, t.S, t.L));
}
function wf(t, e, r) {
  return { y: t, m: e, d: r, H: 0, M: 0, S: 0, L: 0 };
}
function Zte(t) {
  var e = t.dateTime, r = t.date, n = t.time, i = t.periods, a = t.days, s = t.shortDays, o = t.months, l = t.shortMonths, u = Tf(i), h = Ef(i), d = Tf(a), f = Ef(a), p = Tf(s), g = Ef(s), m = Tf(o), v = Ef(o), y = Tf(l), b = Ef(l), w = {
    a: D,
    A: I,
    b: B,
    B: z,
    c: null,
    d: GC,
    e: GC,
    f: bre,
    g: Rre,
    G: Nre,
    H: vre,
    I: yre,
    j: xre,
    L: LD,
    m: wre,
    M: Tre,
    p: F,
    q: V,
    Q: HC,
    s: qC,
    S: Ere,
    u: kre,
    U: Sre,
    V: Cre,
    w: Are,
    W: _re,
    x: null,
    X: null,
    y: Lre,
    Y: Mre,
    Z: Ire,
    "%": UC
  }, T = {
    a: H,
    A: J,
    b: q,
    B: ae,
    c: null,
    d: VC,
    e: VC,
    f: Bre,
    g: Yre,
    G: jre,
    H: Dre,
    I: Ore,
    j: Pre,
    L: MD,
    m: Fre,
    M: $re,
    p: re,
    q: pe,
    Q: HC,
    s: qC,
    S: zre,
    u: Gre,
    U: Vre,
    V: Ure,
    w: Hre,
    W: qre,
    x: null,
    X: null,
    y: Wre,
    Y: Xre,
    Z: Kre,
    "%": UC
  }, E = {
    a: R,
    A: _,
    b: O,
    B: P,
    c: S,
    d: $C,
    e: $C,
    f: fre,
    g: FC,
    G: BC,
    H: zC,
    I: zC,
    j: cre,
    L: dre,
    m: lre,
    M: ure,
    p: A,
    q: ore,
    Q: gre,
    s: mre,
    S: hre,
    u: rre,
    U: nre,
    V: ire,
    w: tre,
    W: are,
    x: M,
    X: N,
    y: FC,
    Y: BC,
    Z: sre,
    "%": pre
  };
  w.x = L(r, w), w.X = L(n, w), w.c = L(e, w), T.x = L(r, T), T.X = L(n, T), T.c = L(e, T);
  function L(K, Z) {
    return function(X) {
      var Y = [], ee = -1, j = 0, fe = K.length, te, Ae, W;
      for (X instanceof Date || (X = /* @__PURE__ */ new Date(+X)); ++ee < fe; )
        K.charCodeAt(ee) === 37 && (Y.push(K.slice(j, ee)), (Ae = PC[te = K.charAt(++ee)]) != null ? te = K.charAt(++ee) : Ae = te === "e" ? " " : "0", (W = Z[te]) && (te = W(X, Ae)), Y.push(te), j = ee + 1);
      return Y.push(K.slice(j, ee)), Y.join("");
    };
  }
  function k(K, Z) {
    return function(X) {
      var Y = wf(1900, void 0, 1), ee = C(Y, K, X += "", 0), j, fe;
      if (ee != X.length) return null;
      if ("Q" in Y) return new Date(Y.Q);
      if ("s" in Y) return new Date(Y.s * 1e3 + ("L" in Y ? Y.L : 0));
      if (Z && !("Z" in Y) && (Y.Z = 0), "p" in Y && (Y.H = Y.H % 12 + Y.p * 12), Y.m === void 0 && (Y.m = "q" in Y ? Y.q : 0), "V" in Y) {
        if (Y.V < 1 || Y.V > 53) return null;
        "w" in Y || (Y.w = 1), "Z" in Y ? (j = Kb(wf(Y.y, 0, 1)), fe = j.getUTCDay(), j = fe > 4 || fe === 0 ? Gv.ceil(j) : Gv(j), j = TE.offset(j, (Y.V - 1) * 7), Y.y = j.getUTCFullYear(), Y.m = j.getUTCMonth(), Y.d = j.getUTCDate() + (Y.w + 6) % 7) : (j = jb(wf(Y.y, 0, 1)), fe = j.getDay(), j = fe > 4 || fe === 0 ? dp.ceil(j) : dp(j), j = mu.offset(j, (Y.V - 1) * 7), Y.y = j.getFullYear(), Y.m = j.getMonth(), Y.d = j.getDate() + (Y.w + 6) % 7);
      } else ("W" in Y || "U" in Y) && ("w" in Y || (Y.w = "u" in Y ? Y.u % 7 : "W" in Y ? 1 : 0), fe = "Z" in Y ? Kb(wf(Y.y, 0, 1)).getUTCDay() : jb(wf(Y.y, 0, 1)).getDay(), Y.m = 0, Y.d = "W" in Y ? (Y.w + 6) % 7 + Y.W * 7 - (fe + 5) % 7 : Y.w + Y.U * 7 - (fe + 6) % 7);
      return "Z" in Y ? (Y.H += Y.Z / 100 | 0, Y.M += Y.Z % 100, Kb(Y)) : jb(Y);
    };
  }
  function C(K, Z, X, Y) {
    for (var ee = 0, j = Z.length, fe = X.length, te, Ae; ee < j; ) {
      if (Y >= fe) return -1;
      if (te = Z.charCodeAt(ee++), te === 37) {
        if (te = Z.charAt(ee++), Ae = E[te in PC ? Z.charAt(ee++) : te], !Ae || (Y = Ae(K, X, Y)) < 0) return -1;
      } else if (te != X.charCodeAt(Y++))
        return -1;
    }
    return Y;
  }
  function A(K, Z, X) {
    var Y = u.exec(Z.slice(X));
    return Y ? (K.p = h.get(Y[0].toLowerCase()), X + Y[0].length) : -1;
  }
  function R(K, Z, X) {
    var Y = p.exec(Z.slice(X));
    return Y ? (K.w = g.get(Y[0].toLowerCase()), X + Y[0].length) : -1;
  }
  function _(K, Z, X) {
    var Y = d.exec(Z.slice(X));
    return Y ? (K.w = f.get(Y[0].toLowerCase()), X + Y[0].length) : -1;
  }
  function O(K, Z, X) {
    var Y = y.exec(Z.slice(X));
    return Y ? (K.m = b.get(Y[0].toLowerCase()), X + Y[0].length) : -1;
  }
  function P(K, Z, X) {
    var Y = m.exec(Z.slice(X));
    return Y ? (K.m = v.get(Y[0].toLowerCase()), X + Y[0].length) : -1;
  }
  function S(K, Z, X) {
    return C(K, e, Z, X);
  }
  function M(K, Z, X) {
    return C(K, r, Z, X);
  }
  function N(K, Z, X) {
    return C(K, n, Z, X);
  }
  function D(K) {
    return s[K.getDay()];
  }
  function I(K) {
    return a[K.getDay()];
  }
  function B(K) {
    return l[K.getMonth()];
  }
  function z(K) {
    return o[K.getMonth()];
  }
  function F(K) {
    return i[+(K.getHours() >= 12)];
  }
  function V(K) {
    return 1 + ~~(K.getMonth() / 3);
  }
  function H(K) {
    return s[K.getUTCDay()];
  }
  function J(K) {
    return a[K.getUTCDay()];
  }
  function q(K) {
    return l[K.getUTCMonth()];
  }
  function ae(K) {
    return o[K.getUTCMonth()];
  }
  function re(K) {
    return i[+(K.getUTCHours() >= 12)];
  }
  function pe(K) {
    return 1 + ~~(K.getUTCMonth() / 3);
  }
  return {
    format: function(K) {
      var Z = L(K += "", w);
      return Z.toString = function() {
        return K;
      }, Z;
    },
    parse: function(K) {
      var Z = k(K += "", !1);
      return Z.toString = function() {
        return K;
      }, Z;
    },
    utcFormat: function(K) {
      var Z = L(K += "", T);
      return Z.toString = function() {
        return K;
      }, Z;
    },
    utcParse: function(K) {
      var Z = k(K += "", !0);
      return Z.toString = function() {
        return K;
      }, Z;
    }
  };
}
var PC = { "-": "", _: " ", 0: "0" }, Qn = /^\s*\d+/, Qte = /^%/, Jte = /[\\^$*+?|[\]().{}]/g;
function Er(t, e, r) {
  var n = t < 0 ? "-" : "", i = (n ? -t : t) + "", a = i.length;
  return n + (a < r ? new Array(r - a + 1).join(e) + i : i);
}
function ere(t) {
  return t.replace(Jte, "\\$&");
}
function Tf(t) {
  return new RegExp("^(?:" + t.map(ere).join("|") + ")", "i");
}
function Ef(t) {
  return new Map(t.map((e, r) => [e.toLowerCase(), r]));
}
function tre(t, e, r) {
  var n = Qn.exec(e.slice(r, r + 1));
  return n ? (t.w = +n[0], r + n[0].length) : -1;
}
function rre(t, e, r) {
  var n = Qn.exec(e.slice(r, r + 1));
  return n ? (t.u = +n[0], r + n[0].length) : -1;
}
function nre(t, e, r) {
  var n = Qn.exec(e.slice(r, r + 2));
  return n ? (t.U = +n[0], r + n[0].length) : -1;
}
function ire(t, e, r) {
  var n = Qn.exec(e.slice(r, r + 2));
  return n ? (t.V = +n[0], r + n[0].length) : -1;
}
function are(t, e, r) {
  var n = Qn.exec(e.slice(r, r + 2));
  return n ? (t.W = +n[0], r + n[0].length) : -1;
}
function BC(t, e, r) {
  var n = Qn.exec(e.slice(r, r + 4));
  return n ? (t.y = +n[0], r + n[0].length) : -1;
}
function FC(t, e, r) {
  var n = Qn.exec(e.slice(r, r + 2));
  return n ? (t.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), r + n[0].length) : -1;
}
function sre(t, e, r) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(e.slice(r, r + 6));
  return n ? (t.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), r + n[0].length) : -1;
}
function ore(t, e, r) {
  var n = Qn.exec(e.slice(r, r + 1));
  return n ? (t.q = n[0] * 3 - 3, r + n[0].length) : -1;
}
function lre(t, e, r) {
  var n = Qn.exec(e.slice(r, r + 2));
  return n ? (t.m = n[0] - 1, r + n[0].length) : -1;
}
function $C(t, e, r) {
  var n = Qn.exec(e.slice(r, r + 2));
  return n ? (t.d = +n[0], r + n[0].length) : -1;
}
function cre(t, e, r) {
  var n = Qn.exec(e.slice(r, r + 3));
  return n ? (t.m = 0, t.d = +n[0], r + n[0].length) : -1;
}
function zC(t, e, r) {
  var n = Qn.exec(e.slice(r, r + 2));
  return n ? (t.H = +n[0], r + n[0].length) : -1;
}
function ure(t, e, r) {
  var n = Qn.exec(e.slice(r, r + 2));
  return n ? (t.M = +n[0], r + n[0].length) : -1;
}
function hre(t, e, r) {
  var n = Qn.exec(e.slice(r, r + 2));
  return n ? (t.S = +n[0], r + n[0].length) : -1;
}
function dre(t, e, r) {
  var n = Qn.exec(e.slice(r, r + 3));
  return n ? (t.L = +n[0], r + n[0].length) : -1;
}
function fre(t, e, r) {
  var n = Qn.exec(e.slice(r, r + 6));
  return n ? (t.L = Math.floor(n[0] / 1e3), r + n[0].length) : -1;
}
function pre(t, e, r) {
  var n = Qte.exec(e.slice(r, r + 1));
  return n ? r + n[0].length : -1;
}
function gre(t, e, r) {
  var n = Qn.exec(e.slice(r));
  return n ? (t.Q = +n[0], r + n[0].length) : -1;
}
function mre(t, e, r) {
  var n = Qn.exec(e.slice(r));
  return n ? (t.s = +n[0], r + n[0].length) : -1;
}
function GC(t, e) {
  return Er(t.getDate(), e, 2);
}
function vre(t, e) {
  return Er(t.getHours(), e, 2);
}
function yre(t, e) {
  return Er(t.getHours() % 12 || 12, e, 2);
}
function xre(t, e) {
  return Er(1 + mu.count(Qo(t), t), e, 3);
}
function LD(t, e) {
  return Er(t.getMilliseconds(), e, 3);
}
function bre(t, e) {
  return LD(t, e) + "000";
}
function wre(t, e) {
  return Er(t.getMonth() + 1, e, 2);
}
function Tre(t, e) {
  return Er(t.getMinutes(), e, 2);
}
function Ere(t, e) {
  return Er(t.getSeconds(), e, 2);
}
function kre(t) {
  var e = t.getDay();
  return e === 0 ? 7 : e;
}
function Sre(t, e) {
  return Er(ug.count(Qo(t) - 1, t), e, 2);
}
function RD(t) {
  var e = t.getDay();
  return e >= 4 || e === 0 ? vu(t) : vu.ceil(t);
}
function Cre(t, e) {
  return t = RD(t), Er(vu.count(Qo(t), t) + (Qo(t).getDay() === 4), e, 2);
}
function Are(t) {
  return t.getDay();
}
function _re(t, e) {
  return Er(dp.count(Qo(t) - 1, t), e, 2);
}
function Lre(t, e) {
  return Er(t.getFullYear() % 100, e, 2);
}
function Rre(t, e) {
  return t = RD(t), Er(t.getFullYear() % 100, e, 2);
}
function Mre(t, e) {
  return Er(t.getFullYear() % 1e4, e, 4);
}
function Nre(t, e) {
  var r = t.getDay();
  return t = r >= 4 || r === 0 ? vu(t) : vu.ceil(t), Er(t.getFullYear() % 1e4, e, 4);
}
function Ire(t) {
  var e = t.getTimezoneOffset();
  return (e > 0 ? "-" : (e *= -1, "+")) + Er(e / 60 | 0, "0", 2) + Er(e % 60, "0", 2);
}
function VC(t, e) {
  return Er(t.getUTCDate(), e, 2);
}
function Dre(t, e) {
  return Er(t.getUTCHours(), e, 2);
}
function Ore(t, e) {
  return Er(t.getUTCHours() % 12 || 12, e, 2);
}
function Pre(t, e) {
  return Er(1 + TE.count(yu(t), t), e, 3);
}
function MD(t, e) {
  return Er(t.getUTCMilliseconds(), e, 3);
}
function Bre(t, e) {
  return MD(t, e) + "000";
}
function Fre(t, e) {
  return Er(t.getUTCMonth() + 1, e, 2);
}
function $re(t, e) {
  return Er(t.getUTCMinutes(), e, 2);
}
function zre(t, e) {
  return Er(t.getUTCSeconds(), e, 2);
}
function Gre(t) {
  var e = t.getUTCDay();
  return e === 0 ? 7 : e;
}
function Vre(t, e) {
  return Er(_D.count(yu(t) - 1, t), e, 2);
}
function ND(t) {
  var e = t.getUTCDay();
  return e >= 4 || e === 0 ? vd(t) : vd.ceil(t);
}
function Ure(t, e) {
  return t = ND(t), Er(vd.count(yu(t), t) + (yu(t).getUTCDay() === 4), e, 2);
}
function Hre(t) {
  return t.getUTCDay();
}
function qre(t, e) {
  return Er(Gv.count(yu(t) - 1, t), e, 2);
}
function Wre(t, e) {
  return Er(t.getUTCFullYear() % 100, e, 2);
}
function Yre(t, e) {
  return t = ND(t), Er(t.getUTCFullYear() % 100, e, 2);
}
function Xre(t, e) {
  return Er(t.getUTCFullYear() % 1e4, e, 4);
}
function jre(t, e) {
  var r = t.getUTCDay();
  return t = r >= 4 || r === 0 ? vd(t) : vd.ceil(t), Er(t.getUTCFullYear() % 1e4, e, 4);
}
function Kre() {
  return "+0000";
}
function UC() {
  return "%";
}
function HC(t) {
  return +t;
}
function qC(t) {
  return Math.floor(+t / 1e3);
}
var gh, Vv;
Zre({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function Zre(t) {
  return gh = Zte(t), Vv = gh.format, gh.parse, gh.utcFormat, gh.utcParse, gh;
}
function Qre(t) {
  return new Date(t);
}
function Jre(t) {
  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
}
function ID(t, e, r, n, i, a, s, o, l, u) {
  var h = ED(), d = h.invert, f = h.domain, p = u(".%L"), g = u(":%S"), m = u("%I:%M"), v = u("%I %p"), y = u("%a %d"), b = u("%b %d"), w = u("%B"), T = u("%Y");
  function E(L) {
    return (l(L) < L ? p : o(L) < L ? g : s(L) < L ? m : a(L) < L ? v : n(L) < L ? i(L) < L ? y : b : r(L) < L ? w : T)(L);
  }
  return h.invert = function(L) {
    return new Date(d(L));
  }, h.domain = function(L) {
    return arguments.length ? f(Array.from(L, Jre)) : f().map(Qre);
  }, h.ticks = function(L) {
    var k = f();
    return t(k[0], k[k.length - 1], L ?? 10);
  }, h.tickFormat = function(L, k) {
    return k == null ? E : u(k);
  }, h.nice = function(L) {
    var k = f();
    return (!L || typeof L.range != "function") && (L = e(k[0], k[k.length - 1], L ?? 10)), L ? f($te(k, L)) : h;
  }, h.copy = function() {
    return TD(h, ID(t, e, r, n, i, a, s, o, l, u));
  }, h;
}
function ene() {
  return $2.apply(ID(jte, Kte, Qo, fp, ug, mu, hp, up, Rl, Vv).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function tne(t) {
  for (var e = t.length / 6 | 0, r = new Array(e), n = 0; n < e; ) r[n] = "#" + t.slice(n * 6, ++n * 6);
  return r;
}
const rne = tne("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");
function gn(t) {
  return function() {
    return t;
  };
}
const WC = Math.abs, mi = Math.atan2, Dc = Math.cos, nne = Math.max, Zb = Math.min, Os = Math.sin, Fh = Math.sqrt, yi = 1e-12, pp = Math.PI, Uv = pp / 2, km = 2 * pp;
function ine(t) {
  return t > 1 ? 0 : t < -1 ? pp : Math.acos(t);
}
function YC(t) {
  return t >= 1 ? Uv : t <= -1 ? -Uv : Math.asin(t);
}
function DD(t) {
  let e = 3;
  return t.digits = function(r) {
    if (!arguments.length) return e;
    if (r == null)
      e = null;
    else {
      const n = Math.floor(r);
      if (!(n >= 0)) throw new RangeError(`invalid digits: ${r}`);
      e = n;
    }
    return t;
  }, () => new qee(e);
}
function ane(t) {
  return t.innerRadius;
}
function sne(t) {
  return t.outerRadius;
}
function one(t) {
  return t.startAngle;
}
function lne(t) {
  return t.endAngle;
}
function cne(t) {
  return t && t.padAngle;
}
function une(t, e, r, n, i, a, s, o) {
  var l = r - t, u = n - e, h = s - i, d = o - a, f = d * l - h * u;
  if (!(f * f < yi))
    return f = (h * (e - a) - d * (t - i)) / f, [t + f * l, e + f * u];
}
function l1(t, e, r, n, i, a, s) {
  var o = t - r, l = e - n, u = (s ? a : -a) / Fh(o * o + l * l), h = u * l, d = -u * o, f = t + h, p = e + d, g = r + h, m = n + d, v = (f + g) / 2, y = (p + m) / 2, b = g - f, w = m - p, T = b * b + w * w, E = i - a, L = f * m - g * p, k = (w < 0 ? -1 : 1) * Fh(nne(0, E * E * T - L * L)), C = (L * w - b * k) / T, A = (-L * b - w * k) / T, R = (L * w + b * k) / T, _ = (-L * b + w * k) / T, O = C - v, P = A - y, S = R - v, M = _ - y;
  return O * O + P * P > S * S + M * M && (C = R, A = _), {
    cx: C,
    cy: A,
    x01: -h,
    y01: -d,
    x11: C * (i / E - 1),
    y11: A * (i / E - 1)
  };
}
function yd() {
  var t = ane, e = sne, r = gn(0), n = null, i = one, a = lne, s = cne, o = null, l = DD(u);
  function u() {
    var h, d, f = +t.apply(this, arguments), p = +e.apply(this, arguments), g = i.apply(this, arguments) - Uv, m = a.apply(this, arguments) - Uv, v = WC(m - g), y = m > g;
    if (o || (o = h = l()), p < f && (d = p, p = f, f = d), !(p > yi)) o.moveTo(0, 0);
    else if (v > km - yi)
      o.moveTo(p * Dc(g), p * Os(g)), o.arc(0, 0, p, g, m, !y), f > yi && (o.moveTo(f * Dc(m), f * Os(m)), o.arc(0, 0, f, m, g, y));
    else {
      var b = g, w = m, T = g, E = m, L = v, k = v, C = s.apply(this, arguments) / 2, A = C > yi && (n ? +n.apply(this, arguments) : Fh(f * f + p * p)), R = Zb(WC(p - f) / 2, +r.apply(this, arguments)), _ = R, O = R, P, S;
      if (A > yi) {
        var M = YC(A / f * Os(C)), N = YC(A / p * Os(C));
        (L -= M * 2) > yi ? (M *= y ? 1 : -1, T += M, E -= M) : (L = 0, T = E = (g + m) / 2), (k -= N * 2) > yi ? (N *= y ? 1 : -1, b += N, w -= N) : (k = 0, b = w = (g + m) / 2);
      }
      var D = p * Dc(b), I = p * Os(b), B = f * Dc(E), z = f * Os(E);
      if (R > yi) {
        var F = p * Dc(w), V = p * Os(w), H = f * Dc(T), J = f * Os(T), q;
        if (v < pp)
          if (q = une(D, I, H, J, F, V, B, z)) {
            var ae = D - q[0], re = I - q[1], pe = F - q[0], K = V - q[1], Z = 1 / Os(ine((ae * pe + re * K) / (Fh(ae * ae + re * re) * Fh(pe * pe + K * K))) / 2), X = Fh(q[0] * q[0] + q[1] * q[1]);
            _ = Zb(R, (f - X) / (Z - 1)), O = Zb(R, (p - X) / (Z + 1));
          } else
            _ = O = 0;
      }
      k > yi ? O > yi ? (P = l1(H, J, D, I, p, O, y), S = l1(F, V, B, z, p, O, y), o.moveTo(P.cx + P.x01, P.cy + P.y01), O < R ? o.arc(P.cx, P.cy, O, mi(P.y01, P.x01), mi(S.y01, S.x01), !y) : (o.arc(P.cx, P.cy, O, mi(P.y01, P.x01), mi(P.y11, P.x11), !y), o.arc(0, 0, p, mi(P.cy + P.y11, P.cx + P.x11), mi(S.cy + S.y11, S.cx + S.x11), !y), o.arc(S.cx, S.cy, O, mi(S.y11, S.x11), mi(S.y01, S.x01), !y))) : (o.moveTo(D, I), o.arc(0, 0, p, b, w, !y)) : o.moveTo(D, I), !(f > yi) || !(L > yi) ? o.lineTo(B, z) : _ > yi ? (P = l1(B, z, F, V, f, -_, y), S = l1(D, I, H, J, f, -_, y), o.lineTo(P.cx + P.x01, P.cy + P.y01), _ < R ? o.arc(P.cx, P.cy, _, mi(P.y01, P.x01), mi(S.y01, S.x01), !y) : (o.arc(P.cx, P.cy, _, mi(P.y01, P.x01), mi(P.y11, P.x11), !y), o.arc(0, 0, f, mi(P.cy + P.y11, P.cx + P.x11), mi(S.cy + S.y11, S.cx + S.x11), y), o.arc(S.cx, S.cy, _, mi(S.y11, S.x11), mi(S.y01, S.x01), !y))) : o.arc(0, 0, f, E, T, y);
    }
    if (o.closePath(), h) return o = null, h + "" || null;
  }
  return u.centroid = function() {
    var h = (+t.apply(this, arguments) + +e.apply(this, arguments)) / 2, d = (+i.apply(this, arguments) + +a.apply(this, arguments)) / 2 - pp / 2;
    return [Dc(d) * h, Os(d) * h];
  }, u.innerRadius = function(h) {
    return arguments.length ? (t = typeof h == "function" ? h : gn(+h), u) : t;
  }, u.outerRadius = function(h) {
    return arguments.length ? (e = typeof h == "function" ? h : gn(+h), u) : e;
  }, u.cornerRadius = function(h) {
    return arguments.length ? (r = typeof h == "function" ? h : gn(+h), u) : r;
  }, u.padRadius = function(h) {
    return arguments.length ? (n = h == null ? null : typeof h == "function" ? h : gn(+h), u) : n;
  }, u.startAngle = function(h) {
    return arguments.length ? (i = typeof h == "function" ? h : gn(+h), u) : i;
  }, u.endAngle = function(h) {
    return arguments.length ? (a = typeof h == "function" ? h : gn(+h), u) : a;
  }, u.padAngle = function(h) {
    return arguments.length ? (s = typeof h == "function" ? h : gn(+h), u) : s;
  }, u.context = function(h) {
    return arguments.length ? (o = h ?? null, u) : o;
  }, u;
}
function OD(t) {
  return typeof t == "object" && "length" in t ? t : Array.from(t);
}
function PD(t) {
  this._context = t;
}
PD.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2;
      // falls through
      default:
        this._context.lineTo(t, e);
        break;
    }
  }
};
function Hv(t) {
  return new PD(t);
}
function hne(t) {
  return t[0];
}
function dne(t) {
  return t[1];
}
function gp(t, e) {
  var r = gn(!0), n = null, i = Hv, a = null, s = DD(o);
  t = typeof t == "function" ? t : t === void 0 ? hne : gn(t), e = typeof e == "function" ? e : e === void 0 ? dne : gn(e);
  function o(l) {
    var u, h = (l = OD(l)).length, d, f = !1, p;
    for (n == null && (a = i(p = s())), u = 0; u <= h; ++u)
      !(u < h && r(d = l[u], u, l)) === f && ((f = !f) ? a.lineStart() : a.lineEnd()), f && a.point(+t(d, u, l), +e(d, u, l));
    if (p) return a = null, p + "" || null;
  }
  return o.x = function(l) {
    return arguments.length ? (t = typeof l == "function" ? l : gn(+l), o) : t;
  }, o.y = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : gn(+l), o) : e;
  }, o.defined = function(l) {
    return arguments.length ? (r = typeof l == "function" ? l : gn(!!l), o) : r;
  }, o.curve = function(l) {
    return arguments.length ? (i = l, n != null && (a = i(n)), o) : i;
  }, o.context = function(l) {
    return arguments.length ? (l == null ? n = a = null : a = i(n = l), o) : n;
  }, o;
}
function fne(t, e) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function pne(t) {
  return t;
}
function gne() {
  var t = pne, e = fne, r = null, n = gn(0), i = gn(km), a = gn(0);
  function s(o) {
    var l, u = (o = OD(o)).length, h, d, f = 0, p = new Array(u), g = new Array(u), m = +n.apply(this, arguments), v = Math.min(km, Math.max(-km, i.apply(this, arguments) - m)), y, b = Math.min(Math.abs(v) / u, a.apply(this, arguments)), w = b * (v < 0 ? -1 : 1), T;
    for (l = 0; l < u; ++l)
      (T = g[p[l] = l] = +t(o[l], l, o)) > 0 && (f += T);
    for (e != null ? p.sort(function(E, L) {
      return e(g[E], g[L]);
    }) : r != null && p.sort(function(E, L) {
      return r(o[E], o[L]);
    }), l = 0, d = f ? (v - u * w) / f : 0; l < u; ++l, m = y)
      h = p[l], T = g[h], y = m + (T > 0 ? T * d : 0) + w, g[h] = {
        data: o[h],
        index: l,
        value: T,
        startAngle: m,
        endAngle: y,
        padAngle: b
      };
    return g;
  }
  return s.value = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : gn(+o), s) : t;
  }, s.sortValues = function(o) {
    return arguments.length ? (e = o, r = null, s) : e;
  }, s.sort = function(o) {
    return arguments.length ? (r = o, e = null, s) : r;
  }, s.startAngle = function(o) {
    return arguments.length ? (n = typeof o == "function" ? o : gn(+o), s) : n;
  }, s.endAngle = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : gn(+o), s) : i;
  }, s.padAngle = function(o) {
    return arguments.length ? (a = typeof o == "function" ? o : gn(+o), s) : a;
  }, s;
}
class BD {
  constructor(e, r) {
    this._context = e, this._x = r;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(e, r) {
    switch (e = +e, r = +r, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(e, r) : this._context.moveTo(e, r);
        break;
      }
      case 1:
        this._point = 2;
      // falls through
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + e) / 2, this._y0, this._x0, r, e, r) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + r) / 2, e, this._y0, e, r);
        break;
      }
    }
    this._x0 = e, this._y0 = r;
  }
}
function FD(t) {
  return new BD(t, !0);
}
function $D(t) {
  return new BD(t, !1);
}
function Ul() {
}
function qv(t, e, r) {
  t._context.bezierCurveTo(
    (2 * t._x0 + t._x1) / 3,
    (2 * t._y0 + t._y1) / 3,
    (t._x0 + 2 * t._x1) / 3,
    (t._y0 + 2 * t._y1) / 3,
    (t._x0 + 4 * t._x1 + e) / 6,
    (t._y0 + 4 * t._y1 + r) / 6
  );
}
function z2(t) {
  this._context = t;
}
z2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        qv(this, this._x1, this._y1);
      // falls through
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // falls through
      default:
        qv(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e;
  }
};
function jh(t) {
  return new z2(t);
}
function zD(t) {
  this._context = t;
}
zD.prototype = {
  areaStart: Ul,
  areaEnd: Ul,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._x2 = t, this._y2 = e;
        break;
      case 1:
        this._point = 2, this._x3 = t, this._y3 = e;
        break;
      case 2:
        this._point = 3, this._x4 = t, this._y4 = e, this._context.moveTo((this._x0 + 4 * this._x1 + t) / 6, (this._y0 + 4 * this._y1 + e) / 6);
        break;
      default:
        qv(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e;
  }
};
function mne(t) {
  return new zD(t);
}
function GD(t) {
  this._context = t;
}
GD.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var r = (this._x0 + 4 * this._x1 + t) / 6, n = (this._y0 + 4 * this._y1 + e) / 6;
        this._line ? this._context.lineTo(r, n) : this._context.moveTo(r, n);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        qv(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e;
  }
};
function vne(t) {
  return new GD(t);
}
function VD(t, e) {
  this._basis = new z2(t), this._beta = e;
}
VD.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var t = this._x, e = this._y, r = t.length - 1;
    if (r > 0)
      for (var n = t[0], i = e[0], a = t[r] - n, s = e[r] - i, o = -1, l; ++o <= r; )
        l = o / r, this._basis.point(
          this._beta * t[o] + (1 - this._beta) * (n + l * a),
          this._beta * e[o] + (1 - this._beta) * (i + l * s)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(t, e) {
    this._x.push(+t), this._y.push(+e);
  }
};
const yne = (function t(e) {
  function r(n) {
    return e === 1 ? new z2(n) : new VD(n, e);
  }
  return r.beta = function(n) {
    return t(+n);
  }, r;
})(0.85);
function Wv(t, e, r) {
  t._context.bezierCurveTo(
    t._x1 + t._k * (t._x2 - t._x0),
    t._y1 + t._k * (t._y2 - t._y0),
    t._x2 + t._k * (t._x1 - e),
    t._y2 + t._k * (t._y1 - r),
    t._x2,
    t._y2
  );
}
function EE(t, e) {
  this._context = t, this._k = (1 - e) / 6;
}
EE.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        Wv(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2, this._x1 = t, this._y1 = e;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        Wv(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const UD = (function t(e) {
  function r(n) {
    return new EE(n, e);
  }
  return r.tension = function(n) {
    return t(+n);
  }, r;
})(0);
function kE(t, e) {
  this._context = t, this._k = (1 - e) / 6;
}
kE.prototype = {
  areaStart: Ul,
  areaEnd: Ul,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._x3 = t, this._y3 = e;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = e);
        break;
      case 2:
        this._point = 3, this._x5 = t, this._y5 = e;
        break;
      default:
        Wv(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const xne = (function t(e) {
  function r(n) {
    return new kE(n, e);
  }
  return r.tension = function(n) {
    return t(+n);
  }, r;
})(0);
function SE(t, e) {
  this._context = t, this._k = (1 - e) / 6;
}
SE.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        Wv(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const bne = (function t(e) {
  function r(n) {
    return new SE(n, e);
  }
  return r.tension = function(n) {
    return t(+n);
  }, r;
})(0);
function CE(t, e, r) {
  var n = t._x1, i = t._y1, a = t._x2, s = t._y2;
  if (t._l01_a > yi) {
    var o = 2 * t._l01_2a + 3 * t._l01_a * t._l12_a + t._l12_2a, l = 3 * t._l01_a * (t._l01_a + t._l12_a);
    n = (n * o - t._x0 * t._l12_2a + t._x2 * t._l01_2a) / l, i = (i * o - t._y0 * t._l12_2a + t._y2 * t._l01_2a) / l;
  }
  if (t._l23_a > yi) {
    var u = 2 * t._l23_2a + 3 * t._l23_a * t._l12_a + t._l12_2a, h = 3 * t._l23_a * (t._l23_a + t._l12_a);
    a = (a * u + t._x1 * t._l23_2a - e * t._l12_2a) / h, s = (s * u + t._y1 * t._l23_2a - r * t._l12_2a) / h;
  }
  t._context.bezierCurveTo(n, i, a, s, t._x2, t._y2);
}
function HD(t, e) {
  this._context = t, this._alpha = e;
}
HD.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    if (t = +t, e = +e, this._point) {
      var r = this._x2 - t, n = this._y2 - e;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        CE(this, t, e);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const qD = (function t(e) {
  function r(n) {
    return e ? new HD(n, e) : new EE(n, 0);
  }
  return r.alpha = function(n) {
    return t(+n);
  }, r;
})(0.5);
function WD(t, e) {
  this._context = t, this._alpha = e;
}
WD.prototype = {
  areaStart: Ul,
  areaEnd: Ul,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(t, e) {
    if (t = +t, e = +e, this._point) {
      var r = this._x2 - t, n = this._y2 - e;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = t, this._y3 = e;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = e);
        break;
      case 2:
        this._point = 3, this._x5 = t, this._y5 = e;
        break;
      default:
        CE(this, t, e);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const wne = (function t(e) {
  function r(n) {
    return e ? new WD(n, e) : new kE(n, 0);
  }
  return r.alpha = function(n) {
    return t(+n);
  }, r;
})(0.5);
function YD(t, e) {
  this._context = t, this._alpha = e;
}
YD.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    if (t = +t, e = +e, this._point) {
      var r = this._x2 - t, n = this._y2 - e;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        CE(this, t, e);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const Tne = (function t(e) {
  function r(n) {
    return e ? new YD(n, e) : new SE(n, 0);
  }
  return r.alpha = function(n) {
    return t(+n);
  }, r;
})(0.5);
function XD(t) {
  this._context = t;
}
XD.prototype = {
  areaStart: Ul,
  areaEnd: Ul,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(t, e) {
    t = +t, e = +e, this._point ? this._context.lineTo(t, e) : (this._point = 1, this._context.moveTo(t, e));
  }
};
function Ene(t) {
  return new XD(t);
}
function XC(t) {
  return t < 0 ? -1 : 1;
}
function jC(t, e, r) {
  var n = t._x1 - t._x0, i = e - t._x1, a = (t._y1 - t._y0) / (n || i < 0 && -0), s = (r - t._y1) / (i || n < 0 && -0), o = (a * i + s * n) / (n + i);
  return (XC(a) + XC(s)) * Math.min(Math.abs(a), Math.abs(s), 0.5 * Math.abs(o)) || 0;
}
function KC(t, e) {
  var r = t._x1 - t._x0;
  return r ? (3 * (t._y1 - t._y0) / r - e) / 2 : e;
}
function Qb(t, e, r) {
  var n = t._x0, i = t._y0, a = t._x1, s = t._y1, o = (a - n) / 3;
  t._context.bezierCurveTo(n + o, i + o * e, a - o, s - o * r, a, s);
}
function Yv(t) {
  this._context = t;
}
Yv.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        Qb(this, this._t0, KC(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    var r = NaN;
    if (t = +t, e = +e, !(t === this._x1 && e === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, Qb(this, KC(this, r = jC(this, t, e)), r);
          break;
        default:
          Qb(this, this._t0, r = jC(this, t, e));
          break;
      }
      this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e, this._t0 = r;
    }
  }
};
function jD(t) {
  this._context = new KD(t);
}
(jD.prototype = Object.create(Yv.prototype)).point = function(t, e) {
  Yv.prototype.point.call(this, e, t);
};
function KD(t) {
  this._context = t;
}
KD.prototype = {
  moveTo: function(t, e) {
    this._context.moveTo(e, t);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(t, e) {
    this._context.lineTo(e, t);
  },
  bezierCurveTo: function(t, e, r, n, i, a) {
    this._context.bezierCurveTo(e, t, n, r, a, i);
  }
};
function ZD(t) {
  return new Yv(t);
}
function QD(t) {
  return new jD(t);
}
function JD(t) {
  this._context = t;
}
JD.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var t = this._x, e = this._y, r = t.length;
    if (r)
      if (this._line ? this._context.lineTo(t[0], e[0]) : this._context.moveTo(t[0], e[0]), r === 2)
        this._context.lineTo(t[1], e[1]);
      else
        for (var n = ZC(t), i = ZC(e), a = 0, s = 1; s < r; ++a, ++s)
          this._context.bezierCurveTo(n[0][a], i[0][a], n[1][a], i[1][a], t[s], e[s]);
    (this._line || this._line !== 0 && r === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(t, e) {
    this._x.push(+t), this._y.push(+e);
  }
};
function ZC(t) {
  var e, r = t.length - 1, n, i = new Array(r), a = new Array(r), s = new Array(r);
  for (i[0] = 0, a[0] = 2, s[0] = t[0] + 2 * t[1], e = 1; e < r - 1; ++e) i[e] = 1, a[e] = 4, s[e] = 4 * t[e] + 2 * t[e + 1];
  for (i[r - 1] = 2, a[r - 1] = 7, s[r - 1] = 8 * t[r - 1] + t[r], e = 1; e < r; ++e) n = i[e] / a[e - 1], a[e] -= n, s[e] -= n * s[e - 1];
  for (i[r - 1] = s[r - 1] / a[r - 1], e = r - 2; e >= 0; --e) i[e] = (s[e] - i[e + 1]) / a[e];
  for (a[r - 1] = (t[r] + i[r - 1]) / 2, e = 0; e < r - 1; ++e) a[e] = 2 * t[e + 1] - i[e + 1];
  return [i, a];
}
function eO(t) {
  return new JD(t);
}
function G2(t, e) {
  this._context = t, this._t = e;
}
G2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, e), this._context.lineTo(t, e);
        else {
          var r = this._x * (1 - this._t) + t * this._t;
          this._context.lineTo(r, this._y), this._context.lineTo(r, e);
        }
        break;
      }
    }
    this._x = t, this._y = e;
  }
};
function tO(t) {
  return new G2(t, 0.5);
}
function rO(t) {
  return new G2(t, 0);
}
function nO(t) {
  return new G2(t, 1);
}
function Wf(t, e, r) {
  this.k = t, this.x = e, this.y = r;
}
Wf.prototype = {
  constructor: Wf,
  scale: function(t) {
    return t === 1 ? this : new Wf(this.k * t, this.x, this.y);
  },
  translate: function(t, e) {
    return t === 0 & e === 0 ? this : new Wf(this.k, this.x + this.k * t, this.y + this.k * e);
  },
  apply: function(t) {
    return [t[0] * this.k + this.x, t[1] * this.k + this.y];
  },
  applyX: function(t) {
    return t * this.k + this.x;
  },
  applyY: function(t) {
    return t * this.k + this.y;
  },
  invert: function(t) {
    return [(t[0] - this.x) / this.k, (t[1] - this.y) / this.k];
  },
  invertX: function(t) {
    return (t - this.x) / this.k;
  },
  invertY: function(t) {
    return (t - this.y) / this.k;
  },
  rescaleX: function(t) {
    return t.copy().domain(t.range().map(this.invertX, this).map(t.invert, t));
  },
  rescaleY: function(t) {
    return t.copy().domain(t.range().map(this.invertY, this).map(t.invert, t));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
Wf.prototype;
var ll = /* @__PURE__ */ x((t) => {
  const { securityLevel: e } = we();
  let r = Qe("body");
  if (e === "sandbox") {
    const a = Qe(`#i${t}`).node()?.contentDocument ?? document;
    r = Qe(a.body);
  }
  return r.select(`#${t}`);
}, "selectSvgElement");
function AE(t) {
  return typeof t > "u" || t === null;
}
x(AE, "isNothing");
function iO(t) {
  return typeof t == "object" && t !== null;
}
x(iO, "isObject");
function aO(t) {
  return Array.isArray(t) ? t : AE(t) ? [] : [t];
}
x(aO, "toArray");
function sO(t, e) {
  var r, n, i, a;
  if (e)
    for (a = Object.keys(e), r = 0, n = a.length; r < n; r += 1)
      i = a[r], t[i] = e[i];
  return t;
}
x(sO, "extend");
function oO(t, e) {
  var r = "", n;
  for (n = 0; n < e; n += 1)
    r += t;
  return r;
}
x(oO, "repeat");
function lO(t) {
  return t === 0 && Number.NEGATIVE_INFINITY === 1 / t;
}
x(lO, "isNegativeZero");
var kne = AE, Sne = iO, Cne = aO, Ane = oO, _ne = lO, Lne = sO, Bn = {
  isNothing: kne,
  isObject: Sne,
  toArray: Cne,
  repeat: Ane,
  isNegativeZero: _ne,
  extend: Lne
};
function _E(t, e) {
  var r = "", n = t.reason || "(unknown reason)";
  return t.mark ? (t.mark.name && (r += 'in "' + t.mark.name + '" '), r += "(" + (t.mark.line + 1) + ":" + (t.mark.column + 1) + ")", !e && t.mark.snippet && (r += `

` + t.mark.snippet), n + " " + r) : n;
}
x(_E, "formatError");
function xd(t, e) {
  Error.call(this), this.name = "YAMLException", this.reason = t, this.mark = e, this.message = _E(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
x(xd, "YAMLException$1");
xd.prototype = Object.create(Error.prototype);
xd.prototype.constructor = xd;
xd.prototype.toString = /* @__PURE__ */ x(function(e) {
  return this.name + ": " + _E(this, e);
}, "toString");
var aa = xd;
function Sm(t, e, r, n, i) {
  var a = "", s = "", o = Math.floor(i / 2) - 1;
  return n - e > o && (a = " ... ", e = n - o + a.length), r - n > o && (s = " ...", r = n + o - s.length), {
    str: a + t.slice(e, r).replace(/\t/g, "") + s,
    pos: n - e + a.length
    // relative position
  };
}
x(Sm, "getLine");
function Cm(t, e) {
  return Bn.repeat(" ", e - t.length) + t;
}
x(Cm, "padStart");
function cO(t, e) {
  if (e = Object.create(e || null), !t.buffer) return null;
  e.maxLength || (e.maxLength = 79), typeof e.indent != "number" && (e.indent = 1), typeof e.linesBefore != "number" && (e.linesBefore = 3), typeof e.linesAfter != "number" && (e.linesAfter = 2);
  for (var r = /\r?\n|\r|\0/g, n = [0], i = [], a, s = -1; a = r.exec(t.buffer); )
    i.push(a.index), n.push(a.index + a[0].length), t.position <= a.index && s < 0 && (s = n.length - 2);
  s < 0 && (s = n.length - 1);
  var o = "", l, u, h = Math.min(t.line + e.linesAfter, i.length).toString().length, d = e.maxLength - (e.indent + h + 3);
  for (l = 1; l <= e.linesBefore && !(s - l < 0); l++)
    u = Sm(
      t.buffer,
      n[s - l],
      i[s - l],
      t.position - (n[s] - n[s - l]),
      d
    ), o = Bn.repeat(" ", e.indent) + Cm((t.line - l + 1).toString(), h) + " | " + u.str + `
` + o;
  for (u = Sm(t.buffer, n[s], i[s], t.position, d), o += Bn.repeat(" ", e.indent) + Cm((t.line + 1).toString(), h) + " | " + u.str + `
`, o += Bn.repeat("-", e.indent + h + 3 + u.pos) + `^
`, l = 1; l <= e.linesAfter && !(s + l >= i.length); l++)
    u = Sm(
      t.buffer,
      n[s + l],
      i[s + l],
      t.position - (n[s] - n[s + l]),
      d
    ), o += Bn.repeat(" ", e.indent) + Cm((t.line + l + 1).toString(), h) + " | " + u.str + `
`;
  return o.replace(/\n$/, "");
}
x(cO, "makeSnippet");
var Rne = cO, Mne = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
], Nne = [
  "scalar",
  "sequence",
  "mapping"
];
function uO(t) {
  var e = {};
  return t !== null && Object.keys(t).forEach(function(r) {
    t[r].forEach(function(n) {
      e[String(n)] = r;
    });
  }), e;
}
x(uO, "compileStyleAliases");
function hO(t, e) {
  if (e = e || {}, Object.keys(e).forEach(function(r) {
    if (Mne.indexOf(r) === -1)
      throw new aa('Unknown option "' + r + '" is met in definition of "' + t + '" YAML type.');
  }), this.options = e, this.tag = t, this.kind = e.kind || null, this.resolve = e.resolve || function() {
    return !0;
  }, this.construct = e.construct || function(r) {
    return r;
  }, this.instanceOf = e.instanceOf || null, this.predicate = e.predicate || null, this.represent = e.represent || null, this.representName = e.representName || null, this.defaultStyle = e.defaultStyle || null, this.multi = e.multi || !1, this.styleAliases = uO(e.styleAliases || null), Nne.indexOf(this.kind) === -1)
    throw new aa('Unknown kind "' + this.kind + '" is specified for "' + t + '" YAML type.');
}
x(hO, "Type$1");
var Ei = hO;
function xw(t, e) {
  var r = [];
  return t[e].forEach(function(n) {
    var i = r.length;
    r.forEach(function(a, s) {
      a.tag === n.tag && a.kind === n.kind && a.multi === n.multi && (i = s);
    }), r[i] = n;
  }), r;
}
x(xw, "compileList");
function dO() {
  var t = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, e, r;
  function n(i) {
    i.multi ? (t.multi[i.kind].push(i), t.multi.fallback.push(i)) : t[i.kind][i.tag] = t.fallback[i.tag] = i;
  }
  for (x(n, "collectType"), e = 0, r = arguments.length; e < r; e += 1)
    arguments[e].forEach(n);
  return t;
}
x(dO, "compileMap");
function Xv(t) {
  return this.extend(t);
}
x(Xv, "Schema$1");
Xv.prototype.extend = /* @__PURE__ */ x(function(e) {
  var r = [], n = [];
  if (e instanceof Ei)
    n.push(e);
  else if (Array.isArray(e))
    n = n.concat(e);
  else if (e && (Array.isArray(e.implicit) || Array.isArray(e.explicit)))
    e.implicit && (r = r.concat(e.implicit)), e.explicit && (n = n.concat(e.explicit));
  else
    throw new aa("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  r.forEach(function(a) {
    if (!(a instanceof Ei))
      throw new aa("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (a.loadKind && a.loadKind !== "scalar")
      throw new aa("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (a.multi)
      throw new aa("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), n.forEach(function(a) {
    if (!(a instanceof Ei))
      throw new aa("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var i = Object.create(Xv.prototype);
  return i.implicit = (this.implicit || []).concat(r), i.explicit = (this.explicit || []).concat(n), i.compiledImplicit = xw(i, "implicit"), i.compiledExplicit = xw(i, "explicit"), i.compiledTypeMap = dO(i.compiledImplicit, i.compiledExplicit), i;
}, "extend");
var Ine = Xv, Dne = new Ei("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: /* @__PURE__ */ x(function(t) {
    return t !== null ? t : "";
  }, "construct")
}), One = new Ei("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: /* @__PURE__ */ x(function(t) {
    return t !== null ? t : [];
  }, "construct")
}), Pne = new Ei("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: /* @__PURE__ */ x(function(t) {
    return t !== null ? t : {};
  }, "construct")
}), Bne = new Ine({
  explicit: [
    Dne,
    One,
    Pne
  ]
});
function fO(t) {
  if (t === null) return !0;
  var e = t.length;
  return e === 1 && t === "~" || e === 4 && (t === "null" || t === "Null" || t === "NULL");
}
x(fO, "resolveYamlNull");
function pO() {
  return null;
}
x(pO, "constructYamlNull");
function gO(t) {
  return t === null;
}
x(gO, "isNull");
var Fne = new Ei("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: fO,
  construct: pO,
  predicate: gO,
  represent: {
    canonical: /* @__PURE__ */ x(function() {
      return "~";
    }, "canonical"),
    lowercase: /* @__PURE__ */ x(function() {
      return "null";
    }, "lowercase"),
    uppercase: /* @__PURE__ */ x(function() {
      return "NULL";
    }, "uppercase"),
    camelcase: /* @__PURE__ */ x(function() {
      return "Null";
    }, "camelcase"),
    empty: /* @__PURE__ */ x(function() {
      return "";
    }, "empty")
  },
  defaultStyle: "lowercase"
});
function mO(t) {
  if (t === null) return !1;
  var e = t.length;
  return e === 4 && (t === "true" || t === "True" || t === "TRUE") || e === 5 && (t === "false" || t === "False" || t === "FALSE");
}
x(mO, "resolveYamlBoolean");
function vO(t) {
  return t === "true" || t === "True" || t === "TRUE";
}
x(vO, "constructYamlBoolean");
function yO(t) {
  return Object.prototype.toString.call(t) === "[object Boolean]";
}
x(yO, "isBoolean");
var $ne = new Ei("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: mO,
  construct: vO,
  predicate: yO,
  represent: {
    lowercase: /* @__PURE__ */ x(function(t) {
      return t ? "true" : "false";
    }, "lowercase"),
    uppercase: /* @__PURE__ */ x(function(t) {
      return t ? "TRUE" : "FALSE";
    }, "uppercase"),
    camelcase: /* @__PURE__ */ x(function(t) {
      return t ? "True" : "False";
    }, "camelcase")
  },
  defaultStyle: "lowercase"
});
function xO(t) {
  return 48 <= t && t <= 57 || 65 <= t && t <= 70 || 97 <= t && t <= 102;
}
x(xO, "isHexCode");
function bO(t) {
  return 48 <= t && t <= 55;
}
x(bO, "isOctCode");
function wO(t) {
  return 48 <= t && t <= 57;
}
x(wO, "isDecCode");
function TO(t) {
  if (t === null) return !1;
  var e = t.length, r = 0, n = !1, i;
  if (!e) return !1;
  if (i = t[r], (i === "-" || i === "+") && (i = t[++r]), i === "0") {
    if (r + 1 === e) return !0;
    if (i = t[++r], i === "b") {
      for (r++; r < e; r++)
        if (i = t[r], i !== "_") {
          if (i !== "0" && i !== "1") return !1;
          n = !0;
        }
      return n && i !== "_";
    }
    if (i === "x") {
      for (r++; r < e; r++)
        if (i = t[r], i !== "_") {
          if (!xO(t.charCodeAt(r))) return !1;
          n = !0;
        }
      return n && i !== "_";
    }
    if (i === "o") {
      for (r++; r < e; r++)
        if (i = t[r], i !== "_") {
          if (!bO(t.charCodeAt(r))) return !1;
          n = !0;
        }
      return n && i !== "_";
    }
  }
  if (i === "_") return !1;
  for (; r < e; r++)
    if (i = t[r], i !== "_") {
      if (!wO(t.charCodeAt(r)))
        return !1;
      n = !0;
    }
  return !(!n || i === "_");
}
x(TO, "resolveYamlInteger");
function EO(t) {
  var e = t, r = 1, n;
  if (e.indexOf("_") !== -1 && (e = e.replace(/_/g, "")), n = e[0], (n === "-" || n === "+") && (n === "-" && (r = -1), e = e.slice(1), n = e[0]), e === "0") return 0;
  if (n === "0") {
    if (e[1] === "b") return r * parseInt(e.slice(2), 2);
    if (e[1] === "x") return r * parseInt(e.slice(2), 16);
    if (e[1] === "o") return r * parseInt(e.slice(2), 8);
  }
  return r * parseInt(e, 10);
}
x(EO, "constructYamlInteger");
function kO(t) {
  return Object.prototype.toString.call(t) === "[object Number]" && t % 1 === 0 && !Bn.isNegativeZero(t);
}
x(kO, "isInteger");
var zne = new Ei("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: TO,
  construct: EO,
  predicate: kO,
  represent: {
    binary: /* @__PURE__ */ x(function(t) {
      return t >= 0 ? "0b" + t.toString(2) : "-0b" + t.toString(2).slice(1);
    }, "binary"),
    octal: /* @__PURE__ */ x(function(t) {
      return t >= 0 ? "0o" + t.toString(8) : "-0o" + t.toString(8).slice(1);
    }, "octal"),
    decimal: /* @__PURE__ */ x(function(t) {
      return t.toString(10);
    }, "decimal"),
    /* eslint-disable max-len */
    hexadecimal: /* @__PURE__ */ x(function(t) {
      return t >= 0 ? "0x" + t.toString(16).toUpperCase() : "-0x" + t.toString(16).toUpperCase().slice(1);
    }, "hexadecimal")
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), Gne = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function SO(t) {
  return !(t === null || !Gne.test(t) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  t[t.length - 1] === "_");
}
x(SO, "resolveYamlFloat");
function CO(t) {
  var e, r;
  return e = t.replace(/_/g, "").toLowerCase(), r = e[0] === "-" ? -1 : 1, "+-".indexOf(e[0]) >= 0 && (e = e.slice(1)), e === ".inf" ? r === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : e === ".nan" ? NaN : r * parseFloat(e, 10);
}
x(CO, "constructYamlFloat");
var Vne = /^[-+]?[0-9]+e/;
function AO(t, e) {
  var r;
  if (isNaN(t))
    switch (e) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === t)
    switch (e) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === t)
    switch (e) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (Bn.isNegativeZero(t))
    return "-0.0";
  return r = t.toString(10), Vne.test(r) ? r.replace("e", ".e") : r;
}
x(AO, "representYamlFloat");
function _O(t) {
  return Object.prototype.toString.call(t) === "[object Number]" && (t % 1 !== 0 || Bn.isNegativeZero(t));
}
x(_O, "isFloat");
var Une = new Ei("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: SO,
  construct: CO,
  predicate: _O,
  represent: AO,
  defaultStyle: "lowercase"
}), LO = Bne.extend({
  implicit: [
    Fne,
    $ne,
    zne,
    Une
  ]
}), Hne = LO, RO = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), MO = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function NO(t) {
  return t === null ? !1 : RO.exec(t) !== null || MO.exec(t) !== null;
}
x(NO, "resolveYamlTimestamp");
function IO(t) {
  var e, r, n, i, a, s, o, l = 0, u = null, h, d, f;
  if (e = RO.exec(t), e === null && (e = MO.exec(t)), e === null) throw new Error("Date resolve error");
  if (r = +e[1], n = +e[2] - 1, i = +e[3], !e[4])
    return new Date(Date.UTC(r, n, i));
  if (a = +e[4], s = +e[5], o = +e[6], e[7]) {
    for (l = e[7].slice(0, 3); l.length < 3; )
      l += "0";
    l = +l;
  }
  return e[9] && (h = +e[10], d = +(e[11] || 0), u = (h * 60 + d) * 6e4, e[9] === "-" && (u = -u)), f = new Date(Date.UTC(r, n, i, a, s, o, l)), u && f.setTime(f.getTime() - u), f;
}
x(IO, "constructYamlTimestamp");
function DO(t) {
  return t.toISOString();
}
x(DO, "representYamlTimestamp");
var qne = new Ei("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: NO,
  construct: IO,
  instanceOf: Date,
  represent: DO
});
function OO(t) {
  return t === "<<" || t === null;
}
x(OO, "resolveYamlMerge");
var Wne = new Ei("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: OO
}), LE = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function PO(t) {
  if (t === null) return !1;
  var e, r, n = 0, i = t.length, a = LE;
  for (r = 0; r < i; r++)
    if (e = a.indexOf(t.charAt(r)), !(e > 64)) {
      if (e < 0) return !1;
      n += 6;
    }
  return n % 8 === 0;
}
x(PO, "resolveYamlBinary");
function BO(t) {
  var e, r, n = t.replace(/[\r\n=]/g, ""), i = n.length, a = LE, s = 0, o = [];
  for (e = 0; e < i; e++)
    e % 4 === 0 && e && (o.push(s >> 16 & 255), o.push(s >> 8 & 255), o.push(s & 255)), s = s << 6 | a.indexOf(n.charAt(e));
  return r = i % 4 * 6, r === 0 ? (o.push(s >> 16 & 255), o.push(s >> 8 & 255), o.push(s & 255)) : r === 18 ? (o.push(s >> 10 & 255), o.push(s >> 2 & 255)) : r === 12 && o.push(s >> 4 & 255), new Uint8Array(o);
}
x(BO, "constructYamlBinary");
function FO(t) {
  var e = "", r = 0, n, i, a = t.length, s = LE;
  for (n = 0; n < a; n++)
    n % 3 === 0 && n && (e += s[r >> 18 & 63], e += s[r >> 12 & 63], e += s[r >> 6 & 63], e += s[r & 63]), r = (r << 8) + t[n];
  return i = a % 3, i === 0 ? (e += s[r >> 18 & 63], e += s[r >> 12 & 63], e += s[r >> 6 & 63], e += s[r & 63]) : i === 2 ? (e += s[r >> 10 & 63], e += s[r >> 4 & 63], e += s[r << 2 & 63], e += s[64]) : i === 1 && (e += s[r >> 2 & 63], e += s[r << 4 & 63], e += s[64], e += s[64]), e;
}
x(FO, "representYamlBinary");
function $O(t) {
  return Object.prototype.toString.call(t) === "[object Uint8Array]";
}
x($O, "isBinary");
var Yne = new Ei("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: PO,
  construct: BO,
  predicate: $O,
  represent: FO
}), Xne = Object.prototype.hasOwnProperty, jne = Object.prototype.toString;
function zO(t) {
  if (t === null) return !0;
  var e = [], r, n, i, a, s, o = t;
  for (r = 0, n = o.length; r < n; r += 1) {
    if (i = o[r], s = !1, jne.call(i) !== "[object Object]") return !1;
    for (a in i)
      if (Xne.call(i, a))
        if (!s) s = !0;
        else return !1;
    if (!s) return !1;
    if (e.indexOf(a) === -1) e.push(a);
    else return !1;
  }
  return !0;
}
x(zO, "resolveYamlOmap");
function GO(t) {
  return t !== null ? t : [];
}
x(GO, "constructYamlOmap");
var Kne = new Ei("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: zO,
  construct: GO
}), Zne = Object.prototype.toString;
function VO(t) {
  if (t === null) return !0;
  var e, r, n, i, a, s = t;
  for (a = new Array(s.length), e = 0, r = s.length; e < r; e += 1) {
    if (n = s[e], Zne.call(n) !== "[object Object]" || (i = Object.keys(n), i.length !== 1)) return !1;
    a[e] = [i[0], n[i[0]]];
  }
  return !0;
}
x(VO, "resolveYamlPairs");
function UO(t) {
  if (t === null) return [];
  var e, r, n, i, a, s = t;
  for (a = new Array(s.length), e = 0, r = s.length; e < r; e += 1)
    n = s[e], i = Object.keys(n), a[e] = [i[0], n[i[0]]];
  return a;
}
x(UO, "constructYamlPairs");
var Qne = new Ei("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: VO,
  construct: UO
}), Jne = Object.prototype.hasOwnProperty;
function HO(t) {
  if (t === null) return !0;
  var e, r = t;
  for (e in r)
    if (Jne.call(r, e) && r[e] !== null)
      return !1;
  return !0;
}
x(HO, "resolveYamlSet");
function qO(t) {
  return t !== null ? t : {};
}
x(qO, "constructYamlSet");
var eie = new Ei("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: HO,
  construct: qO
}), WO = Hne.extend({
  implicit: [
    qne,
    Wne
  ],
  explicit: [
    Yne,
    Kne,
    Qne,
    eie
  ]
}), Hl = Object.prototype.hasOwnProperty, jv = 1, YO = 2, XO = 3, Kv = 4, Jb = 1, tie = 2, QC = 3, rie = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, nie = /[\x85\u2028\u2029]/, iie = /[,\[\]\{\}]/, jO = /^(?:!|!!|![a-z\-]+!)$/i, KO = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function bw(t) {
  return Object.prototype.toString.call(t);
}
x(bw, "_class");
function vs(t) {
  return t === 10 || t === 13;
}
x(vs, "is_EOL");
function $l(t) {
  return t === 9 || t === 32;
}
x($l, "is_WHITE_SPACE");
function Bi(t) {
  return t === 9 || t === 32 || t === 10 || t === 13;
}
x(Bi, "is_WS_OR_EOL");
function nu(t) {
  return t === 44 || t === 91 || t === 93 || t === 123 || t === 125;
}
x(nu, "is_FLOW_INDICATOR");
function ZO(t) {
  var e;
  return 48 <= t && t <= 57 ? t - 48 : (e = t | 32, 97 <= e && e <= 102 ? e - 97 + 10 : -1);
}
x(ZO, "fromHexCode");
function QO(t) {
  return t === 120 ? 2 : t === 117 ? 4 : t === 85 ? 8 : 0;
}
x(QO, "escapedHexLen");
function JO(t) {
  return 48 <= t && t <= 57 ? t - 48 : -1;
}
x(JO, "fromDecimalCode");
function ww(t) {
  return t === 48 ? "\0" : t === 97 ? "\x07" : t === 98 ? "\b" : t === 116 || t === 9 ? "	" : t === 110 ? `
` : t === 118 ? "\v" : t === 102 ? "\f" : t === 114 ? "\r" : t === 101 ? "\x1B" : t === 32 ? " " : t === 34 ? '"' : t === 47 ? "/" : t === 92 ? "\\" : t === 78 ? "" : t === 95 ? "" : t === 76 ? "\u2028" : t === 80 ? "\u2029" : "";
}
x(ww, "simpleEscapeSequence");
function eP(t) {
  return t <= 65535 ? String.fromCharCode(t) : String.fromCharCode(
    (t - 65536 >> 10) + 55296,
    (t - 65536 & 1023) + 56320
  );
}
x(eP, "charFromCodepoint");
var tP = new Array(256), rP = new Array(256);
for (Oc = 0; Oc < 256; Oc++)
  tP[Oc] = ww(Oc) ? 1 : 0, rP[Oc] = ww(Oc);
var Oc;
function nP(t, e) {
  this.input = t, this.filename = e.filename || null, this.schema = e.schema || WO, this.onWarning = e.onWarning || null, this.legacy = e.legacy || !1, this.json = e.json || !1, this.listener = e.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = t.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
x(nP, "State$1");
function RE(t, e) {
  var r = {
    name: t.filename,
    buffer: t.input.slice(0, -1),
    // omit trailing \0
    position: t.position,
    line: t.line,
    column: t.position - t.lineStart
  };
  return r.snippet = Rne(r), new aa(e, r);
}
x(RE, "generateError");
function Pt(t, e) {
  throw RE(t, e);
}
x(Pt, "throwError");
function mp(t, e) {
  t.onWarning && t.onWarning.call(null, RE(t, e));
}
x(mp, "throwWarning");
var JC = {
  YAML: /* @__PURE__ */ x(function(e, r, n) {
    var i, a, s;
    e.version !== null && Pt(e, "duplication of %YAML directive"), n.length !== 1 && Pt(e, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(n[0]), i === null && Pt(e, "ill-formed argument of the YAML directive"), a = parseInt(i[1], 10), s = parseInt(i[2], 10), a !== 1 && Pt(e, "unacceptable YAML version of the document"), e.version = n[0], e.checkLineBreaks = s < 2, s !== 1 && s !== 2 && mp(e, "unsupported YAML version of the document");
  }, "handleYamlDirective"),
  TAG: /* @__PURE__ */ x(function(e, r, n) {
    var i, a;
    n.length !== 2 && Pt(e, "TAG directive accepts exactly two arguments"), i = n[0], a = n[1], jO.test(i) || Pt(e, "ill-formed tag handle (first argument) of the TAG directive"), Hl.call(e.tagMap, i) && Pt(e, 'there is a previously declared suffix for "' + i + '" tag handle'), KO.test(a) || Pt(e, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      a = decodeURIComponent(a);
    } catch {
      Pt(e, "tag prefix is malformed: " + a);
    }
    e.tagMap[i] = a;
  }, "handleTagDirective")
};
function qo(t, e, r, n) {
  var i, a, s, o;
  if (e < r) {
    if (o = t.input.slice(e, r), n)
      for (i = 0, a = o.length; i < a; i += 1)
        s = o.charCodeAt(i), s === 9 || 32 <= s && s <= 1114111 || Pt(t, "expected valid JSON character");
    else rie.test(o) && Pt(t, "the stream contains non-printable characters");
    t.result += o;
  }
}
x(qo, "captureSegment");
function Tw(t, e, r, n) {
  var i, a, s, o;
  for (Bn.isObject(r) || Pt(t, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(r), s = 0, o = i.length; s < o; s += 1)
    a = i[s], Hl.call(e, a) || (e[a] = r[a], n[a] = !0);
}
x(Tw, "mergeMappings");
function iu(t, e, r, n, i, a, s, o, l) {
  var u, h;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), u = 0, h = i.length; u < h; u += 1)
      Array.isArray(i[u]) && Pt(t, "nested arrays are not supported inside keys"), typeof i == "object" && bw(i[u]) === "[object Object]" && (i[u] = "[object Object]");
  if (typeof i == "object" && bw(i) === "[object Object]" && (i = "[object Object]"), i = String(i), e === null && (e = {}), n === "tag:yaml.org,2002:merge")
    if (Array.isArray(a))
      for (u = 0, h = a.length; u < h; u += 1)
        Tw(t, e, a[u], r);
    else
      Tw(t, e, a, r);
  else
    !t.json && !Hl.call(r, i) && Hl.call(e, i) && (t.line = s || t.line, t.lineStart = o || t.lineStart, t.position = l || t.position, Pt(t, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(e, i, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: a
    }) : e[i] = a, delete r[i];
  return e;
}
x(iu, "storeMappingPair");
function V2(t) {
  var e;
  e = t.input.charCodeAt(t.position), e === 10 ? t.position++ : e === 13 ? (t.position++, t.input.charCodeAt(t.position) === 10 && t.position++) : Pt(t, "a line break is expected"), t.line += 1, t.lineStart = t.position, t.firstTabInLine = -1;
}
x(V2, "readLineBreak");
function vn(t, e, r) {
  for (var n = 0, i = t.input.charCodeAt(t.position); i !== 0; ) {
    for (; $l(i); )
      i === 9 && t.firstTabInLine === -1 && (t.firstTabInLine = t.position), i = t.input.charCodeAt(++t.position);
    if (e && i === 35)
      do
        i = t.input.charCodeAt(++t.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (vs(i))
      for (V2(t), i = t.input.charCodeAt(t.position), n++, t.lineIndent = 0; i === 32; )
        t.lineIndent++, i = t.input.charCodeAt(++t.position);
    else
      break;
  }
  return r !== -1 && n !== 0 && t.lineIndent < r && mp(t, "deficient indentation"), n;
}
x(vn, "skipSeparationSpace");
function hg(t) {
  var e = t.position, r;
  return r = t.input.charCodeAt(e), !!((r === 45 || r === 46) && r === t.input.charCodeAt(e + 1) && r === t.input.charCodeAt(e + 2) && (e += 3, r = t.input.charCodeAt(e), r === 0 || Bi(r)));
}
x(hg, "testDocumentSeparator");
function U2(t, e) {
  e === 1 ? t.result += " " : e > 1 && (t.result += Bn.repeat(`
`, e - 1));
}
x(U2, "writeFoldedLines");
function iP(t, e, r) {
  var n, i, a, s, o, l, u, h, d = t.kind, f = t.result, p;
  if (p = t.input.charCodeAt(t.position), Bi(p) || nu(p) || p === 35 || p === 38 || p === 42 || p === 33 || p === 124 || p === 62 || p === 39 || p === 34 || p === 37 || p === 64 || p === 96 || (p === 63 || p === 45) && (i = t.input.charCodeAt(t.position + 1), Bi(i) || r && nu(i)))
    return !1;
  for (t.kind = "scalar", t.result = "", a = s = t.position, o = !1; p !== 0; ) {
    if (p === 58) {
      if (i = t.input.charCodeAt(t.position + 1), Bi(i) || r && nu(i))
        break;
    } else if (p === 35) {
      if (n = t.input.charCodeAt(t.position - 1), Bi(n))
        break;
    } else {
      if (t.position === t.lineStart && hg(t) || r && nu(p))
        break;
      if (vs(p))
        if (l = t.line, u = t.lineStart, h = t.lineIndent, vn(t, !1, -1), t.lineIndent >= e) {
          o = !0, p = t.input.charCodeAt(t.position);
          continue;
        } else {
          t.position = s, t.line = l, t.lineStart = u, t.lineIndent = h;
          break;
        }
    }
    o && (qo(t, a, s, !1), U2(t, t.line - l), a = s = t.position, o = !1), $l(p) || (s = t.position + 1), p = t.input.charCodeAt(++t.position);
  }
  return qo(t, a, s, !1), t.result ? !0 : (t.kind = d, t.result = f, !1);
}
x(iP, "readPlainScalar");
function aP(t, e) {
  var r, n, i;
  if (r = t.input.charCodeAt(t.position), r !== 39)
    return !1;
  for (t.kind = "scalar", t.result = "", t.position++, n = i = t.position; (r = t.input.charCodeAt(t.position)) !== 0; )
    if (r === 39)
      if (qo(t, n, t.position, !0), r = t.input.charCodeAt(++t.position), r === 39)
        n = t.position, t.position++, i = t.position;
      else
        return !0;
    else vs(r) ? (qo(t, n, i, !0), U2(t, vn(t, !1, e)), n = i = t.position) : t.position === t.lineStart && hg(t) ? Pt(t, "unexpected end of the document within a single quoted scalar") : (t.position++, i = t.position);
  Pt(t, "unexpected end of the stream within a single quoted scalar");
}
x(aP, "readSingleQuotedScalar");
function sP(t, e) {
  var r, n, i, a, s, o;
  if (o = t.input.charCodeAt(t.position), o !== 34)
    return !1;
  for (t.kind = "scalar", t.result = "", t.position++, r = n = t.position; (o = t.input.charCodeAt(t.position)) !== 0; ) {
    if (o === 34)
      return qo(t, r, t.position, !0), t.position++, !0;
    if (o === 92) {
      if (qo(t, r, t.position, !0), o = t.input.charCodeAt(++t.position), vs(o))
        vn(t, !1, e);
      else if (o < 256 && tP[o])
        t.result += rP[o], t.position++;
      else if ((s = QO(o)) > 0) {
        for (i = s, a = 0; i > 0; i--)
          o = t.input.charCodeAt(++t.position), (s = ZO(o)) >= 0 ? a = (a << 4) + s : Pt(t, "expected hexadecimal character");
        t.result += eP(a), t.position++;
      } else
        Pt(t, "unknown escape sequence");
      r = n = t.position;
    } else vs(o) ? (qo(t, r, n, !0), U2(t, vn(t, !1, e)), r = n = t.position) : t.position === t.lineStart && hg(t) ? Pt(t, "unexpected end of the document within a double quoted scalar") : (t.position++, n = t.position);
  }
  Pt(t, "unexpected end of the stream within a double quoted scalar");
}
x(sP, "readDoubleQuotedScalar");
function oP(t, e) {
  var r = !0, n, i, a, s = t.tag, o, l = t.anchor, u, h, d, f, p, g = /* @__PURE__ */ Object.create(null), m, v, y, b;
  if (b = t.input.charCodeAt(t.position), b === 91)
    h = 93, p = !1, o = [];
  else if (b === 123)
    h = 125, p = !0, o = {};
  else
    return !1;
  for (t.anchor !== null && (t.anchorMap[t.anchor] = o), b = t.input.charCodeAt(++t.position); b !== 0; ) {
    if (vn(t, !0, e), b = t.input.charCodeAt(t.position), b === h)
      return t.position++, t.tag = s, t.anchor = l, t.kind = p ? "mapping" : "sequence", t.result = o, !0;
    r ? b === 44 && Pt(t, "expected the node content, but found ','") : Pt(t, "missed comma between flow collection entries"), v = m = y = null, d = f = !1, b === 63 && (u = t.input.charCodeAt(t.position + 1), Bi(u) && (d = f = !0, t.position++, vn(t, !0, e))), n = t.line, i = t.lineStart, a = t.position, xu(t, e, jv, !1, !0), v = t.tag, m = t.result, vn(t, !0, e), b = t.input.charCodeAt(t.position), (f || t.line === n) && b === 58 && (d = !0, b = t.input.charCodeAt(++t.position), vn(t, !0, e), xu(t, e, jv, !1, !0), y = t.result), p ? iu(t, o, g, v, m, y, n, i, a) : d ? o.push(iu(t, null, g, v, m, y, n, i, a)) : o.push(m), vn(t, !0, e), b = t.input.charCodeAt(t.position), b === 44 ? (r = !0, b = t.input.charCodeAt(++t.position)) : r = !1;
  }
  Pt(t, "unexpected end of the stream within a flow collection");
}
x(oP, "readFlowCollection");
function lP(t, e) {
  var r, n, i = Jb, a = !1, s = !1, o = e, l = 0, u = !1, h, d;
  if (d = t.input.charCodeAt(t.position), d === 124)
    n = !1;
  else if (d === 62)
    n = !0;
  else
    return !1;
  for (t.kind = "scalar", t.result = ""; d !== 0; )
    if (d = t.input.charCodeAt(++t.position), d === 43 || d === 45)
      Jb === i ? i = d === 43 ? QC : tie : Pt(t, "repeat of a chomping mode identifier");
    else if ((h = JO(d)) >= 0)
      h === 0 ? Pt(t, "bad explicit indentation width of a block scalar; it cannot be less than one") : s ? Pt(t, "repeat of an indentation width identifier") : (o = e + h - 1, s = !0);
    else
      break;
  if ($l(d)) {
    do
      d = t.input.charCodeAt(++t.position);
    while ($l(d));
    if (d === 35)
      do
        d = t.input.charCodeAt(++t.position);
      while (!vs(d) && d !== 0);
  }
  for (; d !== 0; ) {
    for (V2(t), t.lineIndent = 0, d = t.input.charCodeAt(t.position); (!s || t.lineIndent < o) && d === 32; )
      t.lineIndent++, d = t.input.charCodeAt(++t.position);
    if (!s && t.lineIndent > o && (o = t.lineIndent), vs(d)) {
      l++;
      continue;
    }
    if (t.lineIndent < o) {
      i === QC ? t.result += Bn.repeat(`
`, a ? 1 + l : l) : i === Jb && a && (t.result += `
`);
      break;
    }
    for (n ? $l(d) ? (u = !0, t.result += Bn.repeat(`
`, a ? 1 + l : l)) : u ? (u = !1, t.result += Bn.repeat(`
`, l + 1)) : l === 0 ? a && (t.result += " ") : t.result += Bn.repeat(`
`, l) : t.result += Bn.repeat(`
`, a ? 1 + l : l), a = !0, s = !0, l = 0, r = t.position; !vs(d) && d !== 0; )
      d = t.input.charCodeAt(++t.position);
    qo(t, r, t.position, !1);
  }
  return !0;
}
x(lP, "readBlockScalar");
function Ew(t, e) {
  var r, n = t.tag, i = t.anchor, a = [], s, o = !1, l;
  if (t.firstTabInLine !== -1) return !1;
  for (t.anchor !== null && (t.anchorMap[t.anchor] = a), l = t.input.charCodeAt(t.position); l !== 0 && (t.firstTabInLine !== -1 && (t.position = t.firstTabInLine, Pt(t, "tab characters must not be used in indentation")), !(l !== 45 || (s = t.input.charCodeAt(t.position + 1), !Bi(s)))); ) {
    if (o = !0, t.position++, vn(t, !0, -1) && t.lineIndent <= e) {
      a.push(null), l = t.input.charCodeAt(t.position);
      continue;
    }
    if (r = t.line, xu(t, e, XO, !1, !0), a.push(t.result), vn(t, !0, -1), l = t.input.charCodeAt(t.position), (t.line === r || t.lineIndent > e) && l !== 0)
      Pt(t, "bad indentation of a sequence entry");
    else if (t.lineIndent < e)
      break;
  }
  return o ? (t.tag = n, t.anchor = i, t.kind = "sequence", t.result = a, !0) : !1;
}
x(Ew, "readBlockSequence");
function cP(t, e, r) {
  var n, i, a, s, o, l, u = t.tag, h = t.anchor, d = {}, f = /* @__PURE__ */ Object.create(null), p = null, g = null, m = null, v = !1, y = !1, b;
  if (t.firstTabInLine !== -1) return !1;
  for (t.anchor !== null && (t.anchorMap[t.anchor] = d), b = t.input.charCodeAt(t.position); b !== 0; ) {
    if (!v && t.firstTabInLine !== -1 && (t.position = t.firstTabInLine, Pt(t, "tab characters must not be used in indentation")), n = t.input.charCodeAt(t.position + 1), a = t.line, (b === 63 || b === 58) && Bi(n))
      b === 63 ? (v && (iu(t, d, f, p, g, null, s, o, l), p = g = m = null), y = !0, v = !0, i = !0) : v ? (v = !1, i = !0) : Pt(t, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), t.position += 1, b = n;
    else {
      if (s = t.line, o = t.lineStart, l = t.position, !xu(t, r, YO, !1, !0))
        break;
      if (t.line === a) {
        for (b = t.input.charCodeAt(t.position); $l(b); )
          b = t.input.charCodeAt(++t.position);
        if (b === 58)
          b = t.input.charCodeAt(++t.position), Bi(b) || Pt(t, "a whitespace character is expected after the key-value separator within a block mapping"), v && (iu(t, d, f, p, g, null, s, o, l), p = g = m = null), y = !0, v = !1, i = !1, p = t.tag, g = t.result;
        else if (y)
          Pt(t, "can not read an implicit mapping pair; a colon is missed");
        else
          return t.tag = u, t.anchor = h, !0;
      } else if (y)
        Pt(t, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return t.tag = u, t.anchor = h, !0;
    }
    if ((t.line === a || t.lineIndent > e) && (v && (s = t.line, o = t.lineStart, l = t.position), xu(t, e, Kv, !0, i) && (v ? g = t.result : m = t.result), v || (iu(t, d, f, p, g, m, s, o, l), p = g = m = null), vn(t, !0, -1), b = t.input.charCodeAt(t.position)), (t.line === a || t.lineIndent > e) && b !== 0)
      Pt(t, "bad indentation of a mapping entry");
    else if (t.lineIndent < e)
      break;
  }
  return v && iu(t, d, f, p, g, null, s, o, l), y && (t.tag = u, t.anchor = h, t.kind = "mapping", t.result = d), y;
}
x(cP, "readBlockMapping");
function uP(t) {
  var e, r = !1, n = !1, i, a, s;
  if (s = t.input.charCodeAt(t.position), s !== 33) return !1;
  if (t.tag !== null && Pt(t, "duplication of a tag property"), s = t.input.charCodeAt(++t.position), s === 60 ? (r = !0, s = t.input.charCodeAt(++t.position)) : s === 33 ? (n = !0, i = "!!", s = t.input.charCodeAt(++t.position)) : i = "!", e = t.position, r) {
    do
      s = t.input.charCodeAt(++t.position);
    while (s !== 0 && s !== 62);
    t.position < t.length ? (a = t.input.slice(e, t.position), s = t.input.charCodeAt(++t.position)) : Pt(t, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; s !== 0 && !Bi(s); )
      s === 33 && (n ? Pt(t, "tag suffix cannot contain exclamation marks") : (i = t.input.slice(e - 1, t.position + 1), jO.test(i) || Pt(t, "named tag handle cannot contain such characters"), n = !0, e = t.position + 1)), s = t.input.charCodeAt(++t.position);
    a = t.input.slice(e, t.position), iie.test(a) && Pt(t, "tag suffix cannot contain flow indicator characters");
  }
  a && !KO.test(a) && Pt(t, "tag name cannot contain such characters: " + a);
  try {
    a = decodeURIComponent(a);
  } catch {
    Pt(t, "tag name is malformed: " + a);
  }
  return r ? t.tag = a : Hl.call(t.tagMap, i) ? t.tag = t.tagMap[i] + a : i === "!" ? t.tag = "!" + a : i === "!!" ? t.tag = "tag:yaml.org,2002:" + a : Pt(t, 'undeclared tag handle "' + i + '"'), !0;
}
x(uP, "readTagProperty");
function hP(t) {
  var e, r;
  if (r = t.input.charCodeAt(t.position), r !== 38) return !1;
  for (t.anchor !== null && Pt(t, "duplication of an anchor property"), r = t.input.charCodeAt(++t.position), e = t.position; r !== 0 && !Bi(r) && !nu(r); )
    r = t.input.charCodeAt(++t.position);
  return t.position === e && Pt(t, "name of an anchor node must contain at least one character"), t.anchor = t.input.slice(e, t.position), !0;
}
x(hP, "readAnchorProperty");
function dP(t) {
  var e, r, n;
  if (n = t.input.charCodeAt(t.position), n !== 42) return !1;
  for (n = t.input.charCodeAt(++t.position), e = t.position; n !== 0 && !Bi(n) && !nu(n); )
    n = t.input.charCodeAt(++t.position);
  return t.position === e && Pt(t, "name of an alias node must contain at least one character"), r = t.input.slice(e, t.position), Hl.call(t.anchorMap, r) || Pt(t, 'unidentified alias "' + r + '"'), t.result = t.anchorMap[r], vn(t, !0, -1), !0;
}
x(dP, "readAlias");
function xu(t, e, r, n, i) {
  var a, s, o, l = 1, u = !1, h = !1, d, f, p, g, m, v;
  if (t.listener !== null && t.listener("open", t), t.tag = null, t.anchor = null, t.kind = null, t.result = null, a = s = o = Kv === r || XO === r, n && vn(t, !0, -1) && (u = !0, t.lineIndent > e ? l = 1 : t.lineIndent === e ? l = 0 : t.lineIndent < e && (l = -1)), l === 1)
    for (; uP(t) || hP(t); )
      vn(t, !0, -1) ? (u = !0, o = a, t.lineIndent > e ? l = 1 : t.lineIndent === e ? l = 0 : t.lineIndent < e && (l = -1)) : o = !1;
  if (o && (o = u || i), (l === 1 || Kv === r) && (jv === r || YO === r ? m = e : m = e + 1, v = t.position - t.lineStart, l === 1 ? o && (Ew(t, v) || cP(t, v, m)) || oP(t, m) ? h = !0 : (s && lP(t, m) || aP(t, m) || sP(t, m) ? h = !0 : dP(t) ? (h = !0, (t.tag !== null || t.anchor !== null) && Pt(t, "alias node should not have any properties")) : iP(t, m, jv === r) && (h = !0, t.tag === null && (t.tag = "?")), t.anchor !== null && (t.anchorMap[t.anchor] = t.result)) : l === 0 && (h = o && Ew(t, v))), t.tag === null)
    t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
  else if (t.tag === "?") {
    for (t.result !== null && t.kind !== "scalar" && Pt(t, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + t.kind + '"'), d = 0, f = t.implicitTypes.length; d < f; d += 1)
      if (g = t.implicitTypes[d], g.resolve(t.result)) {
        t.result = g.construct(t.result), t.tag = g.tag, t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
        break;
      }
  } else if (t.tag !== "!") {
    if (Hl.call(t.typeMap[t.kind || "fallback"], t.tag))
      g = t.typeMap[t.kind || "fallback"][t.tag];
    else
      for (g = null, p = t.typeMap.multi[t.kind || "fallback"], d = 0, f = p.length; d < f; d += 1)
        if (t.tag.slice(0, p[d].tag.length) === p[d].tag) {
          g = p[d];
          break;
        }
    g || Pt(t, "unknown tag !<" + t.tag + ">"), t.result !== null && g.kind !== t.kind && Pt(t, "unacceptable node kind for !<" + t.tag + '> tag; it should be "' + g.kind + '", not "' + t.kind + '"'), g.resolve(t.result, t.tag) ? (t.result = g.construct(t.result, t.tag), t.anchor !== null && (t.anchorMap[t.anchor] = t.result)) : Pt(t, "cannot resolve a node with !<" + t.tag + "> explicit tag");
  }
  return t.listener !== null && t.listener("close", t), t.tag !== null || t.anchor !== null || h;
}
x(xu, "composeNode");
function fP(t) {
  var e = t.position, r, n, i, a = !1, s;
  for (t.version = null, t.checkLineBreaks = t.legacy, t.tagMap = /* @__PURE__ */ Object.create(null), t.anchorMap = /* @__PURE__ */ Object.create(null); (s = t.input.charCodeAt(t.position)) !== 0 && (vn(t, !0, -1), s = t.input.charCodeAt(t.position), !(t.lineIndent > 0 || s !== 37)); ) {
    for (a = !0, s = t.input.charCodeAt(++t.position), r = t.position; s !== 0 && !Bi(s); )
      s = t.input.charCodeAt(++t.position);
    for (n = t.input.slice(r, t.position), i = [], n.length < 1 && Pt(t, "directive name must not be less than one character in length"); s !== 0; ) {
      for (; $l(s); )
        s = t.input.charCodeAt(++t.position);
      if (s === 35) {
        do
          s = t.input.charCodeAt(++t.position);
        while (s !== 0 && !vs(s));
        break;
      }
      if (vs(s)) break;
      for (r = t.position; s !== 0 && !Bi(s); )
        s = t.input.charCodeAt(++t.position);
      i.push(t.input.slice(r, t.position));
    }
    s !== 0 && V2(t), Hl.call(JC, n) ? JC[n](t, n, i) : mp(t, 'unknown document directive "' + n + '"');
  }
  if (vn(t, !0, -1), t.lineIndent === 0 && t.input.charCodeAt(t.position) === 45 && t.input.charCodeAt(t.position + 1) === 45 && t.input.charCodeAt(t.position + 2) === 45 ? (t.position += 3, vn(t, !0, -1)) : a && Pt(t, "directives end mark is expected"), xu(t, t.lineIndent - 1, Kv, !1, !0), vn(t, !0, -1), t.checkLineBreaks && nie.test(t.input.slice(e, t.position)) && mp(t, "non-ASCII line breaks are interpreted as content"), t.documents.push(t.result), t.position === t.lineStart && hg(t)) {
    t.input.charCodeAt(t.position) === 46 && (t.position += 3, vn(t, !0, -1));
    return;
  }
  if (t.position < t.length - 1)
    Pt(t, "end of the stream or a document separator is expected");
  else
    return;
}
x(fP, "readDocument");
function ME(t, e) {
  t = String(t), e = e || {}, t.length !== 0 && (t.charCodeAt(t.length - 1) !== 10 && t.charCodeAt(t.length - 1) !== 13 && (t += `
`), t.charCodeAt(0) === 65279 && (t = t.slice(1)));
  var r = new nP(t, e), n = t.indexOf("\0");
  for (n !== -1 && (r.position = n, Pt(r, "null byte is not allowed in input")), r.input += "\0"; r.input.charCodeAt(r.position) === 32; )
    r.lineIndent += 1, r.position += 1;
  for (; r.position < r.length - 1; )
    fP(r);
  return r.documents;
}
x(ME, "loadDocuments");
function aie(t, e, r) {
  e !== null && typeof e == "object" && typeof r > "u" && (r = e, e = null);
  var n = ME(t, r);
  if (typeof e != "function")
    return n;
  for (var i = 0, a = n.length; i < a; i += 1)
    e(n[i]);
}
x(aie, "loadAll$1");
function pP(t, e) {
  var r = ME(t, e);
  if (r.length !== 0) {
    if (r.length === 1)
      return r[0];
    throw new aa("expected a single document in the stream, but found more");
  }
}
x(pP, "load$1");
var sie = pP, oie = {
  load: sie
}, gP = Object.prototype.toString, mP = Object.prototype.hasOwnProperty, NE = 65279, lie = 9, vp = 10, cie = 13, uie = 32, hie = 33, die = 34, kw = 35, fie = 37, pie = 38, gie = 39, mie = 42, vP = 44, vie = 45, Zv = 58, yie = 61, xie = 62, bie = 63, wie = 64, yP = 91, xP = 93, Tie = 96, bP = 123, Eie = 124, wP = 125, _i = {};
_i[0] = "\\0";
_i[7] = "\\a";
_i[8] = "\\b";
_i[9] = "\\t";
_i[10] = "\\n";
_i[11] = "\\v";
_i[12] = "\\f";
_i[13] = "\\r";
_i[27] = "\\e";
_i[34] = '\\"';
_i[92] = "\\\\";
_i[133] = "\\N";
_i[160] = "\\_";
_i[8232] = "\\L";
_i[8233] = "\\P";
var kie = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
], Sie = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function TP(t, e) {
  var r, n, i, a, s, o, l;
  if (e === null) return {};
  for (r = {}, n = Object.keys(e), i = 0, a = n.length; i < a; i += 1)
    s = n[i], o = String(e[s]), s.slice(0, 2) === "!!" && (s = "tag:yaml.org,2002:" + s.slice(2)), l = t.compiledTypeMap.fallback[s], l && mP.call(l.styleAliases, o) && (o = l.styleAliases[o]), r[s] = o;
  return r;
}
x(TP, "compileStyleMap");
function EP(t) {
  var e, r, n;
  if (e = t.toString(16).toUpperCase(), t <= 255)
    r = "x", n = 2;
  else if (t <= 65535)
    r = "u", n = 4;
  else if (t <= 4294967295)
    r = "U", n = 8;
  else
    throw new aa("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + r + Bn.repeat("0", n - e.length) + e;
}
x(EP, "encodeHex");
var Cie = 1, yp = 2;
function kP(t) {
  this.schema = t.schema || WO, this.indent = Math.max(1, t.indent || 2), this.noArrayIndent = t.noArrayIndent || !1, this.skipInvalid = t.skipInvalid || !1, this.flowLevel = Bn.isNothing(t.flowLevel) ? -1 : t.flowLevel, this.styleMap = TP(this.schema, t.styles || null), this.sortKeys = t.sortKeys || !1, this.lineWidth = t.lineWidth || 80, this.noRefs = t.noRefs || !1, this.noCompatMode = t.noCompatMode || !1, this.condenseFlow = t.condenseFlow || !1, this.quotingType = t.quotingType === '"' ? yp : Cie, this.forceQuotes = t.forceQuotes || !1, this.replacer = typeof t.replacer == "function" ? t.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
x(kP, "State");
function Sw(t, e) {
  for (var r = Bn.repeat(" ", e), n = 0, i = -1, a = "", s, o = t.length; n < o; )
    i = t.indexOf(`
`, n), i === -1 ? (s = t.slice(n), n = o) : (s = t.slice(n, i + 1), n = i + 1), s.length && s !== `
` && (a += r), a += s;
  return a;
}
x(Sw, "indentString");
function Qv(t, e) {
  return `
` + Bn.repeat(" ", t.indent * e);
}
x(Qv, "generateNextLine");
function SP(t, e) {
  var r, n, i;
  for (r = 0, n = t.implicitTypes.length; r < n; r += 1)
    if (i = t.implicitTypes[r], i.resolve(e))
      return !0;
  return !1;
}
x(SP, "testImplicitResolving");
function xp(t) {
  return t === uie || t === lie;
}
x(xp, "isWhitespace");
function bd(t) {
  return 32 <= t && t <= 126 || 161 <= t && t <= 55295 && t !== 8232 && t !== 8233 || 57344 <= t && t <= 65533 && t !== NE || 65536 <= t && t <= 1114111;
}
x(bd, "isPrintable");
function Cw(t) {
  return bd(t) && t !== NE && t !== cie && t !== vp;
}
x(Cw, "isNsCharOrWhitespace");
function Aw(t, e, r) {
  var n = Cw(t), i = n && !xp(t);
  return (
    // ns-plain-safe
    (r ? (
      // c = flow-in
      n
    ) : n && t !== vP && t !== yP && t !== xP && t !== bP && t !== wP) && t !== kw && !(e === Zv && !i) || Cw(e) && !xp(e) && t === kw || e === Zv && i
  );
}
x(Aw, "isPlainSafe");
function CP(t) {
  return bd(t) && t !== NE && !xp(t) && t !== vie && t !== bie && t !== Zv && t !== vP && t !== yP && t !== xP && t !== bP && t !== wP && t !== kw && t !== pie && t !== mie && t !== hie && t !== Eie && t !== yie && t !== xie && t !== gie && t !== die && t !== fie && t !== wie && t !== Tie;
}
x(CP, "isPlainSafeFirst");
function AP(t) {
  return !xp(t) && t !== Zv;
}
x(AP, "isPlainSafeLast");
function $h(t, e) {
  var r = t.charCodeAt(e), n;
  return r >= 55296 && r <= 56319 && e + 1 < t.length && (n = t.charCodeAt(e + 1), n >= 56320 && n <= 57343) ? (r - 55296) * 1024 + n - 56320 + 65536 : r;
}
x($h, "codePointAt");
function IE(t) {
  var e = /^\n* /;
  return e.test(t);
}
x(IE, "needIndentIndicator");
var _P = 1, _w = 2, LP = 3, RP = 4, Rh = 5;
function MP(t, e, r, n, i, a, s, o) {
  var l, u = 0, h = null, d = !1, f = !1, p = n !== -1, g = -1, m = CP($h(t, 0)) && AP($h(t, t.length - 1));
  if (e || s)
    for (l = 0; l < t.length; u >= 65536 ? l += 2 : l++) {
      if (u = $h(t, l), !bd(u))
        return Rh;
      m = m && Aw(u, h, o), h = u;
    }
  else {
    for (l = 0; l < t.length; u >= 65536 ? l += 2 : l++) {
      if (u = $h(t, l), u === vp)
        d = !0, p && (f = f || // Foldable line = too long, and not more-indented.
        l - g - 1 > n && t[g + 1] !== " ", g = l);
      else if (!bd(u))
        return Rh;
      m = m && Aw(u, h, o), h = u;
    }
    f = f || p && l - g - 1 > n && t[g + 1] !== " ";
  }
  return !d && !f ? m && !s && !i(t) ? _P : a === yp ? Rh : _w : r > 9 && IE(t) ? Rh : s ? a === yp ? Rh : _w : f ? RP : LP;
}
x(MP, "chooseScalarStyle");
function NP(t, e, r, n, i) {
  t.dump = (function() {
    if (e.length === 0)
      return t.quotingType === yp ? '""' : "''";
    if (!t.noCompatMode && (kie.indexOf(e) !== -1 || Sie.test(e)))
      return t.quotingType === yp ? '"' + e + '"' : "'" + e + "'";
    var a = t.indent * Math.max(1, r), s = t.lineWidth === -1 ? -1 : Math.max(Math.min(t.lineWidth, 40), t.lineWidth - a), o = n || t.flowLevel > -1 && r >= t.flowLevel;
    function l(u) {
      return SP(t, u);
    }
    switch (x(l, "testAmbiguity"), MP(
      e,
      o,
      t.indent,
      s,
      l,
      t.quotingType,
      t.forceQuotes && !n,
      i
    )) {
      case _P:
        return e;
      case _w:
        return "'" + e.replace(/'/g, "''") + "'";
      case LP:
        return "|" + Lw(e, t.indent) + Rw(Sw(e, a));
      case RP:
        return ">" + Lw(e, t.indent) + Rw(Sw(IP(e, s), a));
      case Rh:
        return '"' + DP(e) + '"';
      default:
        throw new aa("impossible error: invalid scalar style");
    }
  })();
}
x(NP, "writeScalar");
function Lw(t, e) {
  var r = IE(t) ? String(e) : "", n = t[t.length - 1] === `
`, i = n && (t[t.length - 2] === `
` || t === `
`), a = i ? "+" : n ? "" : "-";
  return r + a + `
`;
}
x(Lw, "blockHeader");
function Rw(t) {
  return t[t.length - 1] === `
` ? t.slice(0, -1) : t;
}
x(Rw, "dropEndingNewline");
function IP(t, e) {
  for (var r = /(\n+)([^\n]*)/g, n = (function() {
    var u = t.indexOf(`
`);
    return u = u !== -1 ? u : t.length, r.lastIndex = u, Mw(t.slice(0, u), e);
  })(), i = t[0] === `
` || t[0] === " ", a, s; s = r.exec(t); ) {
    var o = s[1], l = s[2];
    a = l[0] === " ", n += o + (!i && !a && l !== "" ? `
` : "") + Mw(l, e), i = a;
  }
  return n;
}
x(IP, "foldString");
function Mw(t, e) {
  if (t === "" || t[0] === " ") return t;
  for (var r = / [^ ]/g, n, i = 0, a, s = 0, o = 0, l = ""; n = r.exec(t); )
    o = n.index, o - i > e && (a = s > i ? s : o, l += `
` + t.slice(i, a), i = a + 1), s = o;
  return l += `
`, t.length - i > e && s > i ? l += t.slice(i, s) + `
` + t.slice(s + 1) : l += t.slice(i), l.slice(1);
}
x(Mw, "foldLine");
function DP(t) {
  for (var e = "", r = 0, n, i = 0; i < t.length; r >= 65536 ? i += 2 : i++)
    r = $h(t, i), n = _i[r], !n && bd(r) ? (e += t[i], r >= 65536 && (e += t[i + 1])) : e += n || EP(r);
  return e;
}
x(DP, "escapeString");
function OP(t, e, r) {
  var n = "", i = t.tag, a, s, o;
  for (a = 0, s = r.length; a < s; a += 1)
    o = r[a], t.replacer && (o = t.replacer.call(r, String(a), o)), (no(t, e, o, !1, !1) || typeof o > "u" && no(t, e, null, !1, !1)) && (n !== "" && (n += "," + (t.condenseFlow ? "" : " ")), n += t.dump);
  t.tag = i, t.dump = "[" + n + "]";
}
x(OP, "writeFlowSequence");
function Nw(t, e, r, n) {
  var i = "", a = t.tag, s, o, l;
  for (s = 0, o = r.length; s < o; s += 1)
    l = r[s], t.replacer && (l = t.replacer.call(r, String(s), l)), (no(t, e + 1, l, !0, !0, !1, !0) || typeof l > "u" && no(t, e + 1, null, !0, !0, !1, !0)) && ((!n || i !== "") && (i += Qv(t, e)), t.dump && vp === t.dump.charCodeAt(0) ? i += "-" : i += "- ", i += t.dump);
  t.tag = a, t.dump = i || "[]";
}
x(Nw, "writeBlockSequence");
function PP(t, e, r) {
  var n = "", i = t.tag, a = Object.keys(r), s, o, l, u, h;
  for (s = 0, o = a.length; s < o; s += 1)
    h = "", n !== "" && (h += ", "), t.condenseFlow && (h += '"'), l = a[s], u = r[l], t.replacer && (u = t.replacer.call(r, l, u)), no(t, e, l, !1, !1) && (t.dump.length > 1024 && (h += "? "), h += t.dump + (t.condenseFlow ? '"' : "") + ":" + (t.condenseFlow ? "" : " "), no(t, e, u, !1, !1) && (h += t.dump, n += h));
  t.tag = i, t.dump = "{" + n + "}";
}
x(PP, "writeFlowMapping");
function BP(t, e, r, n) {
  var i = "", a = t.tag, s = Object.keys(r), o, l, u, h, d, f;
  if (t.sortKeys === !0)
    s.sort();
  else if (typeof t.sortKeys == "function")
    s.sort(t.sortKeys);
  else if (t.sortKeys)
    throw new aa("sortKeys must be a boolean or a function");
  for (o = 0, l = s.length; o < l; o += 1)
    f = "", (!n || i !== "") && (f += Qv(t, e)), u = s[o], h = r[u], t.replacer && (h = t.replacer.call(r, u, h)), no(t, e + 1, u, !0, !0, !0) && (d = t.tag !== null && t.tag !== "?" || t.dump && t.dump.length > 1024, d && (t.dump && vp === t.dump.charCodeAt(0) ? f += "?" : f += "? "), f += t.dump, d && (f += Qv(t, e)), no(t, e + 1, h, !0, d) && (t.dump && vp === t.dump.charCodeAt(0) ? f += ":" : f += ": ", f += t.dump, i += f));
  t.tag = a, t.dump = i || "{}";
}
x(BP, "writeBlockMapping");
function Iw(t, e, r) {
  var n, i, a, s, o, l;
  for (i = r ? t.explicitTypes : t.implicitTypes, a = 0, s = i.length; a < s; a += 1)
    if (o = i[a], (o.instanceOf || o.predicate) && (!o.instanceOf || typeof e == "object" && e instanceof o.instanceOf) && (!o.predicate || o.predicate(e))) {
      if (r ? o.multi && o.representName ? t.tag = o.representName(e) : t.tag = o.tag : t.tag = "?", o.represent) {
        if (l = t.styleMap[o.tag] || o.defaultStyle, gP.call(o.represent) === "[object Function]")
          n = o.represent(e, l);
        else if (mP.call(o.represent, l))
          n = o.represent[l](e, l);
        else
          throw new aa("!<" + o.tag + '> tag resolver accepts not "' + l + '" style');
        t.dump = n;
      }
      return !0;
    }
  return !1;
}
x(Iw, "detectType");
function no(t, e, r, n, i, a, s) {
  t.tag = null, t.dump = r, Iw(t, r, !1) || Iw(t, r, !0);
  var o = gP.call(t.dump), l = n, u;
  n && (n = t.flowLevel < 0 || t.flowLevel > e);
  var h = o === "[object Object]" || o === "[object Array]", d, f;
  if (h && (d = t.duplicates.indexOf(r), f = d !== -1), (t.tag !== null && t.tag !== "?" || f || t.indent !== 2 && e > 0) && (i = !1), f && t.usedDuplicates[d])
    t.dump = "*ref_" + d;
  else {
    if (h && f && !t.usedDuplicates[d] && (t.usedDuplicates[d] = !0), o === "[object Object]")
      n && Object.keys(t.dump).length !== 0 ? (BP(t, e, t.dump, i), f && (t.dump = "&ref_" + d + t.dump)) : (PP(t, e, t.dump), f && (t.dump = "&ref_" + d + " " + t.dump));
    else if (o === "[object Array]")
      n && t.dump.length !== 0 ? (t.noArrayIndent && !s && e > 0 ? Nw(t, e - 1, t.dump, i) : Nw(t, e, t.dump, i), f && (t.dump = "&ref_" + d + t.dump)) : (OP(t, e, t.dump), f && (t.dump = "&ref_" + d + " " + t.dump));
    else if (o === "[object String]")
      t.tag !== "?" && NP(t, t.dump, e, a, l);
    else {
      if (o === "[object Undefined]")
        return !1;
      if (t.skipInvalid) return !1;
      throw new aa("unacceptable kind of an object to dump " + o);
    }
    t.tag !== null && t.tag !== "?" && (u = encodeURI(
      t.tag[0] === "!" ? t.tag.slice(1) : t.tag
    ).replace(/!/g, "%21"), t.tag[0] === "!" ? u = "!" + u : u.slice(0, 18) === "tag:yaml.org,2002:" ? u = "!!" + u.slice(18) : u = "!<" + u + ">", t.dump = u + " " + t.dump);
  }
  return !0;
}
x(no, "writeNode");
function FP(t, e) {
  var r = [], n = [], i, a;
  for (Jv(t, r, n), i = 0, a = n.length; i < a; i += 1)
    e.duplicates.push(r[n[i]]);
  e.usedDuplicates = new Array(a);
}
x(FP, "getDuplicateReferences");
function Jv(t, e, r) {
  var n, i, a;
  if (t !== null && typeof t == "object")
    if (i = e.indexOf(t), i !== -1)
      r.indexOf(i) === -1 && r.push(i);
    else if (e.push(t), Array.isArray(t))
      for (i = 0, a = t.length; i < a; i += 1)
        Jv(t[i], e, r);
    else
      for (n = Object.keys(t), i = 0, a = n.length; i < a; i += 1)
        Jv(t[n[i]], e, r);
}
x(Jv, "inspectNode");
function Aie(t, e) {
  e = e || {};
  var r = new kP(e);
  r.noRefs || FP(t, r);
  var n = t;
  return r.replacer && (n = r.replacer.call({ "": n }, "", n)), no(r, 0, n, !0, !0) ? r.dump + `
` : "";
}
x(Aie, "dump$1");
function _ie(t, e) {
  return function() {
    throw new Error("Function yaml." + t + " is removed in js-yaml 4. Use yaml." + e + " instead, which is now safe by default.");
  };
}
x(_ie, "renamed");
var H2 = LO, q2 = oie.load;
var xi = {
  aggregation: 17.25,
  extension: 17.25,
  composition: 17.25,
  dependency: 6,
  lollipop: 13.5,
  arrow_point: 4
  //arrow_cross: 24,
}, e8 = {
  arrow_point: 9,
  arrow_cross: 12.5,
  arrow_circle: 12.5
};
function Yf(t, e) {
  if (t === void 0 || e === void 0)
    return { angle: 0, deltaX: 0, deltaY: 0 };
  t = jr(t), e = jr(e);
  const [r, n] = [t.x, t.y], [i, a] = [e.x, e.y], s = i - r, o = a - n;
  return { angle: Math.atan(o / s), deltaX: s, deltaY: o };
}
x(Yf, "calculateDeltaAndAngle");
var jr = /* @__PURE__ */ x((t) => Array.isArray(t) ? { x: t[0], y: t[1] } : t, "pointTransformer"), $P = /* @__PURE__ */ x((t) => ({
  x: /* @__PURE__ */ x(function(e, r, n) {
    let i = 0;
    const a = jr(n[0]).x < jr(n[n.length - 1]).x ? "left" : "right";
    if (r === 0 && Object.hasOwn(xi, t.arrowTypeStart)) {
      const { angle: p, deltaX: g } = Yf(n[0], n[1]);
      i = xi[t.arrowTypeStart] * Math.cos(p) * (g >= 0 ? 1 : -1);
    } else if (r === n.length - 1 && Object.hasOwn(xi, t.arrowTypeEnd)) {
      const { angle: p, deltaX: g } = Yf(
        n[n.length - 1],
        n[n.length - 2]
      );
      i = xi[t.arrowTypeEnd] * Math.cos(p) * (g >= 0 ? 1 : -1);
    }
    const s = Math.abs(
      jr(e).x - jr(n[n.length - 1]).x
    ), o = Math.abs(
      jr(e).y - jr(n[n.length - 1]).y
    ), l = Math.abs(jr(e).x - jr(n[0]).x), u = Math.abs(jr(e).y - jr(n[0]).y), h = xi[t.arrowTypeStart], d = xi[t.arrowTypeEnd], f = 1;
    if (s < d && s > 0 && o < d) {
      let p = d + f - s;
      p *= a === "right" ? -1 : 1, i -= p;
    }
    if (l < h && l > 0 && u < h) {
      let p = h + f - l;
      p *= a === "right" ? -1 : 1, i += p;
    }
    return jr(e).x + i;
  }, "x"),
  y: /* @__PURE__ */ x(function(e, r, n) {
    let i = 0;
    const a = jr(n[0]).y < jr(n[n.length - 1]).y ? "down" : "up";
    if (r === 0 && Object.hasOwn(xi, t.arrowTypeStart)) {
      const { angle: p, deltaY: g } = Yf(n[0], n[1]);
      i = xi[t.arrowTypeStart] * Math.abs(Math.sin(p)) * (g >= 0 ? 1 : -1);
    } else if (r === n.length - 1 && Object.hasOwn(xi, t.arrowTypeEnd)) {
      const { angle: p, deltaY: g } = Yf(
        n[n.length - 1],
        n[n.length - 2]
      );
      i = xi[t.arrowTypeEnd] * Math.abs(Math.sin(p)) * (g >= 0 ? 1 : -1);
    }
    const s = Math.abs(
      jr(e).y - jr(n[n.length - 1]).y
    ), o = Math.abs(
      jr(e).x - jr(n[n.length - 1]).x
    ), l = Math.abs(jr(e).y - jr(n[0]).y), u = Math.abs(jr(e).x - jr(n[0]).x), h = xi[t.arrowTypeStart], d = xi[t.arrowTypeEnd], f = 1;
    if (s < d && s > 0 && o < d) {
      let p = d + f - s;
      p *= a === "up" ? -1 : 1, i -= p;
    }
    if (l < h && l > 0 && u < h) {
      let p = h + f - l;
      p *= a === "up" ? -1 : 1, i += p;
    }
    return jr(e).y + i;
  }, "y")
}), "getLineFunctionsWithOffset"), dg = /* @__PURE__ */ x(({
  flowchart: t
}) => {
  const e = t?.subGraphTitleMargin?.top ?? 0, r = t?.subGraphTitleMargin?.bottom ?? 0, n = e + r;
  return {
    subGraphTitleTopMargin: e,
    subGraphTitleBottomMargin: r,
    subGraphTitleTotalMargin: n
  };
}, "getSubGraphTitleMargins"), Lie = /* @__PURE__ */ x((t) => {
  const { handDrawnSeed: e } = we();
  return {
    fill: t,
    hachureAngle: 120,
    // angle of hachure,
    hachureGap: 4,
    fillWeight: 2,
    roughness: 0.7,
    stroke: t,
    seed: e
  };
}, "solidStateFill"), Wd = /* @__PURE__ */ x((t) => {
  const e = Rie([
    ...t.cssCompiledStyles || [],
    ...t.cssStyles || [],
    ...t.labelStyle || []
  ]);
  return { stylesMap: e, stylesArray: [...e] };
}, "compileStyles"), Rie = /* @__PURE__ */ x((t) => {
  const e = /* @__PURE__ */ new Map();
  return t.forEach((r) => {
    const [n, i] = r.split(":");
    e.set(n.trim(), i?.trim());
  }), e;
}, "styles2Map"), DE = /* @__PURE__ */ x((t) => t === "color" || t === "font-size" || t === "font-family" || t === "font-weight" || t === "font-style" || t === "text-decoration" || t === "text-align" || t === "text-transform" || t === "line-height" || t === "letter-spacing" || t === "word-spacing" || t === "text-shadow" || t === "text-overflow" || t === "white-space" || t === "word-wrap" || t === "word-break" || t === "overflow-wrap" || t === "hyphens", "isLabelStyle"), St = /* @__PURE__ */ x((t) => {
  const { stylesArray: e } = Wd(t), r = [], n = [], i = [], a = [];
  return e.forEach((s) => {
    const o = s[0];
    DE(o) ? r.push(s.join(":") + " !important") : (n.push(s.join(":") + " !important"), o.includes("stroke") && i.push(s.join(":") + " !important"), o === "fill" && a.push(s.join(":") + " !important"));
  }), {
    labelStyles: r.join(";"),
    nodeStyles: n.join(";"),
    stylesArray: e,
    borderStyles: i,
    backgroundStyles: a
  };
}, "styles2String"), Rt = /* @__PURE__ */ x((t, e) => {
  const { themeVariables: r, handDrawnSeed: n } = we(), { nodeBorder: i, mainBkg: a } = r, { stylesMap: s } = Wd(t);
  return Object.assign(
    {
      roughness: 0.7,
      fill: s.get("fill") || a,
      fillStyle: "hachure",
      // solid fill
      fillWeight: 4,
      hachureGap: 5.2,
      stroke: s.get("stroke") || i,
      seed: n,
      strokeWidth: s.get("stroke-width")?.replace("px", "") || 1.3,
      fillLineDash: [0, 0],
      strokeLineDash: Mie(s.get("stroke-dasharray"))
    },
    e
  );
}, "userNodeOverrides"), Mie = /* @__PURE__ */ x((t) => {
  if (!t)
    return [0, 0];
  const e = t.trim().split(/\s+/).map(Number);
  if (e.length === 1) {
    const i = isNaN(e[0]) ? 0 : e[0];
    return [i, i];
  }
  const r = isNaN(e[0]) ? 0 : e[0], n = isNaN(e[1]) ? 0 : e[1];
  return [r, n];
}, "getStrokeDashArray"), kf = {}, Mn = {}, t8;
function Nie() {
  return t8 || (t8 = 1, Object.defineProperty(Mn, "__esModule", { value: !0 }), Mn.BLANK_URL = Mn.relativeFirstCharacters = Mn.whitespaceEscapeCharsRegex = Mn.urlSchemeRegex = Mn.ctrlCharactersRegex = Mn.htmlCtrlEntityRegex = Mn.htmlEntitiesRegex = Mn.invalidProtocolRegex = void 0, Mn.invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im, Mn.htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g, Mn.htmlCtrlEntityRegex = /&(newline|tab);/gi, Mn.ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim, Mn.urlSchemeRegex = /^.+(:|&colon;)/gim, Mn.whitespaceEscapeCharsRegex = /(\\|%5[cC])((%(6[eE]|72|74))|[nrt])/g, Mn.relativeFirstCharacters = [".", "/"], Mn.BLANK_URL = "about:blank"), Mn;
}
var r8;
function Iie() {
  if (r8) return kf;
  r8 = 1, Object.defineProperty(kf, "__esModule", { value: !0 }), kf.sanitizeUrl = void 0;
  var t = Nie();
  function e(s) {
    return t.relativeFirstCharacters.indexOf(s[0]) > -1;
  }
  function r(s) {
    var o = s.replace(t.ctrlCharactersRegex, "");
    return o.replace(t.htmlEntitiesRegex, function(l, u) {
      return String.fromCharCode(u);
    });
  }
  function n(s) {
    return URL.canParse(s);
  }
  function i(s) {
    try {
      return decodeURIComponent(s);
    } catch {
      return s;
    }
  }
  function a(s) {
    if (!s)
      return t.BLANK_URL;
    var o, l = i(s.trim());
    do
      l = r(l).replace(t.htmlCtrlEntityRegex, "").replace(t.ctrlCharactersRegex, "").replace(t.whitespaceEscapeCharsRegex, "").trim(), l = i(l), o = l.match(t.ctrlCharactersRegex) || l.match(t.htmlEntitiesRegex) || l.match(t.htmlCtrlEntityRegex) || l.match(t.whitespaceEscapeCharsRegex);
    while (o && o.length > 0);
    var u = l;
    if (!u)
      return t.BLANK_URL;
    if (e(u))
      return u;
    var h = u.trimStart(), d = h.match(t.urlSchemeRegex);
    if (!d)
      return u;
    var f = d[0].toLowerCase().trim();
    if (t.invalidProtocolRegex.test(f))
      return t.BLANK_URL;
    var p = h.replace(/\\/g, "/");
    if (f === "mailto:" || f.includes("://"))
      return p;
    if (f === "http:" || f === "https:") {
      if (!n(p))
        return t.BLANK_URL;
      var g = new URL(p);
      return g.protocol = g.protocol.toLowerCase(), g.hostname = g.hostname.toLowerCase(), g.toString();
    }
    return p;
  }
  return kf.sanitizeUrl = a, kf;
}
var Uu = Iie(), zP = typeof global == "object" && global && global.Object === Object && global, Die = typeof self == "object" && self && self.Object === Object && self, uo = zP || Die || Function("return this")(), Qa = uo.Symbol, GP = Object.prototype, Oie = GP.hasOwnProperty, Pie = GP.toString, Sf = Qa ? Qa.toStringTag : void 0;
function Bie(t) {
  var e = Oie.call(t, Sf), r = t[Sf];
  try {
    t[Sf] = void 0;
    var n = !0;
  } catch {
  }
  var i = Pie.call(t);
  return n && (e ? t[Sf] = r : delete t[Sf]), i;
}
var Fie = Object.prototype, $ie = Fie.toString;
function zie(t) {
  return $ie.call(t);
}
var Gie = "[object Null]", Vie = "[object Undefined]", n8 = Qa ? Qa.toStringTag : void 0;
function Hu(t) {
  return t == null ? t === void 0 ? Vie : Gie : n8 && n8 in Object(t) ? Bie(t) : zie(t);
}
function Ca(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var Uie = "[object AsyncFunction]", Hie = "[object Function]", qie = "[object GeneratorFunction]", Wie = "[object Proxy]";
function bp(t) {
  if (!Ca(t))
    return !1;
  var e = Hu(t);
  return e == Hie || e == qie || e == Uie || e == Wie;
}
var e4 = uo["__core-js_shared__"], i8 = (function() {
  var t = /[^.]+$/.exec(e4 && e4.keys && e4.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
})();
function Yie(t) {
  return !!i8 && i8 in t;
}
var Xie = Function.prototype, jie = Xie.toString;
function qu(t) {
  if (t != null) {
    try {
      return jie.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var Kie = /[\\^$.*+?()[\]{}|]/g, Zie = /^\[object .+?Constructor\]$/, Qie = Function.prototype, Jie = Object.prototype, eae = Qie.toString, tae = Jie.hasOwnProperty, rae = RegExp(
  "^" + eae.call(tae).replace(Kie, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function nae(t) {
  if (!Ca(t) || Yie(t))
    return !1;
  var e = bp(t) ? rae : Zie;
  return e.test(qu(t));
}
function iae(t, e) {
  return t?.[e];
}
function Wu(t, e) {
  var r = iae(t, e);
  return nae(r) ? r : void 0;
}
var wp = Wu(Object, "create");
function aae() {
  this.__data__ = wp ? wp(null) : {}, this.size = 0;
}
function sae(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var oae = "__lodash_hash_undefined__", lae = Object.prototype, cae = lae.hasOwnProperty;
function uae(t) {
  var e = this.__data__;
  if (wp) {
    var r = e[t];
    return r === oae ? void 0 : r;
  }
  return cae.call(e, t) ? e[t] : void 0;
}
var hae = Object.prototype, dae = hae.hasOwnProperty;
function fae(t) {
  var e = this.__data__;
  return wp ? e[t] !== void 0 : dae.call(e, t);
}
var pae = "__lodash_hash_undefined__";
function gae(t, e) {
  var r = this.__data__;
  return this.size += this.has(t) ? 0 : 1, r[t] = wp && e === void 0 ? pae : e, this;
}
function bu(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
bu.prototype.clear = aae;
bu.prototype.delete = sae;
bu.prototype.get = uae;
bu.prototype.has = fae;
bu.prototype.set = gae;
function mae() {
  this.__data__ = [], this.size = 0;
}
function Yd(t, e) {
  return t === e || t !== t && e !== e;
}
function W2(t, e) {
  for (var r = t.length; r--; )
    if (Yd(t[r][0], e))
      return r;
  return -1;
}
var vae = Array.prototype, yae = vae.splice;
function xae(t) {
  var e = this.__data__, r = W2(e, t);
  if (r < 0)
    return !1;
  var n = e.length - 1;
  return r == n ? e.pop() : yae.call(e, r, 1), --this.size, !0;
}
function bae(t) {
  var e = this.__data__, r = W2(e, t);
  return r < 0 ? void 0 : e[r][1];
}
function wae(t) {
  return W2(this.__data__, t) > -1;
}
function Tae(t, e) {
  var r = this.__data__, n = W2(r, t);
  return n < 0 ? (++this.size, r.push([t, e])) : r[n][1] = e, this;
}
function cl(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
cl.prototype.clear = mae;
cl.prototype.delete = xae;
cl.prototype.get = bae;
cl.prototype.has = wae;
cl.prototype.set = Tae;
var Tp = Wu(uo, "Map");
function Eae() {
  this.size = 0, this.__data__ = {
    hash: new bu(),
    map: new (Tp || cl)(),
    string: new bu()
  };
}
function kae(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function Y2(t, e) {
  var r = t.__data__;
  return kae(e) ? r[typeof e == "string" ? "string" : "hash"] : r.map;
}
function Sae(t) {
  var e = Y2(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function Cae(t) {
  return Y2(this, t).get(t);
}
function Aae(t) {
  return Y2(this, t).has(t);
}
function _ae(t, e) {
  var r = Y2(this, t), n = r.size;
  return r.set(t, e), this.size += r.size == n ? 0 : 1, this;
}
function ul(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
ul.prototype.clear = Eae;
ul.prototype.delete = Sae;
ul.prototype.get = Cae;
ul.prototype.has = Aae;
ul.prototype.set = _ae;
var Lae = "Expected a function";
function Xd(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(Lae);
  var r = function() {
    var n = arguments, i = e ? e.apply(this, n) : n[0], a = r.cache;
    if (a.has(i))
      return a.get(i);
    var s = t.apply(this, n);
    return r.cache = a.set(i, s) || a, s;
  };
  return r.cache = new (Xd.Cache || ul)(), r;
}
Xd.Cache = ul;
function Rae() {
  this.__data__ = new cl(), this.size = 0;
}
function Mae(t) {
  var e = this.__data__, r = e.delete(t);
  return this.size = e.size, r;
}
function Nae(t) {
  return this.__data__.get(t);
}
function Iae(t) {
  return this.__data__.has(t);
}
var Dae = 200;
function Oae(t, e) {
  var r = this.__data__;
  if (r instanceof cl) {
    var n = r.__data__;
    if (!Tp || n.length < Dae - 1)
      return n.push([t, e]), this.size = ++r.size, this;
    r = this.__data__ = new ul(n);
  }
  return r.set(t, e), this.size = r.size, this;
}
function ys(t) {
  var e = this.__data__ = new cl(t);
  this.size = e.size;
}
ys.prototype.clear = Rae;
ys.prototype.delete = Mae;
ys.prototype.get = Nae;
ys.prototype.has = Iae;
ys.prototype.set = Oae;
var ey = (function() {
  try {
    var t = Wu(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
})();
function X2(t, e, r) {
  e == "__proto__" && ey ? ey(t, e, {
    configurable: !0,
    enumerable: !0,
    value: r,
    writable: !0
  }) : t[e] = r;
}
function Dw(t, e, r) {
  (r !== void 0 && !Yd(t[e], r) || r === void 0 && !(e in t)) && X2(t, e, r);
}
function Pae(t) {
  return function(e, r, n) {
    for (var i = -1, a = Object(e), s = n(e), o = s.length; o--; ) {
      var l = s[++i];
      if (r(a[l], l, a) === !1)
        break;
    }
    return e;
  };
}
var OE = Pae(), VP = typeof exports == "object" && exports && !exports.nodeType && exports, a8 = VP && typeof module == "object" && module && !module.nodeType && module, Bae = a8 && a8.exports === VP, s8 = Bae ? uo.Buffer : void 0, o8 = s8 ? s8.allocUnsafe : void 0;
function UP(t, e) {
  if (e)
    return t.slice();
  var r = t.length, n = o8 ? o8(r) : new t.constructor(r);
  return t.copy(n), n;
}
var ty = uo.Uint8Array;
function PE(t) {
  var e = new t.constructor(t.byteLength);
  return new ty(e).set(new ty(t)), e;
}
function HP(t, e) {
  var r = e ? PE(t.buffer) : t.buffer;
  return new t.constructor(r, t.byteOffset, t.length);
}
function qP(t, e) {
  var r = -1, n = t.length;
  for (e || (e = Array(n)); ++r < n; )
    e[r] = t[r];
  return e;
}
var l8 = Object.create, Fae = /* @__PURE__ */ (function() {
  function t() {
  }
  return function(e) {
    if (!Ca(e))
      return {};
    if (l8)
      return l8(e);
    t.prototype = e;
    var r = new t();
    return t.prototype = void 0, r;
  };
})();
function WP(t, e) {
  return function(r) {
    return t(e(r));
  };
}
var BE = WP(Object.getPrototypeOf, Object), $ae = Object.prototype;
function j2(t) {
  var e = t && t.constructor, r = typeof e == "function" && e.prototype || $ae;
  return t === r;
}
function YP(t) {
  return typeof t.constructor == "function" && !j2(t) ? Fae(BE(t)) : {};
}
function io(t) {
  return t != null && typeof t == "object";
}
var zae = "[object Arguments]";
function c8(t) {
  return io(t) && Hu(t) == zae;
}
var XP = Object.prototype, Gae = XP.hasOwnProperty, Vae = XP.propertyIsEnumerable, wd = c8(/* @__PURE__ */ (function() {
  return arguments;
})()) ? c8 : function(t) {
  return io(t) && Gae.call(t, "callee") && !Vae.call(t, "callee");
}, An = Array.isArray, Uae = 9007199254740991;
function FE(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= Uae;
}
function dc(t) {
  return t != null && FE(t.length) && !bp(t);
}
function jP(t) {
  return io(t) && dc(t);
}
function Hae() {
  return !1;
}
var KP = typeof exports == "object" && exports && !exports.nodeType && exports, u8 = KP && typeof module == "object" && module && !module.nodeType && module, qae = u8 && u8.exports === KP, h8 = qae ? uo.Buffer : void 0, Wae = h8 ? h8.isBuffer : void 0, Td = Wae || Hae, Yae = "[object Object]", Xae = Function.prototype, jae = Object.prototype, ZP = Xae.toString, Kae = jae.hasOwnProperty, Zae = ZP.call(Object);
function Qae(t) {
  if (!io(t) || Hu(t) != Yae)
    return !1;
  var e = BE(t);
  if (e === null)
    return !0;
  var r = Kae.call(e, "constructor") && e.constructor;
  return typeof r == "function" && r instanceof r && ZP.call(r) == Zae;
}
var Jae = "[object Arguments]", ese = "[object Array]", tse = "[object Boolean]", rse = "[object Date]", nse = "[object Error]", ise = "[object Function]", ase = "[object Map]", sse = "[object Number]", ose = "[object Object]", lse = "[object RegExp]", cse = "[object Set]", use = "[object String]", hse = "[object WeakMap]", dse = "[object ArrayBuffer]", fse = "[object DataView]", pse = "[object Float32Array]", gse = "[object Float64Array]", mse = "[object Int8Array]", vse = "[object Int16Array]", yse = "[object Int32Array]", xse = "[object Uint8Array]", bse = "[object Uint8ClampedArray]", wse = "[object Uint16Array]", Tse = "[object Uint32Array]", Hr = {};
Hr[pse] = Hr[gse] = Hr[mse] = Hr[vse] = Hr[yse] = Hr[xse] = Hr[bse] = Hr[wse] = Hr[Tse] = !0;
Hr[Jae] = Hr[ese] = Hr[dse] = Hr[tse] = Hr[fse] = Hr[rse] = Hr[nse] = Hr[ise] = Hr[ase] = Hr[sse] = Hr[ose] = Hr[lse] = Hr[cse] = Hr[use] = Hr[hse] = !1;
function Ese(t) {
  return io(t) && FE(t.length) && !!Hr[Hu(t)];
}
function K2(t) {
  return function(e) {
    return t(e);
  };
}
var QP = typeof exports == "object" && exports && !exports.nodeType && exports, j0 = QP && typeof module == "object" && module && !module.nodeType && module, kse = j0 && j0.exports === QP, t4 = kse && zP.process, Ed = (function() {
  try {
    var t = j0 && j0.require && j0.require("util").types;
    return t || t4 && t4.binding && t4.binding("util");
  } catch {
  }
})(), d8 = Ed && Ed.isTypedArray, Z2 = d8 ? K2(d8) : Ese;
function Ow(t, e) {
  if (!(e === "constructor" && typeof t[e] == "function") && e != "__proto__")
    return t[e];
}
var Sse = Object.prototype, Cse = Sse.hasOwnProperty;
function Q2(t, e, r) {
  var n = t[e];
  (!(Cse.call(t, e) && Yd(n, r)) || r === void 0 && !(e in t)) && X2(t, e, r);
}
function fg(t, e, r, n) {
  var i = !r;
  r || (r = {});
  for (var a = -1, s = e.length; ++a < s; ) {
    var o = e[a], l = void 0;
    l === void 0 && (l = t[o]), i ? X2(r, o, l) : Q2(r, o, l);
  }
  return r;
}
function Ase(t, e) {
  for (var r = -1, n = Array(t); ++r < t; )
    n[r] = e(r);
  return n;
}
var _se = 9007199254740991, Lse = /^(?:0|[1-9]\d*)$/;
function J2(t, e) {
  var r = typeof t;
  return e = e ?? _se, !!e && (r == "number" || r != "symbol" && Lse.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
var Rse = Object.prototype, Mse = Rse.hasOwnProperty;
function JP(t, e) {
  var r = An(t), n = !r && wd(t), i = !r && !n && Td(t), a = !r && !n && !i && Z2(t), s = r || n || i || a, o = s ? Ase(t.length, String) : [], l = o.length;
  for (var u in t)
    (e || Mse.call(t, u)) && !(s && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    a && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    J2(u, l))) && o.push(u);
  return o;
}
function Nse(t) {
  var e = [];
  if (t != null)
    for (var r in Object(t))
      e.push(r);
  return e;
}
var Ise = Object.prototype, Dse = Ise.hasOwnProperty;
function Ose(t) {
  if (!Ca(t))
    return Nse(t);
  var e = j2(t), r = [];
  for (var n in t)
    n == "constructor" && (e || !Dse.call(t, n)) || r.push(n);
  return r;
}
function Yu(t) {
  return dc(t) ? JP(t, !0) : Ose(t);
}
function Pse(t) {
  return fg(t, Yu(t));
}
function Bse(t, e, r, n, i, a, s) {
  var o = Ow(t, r), l = Ow(e, r), u = s.get(l);
  if (u) {
    Dw(t, r, u);
    return;
  }
  var h = a ? a(o, l, r + "", t, e, s) : void 0, d = h === void 0;
  if (d) {
    var f = An(l), p = !f && Td(l), g = !f && !p && Z2(l);
    h = l, f || p || g ? An(o) ? h = o : jP(o) ? h = qP(o) : p ? (d = !1, h = UP(l, !0)) : g ? (d = !1, h = HP(l, !0)) : h = [] : Qae(l) || wd(l) ? (h = o, wd(o) ? h = Pse(o) : (!Ca(o) || bp(o)) && (h = YP(l))) : d = !1;
  }
  d && (s.set(l, h), i(h, l, n, a, s), s.delete(l)), Dw(t, r, h);
}
function eB(t, e, r, n, i) {
  t !== e && OE(e, function(a, s) {
    if (i || (i = new ys()), Ca(a))
      Bse(t, e, s, r, eB, n, i);
    else {
      var o = n ? n(Ow(t, s), a, s + "", t, e, i) : void 0;
      o === void 0 && (o = a), Dw(t, s, o);
    }
  }, Yu);
}
function Xu(t) {
  return t;
}
function Fse(t, e, r) {
  switch (r.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, r[0]);
    case 2:
      return t.call(e, r[0], r[1]);
    case 3:
      return t.call(e, r[0], r[1], r[2]);
  }
  return t.apply(e, r);
}
var f8 = Math.max;
function tB(t, e, r) {
  return e = f8(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var n = arguments, i = -1, a = f8(n.length - e, 0), s = Array(a); ++i < a; )
      s[i] = n[e + i];
    i = -1;
    for (var o = Array(e + 1); ++i < e; )
      o[i] = n[i];
    return o[e] = r(s), Fse(t, this, o);
  };
}
function zh(t) {
  return function() {
    return t;
  };
}
var $se = ey ? function(t, e) {
  return ey(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: zh(e),
    writable: !0
  });
} : Xu, zse = 800, Gse = 16, Vse = Date.now;
function Use(t) {
  var e = 0, r = 0;
  return function() {
    var n = Vse(), i = Gse - (n - r);
    if (r = n, i > 0) {
      if (++e >= zse)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
var rB = Use($se);
function ex(t, e) {
  return rB(tB(t, e, Xu), t + "");
}
function Ep(t, e, r) {
  if (!Ca(r))
    return !1;
  var n = typeof e;
  return (n == "number" ? dc(r) && J2(e, r.length) : n == "string" && e in r) ? Yd(r[e], t) : !1;
}
function Hse(t) {
  return ex(function(e, r) {
    var n = -1, i = r.length, a = i > 1 ? r[i - 1] : void 0, s = i > 2 ? r[2] : void 0;
    for (a = t.length > 3 && typeof a == "function" ? (i--, a) : void 0, s && Ep(r[0], r[1], s) && (a = i < 3 ? void 0 : a, i = 1), e = Object(e); ++n < i; ) {
      var o = r[n];
      o && t(e, o, n, a);
    }
    return e;
  });
}
var ry = Hse(function(t, e, r) {
  eB(t, e, r);
}), nB = "", qse = {
  curveBasis: jh,
  curveBasisClosed: mne,
  curveBasisOpen: vne,
  curveBumpX: FD,
  curveBumpY: $D,
  curveBundle: yne,
  curveCardinalClosed: xne,
  curveCardinalOpen: bne,
  curveCardinal: UD,
  curveCatmullRomClosed: wne,
  curveCatmullRomOpen: Tne,
  curveCatmullRom: qD,
  curveLinear: Hv,
  curveLinearClosed: Ene,
  curveMonotoneX: ZD,
  curveMonotoneY: QD,
  curveNatural: eO,
  curveStep: tO,
  curveStepAfter: nO,
  curveStepBefore: rO
}, Wse = /\s*(?:(\w+)(?=:):|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi, Yse = /* @__PURE__ */ x(function(t, e) {
  const r = iB(t, /(?:init\b)|(?:initialize\b)/);
  let n = {};
  if (Array.isArray(r)) {
    const s = r.map((o) => o.args);
    kv(s), n = mn(n, [...s]);
  } else
    n = r.args;
  if (!n)
    return;
  let i = aE(t, e);
  const a = "config";
  return n[a] !== void 0 && (i === "flowchart-v2" && (i = "flowchart"), n[i] = n[a], delete n[a]), n;
}, "detectInit"), iB = /* @__PURE__ */ x(function(t, e = null) {
  try {
    const r = new RegExp(
      `[%]{2}(?![{]${Wse.source})(?=[}][%]{2}).*
`,
      "ig"
    );
    t = t.trim().replace(r, "").replace(/'/gm, '"'), ie.debug(
      `Detecting diagram directive${e !== null ? " type:" + e : ""} based on the text:${t}`
    );
    let n;
    const i = [];
    for (; (n = W0.exec(t)) !== null; )
      if (n.index === W0.lastIndex && W0.lastIndex++, n && !e || e && n[1]?.match(e) || e && n[2]?.match(e)) {
        const a = n[1] ? n[1] : n[2], s = n[3] ? n[3].trim() : n[4] ? JSON.parse(n[4].trim()) : null;
        i.push({ type: a, args: s });
      }
    return i.length === 0 ? { type: t, args: null } : i.length === 1 ? i[0] : i;
  } catch (r) {
    return ie.error(
      `ERROR: ${r.message} - Unable to parse directive type: '${e}' based on the text: '${t}'`
    ), { type: void 0, args: null };
  }
}, "detectDirective"), Xse = /* @__PURE__ */ x(function(t) {
  return t.replace(W0, "");
}, "removeDirectives"), jse = /* @__PURE__ */ x(function(t, e) {
  for (const [r, n] of e.entries())
    if (n.match(t))
      return r;
  return -1;
}, "isSubstringInArray");
function $E(t, e) {
  if (!t)
    return e;
  const r = `curve${t.charAt(0).toUpperCase() + t.slice(1)}`;
  return qse[r] ?? e;
}
x($E, "interpolateToCurve");
function aB(t, e) {
  const r = t.trim();
  if (r)
    return e.securityLevel !== "loose" ? Uu.sanitizeUrl(r) : r;
}
x(aB, "formatUrl");
var Kse = /* @__PURE__ */ x((t, ...e) => {
  const r = t.split("."), n = r.length - 1, i = r[n];
  let a = window;
  for (let s = 0; s < n; s++)
    if (a = a[r[s]], !a) {
      ie.error(`Function name: ${t} not found in window`);
      return;
    }
  a[i](...e);
}, "runFunc");
function zE(t, e) {
  return !t || !e ? 0 : Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
}
x(zE, "distance");
function sB(t) {
  let e, r = 0;
  t.forEach((i) => {
    r += zE(i, e), e = i;
  });
  const n = r / 2;
  return GE(t, n);
}
x(sB, "traverseEdge");
function oB(t) {
  return t.length === 1 ? t[0] : sB(t);
}
x(oB, "calcLabelPosition");
var p8 = /* @__PURE__ */ x((t, e = 2) => {
  const r = Math.pow(10, e);
  return Math.round(t * r) / r;
}, "roundNumber"), GE = /* @__PURE__ */ x((t, e) => {
  let r, n = e;
  for (const i of t) {
    if (r) {
      const a = zE(i, r);
      if (a === 0)
        return r;
      if (a < n)
        n -= a;
      else {
        const s = n / a;
        if (s <= 0)
          return r;
        if (s >= 1)
          return { x: i.x, y: i.y };
        if (s > 0 && s < 1)
          return {
            x: p8((1 - s) * r.x + s * i.x, 5),
            y: p8((1 - s) * r.y + s * i.y, 5)
          };
      }
    }
    r = i;
  }
  throw new Error("Could not find a suitable point for the given distance");
}, "calculatePoint"), Zse = /* @__PURE__ */ x((t, e, r) => {
  ie.info(`our points ${JSON.stringify(e)}`), e[0] !== r && (e = e.reverse());
  const i = GE(e, 25), a = t ? 10 : 5, s = Math.atan2(e[0].y - i.y, e[0].x - i.x), o = { x: 0, y: 0 };
  return o.x = Math.sin(s) * a + (e[0].x + i.x) / 2, o.y = -Math.cos(s) * a + (e[0].y + i.y) / 2, o;
}, "calcCardinalityPosition");
function lB(t, e, r) {
  const n = structuredClone(r);
  ie.info("our points", n), e !== "start_left" && e !== "start_right" && n.reverse();
  const i = 25 + t, a = GE(n, i), s = 10 + t * 0.5, o = Math.atan2(n[0].y - a.y, n[0].x - a.x), l = { x: 0, y: 0 };
  return e === "start_left" ? (l.x = Math.sin(o + Math.PI) * s + (n[0].x + a.x) / 2, l.y = -Math.cos(o + Math.PI) * s + (n[0].y + a.y) / 2) : e === "end_right" ? (l.x = Math.sin(o - Math.PI) * s + (n[0].x + a.x) / 2 - 5, l.y = -Math.cos(o - Math.PI) * s + (n[0].y + a.y) / 2 - 5) : e === "end_left" ? (l.x = Math.sin(o) * s + (n[0].x + a.x) / 2 - 5, l.y = -Math.cos(o) * s + (n[0].y + a.y) / 2 - 5) : (l.x = Math.sin(o) * s + (n[0].x + a.x) / 2, l.y = -Math.cos(o) * s + (n[0].y + a.y) / 2), l;
}
x(lB, "calcTerminalLabelPosition");
function VE(t) {
  let e = "", r = "";
  for (const n of t)
    n !== void 0 && (n.startsWith("color:") || n.startsWith("text-align:") ? r = r + n + ";" : e = e + n + ";");
  return { style: e, labelStyle: r };
}
x(VE, "getStylesFromArray");
var g8 = 0, cB = /* @__PURE__ */ x(() => (g8++, "id-" + Math.random().toString(36).substr(2, 12) + "-" + g8), "generateId");
function uB(t) {
  let e = "";
  const r = "0123456789abcdef", n = r.length;
  for (let i = 0; i < t; i++)
    e += r.charAt(Math.floor(Math.random() * n));
  return e;
}
x(uB, "makeRandomHex");
var hB = /* @__PURE__ */ x((t) => uB(t.length), "random"), Qse = /* @__PURE__ */ x(function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    anchor: "start",
    style: "#666",
    width: 100,
    height: 100,
    textMargin: 0,
    rx: 0,
    ry: 0,
    valign: void 0,
    text: ""
  };
}, "getTextObj"), Jse = /* @__PURE__ */ x(function(t, e) {
  const r = e.text.replace(at.lineBreakRegex, " "), [, n] = ju(e.fontSize), i = t.append("text");
  i.attr("x", e.x), i.attr("y", e.y), i.style("text-anchor", e.anchor), i.style("font-family", e.fontFamily), i.style("font-size", n), i.style("font-weight", e.fontWeight), i.attr("fill", e.fill), e.class !== void 0 && i.attr("class", e.class);
  const a = i.append("tspan");
  return a.attr("x", e.x + e.textMargin * 2), a.attr("fill", e.fill), a.text(r), i;
}, "drawSimpleText"), dB = Xd(
  (t, e, r) => {
    if (!t || (r = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", joinWith: "<br/>" },
      r
    ), at.lineBreakRegex.test(t)))
      return t;
    const n = t.split(" ").filter(Boolean), i = [];
    let a = "";
    return n.forEach((s, o) => {
      const l = zi(`${s} `, r), u = zi(a, r);
      if (l > e) {
        const { hyphenatedStrings: f, remainingWord: p } = eoe(s, e, "-", r);
        i.push(a, ...f), a = p;
      } else u + l >= e ? (i.push(a), a = s) : a = [a, s].filter(Boolean).join(" ");
      o + 1 === n.length && i.push(a);
    }), i.filter((s) => s !== "").join(r.joinWith);
  },
  (t, e, r) => `${t}${e}${r.fontSize}${r.fontWeight}${r.fontFamily}${r.joinWith}`
), eoe = Xd(
  (t, e, r = "-", n) => {
    n = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", margin: 0 },
      n
    );
    const i = [...t], a = [];
    let s = "";
    return i.forEach((o, l) => {
      const u = `${s}${o}`;
      if (zi(u, n) >= e) {
        const d = l + 1, f = i.length === d, p = `${u}${r}`;
        a.push(f ? u : p), s = "";
      } else
        s = u;
    }), { hyphenatedStrings: a, remainingWord: s };
  },
  (t, e, r = "-", n) => `${t}${e}${r}${n.fontSize}${n.fontWeight}${n.fontFamily}`
);
function ny(t, e) {
  return UE(t, e).height;
}
x(ny, "calculateTextHeight");
function zi(t, e) {
  return UE(t, e).width;
}
x(zi, "calculateTextWidth");
var UE = Xd(
  (t, e) => {
    const { fontSize: r = 12, fontFamily: n = "Arial", fontWeight: i = 400 } = e;
    if (!t)
      return { width: 0, height: 0 };
    const [, a] = ju(r), s = ["sans-serif", n], o = t.split(at.lineBreakRegex), l = [], u = Qe("body");
    if (!u.remove)
      return { width: 0, height: 0, lineHeight: 0 };
    const h = u.append("svg");
    for (const f of s) {
      let p = 0;
      const g = { width: 0, height: 0, lineHeight: 0 };
      for (const m of o) {
        const v = Qse();
        v.text = m || nB;
        const y = Jse(h, v).style("font-size", a).style("font-weight", i).style("font-family", f), b = (y._groups || y)[0][0].getBBox();
        if (b.width === 0 && b.height === 0)
          throw new Error("svg element not in render tree");
        g.width = Math.round(Math.max(g.width, b.width)), p = Math.round(b.height), g.height += p, g.lineHeight = Math.round(Math.max(g.lineHeight, p));
      }
      l.push(g);
    }
    h.remove();
    const d = isNaN(l[1].height) || isNaN(l[1].width) || isNaN(l[1].lineHeight) || l[0].height > l[1].height && l[0].width > l[1].width && l[0].lineHeight > l[1].lineHeight ? 0 : 1;
    return l[d];
  },
  (t, e) => `${t}${e.fontSize}${e.fontWeight}${e.fontFamily}`
), toe = class {
  constructor(t = !1, e) {
    this.count = 0, this.count = e ? e.length : 0, this.next = t ? () => this.count++ : () => Date.now();
  }
  static {
    x(this, "InitIDGenerator");
  }
}, c1, roe = /* @__PURE__ */ x(function(t) {
  return c1 = c1 || document.createElement("div"), t = escape(t).replace(/%26/g, "&").replace(/%23/g, "#").replace(/%3B/g, ";"), c1.innerHTML = t, unescape(c1.textContent);
}, "entityDecode");
function HE(t) {
  return "str" in t;
}
x(HE, "isDetailedError");
var noe = /* @__PURE__ */ x((t, e, r, n) => {
  if (!n)
    return;
  const i = t.node()?.getBBox();
  i && t.append("text").text(n).attr("text-anchor", "middle").attr("x", i.x + i.width / 2).attr("y", -r).attr("class", e);
}, "insertTitle"), ju = /* @__PURE__ */ x((t) => {
  if (typeof t == "number")
    return [t, t + "px"];
  const e = parseInt(t ?? "", 10);
  return Number.isNaN(e) ? [void 0, void 0] : t === String(e) ? [e, t + "px"] : [e, t];
}, "parseFontSize");
function Hi(t, e) {
  return ry({}, t, e);
}
x(Hi, "cleanAndMerge");
var Zt = {
  assignWithDepth: mn,
  wrapLabel: dB,
  calculateTextHeight: ny,
  calculateTextWidth: zi,
  calculateTextDimensions: UE,
  cleanAndMerge: Hi,
  detectInit: Yse,
  detectDirective: iB,
  isSubstringInArray: jse,
  interpolateToCurve: $E,
  calcLabelPosition: oB,
  calcCardinalityPosition: Zse,
  calcTerminalLabelPosition: lB,
  formatUrl: aB,
  getStylesFromArray: VE,
  generateId: cB,
  random: hB,
  runFunc: Kse,
  entityDecode: roe,
  insertTitle: noe,
  isLabelCoordinateInPath: fB,
  parseFontSize: ju,
  InitIDGenerator: toe
}, ioe = /* @__PURE__ */ x(function(t) {
  let e = t;
  return e = e.replace(/style.*:\S*#.*;/g, function(r) {
    return r.substring(0, r.length - 1);
  }), e = e.replace(/classDef.*:\S*#.*;/g, function(r) {
    return r.substring(0, r.length - 1);
  }), e = e.replace(/#\w+;/g, function(r) {
    const n = r.substring(1, r.length - 1);
    return /^\+?\d+$/.test(n) ? "" + n + "" : "" + n + "";
  }), e;
}, "encodeEntities"), ao = /* @__PURE__ */ x(function(t) {
  return t.replace(//g, "&#").replace(//g, "&").replace(//g, ";");
}, "decodeEntities"), Kh = /* @__PURE__ */ x((t, e, {
  counter: r = 0,
  prefix: n,
  suffix: i
}, a) => a || `${n ? `${n}_` : ""}${t}_${e}_${r}${i ? `_${i}` : ""}`, "getEdgeId");
function ki(t) {
  return t ?? null;
}
x(ki, "handleUndefinedAttr");
function fB(t, e) {
  const r = Math.round(t.x), n = Math.round(t.y), i = e.replace(
    /(\d+\.\d+)/g,
    (a) => Math.round(parseFloat(a)).toString()
  );
  return i.includes(r.toString()) || i.includes(n.toString());
}
x(fB, "isLabelCoordinateInPath");
const aoe = Object.freeze({
  left: 0,
  top: 0,
  width: 16,
  height: 16
}), iy = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), pB = Object.freeze({
  ...aoe,
  ...iy
}), soe = Object.freeze({
  ...pB,
  body: "",
  hidden: !1
}), ooe = Object.freeze({
  width: null,
  height: null
}), loe = Object.freeze({
  ...ooe,
  ...iy
}), coe = (t, e, r, n = "") => {
  const i = t.split(":");
  if (t.slice(0, 1) === "@") {
    if (i.length < 2 || i.length > 3) return null;
    n = i.shift().slice(1);
  }
  if (i.length > 3 || !i.length) return null;
  if (i.length > 1) {
    const o = i.pop(), l = i.pop(), u = {
      provider: i.length > 0 ? i[0] : n,
      prefix: l,
      name: o
    };
    return r4(u) ? u : null;
  }
  const a = i[0], s = a.split("-");
  if (s.length > 1) {
    const o = {
      provider: n,
      prefix: s.shift(),
      name: s.join("-")
    };
    return r4(o) ? o : null;
  }
  if (r && n === "") {
    const o = {
      provider: n,
      prefix: "",
      name: a
    };
    return r4(o, r) ? o : null;
  }
  return null;
}, r4 = (t, e) => t ? !!((e && t.prefix === "" || t.prefix) && t.name) : !1;
function uoe(t, e) {
  const r = {};
  !t.hFlip != !e.hFlip && (r.hFlip = !0), !t.vFlip != !e.vFlip && (r.vFlip = !0);
  const n = ((t.rotate || 0) + (e.rotate || 0)) % 4;
  return n && (r.rotate = n), r;
}
function m8(t, e) {
  const r = uoe(t, e);
  for (const n in soe) n in iy ? n in t && !(n in r) && (r[n] = iy[n]) : n in e ? r[n] = e[n] : n in t && (r[n] = t[n]);
  return r;
}
function hoe(t, e) {
  const r = t.icons, n = t.aliases || /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null);
  function a(s) {
    if (r[s]) return i[s] = [];
    if (!(s in i)) {
      i[s] = null;
      const o = n[s] && n[s].parent, l = o && a(o);
      l && (i[s] = [o].concat(l));
    }
    return i[s];
  }
  return (e || Object.keys(r).concat(Object.keys(n))).forEach(a), i;
}
function v8(t, e, r) {
  const n = t.icons, i = t.aliases || /* @__PURE__ */ Object.create(null);
  let a = {};
  function s(o) {
    a = m8(n[o] || i[o], a);
  }
  return s(e), r.forEach(s), m8(t, a);
}
function doe(t, e) {
  if (t.icons[e]) return v8(t, e, []);
  const r = hoe(t, [e])[e];
  return r ? v8(t, e, r) : null;
}
const foe = /(-?[0-9.]*[0-9]+[0-9.]*)/g, poe = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function y8(t, e, r) {
  if (e === 1) return t;
  if (r = r || 100, typeof t == "number") return Math.ceil(t * e * r) / r;
  if (typeof t != "string") return t;
  const n = t.split(foe);
  if (n === null || !n.length) return t;
  const i = [];
  let a = n.shift(), s = poe.test(a);
  for (; ; ) {
    if (s) {
      const o = parseFloat(a);
      isNaN(o) ? i.push(a) : i.push(Math.ceil(o * e * r) / r);
    } else i.push(a);
    if (a = n.shift(), a === void 0) return i.join("");
    s = !s;
  }
}
function goe(t, e = "defs") {
  let r = "";
  const n = t.indexOf("<" + e);
  for (; n >= 0; ) {
    const i = t.indexOf(">", n), a = t.indexOf("</" + e);
    if (i === -1 || a === -1) break;
    const s = t.indexOf(">", a);
    if (s === -1) break;
    r += t.slice(i + 1, a).trim(), t = t.slice(0, n).trim() + t.slice(s + 1);
  }
  return {
    defs: r,
    content: t
  };
}
function moe(t, e) {
  return t ? "<defs>" + t + "</defs>" + e : e;
}
function voe(t, e, r) {
  const n = goe(t);
  return moe(n.defs, e + n.content + r);
}
const yoe = (t) => t === "unset" || t === "undefined" || t === "none";
function xoe(t, e) {
  const r = {
    ...pB,
    ...t
  }, n = {
    ...loe,
    ...e
  }, i = {
    left: r.left,
    top: r.top,
    width: r.width,
    height: r.height
  };
  let a = r.body;
  [r, n].forEach((m) => {
    const v = [], y = m.hFlip, b = m.vFlip;
    let w = m.rotate;
    y ? b ? w += 2 : (v.push("translate(" + (i.width + i.left).toString() + " " + (0 - i.top).toString() + ")"), v.push("scale(-1 1)"), i.top = i.left = 0) : b && (v.push("translate(" + (0 - i.left).toString() + " " + (i.height + i.top).toString() + ")"), v.push("scale(1 -1)"), i.top = i.left = 0);
    let T;
    switch (w < 0 && (w -= Math.floor(w / 4) * 4), w = w % 4, w) {
      case 1:
        T = i.height / 2 + i.top, v.unshift("rotate(90 " + T.toString() + " " + T.toString() + ")");
        break;
      case 2:
        v.unshift("rotate(180 " + (i.width / 2 + i.left).toString() + " " + (i.height / 2 + i.top).toString() + ")");
        break;
      case 3:
        T = i.width / 2 + i.left, v.unshift("rotate(-90 " + T.toString() + " " + T.toString() + ")");
        break;
    }
    w % 2 === 1 && (i.left !== i.top && (T = i.left, i.left = i.top, i.top = T), i.width !== i.height && (T = i.width, i.width = i.height, i.height = T)), v.length && (a = voe(a, '<g transform="' + v.join(" ") + '">', "</g>"));
  });
  const s = n.width, o = n.height, l = i.width, u = i.height;
  let h, d;
  s === null ? (d = o === null ? "1em" : o === "auto" ? u : o, h = y8(d, l / u)) : (h = s === "auto" ? l : s, d = o === null ? y8(h, u / l) : o === "auto" ? u : o);
  const f = {}, p = (m, v) => {
    yoe(v) || (f[m] = v.toString());
  };
  p("width", h), p("height", d);
  const g = [
    i.left,
    i.top,
    l,
    u
  ];
  return f.viewBox = g.join(" "), {
    attributes: f,
    viewBox: g,
    body: a
  };
}
const boe = /\sid="(\S+)"/g, x8 = /* @__PURE__ */ new Map();
function woe(t) {
  t = t.replace(/[0-9]+$/, "") || "a";
  const e = x8.get(t) || 0;
  return x8.set(t, e + 1), e ? `${t}${e}` : t;
}
function Toe(t) {
  const e = [];
  let r;
  for (; r = boe.exec(t); ) e.push(r[1]);
  if (!e.length) return t;
  const n = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return e.forEach((i) => {
    const a = woe(i), s = i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    t = t.replace(new RegExp('([#;"])(' + s + ')([")]|\\.[a-z])', "g"), "$1" + a + n + "$3");
  }), t = t.replace(new RegExp(n, "g"), ""), t;
}
function Eoe(t, e) {
  let r = t.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const n in e) r += " " + n + '="' + e[n] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + r + ">" + t + "</svg>";
}
function qE() {
  return { async: !1, breaks: !1, extensions: null, gfm: !0, hooks: null, pedantic: !1, renderer: null, silent: !1, tokenizer: null, walkTokens: null };
}
var Ku = qE();
function gB(t) {
  Ku = t;
}
var K0 = { exec: () => null };
function kr(t, e = "") {
  let r = typeof t == "string" ? t : t.source, n = { replace: (i, a) => {
    let s = typeof a == "string" ? a : a.source;
    return s = s.replace(Fi.caret, "$1"), r = r.replace(i, s), n;
  }, getRegex: () => new RegExp(r, e) };
  return n;
}
var koe = (() => {
  try {
    return !!new RegExp("(?<=1)(?<!1)");
  } catch {
    return !1;
  }
})(), Fi = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] /, listReplaceTask: /^\[[ xX]\] +/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: (t) => new RegExp(`^( {0,3}${t})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}#`), htmlBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}<(?:[a-z].*>|!--)`, "i") }, Soe = /^(?:[ \t]*(?:\n|$))+/, Coe = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, Aoe = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, pg = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, _oe = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, WE = /(?:[*+-]|\d{1,9}[.)])/, mB = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, vB = kr(mB).replace(/bull/g, WE).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), Loe = kr(mB).replace(/bull/g, WE).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), YE = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, Roe = /^[^\n]+/, XE = /(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/, Moe = kr(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", XE).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), Noe = kr(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, WE).getRegex(), tx = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", jE = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, Ioe = kr("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", jE).replace("tag", tx).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), yB = kr(YE).replace("hr", pg).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", tx).getRegex(), Doe = kr(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", yB).getRegex(), KE = { blockquote: Doe, code: Coe, def: Moe, fences: Aoe, heading: _oe, hr: pg, html: Ioe, lheading: vB, list: Noe, newline: Soe, paragraph: yB, table: K0, text: Roe }, b8 = kr("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", pg).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", tx).getRegex(), Ooe = { ...KE, lheading: Loe, table: b8, paragraph: kr(YE).replace("hr", pg).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", b8).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", tx).getRegex() }, Poe = { ...KE, html: kr(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", jE).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: K0, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: kr(YE).replace("hr", pg).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", vB).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex() }, Boe = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, Foe = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, xB = /^( {2,}|\\)\n(?!\s*$)/, $oe = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, rx = /[\p{P}\p{S}]/u, ZE = /[\s\p{P}\p{S}]/u, bB = /[^\s\p{P}\p{S}]/u, zoe = kr(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, ZE).getRegex(), wB = /(?!~)[\p{P}\p{S}]/u, Goe = /(?!~)[\s\p{P}\p{S}]/u, Voe = /(?:[^\s\p{P}\p{S}]|~)/u, Uoe = kr(/link|precode-code|html/, "g").replace("link", /\[(?:[^\[\]`]|(?<a>`+)[^`]+\k<a>(?!`))*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)/).replace("precode-", koe ? "(?<!`)()" : "(^^|[^`])").replace("code", /(?<b>`+)[^`]+\k<b>(?!`)/).replace("html", /<(?! )[^<>]*?>/).getRegex(), TB = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, Hoe = kr(TB, "u").replace(/punct/g, rx).getRegex(), qoe = kr(TB, "u").replace(/punct/g, wB).getRegex(), EB = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", Woe = kr(EB, "gu").replace(/notPunctSpace/g, bB).replace(/punctSpace/g, ZE).replace(/punct/g, rx).getRegex(), Yoe = kr(EB, "gu").replace(/notPunctSpace/g, Voe).replace(/punctSpace/g, Goe).replace(/punct/g, wB).getRegex(), Xoe = kr("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, bB).replace(/punctSpace/g, ZE).replace(/punct/g, rx).getRegex(), joe = kr(/\\(punct)/, "gu").replace(/punct/g, rx).getRegex(), Koe = kr(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), Zoe = kr(jE).replace("(?:-->|$)", "-->").getRegex(), Qoe = kr("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", Zoe).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), ay = /(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/, Joe = kr(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", ay).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), kB = kr(/^!?\[(label)\]\[(ref)\]/).replace("label", ay).replace("ref", XE).getRegex(), SB = kr(/^!?\[(ref)\](?:\[\])?/).replace("ref", XE).getRegex(), ele = kr("reflink|nolink(?!\\()", "g").replace("reflink", kB).replace("nolink", SB).getRegex(), w8 = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/, QE = { _backpedal: K0, anyPunctuation: joe, autolink: Koe, blockSkip: Uoe, br: xB, code: Foe, del: K0, emStrongLDelim: Hoe, emStrongRDelimAst: Woe, emStrongRDelimUnd: Xoe, escape: Boe, link: Joe, nolink: SB, punctuation: zoe, reflink: kB, reflinkSearch: ele, tag: Qoe, text: $oe, url: K0 }, tle = { ...QE, link: kr(/^!?\[(label)\]\((.*?)\)/).replace("label", ay).getRegex(), reflink: kr(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", ay).getRegex() }, Pw = { ...QE, emStrongRDelimAst: Yoe, emStrongLDelim: qoe, url: kr(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("protocol", w8).replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/, text: kr(/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/).replace("protocol", w8).getRegex() }, rle = { ...Pw, br: kr(xB).replace("{2,}", "*").getRegex(), text: kr(Pw.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }, u1 = { normal: KE, gfm: Ooe, pedantic: Poe }, Cf = { normal: QE, gfm: Pw, breaks: rle, pedantic: tle }, nle = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, T8 = (t) => nle[t];
function $s(t, e) {
  if (e) {
    if (Fi.escapeTest.test(t)) return t.replace(Fi.escapeReplace, T8);
  } else if (Fi.escapeTestNoEncode.test(t)) return t.replace(Fi.escapeReplaceNoEncode, T8);
  return t;
}
function E8(t) {
  try {
    t = encodeURI(t).replace(Fi.percentDecode, "%");
  } catch {
    return null;
  }
  return t;
}
function k8(t, e) {
  let r = t.replace(Fi.findPipe, (a, s, o) => {
    let l = !1, u = s;
    for (; --u >= 0 && o[u] === "\\"; ) l = !l;
    return l ? "|" : " |";
  }), n = r.split(Fi.splitPipe), i = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !n.at(-1)?.trim() && n.pop(), e) if (n.length > e) n.splice(e);
  else for (; n.length < e; ) n.push("");
  for (; i < n.length; i++) n[i] = n[i].trim().replace(Fi.slashPipe, "|");
  return n;
}
function Af(t, e, r) {
  let n = t.length;
  if (n === 0) return "";
  let i = 0;
  for (; i < n && t.charAt(n - i - 1) === e; )
    i++;
  return t.slice(0, n - i);
}
function ile(t, e) {
  if (t.indexOf(e[1]) === -1) return -1;
  let r = 0;
  for (let n = 0; n < t.length; n++) if (t[n] === "\\") n++;
  else if (t[n] === e[0]) r++;
  else if (t[n] === e[1] && (r--, r < 0)) return n;
  return r > 0 ? -2 : -1;
}
function S8(t, e, r, n, i) {
  let a = e.href, s = e.title || null, o = t[1].replace(i.other.outputLinkReplace, "$1");
  n.state.inLink = !0;
  let l = { type: t[0].charAt(0) === "!" ? "image" : "link", raw: r, href: a, title: s, text: o, tokens: n.inlineTokens(o) };
  return n.state.inLink = !1, l;
}
function ale(t, e, r) {
  let n = t.match(r.other.indentCodeCompensation);
  if (n === null) return e;
  let i = n[1];
  return e.split(`
`).map((a) => {
    let s = a.match(r.other.beginningSpace);
    if (s === null) return a;
    let [o] = s;
    return o.length >= i.length ? a.slice(i.length) : a;
  }).join(`
`);
}
var sy = class {
  options;
  rules;
  lexer;
  constructor(e) {
    this.options = e || Ku;
  }
  space(e) {
    let r = this.rules.block.newline.exec(e);
    if (r && r[0].length > 0) return { type: "space", raw: r[0] };
  }
  code(e) {
    let r = this.rules.block.code.exec(e);
    if (r) {
      let n = r[0].replace(this.rules.other.codeRemoveIndent, "");
      return { type: "code", raw: r[0], codeBlockStyle: "indented", text: this.options.pedantic ? n : Af(n, `
`) };
    }
  }
  fences(e) {
    let r = this.rules.block.fences.exec(e);
    if (r) {
      let n = r[0], i = ale(n, r[3] || "", this.rules);
      return { type: "code", raw: n, lang: r[2] ? r[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : r[2], text: i };
    }
  }
  heading(e) {
    let r = this.rules.block.heading.exec(e);
    if (r) {
      let n = r[2].trim();
      if (this.rules.other.endingHash.test(n)) {
        let i = Af(n, "#");
        (this.options.pedantic || !i || this.rules.other.endingSpaceChar.test(i)) && (n = i.trim());
      }
      return { type: "heading", raw: r[0], depth: r[1].length, text: n, tokens: this.lexer.inline(n) };
    }
  }
  hr(e) {
    let r = this.rules.block.hr.exec(e);
    if (r) return { type: "hr", raw: Af(r[0], `
`) };
  }
  blockquote(e) {
    let r = this.rules.block.blockquote.exec(e);
    if (r) {
      let n = Af(r[0], `
`).split(`
`), i = "", a = "", s = [];
      for (; n.length > 0; ) {
        let o = !1, l = [], u;
        for (u = 0; u < n.length; u++) if (this.rules.other.blockquoteStart.test(n[u])) l.push(n[u]), o = !0;
        else if (!o) l.push(n[u]);
        else break;
        n = n.slice(u);
        let h = l.join(`
`), d = h.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        i = i ? `${i}
${h}` : h, a = a ? `${a}
${d}` : d;
        let f = this.lexer.state.top;
        if (this.lexer.state.top = !0, this.lexer.blockTokens(d, s, !0), this.lexer.state.top = f, n.length === 0) break;
        let p = s.at(-1);
        if (p?.type === "code") break;
        if (p?.type === "blockquote") {
          let g = p, m = g.raw + `
` + n.join(`
`), v = this.blockquote(m);
          s[s.length - 1] = v, i = i.substring(0, i.length - g.raw.length) + v.raw, a = a.substring(0, a.length - g.text.length) + v.text;
          break;
        } else if (p?.type === "list") {
          let g = p, m = g.raw + `
` + n.join(`
`), v = this.list(m);
          s[s.length - 1] = v, i = i.substring(0, i.length - p.raw.length) + v.raw, a = a.substring(0, a.length - g.raw.length) + v.raw, n = m.substring(s.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return { type: "blockquote", raw: i, tokens: s, text: a };
    }
  }
  list(e) {
    let r = this.rules.block.list.exec(e);
    if (r) {
      let n = r[1].trim(), i = n.length > 1, a = { type: "list", raw: "", ordered: i, start: i ? +n.slice(0, -1) : "", loose: !1, items: [] };
      n = i ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`, this.options.pedantic && (n = i ? n : "[*+-]");
      let s = this.rules.other.listItemRegex(n), o = !1;
      for (; e; ) {
        let u = !1, h = "", d = "";
        if (!(r = s.exec(e)) || this.rules.block.hr.test(e)) break;
        h = r[0], e = e.substring(h.length);
        let f = r[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (b) => " ".repeat(3 * b.length)), p = e.split(`
`, 1)[0], g = !f.trim(), m = 0;
        if (this.options.pedantic ? (m = 2, d = f.trimStart()) : g ? m = r[1].length + 1 : (m = r[2].search(this.rules.other.nonSpaceChar), m = m > 4 ? 1 : m, d = f.slice(m), m += r[1].length), g && this.rules.other.blankLine.test(p) && (h += p + `
`, e = e.substring(p.length + 1), u = !0), !u) {
          let b = this.rules.other.nextBulletRegex(m), w = this.rules.other.hrRegex(m), T = this.rules.other.fencesBeginRegex(m), E = this.rules.other.headingBeginRegex(m), L = this.rules.other.htmlBeginRegex(m);
          for (; e; ) {
            let k = e.split(`
`, 1)[0], C;
            if (p = k, this.options.pedantic ? (p = p.replace(this.rules.other.listReplaceNesting, "  "), C = p) : C = p.replace(this.rules.other.tabCharGlobal, "    "), T.test(p) || E.test(p) || L.test(p) || b.test(p) || w.test(p)) break;
            if (C.search(this.rules.other.nonSpaceChar) >= m || !p.trim()) d += `
` + C.slice(m);
            else {
              if (g || f.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || T.test(f) || E.test(f) || w.test(f)) break;
              d += `
` + p;
            }
            !g && !p.trim() && (g = !0), h += k + `
`, e = e.substring(k.length + 1), f = C.slice(m);
          }
        }
        a.loose || (o ? a.loose = !0 : this.rules.other.doubleBlankLine.test(h) && (o = !0));
        let v = null, y;
        this.options.gfm && (v = this.rules.other.listIsTask.exec(d), v && (y = v[0] !== "[ ] ", d = d.replace(this.rules.other.listReplaceTask, ""))), a.items.push({ type: "list_item", raw: h, task: !!v, checked: y, loose: !1, text: d, tokens: [] }), a.raw += h;
      }
      let l = a.items.at(-1);
      if (l) l.raw = l.raw.trimEnd(), l.text = l.text.trimEnd();
      else return;
      a.raw = a.raw.trimEnd();
      for (let u = 0; u < a.items.length; u++) if (this.lexer.state.top = !1, a.items[u].tokens = this.lexer.blockTokens(a.items[u].text, []), !a.loose) {
        let h = a.items[u].tokens.filter((f) => f.type === "space"), d = h.length > 0 && h.some((f) => this.rules.other.anyLine.test(f.raw));
        a.loose = d;
      }
      if (a.loose) for (let u = 0; u < a.items.length; u++) a.items[u].loose = !0;
      return a;
    }
  }
  html(e) {
    let r = this.rules.block.html.exec(e);
    if (r) return { type: "html", block: !0, raw: r[0], pre: r[1] === "pre" || r[1] === "script" || r[1] === "style", text: r[0] };
  }
  def(e) {
    let r = this.rules.block.def.exec(e);
    if (r) {
      let n = r[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), i = r[2] ? r[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", a = r[3] ? r[3].substring(1, r[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : r[3];
      return { type: "def", tag: n, raw: r[0], href: i, title: a };
    }
  }
  table(e) {
    let r = this.rules.block.table.exec(e);
    if (!r || !this.rules.other.tableDelimiter.test(r[2])) return;
    let n = k8(r[1]), i = r[2].replace(this.rules.other.tableAlignChars, "").split("|"), a = r[3]?.trim() ? r[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], s = { type: "table", raw: r[0], header: [], align: [], rows: [] };
    if (n.length === i.length) {
      for (let o of i) this.rules.other.tableAlignRight.test(o) ? s.align.push("right") : this.rules.other.tableAlignCenter.test(o) ? s.align.push("center") : this.rules.other.tableAlignLeft.test(o) ? s.align.push("left") : s.align.push(null);
      for (let o = 0; o < n.length; o++) s.header.push({ text: n[o], tokens: this.lexer.inline(n[o]), header: !0, align: s.align[o] });
      for (let o of a) s.rows.push(k8(o, s.header.length).map((l, u) => ({ text: l, tokens: this.lexer.inline(l), header: !1, align: s.align[u] })));
      return s;
    }
  }
  lheading(e) {
    let r = this.rules.block.lheading.exec(e);
    if (r) return { type: "heading", raw: r[0], depth: r[2].charAt(0) === "=" ? 1 : 2, text: r[1], tokens: this.lexer.inline(r[1]) };
  }
  paragraph(e) {
    let r = this.rules.block.paragraph.exec(e);
    if (r) {
      let n = r[1].charAt(r[1].length - 1) === `
` ? r[1].slice(0, -1) : r[1];
      return { type: "paragraph", raw: r[0], text: n, tokens: this.lexer.inline(n) };
    }
  }
  text(e) {
    let r = this.rules.block.text.exec(e);
    if (r) return { type: "text", raw: r[0], text: r[0], tokens: this.lexer.inline(r[0]) };
  }
  escape(e) {
    let r = this.rules.inline.escape.exec(e);
    if (r) return { type: "escape", raw: r[0], text: r[1] };
  }
  tag(e) {
    let r = this.rules.inline.tag.exec(e);
    if (r) return !this.lexer.state.inLink && this.rules.other.startATag.test(r[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && this.rules.other.endATag.test(r[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(r[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(r[0]) && (this.lexer.state.inRawBlock = !1), { type: "html", raw: r[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: !1, text: r[0] };
  }
  link(e) {
    let r = this.rules.inline.link.exec(e);
    if (r) {
      let n = r[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(n)) {
        if (!this.rules.other.endAngleBracket.test(n)) return;
        let s = Af(n.slice(0, -1), "\\");
        if ((n.length - s.length) % 2 === 0) return;
      } else {
        let s = ile(r[2], "()");
        if (s === -2) return;
        if (s > -1) {
          let o = (r[0].indexOf("!") === 0 ? 5 : 4) + r[1].length + s;
          r[2] = r[2].substring(0, s), r[0] = r[0].substring(0, o).trim(), r[3] = "";
        }
      }
      let i = r[2], a = "";
      if (this.options.pedantic) {
        let s = this.rules.other.pedanticHrefTitle.exec(i);
        s && (i = s[1], a = s[3]);
      } else a = r[3] ? r[3].slice(1, -1) : "";
      return i = i.trim(), this.rules.other.startAngleBracket.test(i) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(n) ? i = i.slice(1) : i = i.slice(1, -1)), S8(r, { href: i && i.replace(this.rules.inline.anyPunctuation, "$1"), title: a && a.replace(this.rules.inline.anyPunctuation, "$1") }, r[0], this.lexer, this.rules);
    }
  }
  reflink(e, r) {
    let n;
    if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
      let i = (n[2] || n[1]).replace(this.rules.other.multipleSpaceGlobal, " "), a = r[i.toLowerCase()];
      if (!a) {
        let s = n[0].charAt(0);
        return { type: "text", raw: s, text: s };
      }
      return S8(n, a, n[0], this.lexer, this.rules);
    }
  }
  emStrong(e, r, n = "") {
    let i = this.rules.inline.emStrongLDelim.exec(e);
    if (!(!i || i[3] && n.match(this.rules.other.unicodeAlphaNumeric)) && (!(i[1] || i[2]) || !n || this.rules.inline.punctuation.exec(n))) {
      let a = [...i[0]].length - 1, s, o, l = a, u = 0, h = i[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (h.lastIndex = 0, r = r.slice(-1 * e.length + a); (i = h.exec(r)) != null; ) {
        if (s = i[1] || i[2] || i[3] || i[4] || i[5] || i[6], !s) continue;
        if (o = [...s].length, i[3] || i[4]) {
          l += o;
          continue;
        } else if ((i[5] || i[6]) && a % 3 && !((a + o) % 3)) {
          u += o;
          continue;
        }
        if (l -= o, l > 0) continue;
        o = Math.min(o, o + l + u);
        let d = [...i[0]][0].length, f = e.slice(0, a + i.index + d + o);
        if (Math.min(a, o) % 2) {
          let g = f.slice(1, -1);
          return { type: "em", raw: f, text: g, tokens: this.lexer.inlineTokens(g) };
        }
        let p = f.slice(2, -2);
        return { type: "strong", raw: f, text: p, tokens: this.lexer.inlineTokens(p) };
      }
    }
  }
  codespan(e) {
    let r = this.rules.inline.code.exec(e);
    if (r) {
      let n = r[2].replace(this.rules.other.newLineCharGlobal, " "), i = this.rules.other.nonSpaceChar.test(n), a = this.rules.other.startingSpaceChar.test(n) && this.rules.other.endingSpaceChar.test(n);
      return i && a && (n = n.substring(1, n.length - 1)), { type: "codespan", raw: r[0], text: n };
    }
  }
  br(e) {
    let r = this.rules.inline.br.exec(e);
    if (r) return { type: "br", raw: r[0] };
  }
  del(e) {
    let r = this.rules.inline.del.exec(e);
    if (r) return { type: "del", raw: r[0], text: r[2], tokens: this.lexer.inlineTokens(r[2]) };
  }
  autolink(e) {
    let r = this.rules.inline.autolink.exec(e);
    if (r) {
      let n, i;
      return r[2] === "@" ? (n = r[1], i = "mailto:" + n) : (n = r[1], i = n), { type: "link", raw: r[0], text: n, href: i, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  url(e) {
    let r;
    if (r = this.rules.inline.url.exec(e)) {
      let n, i;
      if (r[2] === "@") n = r[0], i = "mailto:" + n;
      else {
        let a;
        do
          a = r[0], r[0] = this.rules.inline._backpedal.exec(r[0])?.[0] ?? "";
        while (a !== r[0]);
        n = r[0], r[1] === "www." ? i = "http://" + r[0] : i = r[0];
      }
      return { type: "link", raw: r[0], text: n, href: i, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  inlineText(e) {
    let r = this.rules.inline.text.exec(e);
    if (r) {
      let n = this.lexer.state.inRawBlock;
      return { type: "text", raw: r[0], text: r[0], escaped: n };
    }
  }
}, fs = class Bw {
  tokens;
  options;
  state;
  tokenizer;
  inlineQueue;
  constructor(e) {
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || Ku, this.options.tokenizer = this.options.tokenizer || new sy(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: !1, inRawBlock: !1, top: !0 };
    let r = { other: Fi, block: u1.normal, inline: Cf.normal };
    this.options.pedantic ? (r.block = u1.pedantic, r.inline = Cf.pedantic) : this.options.gfm && (r.block = u1.gfm, this.options.breaks ? r.inline = Cf.breaks : r.inline = Cf.gfm), this.tokenizer.rules = r;
  }
  static get rules() {
    return { block: u1, inline: Cf };
  }
  static lex(e, r) {
    return new Bw(r).lex(e);
  }
  static lexInline(e, r) {
    return new Bw(r).inlineTokens(e);
  }
  lex(e) {
    e = e.replace(Fi.carriageReturn, `
`), this.blockTokens(e, this.tokens);
    for (let r = 0; r < this.inlineQueue.length; r++) {
      let n = this.inlineQueue[r];
      this.inlineTokens(n.src, n.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, r = [], n = !1) {
    for (this.options.pedantic && (e = e.replace(Fi.tabCharGlobal, "    ").replace(Fi.spaceLine, "")); e; ) {
      let i;
      if (this.options.extensions?.block?.some((s) => (i = s.call({ lexer: this }, e, r)) ? (e = e.substring(i.raw.length), r.push(i), !0) : !1)) continue;
      if (i = this.tokenizer.space(e)) {
        e = e.substring(i.raw.length);
        let s = r.at(-1);
        i.raw.length === 1 && s !== void 0 ? s.raw += `
` : r.push(i);
        continue;
      }
      if (i = this.tokenizer.code(e)) {
        e = e.substring(i.raw.length);
        let s = r.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + i.raw, s.text += `
` + i.text, this.inlineQueue.at(-1).src = s.text) : r.push(i);
        continue;
      }
      if (i = this.tokenizer.fences(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.heading(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.hr(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.blockquote(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.list(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.html(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.def(e)) {
        e = e.substring(i.raw.length);
        let s = r.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + i.raw, s.text += `
` + i.raw, this.inlineQueue.at(-1).src = s.text) : this.tokens.links[i.tag] || (this.tokens.links[i.tag] = { href: i.href, title: i.title }, r.push(i));
        continue;
      }
      if (i = this.tokenizer.table(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.lheading(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      let a = e;
      if (this.options.extensions?.startBlock) {
        let s = 1 / 0, o = e.slice(1), l;
        this.options.extensions.startBlock.forEach((u) => {
          l = u.call({ lexer: this }, o), typeof l == "number" && l >= 0 && (s = Math.min(s, l));
        }), s < 1 / 0 && s >= 0 && (a = e.substring(0, s + 1));
      }
      if (this.state.top && (i = this.tokenizer.paragraph(a))) {
        let s = r.at(-1);
        n && s?.type === "paragraph" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + i.raw, s.text += `
` + i.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : r.push(i), n = a.length !== e.length, e = e.substring(i.raw.length);
        continue;
      }
      if (i = this.tokenizer.text(e)) {
        e = e.substring(i.raw.length);
        let s = r.at(-1);
        s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + i.raw, s.text += `
` + i.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : r.push(i);
        continue;
      }
      if (e) {
        let s = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(s);
          break;
        } else throw new Error(s);
      }
    }
    return this.state.top = !0, r;
  }
  inline(e, r = []) {
    return this.inlineQueue.push({ src: e, tokens: r }), r;
  }
  inlineTokens(e, r = []) {
    let n = e, i = null;
    if (this.tokens.links) {
      let l = Object.keys(this.tokens.links);
      if (l.length > 0) for (; (i = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null; ) l.includes(i[0].slice(i[0].lastIndexOf("[") + 1, -1)) && (n = n.slice(0, i.index) + "[" + "a".repeat(i[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (i = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null; ) n = n.slice(0, i.index) + "++" + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    let a;
    for (; (i = this.tokenizer.rules.inline.blockSkip.exec(n)) != null; ) a = i[2] ? i[2].length : 0, n = n.slice(0, i.index + a) + "[" + "a".repeat(i[0].length - a - 2) + "]" + n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    n = this.options.hooks?.emStrongMask?.call({ lexer: this }, n) ?? n;
    let s = !1, o = "";
    for (; e; ) {
      s || (o = ""), s = !1;
      let l;
      if (this.options.extensions?.inline?.some((h) => (l = h.call({ lexer: this }, e, r)) ? (e = e.substring(l.raw.length), r.push(l), !0) : !1)) continue;
      if (l = this.tokenizer.escape(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.tag(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.link(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.reflink(e, this.tokens.links)) {
        e = e.substring(l.raw.length);
        let h = r.at(-1);
        l.type === "text" && h?.type === "text" ? (h.raw += l.raw, h.text += l.text) : r.push(l);
        continue;
      }
      if (l = this.tokenizer.emStrong(e, n, o)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.codespan(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.br(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.del(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.autolink(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (!this.state.inLink && (l = this.tokenizer.url(e))) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      let u = e;
      if (this.options.extensions?.startInline) {
        let h = 1 / 0, d = e.slice(1), f;
        this.options.extensions.startInline.forEach((p) => {
          f = p.call({ lexer: this }, d), typeof f == "number" && f >= 0 && (h = Math.min(h, f));
        }), h < 1 / 0 && h >= 0 && (u = e.substring(0, h + 1));
      }
      if (l = this.tokenizer.inlineText(u)) {
        e = e.substring(l.raw.length), l.raw.slice(-1) !== "_" && (o = l.raw.slice(-1)), s = !0;
        let h = r.at(-1);
        h?.type === "text" ? (h.raw += l.raw, h.text += l.text) : r.push(l);
        continue;
      }
      if (e) {
        let h = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(h);
          break;
        } else throw new Error(h);
      }
    }
    return r;
  }
}, oy = class {
  options;
  parser;
  constructor(e) {
    this.options = e || Ku;
  }
  space(e) {
    return "";
  }
  code({ text: e, lang: r, escaped: n }) {
    let i = (r || "").match(Fi.notSpaceStart)?.[0], a = e.replace(Fi.endingNewline, "") + `
`;
    return i ? '<pre><code class="language-' + $s(i) + '">' + (n ? a : $s(a, !0)) + `</code></pre>
` : "<pre><code>" + (n ? a : $s(a, !0)) + `</code></pre>
`;
  }
  blockquote({ tokens: e }) {
    return `<blockquote>
${this.parser.parse(e)}</blockquote>
`;
  }
  html({ text: e }) {
    return e;
  }
  def(e) {
    return "";
  }
  heading({ tokens: e, depth: r }) {
    return `<h${r}>${this.parser.parseInline(e)}</h${r}>
`;
  }
  hr(e) {
    return `<hr>
`;
  }
  list(e) {
    let r = e.ordered, n = e.start, i = "";
    for (let o = 0; o < e.items.length; o++) {
      let l = e.items[o];
      i += this.listitem(l);
    }
    let a = r ? "ol" : "ul", s = r && n !== 1 ? ' start="' + n + '"' : "";
    return "<" + a + s + `>
` + i + "</" + a + `>
`;
  }
  listitem(e) {
    let r = "";
    if (e.task) {
      let n = this.checkbox({ checked: !!e.checked });
      e.loose ? e.tokens[0]?.type === "paragraph" ? (e.tokens[0].text = n + " " + e.tokens[0].text, e.tokens[0].tokens && e.tokens[0].tokens.length > 0 && e.tokens[0].tokens[0].type === "text" && (e.tokens[0].tokens[0].text = n + " " + $s(e.tokens[0].tokens[0].text), e.tokens[0].tokens[0].escaped = !0)) : e.tokens.unshift({ type: "text", raw: n + " ", text: n + " ", escaped: !0 }) : r += n + " ";
    }
    return r += this.parser.parse(e.tokens, !!e.loose), `<li>${r}</li>
`;
  }
  checkbox({ checked: e }) {
    return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: e }) {
    return `<p>${this.parser.parseInline(e)}</p>
`;
  }
  table(e) {
    let r = "", n = "";
    for (let a = 0; a < e.header.length; a++) n += this.tablecell(e.header[a]);
    r += this.tablerow({ text: n });
    let i = "";
    for (let a = 0; a < e.rows.length; a++) {
      let s = e.rows[a];
      n = "";
      for (let o = 0; o < s.length; o++) n += this.tablecell(s[o]);
      i += this.tablerow({ text: n });
    }
    return i && (i = `<tbody>${i}</tbody>`), `<table>
<thead>
` + r + `</thead>
` + i + `</table>
`;
  }
  tablerow({ text: e }) {
    return `<tr>
${e}</tr>
`;
  }
  tablecell(e) {
    let r = this.parser.parseInline(e.tokens), n = e.header ? "th" : "td";
    return (e.align ? `<${n} align="${e.align}">` : `<${n}>`) + r + `</${n}>
`;
  }
  strong({ tokens: e }) {
    return `<strong>${this.parser.parseInline(e)}</strong>`;
  }
  em({ tokens: e }) {
    return `<em>${this.parser.parseInline(e)}</em>`;
  }
  codespan({ text: e }) {
    return `<code>${$s(e, !0)}</code>`;
  }
  br(e) {
    return "<br>";
  }
  del({ tokens: e }) {
    return `<del>${this.parser.parseInline(e)}</del>`;
  }
  link({ href: e, title: r, tokens: n }) {
    let i = this.parser.parseInline(n), a = E8(e);
    if (a === null) return i;
    e = a;
    let s = '<a href="' + e + '"';
    return r && (s += ' title="' + $s(r) + '"'), s += ">" + i + "</a>", s;
  }
  image({ href: e, title: r, text: n, tokens: i }) {
    i && (n = this.parser.parseInline(i, this.parser.textRenderer));
    let a = E8(e);
    if (a === null) return $s(n);
    e = a;
    let s = `<img src="${e}" alt="${n}"`;
    return r && (s += ` title="${$s(r)}"`), s += ">", s;
  }
  text(e) {
    return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : "escaped" in e && e.escaped ? e.text : $s(e.text);
  }
}, JE = class {
  strong({ text: e }) {
    return e;
  }
  em({ text: e }) {
    return e;
  }
  codespan({ text: e }) {
    return e;
  }
  del({ text: e }) {
    return e;
  }
  html({ text: e }) {
    return e;
  }
  text({ text: e }) {
    return e;
  }
  link({ text: e }) {
    return "" + e;
  }
  image({ text: e }) {
    return "" + e;
  }
  br() {
    return "";
  }
}, ps = class Fw {
  options;
  renderer;
  textRenderer;
  constructor(e) {
    this.options = e || Ku, this.options.renderer = this.options.renderer || new oy(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new JE();
  }
  static parse(e, r) {
    return new Fw(r).parse(e);
  }
  static parseInline(e, r) {
    return new Fw(r).parseInline(e);
  }
  parse(e, r = !0) {
    let n = "";
    for (let i = 0; i < e.length; i++) {
      let a = e[i];
      if (this.options.extensions?.renderers?.[a.type]) {
        let o = a, l = this.options.extensions.renderers[o.type].call({ parser: this }, o);
        if (l !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "def", "paragraph", "text"].includes(o.type)) {
          n += l || "";
          continue;
        }
      }
      let s = a;
      switch (s.type) {
        case "space": {
          n += this.renderer.space(s);
          continue;
        }
        case "hr": {
          n += this.renderer.hr(s);
          continue;
        }
        case "heading": {
          n += this.renderer.heading(s);
          continue;
        }
        case "code": {
          n += this.renderer.code(s);
          continue;
        }
        case "table": {
          n += this.renderer.table(s);
          continue;
        }
        case "blockquote": {
          n += this.renderer.blockquote(s);
          continue;
        }
        case "list": {
          n += this.renderer.list(s);
          continue;
        }
        case "html": {
          n += this.renderer.html(s);
          continue;
        }
        case "def": {
          n += this.renderer.def(s);
          continue;
        }
        case "paragraph": {
          n += this.renderer.paragraph(s);
          continue;
        }
        case "text": {
          let o = s, l = this.renderer.text(o);
          for (; i + 1 < e.length && e[i + 1].type === "text"; ) o = e[++i], l += `
` + this.renderer.text(o);
          r ? n += this.renderer.paragraph({ type: "paragraph", raw: l, text: l, tokens: [{ type: "text", raw: l, text: l, escaped: !0 }] }) : n += l;
          continue;
        }
        default: {
          let o = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(o), "";
          throw new Error(o);
        }
      }
    }
    return n;
  }
  parseInline(e, r = this.renderer) {
    let n = "";
    for (let i = 0; i < e.length; i++) {
      let a = e[i];
      if (this.options.extensions?.renderers?.[a.type]) {
        let o = this.options.extensions.renderers[a.type].call({ parser: this }, a);
        if (o !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(a.type)) {
          n += o || "";
          continue;
        }
      }
      let s = a;
      switch (s.type) {
        case "escape": {
          n += r.text(s);
          break;
        }
        case "html": {
          n += r.html(s);
          break;
        }
        case "link": {
          n += r.link(s);
          break;
        }
        case "image": {
          n += r.image(s);
          break;
        }
        case "strong": {
          n += r.strong(s);
          break;
        }
        case "em": {
          n += r.em(s);
          break;
        }
        case "codespan": {
          n += r.codespan(s);
          break;
        }
        case "br": {
          n += r.br(s);
          break;
        }
        case "del": {
          n += r.del(s);
          break;
        }
        case "text": {
          n += r.text(s);
          break;
        }
        default: {
          let o = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(o), "";
          throw new Error(o);
        }
      }
    }
    return n;
  }
}, Xf = class {
  options;
  block;
  constructor(e) {
    this.options = e || Ku;
  }
  static passThroughHooks = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens", "emStrongMask"]);
  static passThroughHooksRespectAsync = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens"]);
  preprocess(e) {
    return e;
  }
  postprocess(e) {
    return e;
  }
  processAllTokens(e) {
    return e;
  }
  emStrongMask(e) {
    return e;
  }
  provideLexer() {
    return this.block ? fs.lex : fs.lexInline;
  }
  provideParser() {
    return this.block ? ps.parse : ps.parseInline;
  }
}, sle = class {
  defaults = qE();
  options = this.setOptions;
  parse = this.parseMarkdown(!0);
  parseInline = this.parseMarkdown(!1);
  Parser = ps;
  Renderer = oy;
  TextRenderer = JE;
  Lexer = fs;
  Tokenizer = sy;
  Hooks = Xf;
  constructor(...e) {
    this.use(...e);
  }
  walkTokens(e, r) {
    let n = [];
    for (let i of e) switch (n = n.concat(r.call(this, i)), i.type) {
      case "table": {
        let a = i;
        for (let s of a.header) n = n.concat(this.walkTokens(s.tokens, r));
        for (let s of a.rows) for (let o of s) n = n.concat(this.walkTokens(o.tokens, r));
        break;
      }
      case "list": {
        let a = i;
        n = n.concat(this.walkTokens(a.items, r));
        break;
      }
      default: {
        let a = i;
        this.defaults.extensions?.childTokens?.[a.type] ? this.defaults.extensions.childTokens[a.type].forEach((s) => {
          let o = a[s].flat(1 / 0);
          n = n.concat(this.walkTokens(o, r));
        }) : a.tokens && (n = n.concat(this.walkTokens(a.tokens, r)));
      }
    }
    return n;
  }
  use(...e) {
    let r = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return e.forEach((n) => {
      let i = { ...n };
      if (i.async = this.defaults.async || i.async || !1, n.extensions && (n.extensions.forEach((a) => {
        if (!a.name) throw new Error("extension name required");
        if ("renderer" in a) {
          let s = r.renderers[a.name];
          s ? r.renderers[a.name] = function(...o) {
            let l = a.renderer.apply(this, o);
            return l === !1 && (l = s.apply(this, o)), l;
          } : r.renderers[a.name] = a.renderer;
        }
        if ("tokenizer" in a) {
          if (!a.level || a.level !== "block" && a.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
          let s = r[a.level];
          s ? s.unshift(a.tokenizer) : r[a.level] = [a.tokenizer], a.start && (a.level === "block" ? r.startBlock ? r.startBlock.push(a.start) : r.startBlock = [a.start] : a.level === "inline" && (r.startInline ? r.startInline.push(a.start) : r.startInline = [a.start]));
        }
        "childTokens" in a && a.childTokens && (r.childTokens[a.name] = a.childTokens);
      }), i.extensions = r), n.renderer) {
        let a = this.defaults.renderer || new oy(this.defaults);
        for (let s in n.renderer) {
          if (!(s in a)) throw new Error(`renderer '${s}' does not exist`);
          if (["options", "parser"].includes(s)) continue;
          let o = s, l = n.renderer[o], u = a[o];
          a[o] = (...h) => {
            let d = l.apply(a, h);
            return d === !1 && (d = u.apply(a, h)), d || "";
          };
        }
        i.renderer = a;
      }
      if (n.tokenizer) {
        let a = this.defaults.tokenizer || new sy(this.defaults);
        for (let s in n.tokenizer) {
          if (!(s in a)) throw new Error(`tokenizer '${s}' does not exist`);
          if (["options", "rules", "lexer"].includes(s)) continue;
          let o = s, l = n.tokenizer[o], u = a[o];
          a[o] = (...h) => {
            let d = l.apply(a, h);
            return d === !1 && (d = u.apply(a, h)), d;
          };
        }
        i.tokenizer = a;
      }
      if (n.hooks) {
        let a = this.defaults.hooks || new Xf();
        for (let s in n.hooks) {
          if (!(s in a)) throw new Error(`hook '${s}' does not exist`);
          if (["options", "block"].includes(s)) continue;
          let o = s, l = n.hooks[o], u = a[o];
          Xf.passThroughHooks.has(s) ? a[o] = (h) => {
            if (this.defaults.async && Xf.passThroughHooksRespectAsync.has(s)) return (async () => {
              let f = await l.call(a, h);
              return u.call(a, f);
            })();
            let d = l.call(a, h);
            return u.call(a, d);
          } : a[o] = (...h) => {
            if (this.defaults.async) return (async () => {
              let f = await l.apply(a, h);
              return f === !1 && (f = await u.apply(a, h)), f;
            })();
            let d = l.apply(a, h);
            return d === !1 && (d = u.apply(a, h)), d;
          };
        }
        i.hooks = a;
      }
      if (n.walkTokens) {
        let a = this.defaults.walkTokens, s = n.walkTokens;
        i.walkTokens = function(o) {
          let l = [];
          return l.push(s.call(this, o)), a && (l = l.concat(a.call(this, o))), l;
        };
      }
      this.defaults = { ...this.defaults, ...i };
    }), this;
  }
  setOptions(e) {
    return this.defaults = { ...this.defaults, ...e }, this;
  }
  lexer(e, r) {
    return fs.lex(e, r ?? this.defaults);
  }
  parser(e, r) {
    return ps.parse(e, r ?? this.defaults);
  }
  parseMarkdown(e) {
    return (r, n) => {
      let i = { ...n }, a = { ...this.defaults, ...i }, s = this.onError(!!a.silent, !!a.async);
      if (this.defaults.async === !0 && i.async === !1) return s(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof r > "u" || r === null) return s(new Error("marked(): input parameter is undefined or null"));
      if (typeof r != "string") return s(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(r) + ", string expected"));
      if (a.hooks && (a.hooks.options = a, a.hooks.block = e), a.async) return (async () => {
        let o = a.hooks ? await a.hooks.preprocess(r) : r, l = await (a.hooks ? await a.hooks.provideLexer() : e ? fs.lex : fs.lexInline)(o, a), u = a.hooks ? await a.hooks.processAllTokens(l) : l;
        a.walkTokens && await Promise.all(this.walkTokens(u, a.walkTokens));
        let h = await (a.hooks ? await a.hooks.provideParser() : e ? ps.parse : ps.parseInline)(u, a);
        return a.hooks ? await a.hooks.postprocess(h) : h;
      })().catch(s);
      try {
        a.hooks && (r = a.hooks.preprocess(r));
        let o = (a.hooks ? a.hooks.provideLexer() : e ? fs.lex : fs.lexInline)(r, a);
        a.hooks && (o = a.hooks.processAllTokens(o)), a.walkTokens && this.walkTokens(o, a.walkTokens);
        let l = (a.hooks ? a.hooks.provideParser() : e ? ps.parse : ps.parseInline)(o, a);
        return a.hooks && (l = a.hooks.postprocess(l)), l;
      } catch (o) {
        return s(o);
      }
    };
  }
  onError(e, r) {
    return (n) => {
      if (n.message += `
Please report this to https://github.com/markedjs/marked.`, e) {
        let i = "<p>An error occurred:</p><pre>" + $s(n.message + "", !0) + "</pre>";
        return r ? Promise.resolve(i) : i;
      }
      if (r) return Promise.reject(n);
      throw n;
    };
  }
}, wu = new sle();
function _r(t, e) {
  return wu.parse(t, e);
}
_r.options = _r.setOptions = function(t) {
  return wu.setOptions(t), _r.defaults = wu.defaults, gB(_r.defaults), _r;
};
_r.getDefaults = qE;
_r.defaults = Ku;
_r.use = function(...t) {
  return wu.use(...t), _r.defaults = wu.defaults, gB(_r.defaults), _r;
};
_r.walkTokens = function(t, e) {
  return wu.walkTokens(t, e);
};
_r.parseInline = wu.parseInline;
_r.Parser = ps;
_r.parser = ps.parse;
_r.Renderer = oy;
_r.TextRenderer = JE;
_r.Lexer = fs;
_r.lexer = fs.lex;
_r.Tokenizer = sy;
_r.Hooks = Xf;
_r.parse = _r;
_r.options;
_r.setOptions;
_r.use;
_r.walkTokens;
_r.parseInline;
ps.parse;
fs.lex;
function CB(t) {
  for (var e = [], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  var n = Array.from(typeof t == "string" ? [t] : t);
  n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var i = n.reduce(function(o, l) {
    var u = l.match(/\n([\t ]+|(?!\s).)/g);
    return u ? o.concat(u.map(function(h) {
      var d, f;
      return (f = (d = h.match(/[\t ]/g)) === null || d === void 0 ? void 0 : d.length) !== null && f !== void 0 ? f : 0;
    })) : o;
  }, []);
  if (i.length) {
    var a = new RegExp(`
[	 ]{` + Math.min.apply(Math, i) + "}", "g");
    n = n.map(function(o) {
      return o.replace(a, `
`);
    });
  }
  n[0] = n[0].replace(/^\r?\n/, "");
  var s = n[0];
  return e.forEach(function(o, l) {
    var u = s.match(/(?:^|\n)( *)$/), h = u ? u[1] : "", d = o;
    typeof o == "string" && o.includes(`
`) && (d = String(o).split(`
`).map(function(f, p) {
      return p === 0 ? f : "" + h + f;
    }).join(`
`)), s += d + n[l + 1];
  }), s;
}
var AB = {
  body: '<g><rect width="80" height="80" style="fill: #087ebf; stroke-width: 0px;"/><text transform="translate(21.16 64.67)" style="fill: #fff; font-family: ArialMT, Arial; font-size: 67.75px;"><tspan x="0" y="0">?</tspan></text></g>',
  height: 80,
  width: 80
}, $w = /* @__PURE__ */ new Map(), _B = /* @__PURE__ */ new Map(), LB = /* @__PURE__ */ x((t) => {
  for (const e of t) {
    if (!e.name)
      throw new Error(
        'Invalid icon loader. Must have a "name" property with non-empty string value.'
      );
    if (ie.debug("Registering icon pack:", e.name), "loader" in e)
      _B.set(e.name, e.loader);
    else if ("icons" in e)
      $w.set(e.name, e.icons);
    else
      throw ie.error("Invalid icon loader:", e), new Error('Invalid icon loader. Must have either "icons" or "loader" property.');
  }
}, "registerIconPacks"), RB = /* @__PURE__ */ x(async (t, e) => {
  const r = coe(t, !0, e !== void 0);
  if (!r)
    throw new Error(`Invalid icon name: ${t}`);
  const n = r.prefix || e;
  if (!n)
    throw new Error(`Icon name must contain a prefix: ${t}`);
  let i = $w.get(n);
  if (!i) {
    const s = _B.get(n);
    if (!s)
      throw new Error(`Icon set not found: ${r.prefix}`);
    try {
      i = { ...await s(), prefix: n }, $w.set(n, i);
    } catch (o) {
      throw ie.error(o), new Error(`Failed to load icon set: ${r.prefix}`);
    }
  }
  const a = doe(i, r.name);
  if (!a)
    throw new Error(`Icon not found: ${t}`);
  return a;
}, "getRegisteredIconData"), ole = /* @__PURE__ */ x(async (t) => {
  try {
    return await RB(t), !0;
  } catch {
    return !1;
  }
}, "isIconAvailable"), ql = /* @__PURE__ */ x(async (t, e, r) => {
  let n;
  try {
    n = await RB(t, e?.fallbackPrefix);
  } catch (s) {
    ie.error(s), n = AB;
  }
  const i = xoe(n, e), a = Eoe(Toe(i.body), {
    ...i.attributes,
    ...r
  });
  return dr(a, pr());
}, "getIconSVG");
function MB(t, { markdownAutoWrap: e }) {
  const n = t.replace(/<br\/>/g, `
`).replace(/\n{2,}/g, `
`), i = CB(n);
  return e === !1 ? i.replace(/ /g, "&nbsp;") : i;
}
x(MB, "preprocessMarkdown");
function NB(t, e = {}) {
  const r = MB(t, e), n = _r.lexer(r), i = [[]];
  let a = 0;
  function s(o, l = "normal") {
    o.type === "text" ? o.text.split(`
`).forEach((h, d) => {
      d !== 0 && (a++, i.push([])), h.split(" ").forEach((f) => {
        f = f.replace(/&#39;/g, "'"), f && i[a].push({ content: f, type: l });
      });
    }) : o.type === "strong" || o.type === "em" ? o.tokens.forEach((u) => {
      s(u, o.type);
    }) : o.type === "html" && i[a].push({ content: o.text, type: "normal" });
  }
  return x(s, "processNode"), n.forEach((o) => {
    o.type === "paragraph" ? o.tokens?.forEach((l) => {
      s(l);
    }) : o.type === "html" ? i[a].push({ content: o.text, type: "normal" }) : i[a].push({ content: o.raw, type: "normal" });
  }), i;
}
x(NB, "markdownToLines");
function IB(t, { markdownAutoWrap: e } = {}) {
  const r = _r.lexer(t);
  function n(i) {
    return i.type === "text" ? e === !1 ? i.text.replace(/\n */g, "<br/>").replace(/ /g, "&nbsp;") : i.text.replace(/\n */g, "<br/>") : i.type === "strong" ? `<strong>${i.tokens?.map(n).join("")}</strong>` : i.type === "em" ? `<em>${i.tokens?.map(n).join("")}</em>` : i.type === "paragraph" ? `<p>${i.tokens?.map(n).join("")}</p>` : i.type === "space" ? "" : i.type === "html" ? `${i.text}` : i.type === "escape" ? i.text : (ie.warn(`Unsupported markdown: ${i.type}`), i.raw);
  }
  return x(n, "output"), r.map(n).join("");
}
x(IB, "markdownToHTML");
function DB(t) {
  return Intl.Segmenter ? [...new Intl.Segmenter().segment(t)].map((e) => e.segment) : [...t];
}
x(DB, "splitTextToChars");
function OB(t, e) {
  const r = DB(e.content);
  return ek(t, [], r, e.type);
}
x(OB, "splitWordToFitWidth");
function ek(t, e, r, n) {
  if (r.length === 0)
    return [
      { content: e.join(""), type: n },
      { content: "", type: n }
    ];
  const [i, ...a] = r, s = [...e, i];
  return t([{ content: s.join(""), type: n }]) ? ek(t, s, a, n) : (e.length === 0 && i && (e.push(i), r.shift()), [
    { content: e.join(""), type: n },
    { content: r.join(""), type: n }
  ]);
}
x(ek, "splitWordToFitWidthRecursion");
function PB(t, e) {
  if (t.some(({ content: r }) => r.includes(`
`)))
    throw new Error("splitLineToFitWidth does not support newlines in the line");
  return ly(t, e);
}
x(PB, "splitLineToFitWidth");
function ly(t, e, r = [], n = []) {
  if (t.length === 0)
    return n.length > 0 && r.push(n), r.length > 0 ? r : [];
  let i = "";
  t[0].content === " " && (i = " ", t.shift());
  const a = t.shift() ?? { content: " ", type: "normal" }, s = [...n];
  if (i !== "" && s.push({ content: i, type: "normal" }), s.push(a), e(s))
    return ly(t, e, r, s);
  if (n.length > 0)
    r.push(n), t.unshift(a);
  else if (a.content) {
    const [o, l] = OB(e, a);
    r.push([o]), l.content && t.unshift(l);
  }
  return ly(t, e, r);
}
x(ly, "splitLineToFitWidthRecursion");
function zw(t, e) {
  e && t.attr("style", e);
}
x(zw, "applyStyle");
async function BB(t, e, r, n, i = !1, a = pr()) {
  const s = t.append("foreignObject");
  s.attr("width", `${10 * r}px`), s.attr("height", `${10 * r}px`);
  const o = s.append("xhtml:div"), l = un(e.label) ? await sg(e.label.replace(at.lineBreakRegex, `
`), a) : dr(e.label, a), u = e.isNode ? "nodeLabel" : "edgeLabel", h = o.append("span");
  h.html(l), zw(h, e.labelStyle), h.attr("class", `${u} ${n}`), zw(o, e.labelStyle), o.style("display", "table-cell"), o.style("white-space", "nowrap"), o.style("line-height", "1.5"), o.style("max-width", r + "px"), o.style("text-align", "center"), o.attr("xmlns", "http://www.w3.org/1999/xhtml"), i && o.attr("class", "labelBkg");
  let d = o.node().getBoundingClientRect();
  return d.width === r && (o.style("display", "table"), o.style("white-space", "break-spaces"), o.style("width", r + "px"), d = o.node().getBoundingClientRect()), s.node();
}
x(BB, "addHtmlSpan");
function nx(t, e, r) {
  return t.append("tspan").attr("class", "text-outer-tspan").attr("x", 0).attr("y", e * r - 0.1 + "em").attr("dy", r + "em");
}
x(nx, "createTspan");
function FB(t, e, r) {
  const n = t.append("text"), i = nx(n, 1, e);
  ix(i, r);
  const a = i.node().getComputedTextLength();
  return n.remove(), a;
}
x(FB, "computeWidthOfText");
function $B(t, e, r) {
  const n = t.append("text"), i = nx(n, 1, e);
  ix(i, [{ content: r, type: "normal" }]);
  const a = i.node()?.getBoundingClientRect();
  return a && n.remove(), a;
}
x($B, "computeDimensionOfText");
function zB(t, e, r, n = !1) {
  const a = e.append("g"), s = a.insert("rect").attr("class", "background").attr("style", "stroke: none"), o = a.append("text").attr("y", "-10.1");
  let l = 0;
  for (const u of r) {
    const h = /* @__PURE__ */ x((f) => FB(a, 1.1, f) <= t, "checkWidth"), d = h(u) ? [u] : PB(u, h);
    for (const f of d) {
      const p = nx(o, l, 1.1);
      ix(p, f), l++;
    }
  }
  if (n) {
    const u = o.node().getBBox(), h = 2;
    return s.attr("x", u.x - h).attr("y", u.y - h).attr("width", u.width + 2 * h).attr("height", u.height + 2 * h), a.node();
  } else
    return o.node();
}
x(zB, "createFormattedText");
function ix(t, e) {
  t.text(""), e.forEach((r, n) => {
    const i = t.append("tspan").attr("font-style", r.type === "em" ? "italic" : "normal").attr("class", "text-inner-tspan").attr("font-weight", r.type === "strong" ? "bold" : "normal");
    n === 0 ? i.text(r.content) : i.text(" " + r.content);
  });
}
x(ix, "updateTextContentAndStyles");
async function tk(t, e = {}) {
  const r = [];
  t.replace(/(fa[bklrs]?):fa-([\w-]+)/g, (i, a, s) => (r.push(
    (async () => {
      const o = `${a}:${s}`;
      return await ole(o) ? await ql(o, void 0, { class: "label-icon" }) : `<i class='${dr(i, e).replace(":", " ")}'></i>`;
    })()
  ), i));
  const n = await Promise.all(r);
  return t.replace(/(fa[bklrs]?):fa-([\w-]+)/g, () => n.shift() ?? "");
}
x(tk, "replaceIconSubstring");
var La = /* @__PURE__ */ x(async (t, e = "", {
  style: r = "",
  isTitle: n = !1,
  classes: i = "",
  useHtmlLabels: a = !0,
  isNode: s = !0,
  width: o = 200,
  addSvgBackground: l = !1
} = {}, u) => {
  if (ie.debug(
    "XYZ createText",
    e,
    r,
    n,
    i,
    a,
    s,
    "addSvgBackground: ",
    l
  ), a) {
    const h = IB(e, u), d = await tk(ao(h), u), f = e.replace(/\\\\/g, "\\"), p = {
      isNode: s,
      label: un(e) ? f : d,
      labelStyle: r.replace("fill:", "color:")
    };
    return await BB(t, p, o, i, l, u);
  } else {
    const h = e.replace(/<br\s*\/?>/g, "<br/>"), d = NB(h.replace("<br>", "<br/>"), u), f = zB(
      o,
      t,
      d,
      e ? l : !1
    );
    if (s) {
      /stroke:/.exec(r) && (r = r.replace("stroke:", "lineColor:"));
      const p = r.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/color:/g, "fill:");
      Qe(f).attr("style", p);
    } else {
      const p = r.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/background:/g, "fill:");
      Qe(f).select("rect").attr("style", p.replace(/background:/g, "fill:"));
      const g = r.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/color:/g, "fill:");
      Qe(f).select("text").attr("style", g);
    }
    return f;
  }
}, "createText");
function n4(t, e, r) {
  if (t && t.length) {
    const [n, i] = e, a = Math.PI / 180 * r, s = Math.cos(a), o = Math.sin(a);
    for (const l of t) {
      const [u, h] = l;
      l[0] = (u - n) * s - (h - i) * o + n, l[1] = (u - n) * o + (h - i) * s + i;
    }
  }
}
function lle(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}
function cle(t, e, r, n = 1) {
  const i = r, a = Math.max(e, 0.1), s = t[0] && t[0][0] && typeof t[0][0] == "number" ? [t] : t, o = [0, 0];
  if (i) for (const u of s) n4(u, o, i);
  const l = (function(u, h, d) {
    const f = [];
    for (const b of u) {
      const w = [...b];
      lle(w[0], w[w.length - 1]) || w.push([w[0][0], w[0][1]]), w.length > 2 && f.push(w);
    }
    const p = [];
    h = Math.max(h, 0.1);
    const g = [];
    for (const b of f) for (let w = 0; w < b.length - 1; w++) {
      const T = b[w], E = b[w + 1];
      if (T[1] !== E[1]) {
        const L = Math.min(T[1], E[1]);
        g.push({ ymin: L, ymax: Math.max(T[1], E[1]), x: L === T[1] ? T[0] : E[0], islope: (E[0] - T[0]) / (E[1] - T[1]) });
      }
    }
    if (g.sort(((b, w) => b.ymin < w.ymin ? -1 : b.ymin > w.ymin ? 1 : b.x < w.x ? -1 : b.x > w.x ? 1 : b.ymax === w.ymax ? 0 : (b.ymax - w.ymax) / Math.abs(b.ymax - w.ymax))), !g.length) return p;
    let m = [], v = g[0].ymin, y = 0;
    for (; m.length || g.length; ) {
      if (g.length) {
        let b = -1;
        for (let w = 0; w < g.length && !(g[w].ymin > v); w++) b = w;
        g.splice(0, b + 1).forEach(((w) => {
          m.push({ s: v, edge: w });
        }));
      }
      if (m = m.filter(((b) => !(b.edge.ymax <= v))), m.sort(((b, w) => b.edge.x === w.edge.x ? 0 : (b.edge.x - w.edge.x) / Math.abs(b.edge.x - w.edge.x))), (d !== 1 || y % h == 0) && m.length > 1) for (let b = 0; b < m.length; b += 2) {
        const w = b + 1;
        if (w >= m.length) break;
        const T = m[b].edge, E = m[w].edge;
        p.push([[Math.round(T.x), v], [Math.round(E.x), v]]);
      }
      v += d, m.forEach(((b) => {
        b.edge.x = b.edge.x + d * b.edge.islope;
      })), y++;
    }
    return p;
  })(s, a, n);
  if (i) {
    for (const u of s) n4(u, o, -i);
    (function(u, h, d) {
      const f = [];
      u.forEach(((p) => f.push(...p))), n4(f, h, d);
    })(l, o, -i);
  }
  return l;
}
function gg(t, e) {
  var r;
  const n = e.hachureAngle + 90;
  let i = e.hachureGap;
  i < 0 && (i = 4 * e.strokeWidth), i = Math.round(Math.max(i, 0.1));
  let a = 1;
  return e.roughness >= 1 && (((r = e.randomizer) === null || r === void 0 ? void 0 : r.next()) || Math.random()) > 0.7 && (a = i), cle(t, i, n, a || 1);
}
class rk {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    return this._fillPolygons(e, r);
  }
  _fillPolygons(e, r) {
    const n = gg(e, r);
    return { type: "fillSketch", ops: this.renderLines(n, r) };
  }
  renderLines(e, r) {
    const n = [];
    for (const i of e) n.push(...this.helper.doubleLineOps(i[0][0], i[0][1], i[1][0], i[1][1], r));
    return n;
  }
}
function ax(t) {
  const e = t[0], r = t[1];
  return Math.sqrt(Math.pow(e[0] - r[0], 2) + Math.pow(e[1] - r[1], 2));
}
class ule extends rk {
  fillPolygons(e, r) {
    let n = r.hachureGap;
    n < 0 && (n = 4 * r.strokeWidth), n = Math.max(n, 0.1);
    const i = gg(e, Object.assign({}, r, { hachureGap: n })), a = Math.PI / 180 * r.hachureAngle, s = [], o = 0.5 * n * Math.cos(a), l = 0.5 * n * Math.sin(a);
    for (const [u, h] of i) ax([u, h]) && s.push([[u[0] - o, u[1] + l], [...h]], [[u[0] + o, u[1] - l], [...h]]);
    return { type: "fillSketch", ops: this.renderLines(s, r) };
  }
}
class hle extends rk {
  fillPolygons(e, r) {
    const n = this._fillPolygons(e, r), i = Object.assign({}, r, { hachureAngle: r.hachureAngle + 90 }), a = this._fillPolygons(e, i);
    return n.ops = n.ops.concat(a.ops), n;
  }
}
let dle = class {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    const n = gg(e, r = Object.assign({}, r, { hachureAngle: 0 }));
    return this.dotsOnLines(n, r);
  }
  dotsOnLines(e, r) {
    const n = [];
    let i = r.hachureGap;
    i < 0 && (i = 4 * r.strokeWidth), i = Math.max(i, 0.1);
    let a = r.fillWeight;
    a < 0 && (a = r.strokeWidth / 2);
    const s = i / 4;
    for (const o of e) {
      const l = ax(o), u = l / i, h = Math.ceil(u) - 1, d = l - h * i, f = (o[0][0] + o[1][0]) / 2 - i / 4, p = Math.min(o[0][1], o[1][1]);
      for (let g = 0; g < h; g++) {
        const m = p + d + g * i, v = f - s + 2 * Math.random() * s, y = m - s + 2 * Math.random() * s, b = this.helper.ellipse(v, y, a, a, r);
        n.push(...b.ops);
      }
    }
    return { type: "fillSketch", ops: n };
  }
}, fle = class {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    const n = gg(e, r);
    return { type: "fillSketch", ops: this.dashedLine(n, r) };
  }
  dashedLine(e, r) {
    const n = r.dashOffset < 0 ? r.hachureGap < 0 ? 4 * r.strokeWidth : r.hachureGap : r.dashOffset, i = r.dashGap < 0 ? r.hachureGap < 0 ? 4 * r.strokeWidth : r.hachureGap : r.dashGap, a = [];
    return e.forEach(((s) => {
      const o = ax(s), l = Math.floor(o / (n + i)), u = (o + i - l * (n + i)) / 2;
      let h = s[0], d = s[1];
      h[0] > d[0] && (h = s[1], d = s[0]);
      const f = Math.atan((d[1] - h[1]) / (d[0] - h[0]));
      for (let p = 0; p < l; p++) {
        const g = p * (n + i), m = g + n, v = [h[0] + g * Math.cos(f) + u * Math.cos(f), h[1] + g * Math.sin(f) + u * Math.sin(f)], y = [h[0] + m * Math.cos(f) + u * Math.cos(f), h[1] + m * Math.sin(f) + u * Math.sin(f)];
        a.push(...this.helper.doubleLineOps(v[0], v[1], y[0], y[1], r));
      }
    })), a;
  }
};
class ple {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    const n = r.hachureGap < 0 ? 4 * r.strokeWidth : r.hachureGap, i = r.zigzagOffset < 0 ? n : r.zigzagOffset, a = gg(e, r = Object.assign({}, r, { hachureGap: n + i }));
    return { type: "fillSketch", ops: this.zigzagLines(a, i, r) };
  }
  zigzagLines(e, r, n) {
    const i = [];
    return e.forEach(((a) => {
      const s = ax(a), o = Math.round(s / (2 * r));
      let l = a[0], u = a[1];
      l[0] > u[0] && (l = a[1], u = a[0]);
      const h = Math.atan((u[1] - l[1]) / (u[0] - l[0]));
      for (let d = 0; d < o; d++) {
        const f = 2 * d * r, p = 2 * (d + 1) * r, g = Math.sqrt(2 * Math.pow(r, 2)), m = [l[0] + f * Math.cos(h), l[1] + f * Math.sin(h)], v = [l[0] + p * Math.cos(h), l[1] + p * Math.sin(h)], y = [m[0] + g * Math.cos(h + Math.PI / 4), m[1] + g * Math.sin(h + Math.PI / 4)];
        i.push(...this.helper.doubleLineOps(m[0], m[1], y[0], y[1], n), ...this.helper.doubleLineOps(y[0], y[1], v[0], v[1], n));
      }
    })), i;
  }
}
const Ji = {};
let gle = class {
  constructor(e) {
    this.seed = e;
  }
  next() {
    return this.seed ? (2 ** 31 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31 : Math.random();
  }
};
const mle = 0, i4 = 1, C8 = 2, h1 = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };
function a4(t, e) {
  return t.type === e;
}
function nk(t) {
  const e = [], r = (function(s) {
    const o = new Array();
    for (; s !== ""; ) if (s.match(/^([ \t\r\n,]+)/)) s = s.substr(RegExp.$1.length);
    else if (s.match(/^([aAcChHlLmMqQsStTvVzZ])/)) o[o.length] = { type: mle, text: RegExp.$1 }, s = s.substr(RegExp.$1.length);
    else {
      if (!s.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) return [];
      o[o.length] = { type: i4, text: `${parseFloat(RegExp.$1)}` }, s = s.substr(RegExp.$1.length);
    }
    return o[o.length] = { type: C8, text: "" }, o;
  })(t);
  let n = "BOD", i = 0, a = r[i];
  for (; !a4(a, C8); ) {
    let s = 0;
    const o = [];
    if (n === "BOD") {
      if (a.text !== "M" && a.text !== "m") return nk("M0,0" + t);
      i++, s = h1[a.text], n = a.text;
    } else a4(a, i4) ? s = h1[n] : (i++, s = h1[a.text], n = a.text);
    if (!(i + s < r.length)) throw new Error("Path data ended short");
    for (let l = i; l < i + s; l++) {
      const u = r[l];
      if (!a4(u, i4)) throw new Error("Param not a number: " + n + "," + u.text);
      o[o.length] = +u.text;
    }
    if (typeof h1[n] != "number") throw new Error("Bad segment: " + n);
    {
      const l = { key: n, data: o };
      e.push(l), i += s, a = r[i], n === "M" && (n = "L"), n === "m" && (n = "l");
    }
  }
  return e;
}
function GB(t) {
  let e = 0, r = 0, n = 0, i = 0;
  const a = [];
  for (const { key: s, data: o } of t) switch (s) {
    case "M":
      a.push({ key: "M", data: [...o] }), [e, r] = o, [n, i] = o;
      break;
    case "m":
      e += o[0], r += o[1], a.push({ key: "M", data: [e, r] }), n = e, i = r;
      break;
    case "L":
      a.push({ key: "L", data: [...o] }), [e, r] = o;
      break;
    case "l":
      e += o[0], r += o[1], a.push({ key: "L", data: [e, r] });
      break;
    case "C":
      a.push({ key: "C", data: [...o] }), e = o[4], r = o[5];
      break;
    case "c": {
      const l = o.map(((u, h) => h % 2 ? u + r : u + e));
      a.push({ key: "C", data: l }), e = l[4], r = l[5];
      break;
    }
    case "Q":
      a.push({ key: "Q", data: [...o] }), e = o[2], r = o[3];
      break;
    case "q": {
      const l = o.map(((u, h) => h % 2 ? u + r : u + e));
      a.push({ key: "Q", data: l }), e = l[2], r = l[3];
      break;
    }
    case "A":
      a.push({ key: "A", data: [...o] }), e = o[5], r = o[6];
      break;
    case "a":
      e += o[5], r += o[6], a.push({ key: "A", data: [o[0], o[1], o[2], o[3], o[4], e, r] });
      break;
    case "H":
      a.push({ key: "H", data: [...o] }), e = o[0];
      break;
    case "h":
      e += o[0], a.push({ key: "H", data: [e] });
      break;
    case "V":
      a.push({ key: "V", data: [...o] }), r = o[0];
      break;
    case "v":
      r += o[0], a.push({ key: "V", data: [r] });
      break;
    case "S":
      a.push({ key: "S", data: [...o] }), e = o[2], r = o[3];
      break;
    case "s": {
      const l = o.map(((u, h) => h % 2 ? u + r : u + e));
      a.push({ key: "S", data: l }), e = l[2], r = l[3];
      break;
    }
    case "T":
      a.push({ key: "T", data: [...o] }), e = o[0], r = o[1];
      break;
    case "t":
      e += o[0], r += o[1], a.push({ key: "T", data: [e, r] });
      break;
    case "Z":
    case "z":
      a.push({ key: "Z", data: [] }), e = n, r = i;
  }
  return a;
}
function VB(t) {
  const e = [];
  let r = "", n = 0, i = 0, a = 0, s = 0, o = 0, l = 0;
  for (const { key: u, data: h } of t) {
    switch (u) {
      case "M":
        e.push({ key: "M", data: [...h] }), [n, i] = h, [a, s] = h;
        break;
      case "C":
        e.push({ key: "C", data: [...h] }), n = h[4], i = h[5], o = h[2], l = h[3];
        break;
      case "L":
        e.push({ key: "L", data: [...h] }), [n, i] = h;
        break;
      case "H":
        n = h[0], e.push({ key: "L", data: [n, i] });
        break;
      case "V":
        i = h[0], e.push({ key: "L", data: [n, i] });
        break;
      case "S": {
        let d = 0, f = 0;
        r === "C" || r === "S" ? (d = n + (n - o), f = i + (i - l)) : (d = n, f = i), e.push({ key: "C", data: [d, f, ...h] }), o = h[0], l = h[1], n = h[2], i = h[3];
        break;
      }
      case "T": {
        const [d, f] = h;
        let p = 0, g = 0;
        r === "Q" || r === "T" ? (p = n + (n - o), g = i + (i - l)) : (p = n, g = i);
        const m = n + 2 * (p - n) / 3, v = i + 2 * (g - i) / 3, y = d + 2 * (p - d) / 3, b = f + 2 * (g - f) / 3;
        e.push({ key: "C", data: [m, v, y, b, d, f] }), o = p, l = g, n = d, i = f;
        break;
      }
      case "Q": {
        const [d, f, p, g] = h, m = n + 2 * (d - n) / 3, v = i + 2 * (f - i) / 3, y = p + 2 * (d - p) / 3, b = g + 2 * (f - g) / 3;
        e.push({ key: "C", data: [m, v, y, b, p, g] }), o = d, l = f, n = p, i = g;
        break;
      }
      case "A": {
        const d = Math.abs(h[0]), f = Math.abs(h[1]), p = h[2], g = h[3], m = h[4], v = h[5], y = h[6];
        d === 0 || f === 0 ? (e.push({ key: "C", data: [n, i, v, y, v, y] }), n = v, i = y) : (n !== v || i !== y) && (UB(n, i, v, y, d, f, p, g, m).forEach((function(b) {
          e.push({ key: "C", data: b });
        })), n = v, i = y);
        break;
      }
      case "Z":
        e.push({ key: "Z", data: [] }), n = a, i = s;
    }
    r = u;
  }
  return e;
}
function _f(t, e, r) {
  return [t * Math.cos(r) - e * Math.sin(r), t * Math.sin(r) + e * Math.cos(r)];
}
function UB(t, e, r, n, i, a, s, o, l, u) {
  const h = (d = s, Math.PI * d / 180);
  var d;
  let f = [], p = 0, g = 0, m = 0, v = 0;
  if (u) [p, g, m, v] = u;
  else {
    [t, e] = _f(t, e, -h), [r, n] = _f(r, n, -h);
    const P = (t - r) / 2, S = (e - n) / 2;
    let M = P * P / (i * i) + S * S / (a * a);
    M > 1 && (M = Math.sqrt(M), i *= M, a *= M);
    const N = i * i, D = a * a, I = N * D - N * S * S - D * P * P, B = N * S * S + D * P * P, z = (o === l ? -1 : 1) * Math.sqrt(Math.abs(I / B));
    m = z * i * S / a + (t + r) / 2, v = z * -a * P / i + (e + n) / 2, p = Math.asin(parseFloat(((e - v) / a).toFixed(9))), g = Math.asin(parseFloat(((n - v) / a).toFixed(9))), t < m && (p = Math.PI - p), r < m && (g = Math.PI - g), p < 0 && (p = 2 * Math.PI + p), g < 0 && (g = 2 * Math.PI + g), l && p > g && (p -= 2 * Math.PI), !l && g > p && (g -= 2 * Math.PI);
  }
  let y = g - p;
  if (Math.abs(y) > 120 * Math.PI / 180) {
    const P = g, S = r, M = n;
    g = l && g > p ? p + 120 * Math.PI / 180 * 1 : p + 120 * Math.PI / 180 * -1, f = UB(r = m + i * Math.cos(g), n = v + a * Math.sin(g), S, M, i, a, s, 0, l, [g, P, m, v]);
  }
  y = g - p;
  const b = Math.cos(p), w = Math.sin(p), T = Math.cos(g), E = Math.sin(g), L = Math.tan(y / 4), k = 4 / 3 * i * L, C = 4 / 3 * a * L, A = [t, e], R = [t + k * w, e - C * b], _ = [r + k * E, n - C * T], O = [r, n];
  if (R[0] = 2 * A[0] - R[0], R[1] = 2 * A[1] - R[1], u) return [R, _, O].concat(f);
  {
    f = [R, _, O].concat(f);
    const P = [];
    for (let S = 0; S < f.length; S += 3) {
      const M = _f(f[S][0], f[S][1], h), N = _f(f[S + 1][0], f[S + 1][1], h), D = _f(f[S + 2][0], f[S + 2][1], h);
      P.push([M[0], M[1], N[0], N[1], D[0], D[1]]);
    }
    return P;
  }
}
const vle = { randOffset: function(t, e) {
  return qt(t, e);
}, randOffsetWithRange: function(t, e, r) {
  return cy(t, e, r);
}, ellipse: function(t, e, r, n, i) {
  const a = qB(r, n, i);
  return Gw(t, e, i, a).opset;
}, doubleLineOps: function(t, e, r, n, i) {
  return Wl(t, e, r, n, i, !0);
} };
function HB(t, e, r, n, i) {
  return { type: "path", ops: Wl(t, e, r, n, i) };
}
function Am(t, e, r) {
  const n = (t || []).length;
  if (n > 2) {
    const i = [];
    for (let a = 0; a < n - 1; a++) i.push(...Wl(t[a][0], t[a][1], t[a + 1][0], t[a + 1][1], r));
    return e && i.push(...Wl(t[n - 1][0], t[n - 1][1], t[0][0], t[0][1], r)), { type: "path", ops: i };
  }
  return n === 2 ? HB(t[0][0], t[0][1], t[1][0], t[1][1], r) : { type: "path", ops: [] };
}
function yle(t, e, r, n, i) {
  return (function(a, s) {
    return Am(a, !0, s);
  })([[t, e], [t + r, e], [t + r, e + n], [t, e + n]], i);
}
function A8(t, e) {
  if (t.length) {
    const r = typeof t[0][0] == "number" ? [t] : t, n = d1(r[0], 1 * (1 + 0.2 * e.roughness), e), i = e.disableMultiStroke ? [] : d1(r[0], 1.5 * (1 + 0.22 * e.roughness), R8(e));
    for (let a = 1; a < r.length; a++) {
      const s = r[a];
      if (s.length) {
        const o = d1(s, 1 * (1 + 0.2 * e.roughness), e), l = e.disableMultiStroke ? [] : d1(s, 1.5 * (1 + 0.22 * e.roughness), R8(e));
        for (const u of o) u.op !== "move" && n.push(u);
        for (const u of l) u.op !== "move" && i.push(u);
      }
    }
    return { type: "path", ops: n.concat(i) };
  }
  return { type: "path", ops: [] };
}
function qB(t, e, r) {
  const n = Math.sqrt(2 * Math.PI * Math.sqrt((Math.pow(t / 2, 2) + Math.pow(e / 2, 2)) / 2)), i = Math.ceil(Math.max(r.curveStepCount, r.curveStepCount / Math.sqrt(200) * n)), a = 2 * Math.PI / i;
  let s = Math.abs(t / 2), o = Math.abs(e / 2);
  const l = 1 - r.curveFitting;
  return s += qt(s * l, r), o += qt(o * l, r), { increment: a, rx: s, ry: o };
}
function Gw(t, e, r, n) {
  const [i, a] = M8(n.increment, t, e, n.rx, n.ry, 1, n.increment * cy(0.1, cy(0.4, 1, r), r), r);
  let s = uy(i, null, r);
  if (!r.disableMultiStroke && r.roughness !== 0) {
    const [o] = M8(n.increment, t, e, n.rx, n.ry, 1.5, 0, r), l = uy(o, null, r);
    s = s.concat(l);
  }
  return { estimatedPoints: a, opset: { type: "path", ops: s } };
}
function _8(t, e, r, n, i, a, s, o, l) {
  const u = t, h = e;
  let d = Math.abs(r / 2), f = Math.abs(n / 2);
  d += qt(0.01 * d, l), f += qt(0.01 * f, l);
  let p = i, g = a;
  for (; p < 0; ) p += 2 * Math.PI, g += 2 * Math.PI;
  g - p > 2 * Math.PI && (p = 0, g = 2 * Math.PI);
  const m = 2 * Math.PI / l.curveStepCount, v = Math.min(m / 2, (g - p) / 2), y = N8(v, u, h, d, f, p, g, 1, l);
  if (!l.disableMultiStroke) {
    const b = N8(v, u, h, d, f, p, g, 1.5, l);
    y.push(...b);
  }
  return s && (o ? y.push(...Wl(u, h, u + d * Math.cos(p), h + f * Math.sin(p), l), ...Wl(u, h, u + d * Math.cos(g), h + f * Math.sin(g), l)) : y.push({ op: "lineTo", data: [u, h] }, { op: "lineTo", data: [u + d * Math.cos(p), h + f * Math.sin(p)] })), { type: "path", ops: y };
}
function L8(t, e) {
  const r = VB(GB(nk(t))), n = [];
  let i = [0, 0], a = [0, 0];
  for (const { key: s, data: o } of r) switch (s) {
    case "M":
      a = [o[0], o[1]], i = [o[0], o[1]];
      break;
    case "L":
      n.push(...Wl(a[0], a[1], o[0], o[1], e)), a = [o[0], o[1]];
      break;
    case "C": {
      const [l, u, h, d, f, p] = o;
      n.push(...xle(l, u, h, d, f, p, a, e)), a = [f, p];
      break;
    }
    case "Z":
      n.push(...Wl(a[0], a[1], i[0], i[1], e)), a = [i[0], i[1]];
  }
  return { type: "path", ops: n };
}
function s4(t, e) {
  const r = [];
  for (const n of t) if (n.length) {
    const i = e.maxRandomnessOffset || 0, a = n.length;
    if (a > 2) {
      r.push({ op: "move", data: [n[0][0] + qt(i, e), n[0][1] + qt(i, e)] });
      for (let s = 1; s < a; s++) r.push({ op: "lineTo", data: [n[s][0] + qt(i, e), n[s][1] + qt(i, e)] });
    }
  }
  return { type: "fillPath", ops: r };
}
function mh(t, e) {
  return (function(r, n) {
    let i = r.fillStyle || "hachure";
    if (!Ji[i]) switch (i) {
      case "zigzag":
        Ji[i] || (Ji[i] = new ule(n));
        break;
      case "cross-hatch":
        Ji[i] || (Ji[i] = new hle(n));
        break;
      case "dots":
        Ji[i] || (Ji[i] = new dle(n));
        break;
      case "dashed":
        Ji[i] || (Ji[i] = new fle(n));
        break;
      case "zigzag-line":
        Ji[i] || (Ji[i] = new ple(n));
        break;
      default:
        i = "hachure", Ji[i] || (Ji[i] = new rk(n));
    }
    return Ji[i];
  })(e, vle).fillPolygons(t, e);
}
function R8(t) {
  const e = Object.assign({}, t);
  return e.randomizer = void 0, t.seed && (e.seed = t.seed + 1), e;
}
function WB(t) {
  return t.randomizer || (t.randomizer = new gle(t.seed || 0)), t.randomizer.next();
}
function cy(t, e, r, n = 1) {
  return r.roughness * n * (WB(r) * (e - t) + t);
}
function qt(t, e, r = 1) {
  return cy(-t, t, e, r);
}
function Wl(t, e, r, n, i, a = !1) {
  const s = a ? i.disableMultiStrokeFill : i.disableMultiStroke, o = Vw(t, e, r, n, i, !0, !1);
  if (s) return o;
  const l = Vw(t, e, r, n, i, !0, !0);
  return o.concat(l);
}
function Vw(t, e, r, n, i, a, s) {
  const o = Math.pow(t - r, 2) + Math.pow(e - n, 2), l = Math.sqrt(o);
  let u = 1;
  u = l < 200 ? 1 : l > 500 ? 0.4 : -16668e-7 * l + 1.233334;
  let h = i.maxRandomnessOffset || 0;
  h * h * 100 > o && (h = l / 10);
  const d = h / 2, f = 0.2 + 0.2 * WB(i);
  let p = i.bowing * i.maxRandomnessOffset * (n - e) / 200, g = i.bowing * i.maxRandomnessOffset * (t - r) / 200;
  p = qt(p, i, u), g = qt(g, i, u);
  const m = [], v = () => qt(d, i, u), y = () => qt(h, i, u), b = i.preserveVertices;
  return s ? m.push({ op: "move", data: [t + (b ? 0 : v()), e + (b ? 0 : v())] }) : m.push({ op: "move", data: [t + (b ? 0 : qt(h, i, u)), e + (b ? 0 : qt(h, i, u))] }), s ? m.push({ op: "bcurveTo", data: [p + t + (r - t) * f + v(), g + e + (n - e) * f + v(), p + t + 2 * (r - t) * f + v(), g + e + 2 * (n - e) * f + v(), r + (b ? 0 : v()), n + (b ? 0 : v())] }) : m.push({ op: "bcurveTo", data: [p + t + (r - t) * f + y(), g + e + (n - e) * f + y(), p + t + 2 * (r - t) * f + y(), g + e + 2 * (n - e) * f + y(), r + (b ? 0 : y()), n + (b ? 0 : y())] }), m;
}
function d1(t, e, r) {
  if (!t.length) return [];
  const n = [];
  n.push([t[0][0] + qt(e, r), t[0][1] + qt(e, r)]), n.push([t[0][0] + qt(e, r), t[0][1] + qt(e, r)]);
  for (let i = 1; i < t.length; i++) n.push([t[i][0] + qt(e, r), t[i][1] + qt(e, r)]), i === t.length - 1 && n.push([t[i][0] + qt(e, r), t[i][1] + qt(e, r)]);
  return uy(n, null, r);
}
function uy(t, e, r) {
  const n = t.length, i = [];
  if (n > 3) {
    const a = [], s = 1 - r.curveTightness;
    i.push({ op: "move", data: [t[1][0], t[1][1]] });
    for (let o = 1; o + 2 < n; o++) {
      const l = t[o];
      a[0] = [l[0], l[1]], a[1] = [l[0] + (s * t[o + 1][0] - s * t[o - 1][0]) / 6, l[1] + (s * t[o + 1][1] - s * t[o - 1][1]) / 6], a[2] = [t[o + 1][0] + (s * t[o][0] - s * t[o + 2][0]) / 6, t[o + 1][1] + (s * t[o][1] - s * t[o + 2][1]) / 6], a[3] = [t[o + 1][0], t[o + 1][1]], i.push({ op: "bcurveTo", data: [a[1][0], a[1][1], a[2][0], a[2][1], a[3][0], a[3][1]] });
    }
  } else n === 3 ? (i.push({ op: "move", data: [t[1][0], t[1][1]] }), i.push({ op: "bcurveTo", data: [t[1][0], t[1][1], t[2][0], t[2][1], t[2][0], t[2][1]] })) : n === 2 && i.push(...Vw(t[0][0], t[0][1], t[1][0], t[1][1], r, !0, !0));
  return i;
}
function M8(t, e, r, n, i, a, s, o) {
  const l = [], u = [];
  if (o.roughness === 0) {
    t /= 4, u.push([e + n * Math.cos(-t), r + i * Math.sin(-t)]);
    for (let h = 0; h <= 2 * Math.PI; h += t) {
      const d = [e + n * Math.cos(h), r + i * Math.sin(h)];
      l.push(d), u.push(d);
    }
    u.push([e + n * Math.cos(0), r + i * Math.sin(0)]), u.push([e + n * Math.cos(t), r + i * Math.sin(t)]);
  } else {
    const h = qt(0.5, o) - Math.PI / 2;
    u.push([qt(a, o) + e + 0.9 * n * Math.cos(h - t), qt(a, o) + r + 0.9 * i * Math.sin(h - t)]);
    const d = 2 * Math.PI + h - 0.01;
    for (let f = h; f < d; f += t) {
      const p = [qt(a, o) + e + n * Math.cos(f), qt(a, o) + r + i * Math.sin(f)];
      l.push(p), u.push(p);
    }
    u.push([qt(a, o) + e + n * Math.cos(h + 2 * Math.PI + 0.5 * s), qt(a, o) + r + i * Math.sin(h + 2 * Math.PI + 0.5 * s)]), u.push([qt(a, o) + e + 0.98 * n * Math.cos(h + s), qt(a, o) + r + 0.98 * i * Math.sin(h + s)]), u.push([qt(a, o) + e + 0.9 * n * Math.cos(h + 0.5 * s), qt(a, o) + r + 0.9 * i * Math.sin(h + 0.5 * s)]);
  }
  return [u, l];
}
function N8(t, e, r, n, i, a, s, o, l) {
  const u = a + qt(0.1, l), h = [];
  h.push([qt(o, l) + e + 0.9 * n * Math.cos(u - t), qt(o, l) + r + 0.9 * i * Math.sin(u - t)]);
  for (let d = u; d <= s; d += t) h.push([qt(o, l) + e + n * Math.cos(d), qt(o, l) + r + i * Math.sin(d)]);
  return h.push([e + n * Math.cos(s), r + i * Math.sin(s)]), h.push([e + n * Math.cos(s), r + i * Math.sin(s)]), uy(h, null, l);
}
function xle(t, e, r, n, i, a, s, o) {
  const l = [], u = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];
  let h = [0, 0];
  const d = o.disableMultiStroke ? 1 : 2, f = o.preserveVertices;
  for (let p = 0; p < d; p++) p === 0 ? l.push({ op: "move", data: [s[0], s[1]] }) : l.push({ op: "move", data: [s[0] + (f ? 0 : qt(u[0], o)), s[1] + (f ? 0 : qt(u[0], o))] }), h = f ? [i, a] : [i + qt(u[p], o), a + qt(u[p], o)], l.push({ op: "bcurveTo", data: [t + qt(u[p], o), e + qt(u[p], o), r + qt(u[p], o), n + qt(u[p], o), h[0], h[1]] });
  return l;
}
function Lf(t) {
  return [...t];
}
function I8(t, e = 0) {
  const r = t.length;
  if (r < 3) throw new Error("A curve must have at least three points.");
  const n = [];
  if (r === 3) n.push(Lf(t[0]), Lf(t[1]), Lf(t[2]), Lf(t[2]));
  else {
    const i = [];
    i.push(t[0], t[0]);
    for (let o = 1; o < t.length; o++) i.push(t[o]), o === t.length - 1 && i.push(t[o]);
    const a = [], s = 1 - e;
    n.push(Lf(i[0]));
    for (let o = 1; o + 2 < i.length; o++) {
      const l = i[o];
      a[0] = [l[0], l[1]], a[1] = [l[0] + (s * i[o + 1][0] - s * i[o - 1][0]) / 6, l[1] + (s * i[o + 1][1] - s * i[o - 1][1]) / 6], a[2] = [i[o + 1][0] + (s * i[o][0] - s * i[o + 2][0]) / 6, i[o + 1][1] + (s * i[o][1] - s * i[o + 2][1]) / 6], a[3] = [i[o + 1][0], i[o + 1][1]], n.push(a[1], a[2], a[3]);
    }
  }
  return n;
}
function _m(t, e) {
  return Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2);
}
function ble(t, e, r) {
  const n = _m(e, r);
  if (n === 0) return _m(t, e);
  let i = ((t[0] - e[0]) * (r[0] - e[0]) + (t[1] - e[1]) * (r[1] - e[1])) / n;
  return i = Math.max(0, Math.min(1, i)), _m(t, qc(e, r, i));
}
function qc(t, e, r) {
  return [t[0] + (e[0] - t[0]) * r, t[1] + (e[1] - t[1]) * r];
}
function Uw(t, e, r, n) {
  const i = n || [];
  if ((function(o, l) {
    const u = o[l + 0], h = o[l + 1], d = o[l + 2], f = o[l + 3];
    let p = 3 * h[0] - 2 * u[0] - f[0];
    p *= p;
    let g = 3 * h[1] - 2 * u[1] - f[1];
    g *= g;
    let m = 3 * d[0] - 2 * f[0] - u[0];
    m *= m;
    let v = 3 * d[1] - 2 * f[1] - u[1];
    return v *= v, p < m && (p = m), g < v && (g = v), p + g;
  })(t, e) < r) {
    const o = t[e + 0];
    i.length ? (a = i[i.length - 1], s = o, Math.sqrt(_m(a, s)) > 1 && i.push(o)) : i.push(o), i.push(t[e + 3]);
  } else {
    const l = t[e + 0], u = t[e + 1], h = t[e + 2], d = t[e + 3], f = qc(l, u, 0.5), p = qc(u, h, 0.5), g = qc(h, d, 0.5), m = qc(f, p, 0.5), v = qc(p, g, 0.5), y = qc(m, v, 0.5);
    Uw([l, f, m, y], 0, r, i), Uw([y, v, g, d], 0, r, i);
  }
  var a, s;
  return i;
}
function wle(t, e) {
  return hy(t, 0, t.length, e);
}
function hy(t, e, r, n, i) {
  const a = i || [], s = t[e], o = t[r - 1];
  let l = 0, u = 1;
  for (let h = e + 1; h < r - 1; ++h) {
    const d = ble(t[h], s, o);
    d > l && (l = d, u = h);
  }
  return Math.sqrt(l) > n ? (hy(t, e, u + 1, n, a), hy(t, u, r, n, a)) : (a.length || a.push(s), a.push(o)), a;
}
function o4(t, e = 0.15, r) {
  const n = [], i = (t.length - 1) / 3;
  for (let a = 0; a < i; a++)
    Uw(t, 3 * a, e, n);
  return r && r > 0 ? hy(n, 0, n.length, r) : n;
}
const va = "none";
class dy {
  constructor(e) {
    this.defaultOptions = { maxRandomnessOffset: 2, roughness: 1, bowing: 1, stroke: "#000", strokeWidth: 1, curveTightness: 0, curveFitting: 0.95, curveStepCount: 9, fillStyle: "hachure", fillWeight: -1, hachureAngle: -41, hachureGap: -1, dashOffset: -1, dashGap: -1, zigzagOffset: -1, seed: 0, disableMultiStroke: !1, disableMultiStrokeFill: !1, preserveVertices: !1, fillShapeRoughnessGain: 0.8 }, this.config = e || {}, this.config.options && (this.defaultOptions = this._o(this.config.options));
  }
  static newSeed() {
    return Math.floor(Math.random() * 2 ** 31);
  }
  _o(e) {
    return e ? Object.assign({}, this.defaultOptions, e) : this.defaultOptions;
  }
  _d(e, r, n) {
    return { shape: e, sets: r || [], options: n || this.defaultOptions };
  }
  line(e, r, n, i, a) {
    const s = this._o(a);
    return this._d("line", [HB(e, r, n, i, s)], s);
  }
  rectangle(e, r, n, i, a) {
    const s = this._o(a), o = [], l = yle(e, r, n, i, s);
    if (s.fill) {
      const u = [[e, r], [e + n, r], [e + n, r + i], [e, r + i]];
      s.fillStyle === "solid" ? o.push(s4([u], s)) : o.push(mh([u], s));
    }
    return s.stroke !== va && o.push(l), this._d("rectangle", o, s);
  }
  ellipse(e, r, n, i, a) {
    const s = this._o(a), o = [], l = qB(n, i, s), u = Gw(e, r, s, l);
    if (s.fill) if (s.fillStyle === "solid") {
      const h = Gw(e, r, s, l).opset;
      h.type = "fillPath", o.push(h);
    } else o.push(mh([u.estimatedPoints], s));
    return s.stroke !== va && o.push(u.opset), this._d("ellipse", o, s);
  }
  circle(e, r, n, i) {
    const a = this.ellipse(e, r, n, n, i);
    return a.shape = "circle", a;
  }
  linearPath(e, r) {
    const n = this._o(r);
    return this._d("linearPath", [Am(e, !1, n)], n);
  }
  arc(e, r, n, i, a, s, o = !1, l) {
    const u = this._o(l), h = [], d = _8(e, r, n, i, a, s, o, !0, u);
    if (o && u.fill) if (u.fillStyle === "solid") {
      const f = Object.assign({}, u);
      f.disableMultiStroke = !0;
      const p = _8(e, r, n, i, a, s, !0, !1, f);
      p.type = "fillPath", h.push(p);
    } else h.push((function(f, p, g, m, v, y, b) {
      const w = f, T = p;
      let E = Math.abs(g / 2), L = Math.abs(m / 2);
      E += qt(0.01 * E, b), L += qt(0.01 * L, b);
      let k = v, C = y;
      for (; k < 0; ) k += 2 * Math.PI, C += 2 * Math.PI;
      C - k > 2 * Math.PI && (k = 0, C = 2 * Math.PI);
      const A = (C - k) / b.curveStepCount, R = [];
      for (let _ = k; _ <= C; _ += A) R.push([w + E * Math.cos(_), T + L * Math.sin(_)]);
      return R.push([w + E * Math.cos(C), T + L * Math.sin(C)]), R.push([w, T]), mh([R], b);
    })(e, r, n, i, a, s, u));
    return u.stroke !== va && h.push(d), this._d("arc", h, u);
  }
  curve(e, r) {
    const n = this._o(r), i = [], a = A8(e, n);
    if (n.fill && n.fill !== va) if (n.fillStyle === "solid") {
      const s = A8(e, Object.assign(Object.assign({}, n), { disableMultiStroke: !0, roughness: n.roughness ? n.roughness + n.fillShapeRoughnessGain : 0 }));
      i.push({ type: "fillPath", ops: this._mergedShape(s.ops) });
    } else {
      const s = [], o = e;
      if (o.length) {
        const l = typeof o[0][0] == "number" ? [o] : o;
        for (const u of l) u.length < 3 ? s.push(...u) : u.length === 3 ? s.push(...o4(I8([u[0], u[0], u[1], u[2]]), 10, (1 + n.roughness) / 2)) : s.push(...o4(I8(u), 10, (1 + n.roughness) / 2));
      }
      s.length && i.push(mh([s], n));
    }
    return n.stroke !== va && i.push(a), this._d("curve", i, n);
  }
  polygon(e, r) {
    const n = this._o(r), i = [], a = Am(e, !0, n);
    return n.fill && (n.fillStyle === "solid" ? i.push(s4([e], n)) : i.push(mh([e], n))), n.stroke !== va && i.push(a), this._d("polygon", i, n);
  }
  path(e, r) {
    const n = this._o(r), i = [];
    if (!e) return this._d("path", i, n);
    e = (e || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
    const a = n.fill && n.fill !== "transparent" && n.fill !== va, s = n.stroke !== va, o = !!(n.simplification && n.simplification < 1), l = (function(h, d, f) {
      const p = VB(GB(nk(h))), g = [];
      let m = [], v = [0, 0], y = [];
      const b = () => {
        y.length >= 4 && m.push(...o4(y, d)), y = [];
      }, w = () => {
        b(), m.length && (g.push(m), m = []);
      };
      for (const { key: E, data: L } of p) switch (E) {
        case "M":
          w(), v = [L[0], L[1]], m.push(v);
          break;
        case "L":
          b(), m.push([L[0], L[1]]);
          break;
        case "C":
          if (!y.length) {
            const k = m.length ? m[m.length - 1] : v;
            y.push([k[0], k[1]]);
          }
          y.push([L[0], L[1]]), y.push([L[2], L[3]]), y.push([L[4], L[5]]);
          break;
        case "Z":
          b(), m.push([v[0], v[1]]);
      }
      if (w(), !f) return g;
      const T = [];
      for (const E of g) {
        const L = wle(E, f);
        L.length && T.push(L);
      }
      return T;
    })(e, 1, o ? 4 - 4 * (n.simplification || 1) : (1 + n.roughness) / 2), u = L8(e, n);
    if (a) if (n.fillStyle === "solid") if (l.length === 1) {
      const h = L8(e, Object.assign(Object.assign({}, n), { disableMultiStroke: !0, roughness: n.roughness ? n.roughness + n.fillShapeRoughnessGain : 0 }));
      i.push({ type: "fillPath", ops: this._mergedShape(h.ops) });
    } else i.push(s4(l, n));
    else i.push(mh(l, n));
    return s && (o ? l.forEach(((h) => {
      i.push(Am(h, !1, n));
    })) : i.push(u)), this._d("path", i, n);
  }
  opsToPath(e, r) {
    let n = "";
    for (const i of e.ops) {
      const a = typeof r == "number" && r >= 0 ? i.data.map(((s) => +s.toFixed(r))) : i.data;
      switch (i.op) {
        case "move":
          n += `M${a[0]} ${a[1]} `;
          break;
        case "bcurveTo":
          n += `C${a[0]} ${a[1]}, ${a[2]} ${a[3]}, ${a[4]} ${a[5]} `;
          break;
        case "lineTo":
          n += `L${a[0]} ${a[1]} `;
      }
    }
    return n.trim();
  }
  toPaths(e) {
    const r = e.sets || [], n = e.options || this.defaultOptions, i = [];
    for (const a of r) {
      let s = null;
      switch (a.type) {
        case "path":
          s = { d: this.opsToPath(a), stroke: n.stroke, strokeWidth: n.strokeWidth, fill: va };
          break;
        case "fillPath":
          s = { d: this.opsToPath(a), stroke: va, strokeWidth: 0, fill: n.fill || va };
          break;
        case "fillSketch":
          s = this.fillSketch(a, n);
      }
      s && i.push(s);
    }
    return i;
  }
  fillSketch(e, r) {
    let n = r.fillWeight;
    return n < 0 && (n = r.strokeWidth / 2), { d: this.opsToPath(e), stroke: r.fill || va, strokeWidth: n, fill: va };
  }
  _mergedShape(e) {
    return e.filter(((r, n) => n === 0 || r.op !== "move"));
  }
}
class Tle {
  constructor(e, r) {
    this.canvas = e, this.ctx = this.canvas.getContext("2d"), this.gen = new dy(r);
  }
  draw(e) {
    const r = e.sets || [], n = e.options || this.getDefaultOptions(), i = this.ctx, a = e.options.fixedDecimalPlaceDigits;
    for (const s of r) switch (s.type) {
      case "path":
        i.save(), i.strokeStyle = n.stroke === "none" ? "transparent" : n.stroke, i.lineWidth = n.strokeWidth, n.strokeLineDash && i.setLineDash(n.strokeLineDash), n.strokeLineDashOffset && (i.lineDashOffset = n.strokeLineDashOffset), this._drawToContext(i, s, a), i.restore();
        break;
      case "fillPath": {
        i.save(), i.fillStyle = n.fill || "";
        const o = e.shape === "curve" || e.shape === "polygon" || e.shape === "path" ? "evenodd" : "nonzero";
        this._drawToContext(i, s, a, o), i.restore();
        break;
      }
      case "fillSketch":
        this.fillSketch(i, s, n);
    }
  }
  fillSketch(e, r, n) {
    let i = n.fillWeight;
    i < 0 && (i = n.strokeWidth / 2), e.save(), n.fillLineDash && e.setLineDash(n.fillLineDash), n.fillLineDashOffset && (e.lineDashOffset = n.fillLineDashOffset), e.strokeStyle = n.fill || "", e.lineWidth = i, this._drawToContext(e, r, n.fixedDecimalPlaceDigits), e.restore();
  }
  _drawToContext(e, r, n, i = "nonzero") {
    e.beginPath();
    for (const a of r.ops) {
      const s = typeof n == "number" && n >= 0 ? a.data.map(((o) => +o.toFixed(n))) : a.data;
      switch (a.op) {
        case "move":
          e.moveTo(s[0], s[1]);
          break;
        case "bcurveTo":
          e.bezierCurveTo(s[0], s[1], s[2], s[3], s[4], s[5]);
          break;
        case "lineTo":
          e.lineTo(s[0], s[1]);
      }
    }
    r.type === "fillPath" ? e.fill(i) : e.stroke();
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  line(e, r, n, i, a) {
    const s = this.gen.line(e, r, n, i, a);
    return this.draw(s), s;
  }
  rectangle(e, r, n, i, a) {
    const s = this.gen.rectangle(e, r, n, i, a);
    return this.draw(s), s;
  }
  ellipse(e, r, n, i, a) {
    const s = this.gen.ellipse(e, r, n, i, a);
    return this.draw(s), s;
  }
  circle(e, r, n, i) {
    const a = this.gen.circle(e, r, n, i);
    return this.draw(a), a;
  }
  linearPath(e, r) {
    const n = this.gen.linearPath(e, r);
    return this.draw(n), n;
  }
  polygon(e, r) {
    const n = this.gen.polygon(e, r);
    return this.draw(n), n;
  }
  arc(e, r, n, i, a, s, o = !1, l) {
    const u = this.gen.arc(e, r, n, i, a, s, o, l);
    return this.draw(u), u;
  }
  curve(e, r) {
    const n = this.gen.curve(e, r);
    return this.draw(n), n;
  }
  path(e, r) {
    const n = this.gen.path(e, r);
    return this.draw(n), n;
  }
}
const f1 = "http://www.w3.org/2000/svg";
class Ele {
  constructor(e, r) {
    this.svg = e, this.gen = new dy(r);
  }
  draw(e) {
    const r = e.sets || [], n = e.options || this.getDefaultOptions(), i = this.svg.ownerDocument || window.document, a = i.createElementNS(f1, "g"), s = e.options.fixedDecimalPlaceDigits;
    for (const o of r) {
      let l = null;
      switch (o.type) {
        case "path":
          l = i.createElementNS(f1, "path"), l.setAttribute("d", this.opsToPath(o, s)), l.setAttribute("stroke", n.stroke), l.setAttribute("stroke-width", n.strokeWidth + ""), l.setAttribute("fill", "none"), n.strokeLineDash && l.setAttribute("stroke-dasharray", n.strokeLineDash.join(" ").trim()), n.strokeLineDashOffset && l.setAttribute("stroke-dashoffset", `${n.strokeLineDashOffset}`);
          break;
        case "fillPath":
          l = i.createElementNS(f1, "path"), l.setAttribute("d", this.opsToPath(o, s)), l.setAttribute("stroke", "none"), l.setAttribute("stroke-width", "0"), l.setAttribute("fill", n.fill || ""), e.shape !== "curve" && e.shape !== "polygon" || l.setAttribute("fill-rule", "evenodd");
          break;
        case "fillSketch":
          l = this.fillSketch(i, o, n);
      }
      l && a.appendChild(l);
    }
    return a;
  }
  fillSketch(e, r, n) {
    let i = n.fillWeight;
    i < 0 && (i = n.strokeWidth / 2);
    const a = e.createElementNS(f1, "path");
    return a.setAttribute("d", this.opsToPath(r, n.fixedDecimalPlaceDigits)), a.setAttribute("stroke", n.fill || ""), a.setAttribute("stroke-width", i + ""), a.setAttribute("fill", "none"), n.fillLineDash && a.setAttribute("stroke-dasharray", n.fillLineDash.join(" ").trim()), n.fillLineDashOffset && a.setAttribute("stroke-dashoffset", `${n.fillLineDashOffset}`), a;
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  opsToPath(e, r) {
    return this.gen.opsToPath(e, r);
  }
  line(e, r, n, i, a) {
    const s = this.gen.line(e, r, n, i, a);
    return this.draw(s);
  }
  rectangle(e, r, n, i, a) {
    const s = this.gen.rectangle(e, r, n, i, a);
    return this.draw(s);
  }
  ellipse(e, r, n, i, a) {
    const s = this.gen.ellipse(e, r, n, i, a);
    return this.draw(s);
  }
  circle(e, r, n, i) {
    const a = this.gen.circle(e, r, n, i);
    return this.draw(a);
  }
  linearPath(e, r) {
    const n = this.gen.linearPath(e, r);
    return this.draw(n);
  }
  polygon(e, r) {
    const n = this.gen.polygon(e, r);
    return this.draw(n);
  }
  arc(e, r, n, i, a, s, o = !1, l) {
    const u = this.gen.arc(e, r, n, i, a, s, o, l);
    return this.draw(u);
  }
  curve(e, r) {
    const n = this.gen.curve(e, r);
    return this.draw(n);
  }
  path(e, r) {
    const n = this.gen.path(e, r);
    return this.draw(n);
  }
}
var Lt = { canvas: (t, e) => new Tle(t, e), svg: (t, e) => new Ele(t, e), generator: (t) => new dy(t), newSeed: () => dy.newSeed() }, Ut = /* @__PURE__ */ x(async (t, e, r) => {
  let n;
  const i = e.useHtmlLabels || Nr(we()?.htmlLabels);
  r ? n = r : n = "node default";
  const a = t.insert("g").attr("class", n).attr("id", e.domId || e.id), s = a.insert("g").attr("class", "label").attr("style", ki(e.labelStyle));
  let o;
  e.label === void 0 ? o = "" : o = typeof e.label == "string" ? e.label : e.label[0];
  const l = await La(s, dr(ao(o), we()), {
    useHtmlLabels: i,
    width: e.width || we().flowchart?.wrappingWidth,
    // @ts-expect-error -- This is currently not used. Should this be `classes` instead?
    cssClasses: "markdown-node-label",
    style: e.labelStyle,
    addSvgBackground: !!e.icon || !!e.img
  });
  let u = l.getBBox();
  const h = (e?.padding ?? 0) / 2;
  if (i) {
    const d = l.children[0], f = Qe(l), p = d.getElementsByTagName("img");
    if (p) {
      const g = o.replace(/<img[^>]*>/g, "").trim() === "";
      await Promise.all(
        [...p].map(
          (m) => new Promise((v) => {
            function y() {
              if (m.style.display = "flex", m.style.flexDirection = "column", g) {
                const b = we().fontSize ? we().fontSize : window.getComputedStyle(document.body).fontSize, w = 5, [T = ur.fontSize] = ju(b), E = T * w + "px";
                m.style.minWidth = E, m.style.maxWidth = E;
              } else
                m.style.width = "100%";
              v(m);
            }
            x(y, "setupImage"), setTimeout(() => {
              m.complete && y();
            }), m.addEventListener("error", y), m.addEventListener("load", y);
          })
        )
      );
    }
    u = d.getBoundingClientRect(), f.attr("width", u.width), f.attr("height", u.height);
  }
  return i ? s.attr("transform", "translate(" + -u.width / 2 + ", " + -u.height / 2 + ")") : s.attr("transform", "translate(0, " + -u.height / 2 + ")"), e.centerLabel && s.attr("transform", "translate(" + -u.width / 2 + ", " + -u.height / 2 + ")"), s.insert("rect", ":first-child"), { shapeSvg: a, bbox: u, halfPadding: h, label: s };
}, "labelHelper"), l4 = /* @__PURE__ */ x(async (t, e, r) => {
  const n = r.useHtmlLabels || Nr(we()?.flowchart?.htmlLabels), i = t.insert("g").attr("class", "label").attr("style", r.labelStyle || ""), a = await La(i, dr(ao(e), we()), {
    useHtmlLabels: n,
    width: r.width || we()?.flowchart?.wrappingWidth,
    style: r.labelStyle,
    addSvgBackground: !!r.icon || !!r.img
  });
  let s = a.getBBox();
  const o = r.padding / 2;
  if (Nr(we()?.flowchart?.htmlLabels)) {
    const l = a.children[0], u = Qe(a);
    s = l.getBoundingClientRect(), u.attr("width", s.width), u.attr("height", s.height);
  }
  return n ? i.attr("transform", "translate(" + -s.width / 2 + ", " + -s.height / 2 + ")") : i.attr("transform", "translate(0, " + -s.height / 2 + ")"), r.centerLabel && i.attr("transform", "translate(" + -s.width / 2 + ", " + -s.height / 2 + ")"), i.insert("rect", ":first-child"), { shapeSvg: t, bbox: s, halfPadding: o, label: i };
}, "insertLabel"), Mt = /* @__PURE__ */ x((t, e) => {
  const r = e.node().getBBox();
  t.width = r.width, t.height = r.height;
}, "updateNodeBounds"), Ft = /* @__PURE__ */ x((t, e) => (t.look === "handDrawn" ? "rough-node" : "node") + " " + t.cssClasses + " " + (e || ""), "getNodeClasses");
function ar(t) {
  const e = t.map((r, n) => `${n === 0 ? "M" : "L"}${r.x},${r.y}`);
  return e.push("Z"), e.join(" ");
}
x(ar, "createPathFromPoints");
function Yl(t, e, r, n, i, a) {
  const s = [], l = r - t, u = n - e, h = l / a, d = 2 * Math.PI / h, f = e + u / 2;
  for (let p = 0; p <= 50; p++) {
    const g = p / 50, m = t + g * l, v = f + i * Math.sin(d * (m - t));
    s.push({ x: m, y: v });
  }
  return s;
}
x(Yl, "generateFullSineWavePoints");
function kp(t, e, r, n, i, a) {
  const s = [], o = i * Math.PI / 180, h = (a * Math.PI / 180 - o) / (n - 1);
  for (let d = 0; d < n; d++) {
    const f = o + d * h, p = t + r * Math.cos(f), g = e + r * Math.sin(f);
    s.push({ x: -p, y: -g });
  }
  return s;
}
x(kp, "generateCirclePoints");
var kle = /* @__PURE__ */ x((t, e) => {
  var r = t.x, n = t.y, i = e.x - r, a = e.y - n, s = t.width / 2, o = t.height / 2, l, u;
  return Math.abs(a) * s > Math.abs(i) * o ? (a < 0 && (o = -o), l = a === 0 ? 0 : o * i / a, u = o) : (i < 0 && (s = -s), l = s, u = i === 0 ? 0 : s * a / i), { x: r + l, y: n + u };
}, "intersectRect"), jd = kle;
function YB(t, e) {
  e && t.attr("style", e);
}
x(YB, "applyStyle");
async function XB(t) {
  const e = Qe(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")), r = e.append("xhtml:div"), n = we();
  let i = t.label;
  t.label && un(t.label) && (i = await sg(t.label.replace(at.lineBreakRegex, `
`), n));
  const s = '<span class="' + (t.isNode ? "nodeLabel" : "edgeLabel") + '" ' + (t.labelStyle ? 'style="' + t.labelStyle + '"' : "") + // codeql [js/html-constructed-from-input] : false positive
  ">" + i + "</span>";
  return r.html(dr(s, n)), YB(r, t.labelStyle), r.style("display", "inline-block"), r.style("padding-right", "1px"), r.style("white-space", "nowrap"), r.attr("xmlns", "http://www.w3.org/1999/xhtml"), e.node();
}
x(XB, "addHtmlLabel");
var Sle = /* @__PURE__ */ x(async (t, e, r, n) => {
  let i = t || "";
  if (typeof i == "object" && (i = i[0]), Nr(we().flowchart.htmlLabels)) {
    i = i.replace(/\\n|\n/g, "<br />"), ie.info("vertexText" + i);
    const a = {
      isNode: n,
      label: ao(i).replace(
        /fa[blrs]?:fa-[\w-]+/g,
        (o) => `<i class='${o.replace(":", " ")}'></i>`
      ),
      labelStyle: e && e.replace("fill:", "color:")
    };
    return await XB(a);
  } else {
    const a = document.createElementNS("http://www.w3.org/2000/svg", "text");
    a.setAttribute("style", e.replace("color:", "fill:"));
    let s = [];
    typeof i == "string" ? s = i.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(i) ? s = i : s = [];
    for (const o of s) {
      const l = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      l.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), l.setAttribute("dy", "1em"), l.setAttribute("x", "0"), r ? l.setAttribute("class", "title-row") : l.setAttribute("class", "row"), l.textContent = o.trim(), a.appendChild(l);
    }
    return a;
  }
}, "createLabel"), au = Sle, fc = /* @__PURE__ */ x((t, e, r, n, i) => [
  "M",
  t + i,
  e,
  // Move to the first point
  "H",
  t + r - i,
  // Draw horizontal line to the beginning of the right corner
  "A",
  i,
  i,
  0,
  0,
  1,
  t + r,
  e + i,
  // Draw arc to the right top corner
  "V",
  e + n - i,
  // Draw vertical line down to the beginning of the right bottom corner
  "A",
  i,
  i,
  0,
  0,
  1,
  t + r - i,
  e + n,
  // Draw arc to the right bottom corner
  "H",
  t + i,
  // Draw horizontal line to the beginning of the left bottom corner
  "A",
  i,
  i,
  0,
  0,
  1,
  t,
  e + n - i,
  // Draw arc to the left bottom corner
  "V",
  e + i,
  // Draw vertical line up to the beginning of the left top corner
  "A",
  i,
  i,
  0,
  0,
  1,
  t + i,
  e,
  // Draw arc to the left top corner
  "Z"
  // Close the path
].join(" "), "createRoundedRectPathD"), jB = /* @__PURE__ */ x(async (t, e) => {
  ie.info("Creating subgraph rect for ", e.id, e);
  const r = we(), { themeVariables: n, handDrawnSeed: i } = r, { clusterBkg: a, clusterBorder: s } = n, { labelStyles: o, nodeStyles: l, borderStyles: u, backgroundStyles: h } = St(e), d = t.insert("g").attr("class", "cluster " + e.cssClasses).attr("id", e.id).attr("data-look", e.look), f = Nr(r.flowchart.htmlLabels), p = d.insert("g").attr("class", "cluster-label "), g = await La(p, e.label, {
    style: e.labelStyle,
    useHtmlLabels: f,
    isNode: !0
  });
  let m = g.getBBox();
  if (Nr(r.flowchart.htmlLabels)) {
    const k = g.children[0], C = Qe(g);
    m = k.getBoundingClientRect(), C.attr("width", m.width), C.attr("height", m.height);
  }
  const v = e.width <= m.width + e.padding ? m.width + e.padding : e.width;
  e.width <= m.width + e.padding ? e.diff = (v - e.width) / 2 - e.padding : e.diff = -e.padding;
  const y = e.height, b = e.x - v / 2, w = e.y - y / 2;
  ie.trace("Data ", e, JSON.stringify(e));
  let T;
  if (e.look === "handDrawn") {
    const k = Lt.svg(d), C = Rt(e, {
      roughness: 0.7,
      fill: a,
      // fill: 'red',
      stroke: s,
      fillWeight: 3,
      seed: i
    }), A = k.path(fc(b, w, v, y, 0), C);
    T = d.insert(() => (ie.debug("Rough node insert CXC", A), A), ":first-child"), T.select("path:nth-child(2)").attr("style", u.join(";")), T.select("path").attr("style", h.join(";").replace("fill", "stroke"));
  } else
    T = d.insert("rect", ":first-child"), T.attr("style", l).attr("rx", e.rx).attr("ry", e.ry).attr("x", b).attr("y", w).attr("width", v).attr("height", y);
  const { subGraphTitleTopMargin: E } = dg(r);
  if (p.attr(
    "transform",
    // This puts the label on top of the box instead of inside it
    `translate(${e.x - m.width / 2}, ${e.y - e.height / 2 + E})`
  ), o) {
    const k = p.select("span");
    k && k.attr("style", o);
  }
  const L = T.node().getBBox();
  return e.offsetX = 0, e.width = L.width, e.height = L.height, e.offsetY = m.height - e.padding / 2, e.intersect = function(k) {
    return jd(e, k);
  }, { cluster: d, labelBBox: m };
}, "rect"), Cle = /* @__PURE__ */ x((t, e) => {
  const r = t.insert("g").attr("class", "note-cluster").attr("id", e.id), n = r.insert("rect", ":first-child"), i = 0 * e.padding, a = i / 2;
  n.attr("rx", e.rx).attr("ry", e.ry).attr("x", e.x - e.width / 2 - a).attr("y", e.y - e.height / 2 - a).attr("width", e.width + i).attr("height", e.height + i).attr("fill", "none");
  const s = n.node().getBBox();
  return e.width = s.width, e.height = s.height, e.intersect = function(o) {
    return jd(e, o);
  }, { cluster: r, labelBBox: { width: 0, height: 0 } };
}, "noteGroup"), Ale = /* @__PURE__ */ x(async (t, e) => {
  const r = we(), { themeVariables: n, handDrawnSeed: i } = r, { altBackground: a, compositeBackground: s, compositeTitleBackground: o, nodeBorder: l } = n, u = t.insert("g").attr("class", e.cssClasses).attr("id", e.id).attr("data-id", e.id).attr("data-look", e.look), h = u.insert("g", ":first-child"), d = u.insert("g").attr("class", "cluster-label");
  let f = u.append("rect");
  const p = d.node().appendChild(await au(e.label, e.labelStyle, void 0, !0));
  let g = p.getBBox();
  if (Nr(r.flowchart.htmlLabels)) {
    const A = p.children[0], R = Qe(p);
    g = A.getBoundingClientRect(), R.attr("width", g.width), R.attr("height", g.height);
  }
  const m = 0 * e.padding, v = m / 2, y = (e.width <= g.width + e.padding ? g.width + e.padding : e.width) + m;
  e.width <= g.width + e.padding ? e.diff = (y - e.width) / 2 - e.padding : e.diff = -e.padding;
  const b = e.height + m, w = e.height + m - g.height - 6, T = e.x - y / 2, E = e.y - b / 2;
  e.width = y;
  const L = e.y - e.height / 2 - v + g.height + 2;
  let k;
  if (e.look === "handDrawn") {
    const A = e.cssClasses.includes("statediagram-cluster-alt"), R = Lt.svg(u), _ = e.rx || e.ry ? R.path(fc(T, E, y, b, 10), {
      roughness: 0.7,
      fill: o,
      fillStyle: "solid",
      stroke: l,
      seed: i
    }) : R.rectangle(T, E, y, b, { seed: i });
    k = u.insert(() => _, ":first-child");
    const O = R.rectangle(T, L, y, w, {
      fill: A ? a : s,
      fillStyle: A ? "hachure" : "solid",
      stroke: l,
      seed: i
    });
    k = u.insert(() => _, ":first-child"), f = u.insert(() => O);
  } else
    k = h.insert("rect", ":first-child"), k.attr("class", "outer").attr("x", T).attr("y", E).attr("width", y).attr("height", b).attr("data-look", e.look), f.attr("class", "inner").attr("x", T).attr("y", L).attr("width", y).attr("height", w);
  d.attr(
    "transform",
    `translate(${e.x - g.width / 2}, ${E + 1 - (Nr(r.flowchart.htmlLabels) ? 0 : 3)})`
  );
  const C = k.node().getBBox();
  return e.height = C.height, e.offsetX = 0, e.offsetY = g.height - e.padding / 2, e.labelBBox = g, e.intersect = function(A) {
    return jd(e, A);
  }, { cluster: u, labelBBox: g };
}, "roundedWithTitle"), _le = /* @__PURE__ */ x(async (t, e) => {
  ie.info("Creating subgraph rect for ", e.id, e);
  const r = we(), { themeVariables: n, handDrawnSeed: i } = r, { clusterBkg: a, clusterBorder: s } = n, { labelStyles: o, nodeStyles: l, borderStyles: u, backgroundStyles: h } = St(e), d = t.insert("g").attr("class", "cluster " + e.cssClasses).attr("id", e.id).attr("data-look", e.look), f = Nr(r.flowchart.htmlLabels), p = d.insert("g").attr("class", "cluster-label "), g = await La(p, e.label, {
    style: e.labelStyle,
    useHtmlLabels: f,
    isNode: !0,
    width: e.width
  });
  let m = g.getBBox();
  if (Nr(r.flowchart.htmlLabels)) {
    const k = g.children[0], C = Qe(g);
    m = k.getBoundingClientRect(), C.attr("width", m.width), C.attr("height", m.height);
  }
  const v = e.width <= m.width + e.padding ? m.width + e.padding : e.width;
  e.width <= m.width + e.padding ? e.diff = (v - e.width) / 2 - e.padding : e.diff = -e.padding;
  const y = e.height, b = e.x - v / 2, w = e.y - y / 2;
  ie.trace("Data ", e, JSON.stringify(e));
  let T;
  if (e.look === "handDrawn") {
    const k = Lt.svg(d), C = Rt(e, {
      roughness: 0.7,
      fill: a,
      // fill: 'red',
      stroke: s,
      fillWeight: 4,
      seed: i
    }), A = k.path(fc(b, w, v, y, e.rx), C);
    T = d.insert(() => (ie.debug("Rough node insert CXC", A), A), ":first-child"), T.select("path:nth-child(2)").attr("style", u.join(";")), T.select("path").attr("style", h.join(";").replace("fill", "stroke"));
  } else
    T = d.insert("rect", ":first-child"), T.attr("style", l).attr("rx", e.rx).attr("ry", e.ry).attr("x", b).attr("y", w).attr("width", v).attr("height", y);
  const { subGraphTitleTopMargin: E } = dg(r);
  if (p.attr(
    "transform",
    // This puts the label on top of the box instead of inside it
    `translate(${e.x - m.width / 2}, ${e.y - e.height / 2 + E})`
  ), o) {
    const k = p.select("span");
    k && k.attr("style", o);
  }
  const L = T.node().getBBox();
  return e.offsetX = 0, e.width = L.width, e.height = L.height, e.offsetY = m.height - e.padding / 2, e.intersect = function(k) {
    return jd(e, k);
  }, { cluster: d, labelBBox: m };
}, "kanbanSection"), Lle = /* @__PURE__ */ x((t, e) => {
  const r = we(), { themeVariables: n, handDrawnSeed: i } = r, { nodeBorder: a } = n, s = t.insert("g").attr("class", e.cssClasses).attr("id", e.id).attr("data-look", e.look), o = s.insert("g", ":first-child"), l = 0 * e.padding, u = e.width + l;
  e.diff = -e.padding;
  const h = e.height + l, d = e.x - u / 2, f = e.y - h / 2;
  e.width = u;
  let p;
  if (e.look === "handDrawn") {
    const v = Lt.svg(s).rectangle(d, f, u, h, {
      fill: "lightgrey",
      roughness: 0.5,
      strokeLineDash: [5],
      stroke: a,
      seed: i
    });
    p = s.insert(() => v, ":first-child");
  } else
    p = o.insert("rect", ":first-child"), p.attr("class", "divider").attr("x", d).attr("y", f).attr("width", u).attr("height", h).attr("data-look", e.look);
  const g = p.node().getBBox();
  return e.height = g.height, e.offsetX = 0, e.offsetY = 0, e.intersect = function(m) {
    return jd(e, m);
  }, { cluster: s, labelBBox: {} };
}, "divider"), Rle = jB, Mle = {
  rect: jB,
  squareRect: Rle,
  roundedWithTitle: Ale,
  noteGroup: Cle,
  divider: Lle,
  kanbanSection: _le
}, KB = /* @__PURE__ */ new Map(), ik = /* @__PURE__ */ x(async (t, e) => {
  const r = e.shape || "rect", n = await Mle[r](t, e);
  return KB.set(e.id, n), n;
}, "insertCluster"), Nle = /* @__PURE__ */ x(() => {
  KB = /* @__PURE__ */ new Map();
}, "clear");
function ZB(t, e) {
  return t.intersect(e);
}
x(ZB, "intersectNode");
var Ile = ZB;
function QB(t, e, r, n) {
  var i = t.x, a = t.y, s = i - n.x, o = a - n.y, l = Math.sqrt(e * e * o * o + r * r * s * s), u = Math.abs(e * r * s / l);
  n.x < i && (u = -u);
  var h = Math.abs(e * r * o / l);
  return n.y < a && (h = -h), { x: i + u, y: a + h };
}
x(QB, "intersectEllipse");
var JB = QB;
function eF(t, e, r) {
  return JB(t, e, e, r);
}
x(eF, "intersectCircle");
var Dle = eF;
function tF(t, e, r, n) {
  {
    const i = e.y - t.y, a = t.x - e.x, s = e.x * t.y - t.x * e.y, o = i * r.x + a * r.y + s, l = i * n.x + a * n.y + s, u = 1e-6;
    if (o !== 0 && l !== 0 && Hw(o, l))
      return;
    const h = n.y - r.y, d = r.x - n.x, f = n.x * r.y - r.x * n.y, p = h * t.x + d * t.y + f, g = h * e.x + d * e.y + f;
    if (Math.abs(p) < u && Math.abs(g) < u && Hw(p, g))
      return;
    const m = i * d - h * a;
    if (m === 0)
      return;
    const v = Math.abs(m / 2);
    let y = a * f - d * s;
    const b = y < 0 ? (y - v) / m : (y + v) / m;
    y = h * s - i * f;
    const w = y < 0 ? (y - v) / m : (y + v) / m;
    return { x: b, y: w };
  }
}
x(tF, "intersectLine");
function Hw(t, e) {
  return t * e > 0;
}
x(Hw, "sameSign");
var Ole = tF;
function rF(t, e, r) {
  let n = t.x, i = t.y, a = [], s = Number.POSITIVE_INFINITY, o = Number.POSITIVE_INFINITY;
  typeof e.forEach == "function" ? e.forEach(function(h) {
    s = Math.min(s, h.x), o = Math.min(o, h.y);
  }) : (s = Math.min(s, e.x), o = Math.min(o, e.y));
  let l = n - t.width / 2 - s, u = i - t.height / 2 - o;
  for (let h = 0; h < e.length; h++) {
    let d = e[h], f = e[h < e.length - 1 ? h + 1 : 0], p = Ole(
      t,
      r,
      { x: l + d.x, y: u + d.y },
      { x: l + f.x, y: u + f.y }
    );
    p && a.push(p);
  }
  return a.length ? (a.length > 1 && a.sort(function(h, d) {
    let f = h.x - r.x, p = h.y - r.y, g = Math.sqrt(f * f + p * p), m = d.x - r.x, v = d.y - r.y, y = Math.sqrt(m * m + v * v);
    return g < y ? -1 : g === y ? 0 : 1;
  }), a[0]) : t;
}
x(rF, "intersectPolygon");
var Ple = rF, kt = {
  node: Ile,
  circle: Dle,
  ellipse: JB,
  polygon: Ple,
  rect: jd
};
function nF(t, e) {
  const { labelStyles: r } = St(e);
  e.labelStyle = r;
  const n = Ft(e);
  let i = n;
  n || (i = "anchor");
  const a = t.insert("g").attr("class", i).attr("id", e.domId || e.id), s = 1, { cssStyles: o } = e, l = Lt.svg(a), u = Rt(e, { fill: "black", stroke: "none", fillStyle: "solid" });
  e.look !== "handDrawn" && (u.roughness = 0);
  const h = l.circle(0, 0, s * 2, u), d = a.insert(() => h, ":first-child");
  return d.attr("class", "anchor").attr("style", ki(o)), Mt(e, d), e.intersect = function(f) {
    return ie.info("Circle intersect", e, s, f), kt.circle(e, s, f);
  }, a;
}
x(nF, "anchor");
function qw(t, e, r, n, i, a, s) {
  const l = (t + r) / 2, u = (e + n) / 2, h = Math.atan2(n - e, r - t), d = (r - t) / 2, f = (n - e) / 2, p = d / i, g = f / a, m = Math.sqrt(p ** 2 + g ** 2);
  if (m > 1)
    throw new Error("The given radii are too small to create an arc between the points.");
  const v = Math.sqrt(1 - m ** 2), y = l + v * a * Math.sin(h) * (s ? -1 : 1), b = u - v * i * Math.cos(h) * (s ? -1 : 1), w = Math.atan2((e - b) / a, (t - y) / i);
  let E = Math.atan2((n - b) / a, (r - y) / i) - w;
  s && E < 0 && (E += 2 * Math.PI), !s && E > 0 && (E -= 2 * Math.PI);
  const L = [];
  for (let k = 0; k < 20; k++) {
    const C = k / 19, A = w + C * E, R = y + i * Math.cos(A), _ = b + a * Math.sin(A);
    L.push({ x: R, y: _ });
  }
  return L;
}
x(qw, "generateArcPoints");
async function iF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ut(t, e, Ft(e)), s = a.width + e.padding + 20, o = a.height + e.padding, l = o / 2, u = l / (2.5 + o / 50), { cssStyles: h } = e, d = [
    { x: s / 2, y: -o / 2 },
    { x: -s / 2, y: -o / 2 },
    ...qw(-s / 2, -o / 2, -s / 2, o / 2, u, l, !1),
    { x: s / 2, y: o / 2 },
    ...qw(s / 2, o / 2, s / 2, -o / 2, u, l, !0)
  ], f = Lt.svg(i), p = Rt(e, {});
  e.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const g = ar(d), m = f.path(g, p), v = i.insert(() => m, ":first-child");
  return v.attr("class", "basic label-container"), h && e.look !== "handDrawn" && v.selectAll("path").attr("style", h), n && e.look !== "handDrawn" && v.selectAll("path").attr("style", n), v.attr("transform", `translate(${u / 2}, 0)`), Mt(e, v), e.intersect = function(y) {
    return kt.polygon(e, d, y);
  }, i;
}
x(iF, "bowTieRect");
function pc(t, e, r, n) {
  return t.insert("polygon", ":first-child").attr(
    "points",
    n.map(function(i) {
      return i.x + "," + i.y;
    }).join(" ")
  ).attr("class", "label-container").attr("transform", "translate(" + -e / 2 + "," + r / 2 + ")");
}
x(pc, "insertPolygonShape");
async function aF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ut(t, e, Ft(e)), s = a.height + e.padding, o = 12, l = a.width + e.padding + o, u = 0, h = l, d = -s, f = 0, p = [
    { x: u + o, y: d },
    { x: h, y: d },
    { x: h, y: f },
    { x: u, y: f },
    { x: u, y: d + o },
    { x: u + o, y: d }
  ];
  let g;
  const { cssStyles: m } = e;
  if (e.look === "handDrawn") {
    const v = Lt.svg(i), y = Rt(e, {}), b = ar(p), w = v.path(b, y);
    g = i.insert(() => w, ":first-child").attr("transform", `translate(${-l / 2}, ${s / 2})`), m && g.attr("style", m);
  } else
    g = pc(i, l, s, p);
  return n && g.attr("style", n), Mt(e, g), e.intersect = function(v) {
    return kt.polygon(e, p, v);
  }, i;
}
x(aF, "card");
function sF(t, e) {
  const { nodeStyles: r } = St(e);
  e.label = "";
  const n = t.insert("g").attr("class", Ft(e)).attr("id", e.domId ?? e.id), { cssStyles: i } = e, a = Math.max(28, e.width ?? 0), s = [
    { x: 0, y: a / 2 },
    { x: a / 2, y: 0 },
    { x: 0, y: -a / 2 },
    { x: -a / 2, y: 0 }
  ], o = Lt.svg(n), l = Rt(e, {});
  e.look !== "handDrawn" && (l.roughness = 0, l.fillStyle = "solid");
  const u = ar(s), h = o.path(u, l), d = n.insert(() => h, ":first-child");
  return i && e.look !== "handDrawn" && d.selectAll("path").attr("style", i), r && e.look !== "handDrawn" && d.selectAll("path").attr("style", r), e.width = 28, e.height = 28, e.intersect = function(f) {
    return kt.polygon(e, s, f);
  }, n;
}
x(sF, "choice");
async function ak(t, e, r) {
  const { labelStyles: n, nodeStyles: i } = St(e);
  e.labelStyle = n;
  const { shapeSvg: a, bbox: s, halfPadding: o } = await Ut(t, e, Ft(e)), l = r?.padding ?? o, u = s.width / 2 + l;
  let h;
  const { cssStyles: d } = e;
  if (e.look === "handDrawn") {
    const f = Lt.svg(a), p = Rt(e, {}), g = f.circle(0, 0, u * 2, p);
    h = a.insert(() => g, ":first-child"), h.attr("class", "basic label-container").attr("style", ki(d));
  } else
    h = a.insert("circle", ":first-child").attr("class", "basic label-container").attr("style", i).attr("r", u).attr("cx", 0).attr("cy", 0);
  return Mt(e, h), e.calcIntersect = function(f, p) {
    const g = f.width / 2;
    return kt.circle(f, g, p);
  }, e.intersect = function(f) {
    return ie.info("Circle intersect", e, u, f), kt.circle(e, u, f);
  }, a;
}
x(ak, "circle");
function oF(t) {
  const e = Math.cos(Math.PI / 4), r = Math.sin(Math.PI / 4), n = t * 2, i = { x: n / 2 * e, y: n / 2 * r }, a = { x: -(n / 2) * e, y: n / 2 * r }, s = { x: -(n / 2) * e, y: -(n / 2) * r }, o = { x: n / 2 * e, y: -(n / 2) * r };
  return `M ${a.x},${a.y} L ${o.x},${o.y}
                   M ${i.x},${i.y} L ${s.x},${s.y}`;
}
x(oF, "createLine");
function lF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r, e.label = "";
  const i = t.insert("g").attr("class", Ft(e)).attr("id", e.domId ?? e.id), a = Math.max(30, e?.width ?? 0), { cssStyles: s } = e, o = Lt.svg(i), l = Rt(e, {});
  e.look !== "handDrawn" && (l.roughness = 0, l.fillStyle = "solid");
  const u = o.circle(0, 0, a * 2, l), h = oF(a), d = o.path(h, l), f = i.insert(() => u, ":first-child");
  return f.insert(() => d), s && e.look !== "handDrawn" && f.selectAll("path").attr("style", s), n && e.look !== "handDrawn" && f.selectAll("path").attr("style", n), Mt(e, f), e.intersect = function(p) {
    return ie.info("crossedCircle intersect", e, { radius: a, point: p }), kt.circle(e, a, p);
  }, i;
}
x(lF, "crossedCircle");
function Lo(t, e, r, n = 100, i = 0, a = 180) {
  const s = [], o = i * Math.PI / 180, h = (a * Math.PI / 180 - o) / (n - 1);
  for (let d = 0; d < n; d++) {
    const f = o + d * h, p = t + r * Math.cos(f), g = e + r * Math.sin(f);
    s.push({ x: -p, y: -g });
  }
  return s;
}
x(Lo, "generateCirclePoints");
async function cF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ut(t, e, Ft(e)), o = a.width + (e.padding ?? 0), l = a.height + (e.padding ?? 0), u = Math.max(5, l * 0.1), { cssStyles: h } = e, d = [
    ...Lo(o / 2, -l / 2, u, 30, -90, 0),
    { x: -o / 2 - u, y: u },
    ...Lo(o / 2 + u * 2, -u, u, 20, -180, -270),
    ...Lo(o / 2 + u * 2, u, u, 20, -90, -180),
    { x: -o / 2 - u, y: -l / 2 },
    ...Lo(o / 2, l / 2, u, 20, 0, 90)
  ], f = [
    { x: o / 2, y: -l / 2 - u },
    { x: -o / 2, y: -l / 2 - u },
    ...Lo(o / 2, -l / 2, u, 20, -90, 0),
    { x: -o / 2 - u, y: -u },
    ...Lo(o / 2 + o * 0.1, -u, u, 20, -180, -270),
    ...Lo(o / 2 + o * 0.1, u, u, 20, -90, -180),
    { x: -o / 2 - u, y: l / 2 },
    ...Lo(o / 2, l / 2, u, 20, 0, 90),
    { x: -o / 2, y: l / 2 + u },
    { x: o / 2, y: l / 2 + u }
  ], p = Lt.svg(i), g = Rt(e, { fill: "none" });
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const v = ar(d).replace("Z", ""), y = p.path(v, g), b = ar(f), w = p.path(b, { ...g }), T = i.insert("g", ":first-child");
  return T.insert(() => w, ":first-child").attr("stroke-opacity", 0), T.insert(() => y, ":first-child"), T.attr("class", "text"), h && e.look !== "handDrawn" && T.selectAll("path").attr("style", h), n && e.look !== "handDrawn" && T.selectAll("path").attr("style", n), T.attr("transform", `translate(${u}, 0)`), s.attr(
    "transform",
    `translate(${-o / 2 + u - (a.x - (a.left ?? 0))},${-l / 2 + (e.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`
  ), Mt(e, T), e.intersect = function(E) {
    return kt.polygon(e, f, E);
  }, i;
}
x(cF, "curlyBraceLeft");
function Ro(t, e, r, n = 100, i = 0, a = 180) {
  const s = [], o = i * Math.PI / 180, h = (a * Math.PI / 180 - o) / (n - 1);
  for (let d = 0; d < n; d++) {
    const f = o + d * h, p = t + r * Math.cos(f), g = e + r * Math.sin(f);
    s.push({ x: p, y: g });
  }
  return s;
}
x(Ro, "generateCirclePoints");
async function uF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ut(t, e, Ft(e)), o = a.width + (e.padding ?? 0), l = a.height + (e.padding ?? 0), u = Math.max(5, l * 0.1), { cssStyles: h } = e, d = [
    ...Ro(o / 2, -l / 2, u, 20, -90, 0),
    { x: o / 2 + u, y: -u },
    ...Ro(o / 2 + u * 2, -u, u, 20, -180, -270),
    ...Ro(o / 2 + u * 2, u, u, 20, -90, -180),
    { x: o / 2 + u, y: l / 2 },
    ...Ro(o / 2, l / 2, u, 20, 0, 90)
  ], f = [
    { x: -o / 2, y: -l / 2 - u },
    { x: o / 2, y: -l / 2 - u },
    ...Ro(o / 2, -l / 2, u, 20, -90, 0),
    { x: o / 2 + u, y: -u },
    ...Ro(o / 2 + u * 2, -u, u, 20, -180, -270),
    ...Ro(o / 2 + u * 2, u, u, 20, -90, -180),
    { x: o / 2 + u, y: l / 2 },
    ...Ro(o / 2, l / 2, u, 20, 0, 90),
    { x: o / 2, y: l / 2 + u },
    { x: -o / 2, y: l / 2 + u }
  ], p = Lt.svg(i), g = Rt(e, { fill: "none" });
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const v = ar(d).replace("Z", ""), y = p.path(v, g), b = ar(f), w = p.path(b, { ...g }), T = i.insert("g", ":first-child");
  return T.insert(() => w, ":first-child").attr("stroke-opacity", 0), T.insert(() => y, ":first-child"), T.attr("class", "text"), h && e.look !== "handDrawn" && T.selectAll("path").attr("style", h), n && e.look !== "handDrawn" && T.selectAll("path").attr("style", n), T.attr("transform", `translate(${-u}, 0)`), s.attr(
    "transform",
    `translate(${-o / 2 + (e.padding ?? 0) / 2 - (a.x - (a.left ?? 0))},${-l / 2 + (e.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`
  ), Mt(e, T), e.intersect = function(E) {
    return kt.polygon(e, f, E);
  }, i;
}
x(uF, "curlyBraceRight");
function ri(t, e, r, n = 100, i = 0, a = 180) {
  const s = [], o = i * Math.PI / 180, h = (a * Math.PI / 180 - o) / (n - 1);
  for (let d = 0; d < n; d++) {
    const f = o + d * h, p = t + r * Math.cos(f), g = e + r * Math.sin(f);
    s.push({ x: -p, y: -g });
  }
  return s;
}
x(ri, "generateCirclePoints");
async function hF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ut(t, e, Ft(e)), o = a.width + (e.padding ?? 0), l = a.height + (e.padding ?? 0), u = Math.max(5, l * 0.1), { cssStyles: h } = e, d = [
    ...ri(o / 2, -l / 2, u, 30, -90, 0),
    { x: -o / 2 - u, y: u },
    ...ri(o / 2 + u * 2, -u, u, 20, -180, -270),
    ...ri(o / 2 + u * 2, u, u, 20, -90, -180),
    { x: -o / 2 - u, y: -l / 2 },
    ...ri(o / 2, l / 2, u, 20, 0, 90)
  ], f = [
    ...ri(-o / 2 + u + u / 2, -l / 2, u, 20, -90, -180),
    { x: o / 2 - u / 2, y: u },
    ...ri(-o / 2 - u / 2, -u, u, 20, 0, 90),
    ...ri(-o / 2 - u / 2, u, u, 20, -90, 0),
    { x: o / 2 - u / 2, y: -u },
    ...ri(-o / 2 + u + u / 2, l / 2, u, 30, -180, -270)
  ], p = [
    { x: o / 2, y: -l / 2 - u },
    { x: -o / 2, y: -l / 2 - u },
    ...ri(o / 2, -l / 2, u, 20, -90, 0),
    { x: -o / 2 - u, y: -u },
    ...ri(o / 2 + u * 2, -u, u, 20, -180, -270),
    ...ri(o / 2 + u * 2, u, u, 20, -90, -180),
    { x: -o / 2 - u, y: l / 2 },
    ...ri(o / 2, l / 2, u, 20, 0, 90),
    { x: -o / 2, y: l / 2 + u },
    { x: o / 2 - u - u / 2, y: l / 2 + u },
    ...ri(-o / 2 + u + u / 2, -l / 2, u, 20, -90, -180),
    { x: o / 2 - u / 2, y: u },
    ...ri(-o / 2 - u / 2, -u, u, 20, 0, 90),
    ...ri(-o / 2 - u / 2, u, u, 20, -90, 0),
    { x: o / 2 - u / 2, y: -u },
    ...ri(-o / 2 + u + u / 2, l / 2, u, 30, -180, -270)
  ], g = Lt.svg(i), m = Rt(e, { fill: "none" });
  e.look !== "handDrawn" && (m.roughness = 0, m.fillStyle = "solid");
  const y = ar(d).replace("Z", ""), b = g.path(y, m), T = ar(f).replace("Z", ""), E = g.path(T, m), L = ar(p), k = g.path(L, { ...m }), C = i.insert("g", ":first-child");
  return C.insert(() => k, ":first-child").attr("stroke-opacity", 0), C.insert(() => b, ":first-child"), C.insert(() => E, ":first-child"), C.attr("class", "text"), h && e.look !== "handDrawn" && C.selectAll("path").attr("style", h), n && e.look !== "handDrawn" && C.selectAll("path").attr("style", n), C.attr("transform", `translate(${u - u / 4}, 0)`), s.attr(
    "transform",
    `translate(${-o / 2 + (e.padding ?? 0) / 2 - (a.x - (a.left ?? 0))},${-l / 2 + (e.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`
  ), Mt(e, C), e.intersect = function(A) {
    return kt.polygon(e, p, A);
  }, i;
}
x(hF, "curlyBraces");
async function dF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ut(t, e, Ft(e)), s = 80, o = 20, l = Math.max(s, (a.width + (e.padding ?? 0) * 2) * 1.25, e?.width ?? 0), u = Math.max(o, a.height + (e.padding ?? 0) * 2, e?.height ?? 0), h = u / 2, { cssStyles: d } = e, f = Lt.svg(i), p = Rt(e, {});
  e.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const g = l, m = u, v = g - h, y = m / 4, b = [
    { x: v, y: 0 },
    { x: y, y: 0 },
    { x: 0, y: m / 2 },
    { x: y, y: m },
    { x: v, y: m },
    ...kp(-v, -m / 2, h, 50, 270, 90)
  ], w = ar(b), T = f.path(w, p), E = i.insert(() => T, ":first-child");
  return E.attr("class", "basic label-container"), d && e.look !== "handDrawn" && E.selectChildren("path").attr("style", d), n && e.look !== "handDrawn" && E.selectChildren("path").attr("style", n), E.attr("transform", `translate(${-l / 2}, ${-u / 2})`), Mt(e, E), e.intersect = function(L) {
    return kt.polygon(e, b, L);
  }, i;
}
x(dF, "curvedTrapezoid");
var Ble = /* @__PURE__ */ x((t, e, r, n, i, a) => [
  `M${t},${e + a}`,
  `a${i},${a} 0,0,0 ${r},0`,
  `a${i},${a} 0,0,0 ${-r},0`,
  `l0,${n}`,
  `a${i},${a} 0,0,0 ${r},0`,
  `l0,${-n}`
].join(" "), "createCylinderPathD"), Fle = /* @__PURE__ */ x((t, e, r, n, i, a) => [
  `M${t},${e + a}`,
  `M${t + r},${e + a}`,
  `a${i},${a} 0,0,0 ${-r},0`,
  `l0,${n}`,
  `a${i},${a} 0,0,0 ${r},0`,
  `l0,${-n}`
].join(" "), "createOuterCylinderPathD"), $le = /* @__PURE__ */ x((t, e, r, n, i, a) => [`M${t - r / 2},${-n / 2}`, `a${i},${a} 0,0,0 ${r},0`].join(" "), "createInnerCylinderPathD");
async function fF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ut(t, e, Ft(e)), o = Math.max(a.width + e.padding, e.width ?? 0), l = o / 2, u = l / (2.5 + o / 50), h = Math.max(a.height + u + e.padding, e.height ?? 0);
  let d;
  const { cssStyles: f } = e;
  if (e.look === "handDrawn") {
    const p = Lt.svg(i), g = Fle(0, 0, o, h, l, u), m = $le(0, u, o, h, l, u), v = p.path(g, Rt(e, {})), y = p.path(m, Rt(e, { fill: "none" }));
    d = i.insert(() => y, ":first-child"), d = i.insert(() => v, ":first-child"), d.attr("class", "basic label-container"), f && d.attr("style", f);
  } else {
    const p = Ble(0, 0, o, h, l, u);
    d = i.insert("path", ":first-child").attr("d", p).attr("class", "basic label-container").attr("style", ki(f)).attr("style", n);
  }
  return d.attr("label-offset-y", u), d.attr("transform", `translate(${-o / 2}, ${-(h / 2 + u)})`), Mt(e, d), s.attr(
    "transform",
    `translate(${-(a.width / 2) - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + (e.padding ?? 0) / 1.5 - (a.y - (a.top ?? 0))})`
  ), e.intersect = function(p) {
    const g = kt.rect(e, p), m = g.x - (e.x ?? 0);
    if (l != 0 && (Math.abs(m) < (e.width ?? 0) / 2 || Math.abs(m) == (e.width ?? 0) / 2 && Math.abs(g.y - (e.y ?? 0)) > (e.height ?? 0) / 2 - u)) {
      let v = u * u * (1 - m * m / (l * l));
      v > 0 && (v = Math.sqrt(v)), v = u - v, p.y - (e.y ?? 0) > 0 && (v = -v), g.y += v;
    }
    return g;
  }, i;
}
x(fF, "cylinder");
async function pF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ut(t, e, Ft(e)), o = a.width + e.padding, l = a.height + e.padding, u = l * 0.2, h = -o / 2, d = -l / 2 - u / 2, { cssStyles: f } = e, p = Lt.svg(i), g = Rt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const m = [
    { x: h, y: d + u },
    { x: -h, y: d + u },
    { x: -h, y: -d },
    { x: h, y: -d },
    { x: h, y: d },
    { x: -h, y: d },
    { x: -h, y: d + u }
  ], v = p.polygon(
    m.map((b) => [b.x, b.y]),
    g
  ), y = i.insert(() => v, ":first-child");
  return y.attr("class", "basic label-container"), f && e.look !== "handDrawn" && y.selectAll("path").attr("style", f), n && e.look !== "handDrawn" && y.selectAll("path").attr("style", n), s.attr(
    "transform",
    `translate(${h + (e.padding ?? 0) / 2 - (a.x - (a.left ?? 0))}, ${d + u + (e.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`
  ), Mt(e, y), e.intersect = function(b) {
    return kt.rect(e, b);
  }, i;
}
x(pF, "dividedRectangle");
async function gF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, halfPadding: s } = await Ut(t, e, Ft(e)), l = a.width / 2 + s + 5, u = a.width / 2 + s;
  let h;
  const { cssStyles: d } = e;
  if (e.look === "handDrawn") {
    const f = Lt.svg(i), p = Rt(e, { roughness: 0.2, strokeWidth: 2.5 }), g = Rt(e, { roughness: 0.2, strokeWidth: 1.5 }), m = f.circle(0, 0, l * 2, p), v = f.circle(0, 0, u * 2, g);
    h = i.insert("g", ":first-child"), h.attr("class", ki(e.cssClasses)).attr("style", ki(d)), h.node()?.appendChild(m), h.node()?.appendChild(v);
  } else {
    h = i.insert("g", ":first-child");
    const f = h.insert("circle", ":first-child"), p = h.insert("circle");
    h.attr("class", "basic label-container").attr("style", n), f.attr("class", "outer-circle").attr("style", n).attr("r", l).attr("cx", 0).attr("cy", 0), p.attr("class", "inner-circle").attr("style", n).attr("r", u).attr("cx", 0).attr("cy", 0);
  }
  return Mt(e, h), e.intersect = function(f) {
    return ie.info("DoubleCircle intersect", e, l, f), kt.circle(e, l, f);
  }, i;
}
x(gF, "doublecircle");
function mF(t, e, { config: { themeVariables: r } }) {
  const { labelStyles: n, nodeStyles: i } = St(e);
  e.label = "", e.labelStyle = n;
  const a = t.insert("g").attr("class", Ft(e)).attr("id", e.domId ?? e.id), s = 7, { cssStyles: o } = e, l = Lt.svg(a), { nodeBorder: u } = r, h = Rt(e, { fillStyle: "solid" });
  e.look !== "handDrawn" && (h.roughness = 0);
  const d = l.circle(0, 0, s * 2, h), f = a.insert(() => d, ":first-child");
  return f.selectAll("path").attr("style", `fill: ${u} !important;`), o && o.length > 0 && e.look !== "handDrawn" && f.selectAll("path").attr("style", o), i && e.look !== "handDrawn" && f.selectAll("path").attr("style", i), Mt(e, f), e.intersect = function(p) {
    return ie.info("filledCircle intersect", e, { radius: s, point: p }), kt.circle(e, s, p);
  }, a;
}
x(mF, "filledCircle");
async function vF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ut(t, e, Ft(e)), o = a.width + (e.padding ?? 0), l = o + a.height, u = o + a.height, h = [
    { x: 0, y: -l },
    { x: u, y: -l },
    { x: u / 2, y: 0 }
  ], { cssStyles: d } = e, f = Lt.svg(i), p = Rt(e, {});
  e.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const g = ar(h), m = f.path(g, p), v = i.insert(() => m, ":first-child").attr("transform", `translate(${-l / 2}, ${l / 2})`);
  return d && e.look !== "handDrawn" && v.selectChildren("path").attr("style", d), n && e.look !== "handDrawn" && v.selectChildren("path").attr("style", n), e.width = o, e.height = l, Mt(e, v), s.attr(
    "transform",
    `translate(${-a.width / 2 - (a.x - (a.left ?? 0))}, ${-l / 2 + (e.padding ?? 0) / 2 + (a.y - (a.top ?? 0))})`
  ), e.intersect = function(y) {
    return ie.info("Triangle intersect", e, h, y), kt.polygon(e, h, y);
  }, i;
}
x(vF, "flippedTriangle");
function yF(t, e, { dir: r, config: { state: n, themeVariables: i } }) {
  const { nodeStyles: a } = St(e);
  e.label = "";
  const s = t.insert("g").attr("class", Ft(e)).attr("id", e.domId ?? e.id), { cssStyles: o } = e;
  let l = Math.max(70, e?.width ?? 0), u = Math.max(10, e?.height ?? 0);
  r === "LR" && (l = Math.max(10, e?.width ?? 0), u = Math.max(70, e?.height ?? 0));
  const h = -1 * l / 2, d = -1 * u / 2, f = Lt.svg(s), p = Rt(e, {
    stroke: i.lineColor,
    fill: i.lineColor
  });
  e.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const g = f.rectangle(h, d, l, u, p), m = s.insert(() => g, ":first-child");
  o && e.look !== "handDrawn" && m.selectAll("path").attr("style", o), a && e.look !== "handDrawn" && m.selectAll("path").attr("style", a), Mt(e, m);
  const v = n?.padding ?? 0;
  return e.width && e.height && (e.width += v / 2 || 0, e.height += v / 2 || 0), e.intersect = function(y) {
    return kt.rect(e, y);
  }, s;
}
x(yF, "forkJoin");
async function xF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const i = 80, a = 50, { shapeSvg: s, bbox: o } = await Ut(t, e, Ft(e)), l = Math.max(i, o.width + (e.padding ?? 0) * 2, e?.width ?? 0), u = Math.max(a, o.height + (e.padding ?? 0) * 2, e?.height ?? 0), h = u / 2, { cssStyles: d } = e, f = Lt.svg(s), p = Rt(e, {});
  e.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const g = [
    { x: -l / 2, y: -u / 2 },
    { x: l / 2 - h, y: -u / 2 },
    ...kp(-l / 2 + h, 0, h, 50, 90, 270),
    { x: l / 2 - h, y: u / 2 },
    { x: -l / 2, y: u / 2 }
  ], m = ar(g), v = f.path(m, p), y = s.insert(() => v, ":first-child");
  return y.attr("class", "basic label-container"), d && e.look !== "handDrawn" && y.selectChildren("path").attr("style", d), n && e.look !== "handDrawn" && y.selectChildren("path").attr("style", n), Mt(e, y), e.intersect = function(b) {
    return ie.info("Pill intersect", e, { radius: h, point: b }), kt.polygon(e, g, b);
  }, s;
}
x(xF, "halfRoundedRectangle");
async function bF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ut(t, e, Ft(e)), s = a.height + (e.padding ?? 0), o = a.width + (e.padding ?? 0) * 2.5, { cssStyles: l } = e, u = Lt.svg(i), h = Rt(e, {});
  e.look !== "handDrawn" && (h.roughness = 0, h.fillStyle = "solid");
  let d = o / 2;
  const f = d / 6;
  d = d + f;
  const p = s / 2, g = p / 2, m = d - g, v = [
    { x: -m, y: -p },
    { x: 0, y: -p },
    { x: m, y: -p },
    { x: d, y: 0 },
    { x: m, y: p },
    { x: 0, y: p },
    { x: -m, y: p },
    { x: -d, y: 0 }
  ], y = ar(v), b = u.path(y, h), w = i.insert(() => b, ":first-child");
  return w.attr("class", "basic label-container"), l && e.look !== "handDrawn" && w.selectChildren("path").attr("style", l), n && e.look !== "handDrawn" && w.selectChildren("path").attr("style", n), e.width = o, e.height = s, Mt(e, w), e.intersect = function(T) {
    return kt.polygon(e, v, T);
  }, i;
}
x(bF, "hexagon");
async function wF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.label = "", e.labelStyle = r;
  const { shapeSvg: i } = await Ut(t, e, Ft(e)), a = Math.max(30, e?.width ?? 0), s = Math.max(30, e?.height ?? 0), { cssStyles: o } = e, l = Lt.svg(i), u = Rt(e, {});
  e.look !== "handDrawn" && (u.roughness = 0, u.fillStyle = "solid");
  const h = [
    { x: 0, y: 0 },
    { x: a, y: 0 },
    { x: 0, y: s },
    { x: a, y: s }
  ], d = ar(h), f = l.path(d, u), p = i.insert(() => f, ":first-child");
  return p.attr("class", "basic label-container"), o && e.look !== "handDrawn" && p.selectChildren("path").attr("style", o), n && e.look !== "handDrawn" && p.selectChildren("path").attr("style", n), p.attr("transform", `translate(${-a / 2}, ${-s / 2})`), Mt(e, p), e.intersect = function(g) {
    return ie.info("Pill intersect", e, { points: h }), kt.polygon(e, h, g);
  }, i;
}
x(wF, "hourglass");
async function TF(t, e, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = St(e);
  e.labelStyle = i;
  const a = e.assetHeight ?? 48, s = e.assetWidth ?? 48, o = Math.max(a, s), l = n?.wrappingWidth;
  e.width = Math.max(o, l ?? 0);
  const { shapeSvg: u, bbox: h, label: d } = await Ut(t, e, "icon-shape default"), f = e.pos === "t", p = o, g = o, { nodeBorder: m } = r, { stylesMap: v } = Wd(e), y = -g / 2, b = -p / 2, w = e.label ? 8 : 0, T = Lt.svg(u), E = Rt(e, { stroke: "none", fill: "none" });
  e.look !== "handDrawn" && (E.roughness = 0, E.fillStyle = "solid");
  const L = T.rectangle(y, b, g, p, E), k = Math.max(g, h.width), C = p + h.height + w, A = T.rectangle(-k / 2, -C / 2, k, C, {
    ...E,
    fill: "transparent",
    stroke: "none"
  }), R = u.insert(() => L, ":first-child"), _ = u.insert(() => A);
  if (e.icon) {
    const O = u.append("g");
    O.html(
      `<g>${await ql(e.icon, {
        height: o,
        width: o,
        fallbackPrefix: ""
      })}</g>`
    );
    const P = O.node().getBBox(), S = P.width, M = P.height, N = P.x, D = P.y;
    O.attr(
      "transform",
      `translate(${-S / 2 - N},${f ? h.height / 2 + w / 2 - M / 2 - D : -h.height / 2 - w / 2 - M / 2 - D})`
    ), O.attr("style", `color: ${v.get("stroke") ?? m};`);
  }
  return d.attr(
    "transform",
    `translate(${-h.width / 2 - (h.x - (h.left ?? 0))},${f ? -C / 2 : C / 2 - h.height})`
  ), R.attr(
    "transform",
    `translate(0,${f ? h.height / 2 + w / 2 : -h.height / 2 - w / 2})`
  ), Mt(e, _), e.intersect = function(O) {
    if (ie.info("iconSquare intersect", e, O), !e.label)
      return kt.rect(e, O);
    const P = e.x ?? 0, S = e.y ?? 0, M = e.height ?? 0;
    let N = [];
    return f ? N = [
      { x: P - h.width / 2, y: S - M / 2 },
      { x: P + h.width / 2, y: S - M / 2 },
      { x: P + h.width / 2, y: S - M / 2 + h.height + w },
      { x: P + g / 2, y: S - M / 2 + h.height + w },
      { x: P + g / 2, y: S + M / 2 },
      { x: P - g / 2, y: S + M / 2 },
      { x: P - g / 2, y: S - M / 2 + h.height + w },
      { x: P - h.width / 2, y: S - M / 2 + h.height + w }
    ] : N = [
      { x: P - g / 2, y: S - M / 2 },
      { x: P + g / 2, y: S - M / 2 },
      { x: P + g / 2, y: S - M / 2 + p },
      { x: P + h.width / 2, y: S - M / 2 + p },
      { x: P + h.width / 2 / 2, y: S + M / 2 },
      { x: P - h.width / 2, y: S + M / 2 },
      { x: P - h.width / 2, y: S - M / 2 + p },
      { x: P - g / 2, y: S - M / 2 + p }
    ], kt.polygon(e, N, O);
  }, u;
}
x(TF, "icon");
async function EF(t, e, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = St(e);
  e.labelStyle = i;
  const a = e.assetHeight ?? 48, s = e.assetWidth ?? 48, o = Math.max(a, s), l = n?.wrappingWidth;
  e.width = Math.max(o, l ?? 0);
  const { shapeSvg: u, bbox: h, label: d } = await Ut(t, e, "icon-shape default"), f = 20, p = e.label ? 8 : 0, g = e.pos === "t", { nodeBorder: m, mainBkg: v } = r, { stylesMap: y } = Wd(e), b = Lt.svg(u), w = Rt(e, {});
  e.look !== "handDrawn" && (w.roughness = 0, w.fillStyle = "solid");
  const T = y.get("fill");
  w.stroke = T ?? v;
  const E = u.append("g");
  e.icon && E.html(
    `<g>${await ql(e.icon, {
      height: o,
      width: o,
      fallbackPrefix: ""
    })}</g>`
  );
  const L = E.node().getBBox(), k = L.width, C = L.height, A = L.x, R = L.y, _ = Math.max(k, C) * Math.SQRT2 + f * 2, O = b.circle(0, 0, _, w), P = Math.max(_, h.width), S = _ + h.height + p, M = b.rectangle(-P / 2, -S / 2, P, S, {
    ...w,
    fill: "transparent",
    stroke: "none"
  }), N = u.insert(() => O, ":first-child"), D = u.insert(() => M);
  return E.attr(
    "transform",
    `translate(${-k / 2 - A},${g ? h.height / 2 + p / 2 - C / 2 - R : -h.height / 2 - p / 2 - C / 2 - R})`
  ), E.attr("style", `color: ${y.get("stroke") ?? m};`), d.attr(
    "transform",
    `translate(${-h.width / 2 - (h.x - (h.left ?? 0))},${g ? -S / 2 : S / 2 - h.height})`
  ), N.attr(
    "transform",
    `translate(0,${g ? h.height / 2 + p / 2 : -h.height / 2 - p / 2})`
  ), Mt(e, D), e.intersect = function(I) {
    return ie.info("iconSquare intersect", e, I), kt.rect(e, I);
  }, u;
}
x(EF, "iconCircle");
async function kF(t, e, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = St(e);
  e.labelStyle = i;
  const a = e.assetHeight ?? 48, s = e.assetWidth ?? 48, o = Math.max(a, s), l = n?.wrappingWidth;
  e.width = Math.max(o, l ?? 0);
  const { shapeSvg: u, bbox: h, halfPadding: d, label: f } = await Ut(
    t,
    e,
    "icon-shape default"
  ), p = e.pos === "t", g = o + d * 2, m = o + d * 2, { nodeBorder: v, mainBkg: y } = r, { stylesMap: b } = Wd(e), w = -m / 2, T = -g / 2, E = e.label ? 8 : 0, L = Lt.svg(u), k = Rt(e, {});
  e.look !== "handDrawn" && (k.roughness = 0, k.fillStyle = "solid");
  const C = b.get("fill");
  k.stroke = C ?? y;
  const A = L.path(fc(w, T, m, g, 5), k), R = Math.max(m, h.width), _ = g + h.height + E, O = L.rectangle(-R / 2, -_ / 2, R, _, {
    ...k,
    fill: "transparent",
    stroke: "none"
  }), P = u.insert(() => A, ":first-child").attr("class", "icon-shape2"), S = u.insert(() => O);
  if (e.icon) {
    const M = u.append("g");
    M.html(
      `<g>${await ql(e.icon, {
        height: o,
        width: o,
        fallbackPrefix: ""
      })}</g>`
    );
    const N = M.node().getBBox(), D = N.width, I = N.height, B = N.x, z = N.y;
    M.attr(
      "transform",
      `translate(${-D / 2 - B},${p ? h.height / 2 + E / 2 - I / 2 - z : -h.height / 2 - E / 2 - I / 2 - z})`
    ), M.attr("style", `color: ${b.get("stroke") ?? v};`);
  }
  return f.attr(
    "transform",
    `translate(${-h.width / 2 - (h.x - (h.left ?? 0))},${p ? -_ / 2 : _ / 2 - h.height})`
  ), P.attr(
    "transform",
    `translate(0,${p ? h.height / 2 + E / 2 : -h.height / 2 - E / 2})`
  ), Mt(e, S), e.intersect = function(M) {
    if (ie.info("iconSquare intersect", e, M), !e.label)
      return kt.rect(e, M);
    const N = e.x ?? 0, D = e.y ?? 0, I = e.height ?? 0;
    let B = [];
    return p ? B = [
      { x: N - h.width / 2, y: D - I / 2 },
      { x: N + h.width / 2, y: D - I / 2 },
      { x: N + h.width / 2, y: D - I / 2 + h.height + E },
      { x: N + m / 2, y: D - I / 2 + h.height + E },
      { x: N + m / 2, y: D + I / 2 },
      { x: N - m / 2, y: D + I / 2 },
      { x: N - m / 2, y: D - I / 2 + h.height + E },
      { x: N - h.width / 2, y: D - I / 2 + h.height + E }
    ] : B = [
      { x: N - m / 2, y: D - I / 2 },
      { x: N + m / 2, y: D - I / 2 },
      { x: N + m / 2, y: D - I / 2 + g },
      { x: N + h.width / 2, y: D - I / 2 + g },
      { x: N + h.width / 2 / 2, y: D + I / 2 },
      { x: N - h.width / 2, y: D + I / 2 },
      { x: N - h.width / 2, y: D - I / 2 + g },
      { x: N - m / 2, y: D - I / 2 + g }
    ], kt.polygon(e, B, M);
  }, u;
}
x(kF, "iconRounded");
async function SF(t, e, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = St(e);
  e.labelStyle = i;
  const a = e.assetHeight ?? 48, s = e.assetWidth ?? 48, o = Math.max(a, s), l = n?.wrappingWidth;
  e.width = Math.max(o, l ?? 0);
  const { shapeSvg: u, bbox: h, halfPadding: d, label: f } = await Ut(
    t,
    e,
    "icon-shape default"
  ), p = e.pos === "t", g = o + d * 2, m = o + d * 2, { nodeBorder: v, mainBkg: y } = r, { stylesMap: b } = Wd(e), w = -m / 2, T = -g / 2, E = e.label ? 8 : 0, L = Lt.svg(u), k = Rt(e, {});
  e.look !== "handDrawn" && (k.roughness = 0, k.fillStyle = "solid");
  const C = b.get("fill");
  k.stroke = C ?? y;
  const A = L.path(fc(w, T, m, g, 0.1), k), R = Math.max(m, h.width), _ = g + h.height + E, O = L.rectangle(-R / 2, -_ / 2, R, _, {
    ...k,
    fill: "transparent",
    stroke: "none"
  }), P = u.insert(() => A, ":first-child"), S = u.insert(() => O);
  if (e.icon) {
    const M = u.append("g");
    M.html(
      `<g>${await ql(e.icon, {
        height: o,
        width: o,
        fallbackPrefix: ""
      })}</g>`
    );
    const N = M.node().getBBox(), D = N.width, I = N.height, B = N.x, z = N.y;
    M.attr(
      "transform",
      `translate(${-D / 2 - B},${p ? h.height / 2 + E / 2 - I / 2 - z : -h.height / 2 - E / 2 - I / 2 - z})`
    ), M.attr("style", `color: ${b.get("stroke") ?? v};`);
  }
  return f.attr(
    "transform",
    `translate(${-h.width / 2 - (h.x - (h.left ?? 0))},${p ? -_ / 2 : _ / 2 - h.height})`
  ), P.attr(
    "transform",
    `translate(0,${p ? h.height / 2 + E / 2 : -h.height / 2 - E / 2})`
  ), Mt(e, S), e.intersect = function(M) {
    if (ie.info("iconSquare intersect", e, M), !e.label)
      return kt.rect(e, M);
    const N = e.x ?? 0, D = e.y ?? 0, I = e.height ?? 0;
    let B = [];
    return p ? B = [
      { x: N - h.width / 2, y: D - I / 2 },
      { x: N + h.width / 2, y: D - I / 2 },
      { x: N + h.width / 2, y: D - I / 2 + h.height + E },
      { x: N + m / 2, y: D - I / 2 + h.height + E },
      { x: N + m / 2, y: D + I / 2 },
      { x: N - m / 2, y: D + I / 2 },
      { x: N - m / 2, y: D - I / 2 + h.height + E },
      { x: N - h.width / 2, y: D - I / 2 + h.height + E }
    ] : B = [
      { x: N - m / 2, y: D - I / 2 },
      { x: N + m / 2, y: D - I / 2 },
      { x: N + m / 2, y: D - I / 2 + g },
      { x: N + h.width / 2, y: D - I / 2 + g },
      { x: N + h.width / 2 / 2, y: D + I / 2 },
      { x: N - h.width / 2, y: D + I / 2 },
      { x: N - h.width / 2, y: D - I / 2 + g },
      { x: N - m / 2, y: D - I / 2 + g }
    ], kt.polygon(e, B, M);
  }, u;
}
x(SF, "iconSquare");
async function CF(t, e, { config: { flowchart: r } }) {
  const n = new Image();
  n.src = e?.img ?? "", await n.decode();
  const i = Number(n.naturalWidth.toString().replace("px", "")), a = Number(n.naturalHeight.toString().replace("px", ""));
  e.imageAspectRatio = i / a;
  const { labelStyles: s } = St(e);
  e.labelStyle = s;
  const o = r?.wrappingWidth;
  e.defaultWidth = r?.wrappingWidth;
  const l = Math.max(
    e.label ? o ?? 0 : 0,
    e?.assetWidth ?? i
  ), u = e.constraint === "on" && e?.assetHeight ? e.assetHeight * e.imageAspectRatio : l, h = e.constraint === "on" ? u / e.imageAspectRatio : e?.assetHeight ?? a;
  e.width = Math.max(u, o ?? 0);
  const { shapeSvg: d, bbox: f, label: p } = await Ut(t, e, "image-shape default"), g = e.pos === "t", m = -u / 2, v = -h / 2, y = e.label ? 8 : 0, b = Lt.svg(d), w = Rt(e, {});
  e.look !== "handDrawn" && (w.roughness = 0, w.fillStyle = "solid");
  const T = b.rectangle(m, v, u, h, w), E = Math.max(u, f.width), L = h + f.height + y, k = b.rectangle(-E / 2, -L / 2, E, L, {
    ...w,
    fill: "none",
    stroke: "none"
  }), C = d.insert(() => T, ":first-child"), A = d.insert(() => k);
  if (e.img) {
    const R = d.append("image");
    R.attr("href", e.img), R.attr("width", u), R.attr("height", h), R.attr("preserveAspectRatio", "none"), R.attr(
      "transform",
      `translate(${-u / 2},${g ? L / 2 - h : -L / 2})`
    );
  }
  return p.attr(
    "transform",
    `translate(${-f.width / 2 - (f.x - (f.left ?? 0))},${g ? -h / 2 - f.height / 2 - y / 2 : h / 2 - f.height / 2 + y / 2})`
  ), C.attr(
    "transform",
    `translate(0,${g ? f.height / 2 + y / 2 : -f.height / 2 - y / 2})`
  ), Mt(e, A), e.intersect = function(R) {
    if (ie.info("iconSquare intersect", e, R), !e.label)
      return kt.rect(e, R);
    const _ = e.x ?? 0, O = e.y ?? 0, P = e.height ?? 0;
    let S = [];
    return g ? S = [
      { x: _ - f.width / 2, y: O - P / 2 },
      { x: _ + f.width / 2, y: O - P / 2 },
      { x: _ + f.width / 2, y: O - P / 2 + f.height + y },
      { x: _ + u / 2, y: O - P / 2 + f.height + y },
      { x: _ + u / 2, y: O + P / 2 },
      { x: _ - u / 2, y: O + P / 2 },
      { x: _ - u / 2, y: O - P / 2 + f.height + y },
      { x: _ - f.width / 2, y: O - P / 2 + f.height + y }
    ] : S = [
      { x: _ - u / 2, y: O - P / 2 },
      { x: _ + u / 2, y: O - P / 2 },
      { x: _ + u / 2, y: O - P / 2 + h },
      { x: _ + f.width / 2, y: O - P / 2 + h },
      { x: _ + f.width / 2 / 2, y: O + P / 2 },
      { x: _ - f.width / 2, y: O + P / 2 },
      { x: _ - f.width / 2, y: O - P / 2 + h },
      { x: _ - u / 2, y: O - P / 2 + h }
    ], kt.polygon(e, S, R);
  }, d;
}
x(CF, "imageSquare");
async function AF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ut(t, e, Ft(e)), s = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), o = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), l = [
    { x: 0, y: 0 },
    { x: s, y: 0 },
    { x: s + 3 * o / 6, y: -o },
    { x: -3 * o / 6, y: -o }
  ];
  let u;
  const { cssStyles: h } = e;
  if (e.look === "handDrawn") {
    const d = Lt.svg(i), f = Rt(e, {}), p = ar(l), g = d.path(p, f);
    u = i.insert(() => g, ":first-child").attr("transform", `translate(${-s / 2}, ${o / 2})`), h && u.attr("style", h);
  } else
    u = pc(i, s, o, l);
  return n && u.attr("style", n), e.width = s, e.height = o, Mt(e, u), e.intersect = function(d) {
    return kt.polygon(e, l, d);
  }, i;
}
x(AF, "inv_trapezoid");
async function sx(t, e, r) {
  const { labelStyles: n, nodeStyles: i } = St(e);
  e.labelStyle = n;
  const { shapeSvg: a, bbox: s } = await Ut(t, e, Ft(e)), o = Math.max(s.width + r.labelPaddingX * 2, e?.width || 0), l = Math.max(s.height + r.labelPaddingY * 2, e?.height || 0), u = -o / 2, h = -l / 2;
  let d, { rx: f, ry: p } = e;
  const { cssStyles: g } = e;
  if (r?.rx && r.ry && (f = r.rx, p = r.ry), e.look === "handDrawn") {
    const m = Lt.svg(a), v = Rt(e, {}), y = f || p ? m.path(fc(u, h, o, l, f || 0), v) : m.rectangle(u, h, o, l, v);
    d = a.insert(() => y, ":first-child"), d.attr("class", "basic label-container").attr("style", ki(g));
  } else
    d = a.insert("rect", ":first-child"), d.attr("class", "basic label-container").attr("style", i).attr("rx", ki(f)).attr("ry", ki(p)).attr("x", u).attr("y", h).attr("width", o).attr("height", l);
  return Mt(e, d), e.calcIntersect = function(m, v) {
    return kt.rect(m, v);
  }, e.intersect = function(m) {
    return kt.rect(e, m);
  }, a;
}
x(sx, "drawRect");
async function _F(t, e) {
  const { shapeSvg: r, bbox: n, label: i } = await Ut(t, e, "label"), a = r.insert("rect", ":first-child");
  return a.attr("width", 0.1).attr("height", 0.1), r.attr("class", "label edgeLabel"), i.attr(
    "transform",
    `translate(${-(n.width / 2) - (n.x - (n.left ?? 0))}, ${-(n.height / 2) - (n.y - (n.top ?? 0))})`
  ), Mt(e, a), e.intersect = function(l) {
    return kt.rect(e, l);
  }, r;
}
x(_F, "labelRect");
async function LF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ut(t, e, Ft(e)), s = Math.max(a.width + (e.padding ?? 0), e?.width ?? 0), o = Math.max(a.height + (e.padding ?? 0), e?.height ?? 0), l = [
    { x: 0, y: 0 },
    { x: s + 3 * o / 6, y: 0 },
    { x: s, y: -o },
    { x: -(3 * o) / 6, y: -o }
  ];
  let u;
  const { cssStyles: h } = e;
  if (e.look === "handDrawn") {
    const d = Lt.svg(i), f = Rt(e, {}), p = ar(l), g = d.path(p, f);
    u = i.insert(() => g, ":first-child").attr("transform", `translate(${-s / 2}, ${o / 2})`), h && u.attr("style", h);
  } else
    u = pc(i, s, o, l);
  return n && u.attr("style", n), e.width = s, e.height = o, Mt(e, u), e.intersect = function(d) {
    return kt.polygon(e, l, d);
  }, i;
}
x(LF, "lean_left");
async function RF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ut(t, e, Ft(e)), s = Math.max(a.width + (e.padding ?? 0), e?.width ?? 0), o = Math.max(a.height + (e.padding ?? 0), e?.height ?? 0), l = [
    { x: -3 * o / 6, y: 0 },
    { x: s, y: 0 },
    { x: s + 3 * o / 6, y: -o },
    { x: 0, y: -o }
  ];
  let u;
  const { cssStyles: h } = e;
  if (e.look === "handDrawn") {
    const d = Lt.svg(i), f = Rt(e, {}), p = ar(l), g = d.path(p, f);
    u = i.insert(() => g, ":first-child").attr("transform", `translate(${-s / 2}, ${o / 2})`), h && u.attr("style", h);
  } else
    u = pc(i, s, o, l);
  return n && u.attr("style", n), e.width = s, e.height = o, Mt(e, u), e.intersect = function(d) {
    return kt.polygon(e, l, d);
  }, i;
}
x(RF, "lean_right");
function MF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.label = "", e.labelStyle = r;
  const i = t.insert("g").attr("class", Ft(e)).attr("id", e.domId ?? e.id), { cssStyles: a } = e, s = Math.max(35, e?.width ?? 0), o = Math.max(35, e?.height ?? 0), l = 7, u = [
    { x: s, y: 0 },
    { x: 0, y: o + l / 2 },
    { x: s - 2 * l, y: o + l / 2 },
    { x: 0, y: 2 * o },
    { x: s, y: o - l / 2 },
    { x: 2 * l, y: o - l / 2 }
  ], h = Lt.svg(i), d = Rt(e, {});
  e.look !== "handDrawn" && (d.roughness = 0, d.fillStyle = "solid");
  const f = ar(u), p = h.path(f, d), g = i.insert(() => p, ":first-child");
  return a && e.look !== "handDrawn" && g.selectAll("path").attr("style", a), n && e.look !== "handDrawn" && g.selectAll("path").attr("style", n), g.attr("transform", `translate(-${s / 2},${-o})`), Mt(e, g), e.intersect = function(m) {
    return ie.info("lightningBolt intersect", e, m), kt.polygon(e, u, m);
  }, i;
}
x(MF, "lightningBolt");
var zle = /* @__PURE__ */ x((t, e, r, n, i, a, s) => [
  `M${t},${e + a}`,
  `a${i},${a} 0,0,0 ${r},0`,
  `a${i},${a} 0,0,0 ${-r},0`,
  `l0,${n}`,
  `a${i},${a} 0,0,0 ${r},0`,
  `l0,${-n}`,
  `M${t},${e + a + s}`,
  `a${i},${a} 0,0,0 ${r},0`
].join(" "), "createCylinderPathD"), Gle = /* @__PURE__ */ x((t, e, r, n, i, a, s) => [
  `M${t},${e + a}`,
  `M${t + r},${e + a}`,
  `a${i},${a} 0,0,0 ${-r},0`,
  `l0,${n}`,
  `a${i},${a} 0,0,0 ${r},0`,
  `l0,${-n}`,
  `M${t},${e + a + s}`,
  `a${i},${a} 0,0,0 ${r},0`
].join(" "), "createOuterCylinderPathD"), Vle = /* @__PURE__ */ x((t, e, r, n, i, a) => [`M${t - r / 2},${-n / 2}`, `a${i},${a} 0,0,0 ${r},0`].join(" "), "createInnerCylinderPathD");
async function NF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ut(t, e, Ft(e)), o = Math.max(a.width + (e.padding ?? 0), e.width ?? 0), l = o / 2, u = l / (2.5 + o / 50), h = Math.max(a.height + u + (e.padding ?? 0), e.height ?? 0), d = h * 0.1;
  let f;
  const { cssStyles: p } = e;
  if (e.look === "handDrawn") {
    const g = Lt.svg(i), m = Gle(0, 0, o, h, l, u, d), v = Vle(0, u, o, h, l, u), y = Rt(e, {}), b = g.path(m, y), w = g.path(v, y);
    i.insert(() => w, ":first-child").attr("class", "line"), f = i.insert(() => b, ":first-child"), f.attr("class", "basic label-container"), p && f.attr("style", p);
  } else {
    const g = zle(0, 0, o, h, l, u, d);
    f = i.insert("path", ":first-child").attr("d", g).attr("class", "basic label-container").attr("style", ki(p)).attr("style", n);
  }
  return f.attr("label-offset-y", u), f.attr("transform", `translate(${-o / 2}, ${-(h / 2 + u)})`), Mt(e, f), s.attr(
    "transform",
    `translate(${-(a.width / 2) - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + u - (a.y - (a.top ?? 0))})`
  ), e.intersect = function(g) {
    const m = kt.rect(e, g), v = m.x - (e.x ?? 0);
    if (l != 0 && (Math.abs(v) < (e.width ?? 0) / 2 || Math.abs(v) == (e.width ?? 0) / 2 && Math.abs(m.y - (e.y ?? 0)) > (e.height ?? 0) / 2 - u)) {
      let y = u * u * (1 - v * v / (l * l));
      y > 0 && (y = Math.sqrt(y)), y = u - y, g.y - (e.y ?? 0) > 0 && (y = -y), m.y += y;
    }
    return m;
  }, i;
}
x(NF, "linedCylinder");
async function IF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ut(t, e, Ft(e)), o = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), l = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), u = l / 4, h = l + u, { cssStyles: d } = e, f = Lt.svg(i), p = Rt(e, {});
  e.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const g = [
    { x: -o / 2 - o / 2 * 0.1, y: -h / 2 },
    { x: -o / 2 - o / 2 * 0.1, y: h / 2 },
    ...Yl(
      -o / 2 - o / 2 * 0.1,
      h / 2,
      o / 2 + o / 2 * 0.1,
      h / 2,
      u,
      0.8
    ),
    { x: o / 2 + o / 2 * 0.1, y: -h / 2 },
    { x: -o / 2 - o / 2 * 0.1, y: -h / 2 },
    { x: -o / 2, y: -h / 2 },
    { x: -o / 2, y: h / 2 * 1.1 },
    { x: -o / 2, y: -h / 2 }
  ], m = f.polygon(
    g.map((y) => [y.x, y.y]),
    p
  ), v = i.insert(() => m, ":first-child");
  return v.attr("class", "basic label-container"), d && e.look !== "handDrawn" && v.selectAll("path").attr("style", d), n && e.look !== "handDrawn" && v.selectAll("path").attr("style", n), v.attr("transform", `translate(0,${-u / 2})`), s.attr(
    "transform",
    `translate(${-o / 2 + (e.padding ?? 0) + o / 2 * 0.1 / 2 - (a.x - (a.left ?? 0))},${-l / 2 + (e.padding ?? 0) - u / 2 - (a.y - (a.top ?? 0))})`
  ), Mt(e, v), e.intersect = function(y) {
    return kt.polygon(e, g, y);
  }, i;
}
x(IF, "linedWaveEdgedRect");
async function DF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ut(t, e, Ft(e)), o = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), l = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), u = 5, h = -o / 2, d = -l / 2, { cssStyles: f } = e, p = Lt.svg(i), g = Rt(e, {}), m = [
    { x: h - u, y: d + u },
    { x: h - u, y: d + l + u },
    { x: h + o - u, y: d + l + u },
    { x: h + o - u, y: d + l },
    { x: h + o, y: d + l },
    { x: h + o, y: d + l - u },
    { x: h + o + u, y: d + l - u },
    { x: h + o + u, y: d - u },
    { x: h + u, y: d - u },
    { x: h + u, y: d },
    { x: h, y: d },
    { x: h, y: d + u }
  ], v = [
    { x: h, y: d + u },
    { x: h + o - u, y: d + u },
    { x: h + o - u, y: d + l },
    { x: h + o, y: d + l },
    { x: h + o, y: d },
    { x: h, y: d }
  ];
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = ar(m), b = p.path(y, g), w = ar(v), T = p.path(w, { ...g, fill: "none" }), E = i.insert(() => T, ":first-child");
  return E.insert(() => b, ":first-child"), E.attr("class", "basic label-container"), f && e.look !== "handDrawn" && E.selectAll("path").attr("style", f), n && e.look !== "handDrawn" && E.selectAll("path").attr("style", n), s.attr(
    "transform",
    `translate(${-(a.width / 2) - u - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + u - (a.y - (a.top ?? 0))})`
  ), Mt(e, E), e.intersect = function(L) {
    return kt.polygon(e, m, L);
  }, i;
}
x(DF, "multiRect");
async function OF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ut(t, e, Ft(e)), o = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), l = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), u = l / 4, h = l + u, d = -o / 2, f = -h / 2, p = 5, { cssStyles: g } = e, m = Yl(
    d - p,
    f + h + p,
    d + o - p,
    f + h + p,
    u,
    0.8
  ), v = m?.[m.length - 1], y = [
    { x: d - p, y: f + p },
    { x: d - p, y: f + h + p },
    ...m,
    { x: d + o - p, y: v.y - p },
    { x: d + o, y: v.y - p },
    { x: d + o, y: v.y - 2 * p },
    { x: d + o + p, y: v.y - 2 * p },
    { x: d + o + p, y: f - p },
    { x: d + p, y: f - p },
    { x: d + p, y: f },
    { x: d, y: f },
    { x: d, y: f + p }
  ], b = [
    { x: d, y: f + p },
    { x: d + o - p, y: f + p },
    { x: d + o - p, y: v.y - p },
    { x: d + o, y: v.y - p },
    { x: d + o, y: f },
    { x: d, y: f }
  ], w = Lt.svg(i), T = Rt(e, {});
  e.look !== "handDrawn" && (T.roughness = 0, T.fillStyle = "solid");
  const E = ar(y), L = w.path(E, T), k = ar(b), C = w.path(k, T), A = i.insert(() => L, ":first-child");
  return A.insert(() => C), A.attr("class", "basic label-container"), g && e.look !== "handDrawn" && A.selectAll("path").attr("style", g), n && e.look !== "handDrawn" && A.selectAll("path").attr("style", n), A.attr("transform", `translate(0,${-u / 2})`), s.attr(
    "transform",
    `translate(${-(a.width / 2) - p - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + p - u / 2 - (a.y - (a.top ?? 0))})`
  ), Mt(e, A), e.intersect = function(R) {
    return kt.polygon(e, y, R);
  }, i;
}
x(OF, "multiWaveEdgedRectangle");
async function PF(t, e, { config: { themeVariables: r } }) {
  const { labelStyles: n, nodeStyles: i } = St(e);
  e.labelStyle = n, e.useHtmlLabels || pr().flowchart?.htmlLabels !== !1 || (e.centerLabel = !0);
  const { shapeSvg: s, bbox: o, label: l } = await Ut(t, e, Ft(e)), u = Math.max(o.width + (e.padding ?? 0) * 2, e?.width ?? 0), h = Math.max(o.height + (e.padding ?? 0) * 2, e?.height ?? 0), d = -u / 2, f = -h / 2, { cssStyles: p } = e, g = Lt.svg(s), m = Rt(e, {
    fill: r.noteBkgColor,
    stroke: r.noteBorderColor
  });
  e.look !== "handDrawn" && (m.roughness = 0, m.fillStyle = "solid");
  const v = g.rectangle(d, f, u, h, m), y = s.insert(() => v, ":first-child");
  return y.attr("class", "basic label-container"), p && e.look !== "handDrawn" && y.selectAll("path").attr("style", p), i && e.look !== "handDrawn" && y.selectAll("path").attr("style", i), l.attr(
    "transform",
    `translate(${-o.width / 2 - (o.x - (o.left ?? 0))}, ${-(o.height / 2) - (o.y - (o.top ?? 0))})`
  ), Mt(e, y), e.intersect = function(b) {
    return kt.rect(e, b);
  }, s;
}
x(PF, "note");
var Ule = /* @__PURE__ */ x((t, e, r) => [
  `M${t + r / 2},${e}`,
  `L${t + r},${e - r / 2}`,
  `L${t + r / 2},${e - r}`,
  `L${t},${e - r / 2}`,
  "Z"
].join(" "), "createDecisionBoxPathD");
async function BF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ut(t, e, Ft(e)), s = a.width + e.padding, o = a.height + e.padding, l = s + o, u = 0.5, h = [
    { x: l / 2, y: 0 },
    { x: l, y: -l / 2 },
    { x: l / 2, y: -l },
    { x: 0, y: -l / 2 }
  ];
  let d;
  const { cssStyles: f } = e;
  if (e.look === "handDrawn") {
    const p = Lt.svg(i), g = Rt(e, {}), m = Ule(0, 0, l), v = p.path(m, g);
    d = i.insert(() => v, ":first-child").attr("transform", `translate(${-l / 2 + u}, ${l / 2})`), f && d.attr("style", f);
  } else
    d = pc(i, l, l, h), d.attr("transform", `translate(${-l / 2 + u}, ${l / 2})`);
  return n && d.attr("style", n), Mt(e, d), e.calcIntersect = function(p, g) {
    const m = p.width, v = [
      { x: m / 2, y: 0 },
      { x: m, y: -m / 2 },
      { x: m / 2, y: -m },
      { x: 0, y: -m / 2 }
    ], y = kt.polygon(p, v, g);
    return { x: y.x - 0.5, y: y.y - 0.5 };
  }, e.intersect = function(p) {
    return this.calcIntersect(e, p);
  }, i;
}
x(BF, "question");
async function FF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ut(t, e, Ft(e)), o = Math.max(a.width + (e.padding ?? 0), e?.width ?? 0), l = Math.max(a.height + (e.padding ?? 0), e?.height ?? 0), u = -o / 2, h = -l / 2, d = h / 2, f = [
    { x: u + d, y: h },
    { x: u, y: 0 },
    { x: u + d, y: -h },
    { x: -u, y: -h },
    { x: -u, y: h }
  ], { cssStyles: p } = e, g = Lt.svg(i), m = Rt(e, {});
  e.look !== "handDrawn" && (m.roughness = 0, m.fillStyle = "solid");
  const v = ar(f), y = g.path(v, m), b = i.insert(() => y, ":first-child");
  return b.attr("class", "basic label-container"), p && e.look !== "handDrawn" && b.selectAll("path").attr("style", p), n && e.look !== "handDrawn" && b.selectAll("path").attr("style", n), b.attr("transform", `translate(${-d / 2},0)`), s.attr(
    "transform",
    `translate(${-d / 2 - a.width / 2 - (a.x - (a.left ?? 0))}, ${-(a.height / 2) - (a.y - (a.top ?? 0))})`
  ), Mt(e, b), e.intersect = function(w) {
    return kt.polygon(e, f, w);
  }, i;
}
x(FF, "rect_left_inv_arrow");
async function $F(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  let i;
  e.cssClasses ? i = "node " + e.cssClasses : i = "node default";
  const a = t.insert("g").attr("class", i).attr("id", e.domId || e.id), s = a.insert("g"), o = a.insert("g").attr("class", "label").attr("style", n), l = e.description, u = e.label, h = o.node().appendChild(await au(u, e.labelStyle, !0, !0));
  let d = { width: 0, height: 0 };
  if (Nr(we()?.flowchart?.htmlLabels)) {
    const C = h.children[0], A = Qe(h);
    d = C.getBoundingClientRect(), A.attr("width", d.width), A.attr("height", d.height);
  }
  ie.info("Text 2", l);
  const f = l || [], p = h.getBBox(), g = o.node().appendChild(
    await au(
      f.join ? f.join("<br/>") : f,
      e.labelStyle,
      !0,
      !0
    )
  ), m = g.children[0], v = Qe(g);
  d = m.getBoundingClientRect(), v.attr("width", d.width), v.attr("height", d.height);
  const y = (e.padding || 0) / 2;
  Qe(g).attr(
    "transform",
    "translate( " + (d.width > p.width ? 0 : (p.width - d.width) / 2) + ", " + (p.height + y + 5) + ")"
  ), Qe(h).attr(
    "transform",
    "translate( " + (d.width < p.width ? 0 : -(p.width - d.width) / 2) + ", 0)"
  ), d = o.node().getBBox(), o.attr(
    "transform",
    "translate(" + -d.width / 2 + ", " + (-d.height / 2 - y + 3) + ")"
  );
  const b = d.width + (e.padding || 0), w = d.height + (e.padding || 0), T = -d.width / 2 - y, E = -d.height / 2 - y;
  let L, k;
  if (e.look === "handDrawn") {
    const C = Lt.svg(a), A = Rt(e, {}), R = C.path(
      fc(T, E, b, w, e.rx || 0),
      A
    ), _ = C.line(
      -d.width / 2 - y,
      -d.height / 2 - y + p.height + y,
      d.width / 2 + y,
      -d.height / 2 - y + p.height + y,
      A
    );
    k = a.insert(() => (ie.debug("Rough node insert CXC", R), _), ":first-child"), L = a.insert(() => (ie.debug("Rough node insert CXC", R), R), ":first-child");
  } else
    L = s.insert("rect", ":first-child"), k = s.insert("line"), L.attr("class", "outer title-state").attr("style", n).attr("x", -d.width / 2 - y).attr("y", -d.height / 2 - y).attr("width", d.width + (e.padding || 0)).attr("height", d.height + (e.padding || 0)), k.attr("class", "divider").attr("x1", -d.width / 2 - y).attr("x2", d.width / 2 + y).attr("y1", -d.height / 2 - y + p.height + y).attr("y2", -d.height / 2 - y + p.height + y);
  return Mt(e, L), e.intersect = function(C) {
    return kt.rect(e, C);
  }, a;
}
x($F, "rectWithTitle");
function jf(t, e, r, n, i, a, s) {
  const l = (t + r) / 2, u = (e + n) / 2, h = Math.atan2(n - e, r - t), d = (r - t) / 2, f = (n - e) / 2, p = d / i, g = f / a, m = Math.sqrt(p ** 2 + g ** 2);
  if (m > 1)
    throw new Error("The given radii are too small to create an arc between the points.");
  const v = Math.sqrt(1 - m ** 2), y = l + v * a * Math.sin(h) * (s ? -1 : 1), b = u - v * i * Math.cos(h) * (s ? -1 : 1), w = Math.atan2((e - b) / a, (t - y) / i);
  let E = Math.atan2((n - b) / a, (r - y) / i) - w;
  s && E < 0 && (E += 2 * Math.PI), !s && E > 0 && (E -= 2 * Math.PI);
  const L = [];
  for (let k = 0; k < 20; k++) {
    const C = k / 19, A = w + C * E, R = y + i * Math.cos(A), _ = b + a * Math.sin(A);
    L.push({ x: R, y: _ });
  }
  return L;
}
x(jf, "generateArcPoints");
async function zF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ut(t, e, Ft(e)), s = e?.padding ?? 0, o = e?.padding ?? 0, l = (e?.width ? e?.width : a.width) + s * 2, u = (e?.height ? e?.height : a.height) + o * 2, h = e.radius || 5, d = e.taper || 5, { cssStyles: f } = e, p = Lt.svg(i), g = Rt(e, {});
  e.stroke && (g.stroke = e.stroke), e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const m = [
    // Top edge (left to right)
    { x: -l / 2 + d, y: -u / 2 },
    // Top-left corner start (1)
    { x: l / 2 - d, y: -u / 2 },
    // Top-right corner start (2)
    ...jf(l / 2 - d, -u / 2, l / 2, -u / 2 + d, h, h, !0),
    // Top-left arc (2 to 3)
    // Right edge (top to bottom)
    { x: l / 2, y: -u / 2 + d },
    // Top-right taper point (3)
    { x: l / 2, y: u / 2 - d },
    // Bottom-right taper point (4)
    ...jf(l / 2, u / 2 - d, l / 2 - d, u / 2, h, h, !0),
    // Top-left arc (4 to 5)
    // Bottom edge (right to left)
    { x: l / 2 - d, y: u / 2 },
    // Bottom-right corner start (5)
    { x: -l / 2 + d, y: u / 2 },
    // Bottom-left corner start (6)
    ...jf(-l / 2 + d, u / 2, -l / 2, u / 2 - d, h, h, !0),
    // Top-left arc (4 to 5)
    // Left edge (bottom to top)
    { x: -l / 2, y: u / 2 - d },
    // Bottom-left taper point (7)
    { x: -l / 2, y: -u / 2 + d },
    // Top-left taper point (8)
    ...jf(-l / 2, -u / 2 + d, -l / 2 + d, -u / 2, h, h, !0)
    // Top-left arc (4 to 5)
  ], v = ar(m), y = p.path(v, g), b = i.insert(() => y, ":first-child");
  return b.attr("class", "basic label-container outer-path"), f && e.look !== "handDrawn" && b.selectChildren("path").attr("style", f), n && e.look !== "handDrawn" && b.selectChildren("path").attr("style", n), Mt(e, b), e.intersect = function(w) {
    return kt.polygon(e, m, w);
  }, i;
}
x(zF, "roundedRect");
async function GF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ut(t, e, Ft(e)), o = e?.padding ?? 0, l = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), u = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), h = -a.width / 2 - o, d = -a.height / 2 - o, { cssStyles: f } = e, p = Lt.svg(i), g = Rt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const m = [
    { x: h, y: d },
    { x: h + l + 8, y: d },
    { x: h + l + 8, y: d + u },
    { x: h - 8, y: d + u },
    { x: h - 8, y: d },
    { x: h, y: d },
    { x: h, y: d + u }
  ], v = p.polygon(
    m.map((b) => [b.x, b.y]),
    g
  ), y = i.insert(() => v, ":first-child");
  return y.attr("class", "basic label-container").attr("style", ki(f)), n && e.look !== "handDrawn" && y.selectAll("path").attr("style", n), f && e.look !== "handDrawn" && y.selectAll("path").attr("style", n), s.attr(
    "transform",
    `translate(${-l / 2 + 4 + (e.padding ?? 0) - (a.x - (a.left ?? 0))},${-u / 2 + (e.padding ?? 0) - (a.y - (a.top ?? 0))})`
  ), Mt(e, y), e.intersect = function(b) {
    return kt.rect(e, b);
  }, i;
}
x(GF, "shadedProcess");
async function VF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ut(t, e, Ft(e)), o = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), l = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), u = -o / 2, h = -l / 2, { cssStyles: d } = e, f = Lt.svg(i), p = Rt(e, {});
  e.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const g = [
    { x: u, y: h },
    { x: u, y: h + l },
    { x: u + o, y: h + l },
    { x: u + o, y: h - l / 2 }
  ], m = ar(g), v = f.path(m, p), y = i.insert(() => v, ":first-child");
  return y.attr("class", "basic label-container"), d && e.look !== "handDrawn" && y.selectChildren("path").attr("style", d), n && e.look !== "handDrawn" && y.selectChildren("path").attr("style", n), y.attr("transform", `translate(0, ${l / 4})`), s.attr(
    "transform",
    `translate(${-o / 2 + (e.padding ?? 0) - (a.x - (a.left ?? 0))}, ${-l / 4 + (e.padding ?? 0) - (a.y - (a.top ?? 0))})`
  ), Mt(e, y), e.intersect = function(b) {
    return kt.polygon(e, g, b);
  }, i;
}
x(VF, "slopedRect");
async function UF(t, e) {
  const r = {
    rx: 0,
    ry: 0,
    labelPaddingX: e.labelPaddingX ?? (e?.padding || 0) * 2,
    labelPaddingY: (e?.padding || 0) * 1
  };
  return sx(t, e, r);
}
x(UF, "squareRect");
async function HF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ut(t, e, Ft(e)), s = a.height + e.padding, o = a.width + s / 4 + e.padding, l = s / 2, { cssStyles: u } = e, h = Lt.svg(i), d = Rt(e, {});
  e.look !== "handDrawn" && (d.roughness = 0, d.fillStyle = "solid");
  const f = [
    { x: -o / 2 + l, y: -s / 2 },
    { x: o / 2 - l, y: -s / 2 },
    ...kp(-o / 2 + l, 0, l, 50, 90, 270),
    { x: o / 2 - l, y: s / 2 },
    ...kp(o / 2 - l, 0, l, 50, 270, 450)
  ], p = ar(f), g = h.path(p, d), m = i.insert(() => g, ":first-child");
  return m.attr("class", "basic label-container outer-path"), u && e.look !== "handDrawn" && m.selectChildren("path").attr("style", u), n && e.look !== "handDrawn" && m.selectChildren("path").attr("style", n), Mt(e, m), e.intersect = function(v) {
    return kt.polygon(e, f, v);
  }, i;
}
x(HF, "stadium");
async function qF(t, e) {
  return sx(t, e, {
    rx: 5,
    ry: 5
  });
}
x(qF, "state");
function WF(t, e, { config: { themeVariables: r } }) {
  const { labelStyles: n, nodeStyles: i } = St(e);
  e.labelStyle = n;
  const { cssStyles: a } = e, { lineColor: s, stateBorder: o, nodeBorder: l } = r, u = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id), h = Lt.svg(u), d = Rt(e, {});
  e.look !== "handDrawn" && (d.roughness = 0, d.fillStyle = "solid");
  const f = h.circle(0, 0, 14, {
    ...d,
    stroke: s,
    strokeWidth: 2
  }), p = o ?? l, g = h.circle(0, 0, 5, {
    ...d,
    fill: p,
    stroke: p,
    strokeWidth: 2,
    fillStyle: "solid"
  }), m = u.insert(() => f, ":first-child");
  return m.insert(() => g), a && m.selectAll("path").attr("style", a), i && m.selectAll("path").attr("style", i), Mt(e, m), e.intersect = function(v) {
    return kt.circle(e, 7, v);
  }, u;
}
x(WF, "stateEnd");
function YF(t, e, { config: { themeVariables: r } }) {
  const { lineColor: n } = r, i = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id);
  let a;
  if (e.look === "handDrawn") {
    const o = Lt.svg(i).circle(0, 0, 14, Lie(n));
    a = i.insert(() => o), a.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
  } else
    a = i.insert("circle", ":first-child"), a.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
  return Mt(e, a), e.intersect = function(s) {
    return kt.circle(e, 7, s);
  }, i;
}
x(YF, "stateStart");
async function XF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ut(t, e, Ft(e)), s = (e?.padding || 0) / 2, o = a.width + e.padding, l = a.height + e.padding, u = -a.width / 2 - s, h = -a.height / 2 - s, d = [
    { x: 0, y: 0 },
    { x: o, y: 0 },
    { x: o, y: -l },
    { x: 0, y: -l },
    { x: 0, y: 0 },
    { x: -8, y: 0 },
    { x: o + 8, y: 0 },
    { x: o + 8, y: -l },
    { x: -8, y: -l },
    { x: -8, y: 0 }
  ];
  if (e.look === "handDrawn") {
    const f = Lt.svg(i), p = Rt(e, {}), g = f.rectangle(u - 8, h, o + 16, l, p), m = f.line(u, h, u, h + l, p), v = f.line(u + o, h, u + o, h + l, p);
    i.insert(() => m, ":first-child"), i.insert(() => v, ":first-child");
    const y = i.insert(() => g, ":first-child"), { cssStyles: b } = e;
    y.attr("class", "basic label-container").attr("style", ki(b)), Mt(e, y);
  } else {
    const f = pc(i, o, l, d);
    n && f.attr("style", n), Mt(e, f);
  }
  return e.intersect = function(f) {
    return kt.polygon(e, d, f);
  }, i;
}
x(XF, "subroutine");
async function jF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ut(t, e, Ft(e)), s = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), o = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), l = -s / 2, u = -o / 2, h = 0.2 * o, d = 0.2 * o, { cssStyles: f } = e, p = Lt.svg(i), g = Rt(e, {}), m = [
    { x: l - h / 2, y: u },
    { x: l + s + h / 2, y: u },
    { x: l + s + h / 2, y: u + o },
    { x: l - h / 2, y: u + o }
  ], v = [
    { x: l + s - h / 2, y: u + o },
    { x: l + s + h / 2, y: u + o },
    { x: l + s + h / 2, y: u + o - d }
  ];
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = ar(m), b = p.path(y, g), w = ar(v), T = p.path(w, { ...g, fillStyle: "solid" }), E = i.insert(() => T, ":first-child");
  return E.insert(() => b, ":first-child"), E.attr("class", "basic label-container"), f && e.look !== "handDrawn" && E.selectAll("path").attr("style", f), n && e.look !== "handDrawn" && E.selectAll("path").attr("style", n), Mt(e, E), e.intersect = function(L) {
    return kt.polygon(e, m, L);
  }, i;
}
x(jF, "taggedRect");
async function KF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ut(t, e, Ft(e)), o = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), l = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), u = l / 4, h = 0.2 * o, d = 0.2 * l, f = l + u, { cssStyles: p } = e, g = Lt.svg(i), m = Rt(e, {});
  e.look !== "handDrawn" && (m.roughness = 0, m.fillStyle = "solid");
  const v = [
    { x: -o / 2 - o / 2 * 0.1, y: f / 2 },
    ...Yl(
      -o / 2 - o / 2 * 0.1,
      f / 2,
      o / 2 + o / 2 * 0.1,
      f / 2,
      u,
      0.8
    ),
    { x: o / 2 + o / 2 * 0.1, y: -f / 2 },
    { x: -o / 2 - o / 2 * 0.1, y: -f / 2 }
  ], y = -o / 2 + o / 2 * 0.1, b = -f / 2 - d * 0.4, w = [
    { x: y + o - h, y: (b + l) * 1.4 },
    { x: y + o, y: b + l - d },
    { x: y + o, y: (b + l) * 0.9 },
    ...Yl(
      y + o,
      (b + l) * 1.3,
      y + o - h,
      (b + l) * 1.5,
      -l * 0.03,
      0.5
    )
  ], T = ar(v), E = g.path(T, m), L = ar(w), k = g.path(L, {
    ...m,
    fillStyle: "solid"
  }), C = i.insert(() => k, ":first-child");
  return C.insert(() => E, ":first-child"), C.attr("class", "basic label-container"), p && e.look !== "handDrawn" && C.selectAll("path").attr("style", p), n && e.look !== "handDrawn" && C.selectAll("path").attr("style", n), C.attr("transform", `translate(0,${-u / 2})`), s.attr(
    "transform",
    `translate(${-o / 2 + (e.padding ?? 0) - (a.x - (a.left ?? 0))},${-l / 2 + (e.padding ?? 0) - u / 2 - (a.y - (a.top ?? 0))})`
  ), Mt(e, C), e.intersect = function(A) {
    return kt.polygon(e, v, A);
  }, i;
}
x(KF, "taggedWaveEdgedRectangle");
async function ZF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ut(t, e, Ft(e)), s = Math.max(a.width + e.padding, e?.width || 0), o = Math.max(a.height + e.padding, e?.height || 0), l = -s / 2, u = -o / 2, h = i.insert("rect", ":first-child");
  return h.attr("class", "text").attr("style", n).attr("rx", 0).attr("ry", 0).attr("x", l).attr("y", u).attr("width", s).attr("height", o), Mt(e, h), e.intersect = function(d) {
    return kt.rect(e, d);
  }, i;
}
x(ZF, "text");
var Hle = /* @__PURE__ */ x((t, e, r, n, i, a) => `M${t},${e}
    a${i},${a} 0,0,1 0,${-n}
    l${r},0
    a${i},${a} 0,0,1 0,${n}
    M${r},${-n}
    a${i},${a} 0,0,0 0,${n}
    l${-r},0`, "createCylinderPathD"), qle = /* @__PURE__ */ x((t, e, r, n, i, a) => [
  `M${t},${e}`,
  `M${t + r},${e}`,
  `a${i},${a} 0,0,0 0,${-n}`,
  `l${-r},0`,
  `a${i},${a} 0,0,0 0,${n}`,
  `l${r},0`
].join(" "), "createOuterCylinderPathD"), Wle = /* @__PURE__ */ x((t, e, r, n, i, a) => [`M${t + r / 2},${-n / 2}`, `a${i},${a} 0,0,0 0,${n}`].join(" "), "createInnerCylinderPathD");
async function QF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s, halfPadding: o } = await Ut(
    t,
    e,
    Ft(e)
  ), l = e.look === "neo" ? o * 2 : o, u = a.height + l, h = u / 2, d = h / (2.5 + u / 50), f = a.width + d + l, { cssStyles: p } = e;
  let g;
  if (e.look === "handDrawn") {
    const m = Lt.svg(i), v = qle(0, 0, f, u, d, h), y = Wle(0, 0, f, u, d, h), b = m.path(v, Rt(e, {})), w = m.path(y, Rt(e, { fill: "none" }));
    g = i.insert(() => w, ":first-child"), g = i.insert(() => b, ":first-child"), g.attr("class", "basic label-container"), p && g.attr("style", p);
  } else {
    const m = Hle(0, 0, f, u, d, h);
    g = i.insert("path", ":first-child").attr("d", m).attr("class", "basic label-container").attr("style", ki(p)).attr("style", n), g.attr("class", "basic label-container"), p && g.selectAll("path").attr("style", p), n && g.selectAll("path").attr("style", n);
  }
  return g.attr("label-offset-x", d), g.attr("transform", `translate(${-f / 2}, ${u / 2} )`), s.attr(
    "transform",
    `translate(${-(a.width / 2) - d - (a.x - (a.left ?? 0))}, ${-(a.height / 2) - (a.y - (a.top ?? 0))})`
  ), Mt(e, g), e.intersect = function(m) {
    const v = kt.rect(e, m), y = v.y - (e.y ?? 0);
    if (h != 0 && (Math.abs(y) < (e.height ?? 0) / 2 || Math.abs(y) == (e.height ?? 0) / 2 && Math.abs(v.x - (e.x ?? 0)) > (e.width ?? 0) / 2 - d)) {
      let b = d * d * (1 - y * y / (h * h));
      b != 0 && (b = Math.sqrt(Math.abs(b))), b = d - b, m.x - (e.x ?? 0) > 0 && (b = -b), v.x += b;
    }
    return v;
  }, i;
}
x(QF, "tiltedCylinder");
async function JF(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ut(t, e, Ft(e)), s = a.width + e.padding, o = a.height + e.padding, l = [
    { x: -3 * o / 6, y: 0 },
    { x: s + 3 * o / 6, y: 0 },
    { x: s, y: -o },
    { x: 0, y: -o }
  ];
  let u;
  const { cssStyles: h } = e;
  if (e.look === "handDrawn") {
    const d = Lt.svg(i), f = Rt(e, {}), p = ar(l), g = d.path(p, f);
    u = i.insert(() => g, ":first-child").attr("transform", `translate(${-s / 2}, ${o / 2})`), h && u.attr("style", h);
  } else
    u = pc(i, s, o, l);
  return n && u.attr("style", n), e.width = s, e.height = o, Mt(e, u), e.intersect = function(d) {
    return kt.polygon(e, l, d);
  }, i;
}
x(JF, "trapezoid");
async function e$(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ut(t, e, Ft(e)), s = 60, o = 20, l = Math.max(s, a.width + (e.padding ?? 0) * 2, e?.width ?? 0), u = Math.max(o, a.height + (e.padding ?? 0) * 2, e?.height ?? 0), { cssStyles: h } = e, d = Lt.svg(i), f = Rt(e, {});
  e.look !== "handDrawn" && (f.roughness = 0, f.fillStyle = "solid");
  const p = [
    { x: -l / 2 * 0.8, y: -u / 2 },
    { x: l / 2 * 0.8, y: -u / 2 },
    { x: l / 2, y: -u / 2 * 0.6 },
    { x: l / 2, y: u / 2 },
    { x: -l / 2, y: u / 2 },
    { x: -l / 2, y: -u / 2 * 0.6 }
  ], g = ar(p), m = d.path(g, f), v = i.insert(() => m, ":first-child");
  return v.attr("class", "basic label-container"), h && e.look !== "handDrawn" && v.selectChildren("path").attr("style", h), n && e.look !== "handDrawn" && v.selectChildren("path").attr("style", n), Mt(e, v), e.intersect = function(y) {
    return kt.polygon(e, p, y);
  }, i;
}
x(e$, "trapezoidalPentagon");
async function t$(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ut(t, e, Ft(e)), o = Nr(we().flowchart?.htmlLabels), l = a.width + (e.padding ?? 0), u = l + a.height, h = l + a.height, d = [
    { x: 0, y: 0 },
    { x: h, y: 0 },
    { x: h / 2, y: -u }
  ], { cssStyles: f } = e, p = Lt.svg(i), g = Rt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const m = ar(d), v = p.path(m, g), y = i.insert(() => v, ":first-child").attr("transform", `translate(${-u / 2}, ${u / 2})`);
  return f && e.look !== "handDrawn" && y.selectChildren("path").attr("style", f), n && e.look !== "handDrawn" && y.selectChildren("path").attr("style", n), e.width = l, e.height = u, Mt(e, y), s.attr(
    "transform",
    `translate(${-a.width / 2 - (a.x - (a.left ?? 0))}, ${u / 2 - (a.height + (e.padding ?? 0) / (o ? 2 : 1) - (a.y - (a.top ?? 0)))})`
  ), e.intersect = function(b) {
    return ie.info("Triangle intersect", e, d, b), kt.polygon(e, d, b);
  }, i;
}
x(t$, "triangle");
async function r$(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ut(t, e, Ft(e)), o = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), l = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), u = l / 8, h = l + u, { cssStyles: d } = e, p = 70 - o, g = p > 0 ? p / 2 : 0, m = Lt.svg(i), v = Rt(e, {});
  e.look !== "handDrawn" && (v.roughness = 0, v.fillStyle = "solid");
  const y = [
    { x: -o / 2 - g, y: h / 2 },
    ...Yl(
      -o / 2 - g,
      h / 2,
      o / 2 + g,
      h / 2,
      u,
      0.8
    ),
    { x: o / 2 + g, y: -h / 2 },
    { x: -o / 2 - g, y: -h / 2 }
  ], b = ar(y), w = m.path(b, v), T = i.insert(() => w, ":first-child");
  return T.attr("class", "basic label-container"), d && e.look !== "handDrawn" && T.selectAll("path").attr("style", d), n && e.look !== "handDrawn" && T.selectAll("path").attr("style", n), T.attr("transform", `translate(0,${-u / 2})`), s.attr(
    "transform",
    `translate(${-o / 2 + (e.padding ?? 0) - (a.x - (a.left ?? 0))},${-l / 2 + (e.padding ?? 0) - u - (a.y - (a.top ?? 0))})`
  ), Mt(e, T), e.intersect = function(E) {
    return kt.polygon(e, y, E);
  }, i;
}
x(r$, "waveEdgedRectangle");
async function n$(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ut(t, e, Ft(e)), s = 100, o = 50, l = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), u = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), h = l / u;
  let d = l, f = u;
  d > f * h ? f = d / h : d = f * h, d = Math.max(d, s), f = Math.max(f, o);
  const p = Math.min(f * 0.2, f / 4), g = f + p * 2, { cssStyles: m } = e, v = Lt.svg(i), y = Rt(e, {});
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const b = [
    { x: -d / 2, y: g / 2 },
    ...Yl(-d / 2, g / 2, d / 2, g / 2, p, 1),
    { x: d / 2, y: -g / 2 },
    ...Yl(d / 2, -g / 2, -d / 2, -g / 2, p, -1)
  ], w = ar(b), T = v.path(w, y), E = i.insert(() => T, ":first-child");
  return E.attr("class", "basic label-container"), m && e.look !== "handDrawn" && E.selectAll("path").attr("style", m), n && e.look !== "handDrawn" && E.selectAll("path").attr("style", n), Mt(e, E), e.intersect = function(L) {
    return kt.polygon(e, b, L);
  }, i;
}
x(n$, "waveRectangle");
async function i$(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ut(t, e, Ft(e)), o = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), l = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), u = 5, h = -o / 2, d = -l / 2, { cssStyles: f } = e, p = Lt.svg(i), g = Rt(e, {}), m = [
    { x: h - u, y: d - u },
    { x: h - u, y: d + l },
    { x: h + o, y: d + l },
    { x: h + o, y: d - u }
  ], v = `M${h - u},${d - u} L${h + o},${d - u} L${h + o},${d + l} L${h - u},${d + l} L${h - u},${d - u}
                M${h - u},${d} L${h + o},${d}
                M${h},${d - u} L${h},${d + l}`;
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = p.path(v, g), b = i.insert(() => y, ":first-child");
  return b.attr("transform", `translate(${u / 2}, ${u / 2})`), b.attr("class", "basic label-container"), f && e.look !== "handDrawn" && b.selectAll("path").attr("style", f), n && e.look !== "handDrawn" && b.selectAll("path").attr("style", n), s.attr(
    "transform",
    `translate(${-(a.width / 2) + u / 2 - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + u / 2 - (a.y - (a.top ?? 0))})`
  ), Mt(e, b), e.intersect = function(w) {
    return kt.polygon(e, m, w);
  }, i;
}
x(i$, "windowPane");
async function sk(t, e) {
  const r = e;
  if (r.alias && (e.label = r.alias), e.look === "handDrawn") {
    const { themeVariables: V } = pr(), { background: H } = V, J = {
      ...e,
      id: e.id + "-background",
      look: "default",
      cssStyles: ["stroke: none", `fill: ${H}`]
    };
    await sk(t, J);
  }
  const n = pr();
  e.useHtmlLabels = n.htmlLabels;
  let i = n.er?.diagramPadding ?? 10, a = n.er?.entityPadding ?? 6;
  const { cssStyles: s } = e, { labelStyles: o, nodeStyles: l } = St(e);
  if (r.attributes.length === 0 && e.label) {
    const V = {
      rx: 0,
      ry: 0,
      labelPaddingX: i,
      labelPaddingY: i * 1.5
    };
    zi(e.label, n) + V.labelPaddingX * 2 < n.er.minEntityWidth && (e.width = n.er.minEntityWidth);
    const H = await sx(t, e, V);
    if (!Nr(n.htmlLabels)) {
      const J = H.select("text"), q = J.node()?.getBBox();
      J.attr("transform", `translate(${-q.width / 2}, 0)`);
    }
    return H;
  }
  n.htmlLabels || (i *= 1.25, a *= 1.25);
  let u = Ft(e);
  u || (u = "node default");
  const h = t.insert("g").attr("class", u).attr("id", e.domId || e.id), d = await Mh(h, e.label ?? "", n, 0, 0, ["name"], o);
  d.height += a;
  let f = 0;
  const p = [], g = [];
  let m = 0, v = 0, y = 0, b = 0, w = !0, T = !0;
  for (const V of r.attributes) {
    const H = await Mh(
      h,
      V.type,
      n,
      0,
      f,
      ["attribute-type"],
      o
    );
    m = Math.max(m, H.width + i);
    const J = await Mh(
      h,
      V.name,
      n,
      0,
      f,
      ["attribute-name"],
      o
    );
    v = Math.max(v, J.width + i);
    const q = await Mh(
      h,
      V.keys.join(),
      n,
      0,
      f,
      ["attribute-keys"],
      o
    );
    y = Math.max(y, q.width + i);
    const ae = await Mh(
      h,
      V.comment,
      n,
      0,
      f,
      ["attribute-comment"],
      o
    );
    b = Math.max(b, ae.width + i);
    const re = Math.max(H.height, J.height, q.height, ae.height) + a;
    g.push({ yOffset: f, rowHeight: re }), f += re;
  }
  let E = 4;
  y <= i && (w = !1, y = 0, E--), b <= i && (T = !1, b = 0, E--);
  const L = h.node().getBBox();
  if (d.width + i * 2 - (m + v + y + b) > 0) {
    const V = d.width + i * 2 - (m + v + y + b);
    m += V / E, v += V / E, y > 0 && (y += V / E), b > 0 && (b += V / E);
  }
  const k = m + v + y + b, C = Lt.svg(h), A = Rt(e, {});
  e.look !== "handDrawn" && (A.roughness = 0, A.fillStyle = "solid");
  let R = 0;
  g.length > 0 && (R = g.reduce((V, H) => V + (H?.rowHeight ?? 0), 0));
  const _ = Math.max(L.width + i * 2, e?.width || 0, k), O = Math.max((R ?? 0) + d.height, e?.height || 0), P = -_ / 2, S = -O / 2;
  h.selectAll("g:not(:first-child)").each((V, H, J) => {
    const q = Qe(J[H]), ae = q.attr("transform");
    let re = 0, pe = 0;
    if (ae) {
      const Z = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(ae);
      Z && (re = parseFloat(Z[1]), pe = parseFloat(Z[2]), q.attr("class").includes("attribute-name") ? re += m : q.attr("class").includes("attribute-keys") ? re += m + v : q.attr("class").includes("attribute-comment") && (re += m + v + y));
    }
    q.attr(
      "transform",
      `translate(${P + i / 2 + re}, ${pe + S + d.height + a / 2})`
    );
  }), h.select(".name").attr("transform", "translate(" + -d.width / 2 + ", " + (S + a / 2) + ")");
  const M = C.rectangle(P, S, _, O, A), N = h.insert(() => M, ":first-child").attr("style", s.join("")), { themeVariables: D } = pr(), { rowEven: I, rowOdd: B, nodeBorder: z } = D;
  p.push(0);
  for (const [V, H] of g.entries()) {
    const q = (V + 1) % 2 === 0 && H.yOffset !== 0, ae = C.rectangle(P, d.height + S + H?.yOffset, _, H?.rowHeight, {
      ...A,
      fill: q ? I : B,
      stroke: z
    });
    h.insert(() => ae, "g.label").attr("style", s.join("")).attr("class", `row-rect-${q ? "even" : "odd"}`);
  }
  let F = C.line(P, d.height + S, _ + P, d.height + S, A);
  h.insert(() => F).attr("class", "divider"), F = C.line(m + P, d.height + S, m + P, O + S, A), h.insert(() => F).attr("class", "divider"), w && (F = C.line(
    m + v + P,
    d.height + S,
    m + v + P,
    O + S,
    A
  ), h.insert(() => F).attr("class", "divider")), T && (F = C.line(
    m + v + y + P,
    d.height + S,
    m + v + y + P,
    O + S,
    A
  ), h.insert(() => F).attr("class", "divider"));
  for (const V of p)
    F = C.line(
      P,
      d.height + S + V,
      _ + P,
      d.height + S + V,
      A
    ), h.insert(() => F).attr("class", "divider");
  if (Mt(e, N), l && e.look !== "handDrawn") {
    const H = l.split(";")?.filter((J) => J.includes("stroke"))?.map((J) => `${J}`).join("; ");
    h.selectAll("path").attr("style", H ?? ""), h.selectAll(".row-rect-even path").attr("style", l);
  }
  return e.intersect = function(V) {
    return kt.rect(e, V);
  }, h;
}
x(sk, "erBox");
async function Mh(t, e, r, n = 0, i = 0, a = [], s = "") {
  const o = t.insert("g").attr("class", `label ${a.join(" ")}`).attr("transform", `translate(${n}, ${i})`).attr("style", s);
  e !== Sl(e) && (e = Sl(e), e = e.replaceAll("<", "&lt;").replaceAll(">", "&gt;"));
  const l = o.node().appendChild(
    await La(
      o,
      e,
      {
        width: zi(e, r) + 100,
        style: s,
        useHtmlLabels: r.htmlLabels
      },
      r
    )
  );
  if (e.includes("&lt;") || e.includes("&gt;")) {
    let h = l.children[0];
    for (h.textContent = h.textContent.replaceAll("&lt;", "<").replaceAll("&gt;", ">"); h.childNodes[0]; )
      h = h.childNodes[0], h.textContent = h.textContent.replaceAll("&lt;", "<").replaceAll("&gt;", ">");
  }
  let u = l.getBBox();
  if (Nr(r.htmlLabels)) {
    const h = l.children[0];
    h.style.textAlign = "start";
    const d = Qe(l);
    u = h.getBoundingClientRect(), d.attr("width", u.width), d.attr("height", u.height);
  }
  return u;
}
x(Mh, "addText");
async function a$(t, e, r, n, i = r.class.padding ?? 12) {
  const a = n ? 0 : 3, s = t.insert("g").attr("class", Ft(e)).attr("id", e.domId || e.id);
  let o = null, l = null, u = null, h = null, d = 0, f = 0, p = 0;
  if (o = s.insert("g").attr("class", "annotation-group text"), e.annotations.length > 0) {
    const b = e.annotations[0];
    await Kf(o, { text: `${b}` }, 0), d = o.node().getBBox().height;
  }
  l = s.insert("g").attr("class", "label-group text"), await Kf(l, e, 0, ["font-weight: bolder"]);
  const g = l.node().getBBox();
  f = g.height, u = s.insert("g").attr("class", "members-group text");
  let m = 0;
  for (const b of e.members) {
    const w = await Kf(u, b, m, [b.parseClassifier()]);
    m += w + a;
  }
  p = u.node().getBBox().height, p <= 0 && (p = i / 2), h = s.insert("g").attr("class", "methods-group text");
  let v = 0;
  for (const b of e.methods) {
    const w = await Kf(h, b, v, [b.parseClassifier()]);
    v += w + a;
  }
  let y = s.node().getBBox();
  if (o !== null) {
    const b = o.node().getBBox();
    o.attr("transform", `translate(${-b.width / 2})`);
  }
  return l.attr("transform", `translate(${-g.width / 2}, ${d})`), y = s.node().getBBox(), u.attr(
    "transform",
    `translate(0, ${d + f + i * 2})`
  ), y = s.node().getBBox(), h.attr(
    "transform",
    `translate(0, ${d + f + (p ? p + i * 4 : i * 2)})`
  ), y = s.node().getBBox(), { shapeSvg: s, bbox: y };
}
x(a$, "textHelper");
async function Kf(t, e, r, n = []) {
  const i = t.insert("g").attr("class", "label").attr("style", n.join("; ")), a = pr();
  let s = "useHtmlLabels" in e ? e.useHtmlLabels : Nr(a.htmlLabels) ?? !0, o = "";
  "text" in e ? o = e.text : o = e.label, !s && o.startsWith("\\") && (o = o.substring(1)), un(o) && (s = !0);
  const l = await La(
    i,
    hE(ao(o)),
    {
      width: zi(o, a) + 50,
      // Add room for error when splitting text into multiple lines
      classes: "markdown-node-label",
      useHtmlLabels: s
    },
    a
  );
  let u, h = 1;
  if (s) {
    const d = l.children[0], f = Qe(l);
    h = d.innerHTML.split("<br>").length, d.innerHTML.includes("</math>") && (h += d.innerHTML.split("<mrow>").length - 1);
    const p = d.getElementsByTagName("img");
    if (p) {
      const g = o.replace(/<img[^>]*>/g, "").trim() === "";
      await Promise.all(
        [...p].map(
          (m) => new Promise((v) => {
            function y() {
              if (m.style.display = "flex", m.style.flexDirection = "column", g) {
                const b = a.fontSize?.toString() ?? window.getComputedStyle(document.body).fontSize, T = parseInt(b, 10) * 5 + "px";
                m.style.minWidth = T, m.style.maxWidth = T;
              } else
                m.style.width = "100%";
              v(m);
            }
            x(y, "setupImage"), setTimeout(() => {
              m.complete && y();
            }), m.addEventListener("error", y), m.addEventListener("load", y);
          })
        )
      );
    }
    u = d.getBoundingClientRect(), f.attr("width", u.width), f.attr("height", u.height);
  } else {
    n.includes("font-weight: bolder") && Qe(l).selectAll("tspan").attr("font-weight", ""), h = l.children.length;
    const d = l.children[0];
    (l.textContent === "" || l.textContent.includes("&gt")) && (d.textContent = o[0] + o.substring(1).replaceAll("&gt;", ">").replaceAll("&lt;", "<").trim(), o[1] === " " && (d.textContent = d.textContent[0] + " " + d.textContent.substring(1))), d.textContent === "undefined" && (d.textContent = ""), u = l.getBBox();
  }
  return i.attr("transform", "translate(0," + (-u.height / (2 * h) + r) + ")"), u.height;
}
x(Kf, "addText");
async function s$(t, e) {
  const r = we(), n = r.class.padding ?? 12, i = n, a = e.useHtmlLabels ?? Nr(r.htmlLabels) ?? !0, s = e;
  s.annotations = s.annotations ?? [], s.members = s.members ?? [], s.methods = s.methods ?? [];
  const { shapeSvg: o, bbox: l } = await a$(t, e, r, a, i), { labelStyles: u, nodeStyles: h } = St(e);
  e.labelStyle = u, e.cssStyles = s.styles || "";
  const d = s.styles?.join(";") || h || "";
  e.cssStyles || (e.cssStyles = d.replaceAll("!important", "").split(";"));
  const f = s.members.length === 0 && s.methods.length === 0 && !r.class?.hideEmptyMembersBox, p = Lt.svg(o), g = Rt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const m = l.width;
  let v = l.height;
  s.members.length === 0 && s.methods.length === 0 ? v += i : s.members.length > 0 && s.methods.length === 0 && (v += i * 2);
  const y = -m / 2, b = -v / 2, w = p.rectangle(
    y - n,
    b - n - (f ? n : s.members.length === 0 && s.methods.length === 0 ? -n / 2 : 0),
    m + 2 * n,
    v + 2 * n + (f ? n * 2 : s.members.length === 0 && s.methods.length === 0 ? -n : 0),
    g
  ), T = o.insert(() => w, ":first-child");
  T.attr("class", "basic label-container");
  const E = T.node().getBBox();
  o.selectAll(".text").each((A, R, _) => {
    const O = Qe(_[R]), P = O.attr("transform");
    let S = 0;
    if (P) {
      const I = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(P);
      I && (S = parseFloat(I[2]));
    }
    let M = S + b + n - (f ? n : s.members.length === 0 && s.methods.length === 0 ? -n / 2 : 0);
    a || (M -= 4);
    let N = y;
    (O.attr("class").includes("label-group") || O.attr("class").includes("annotation-group")) && (N = -O.node()?.getBBox().width / 2 || 0, o.selectAll("text").each(function(D, I, B) {
      window.getComputedStyle(B[I]).textAnchor === "middle" && (N = 0);
    })), O.attr("transform", `translate(${N}, ${M})`);
  });
  const L = o.select(".annotation-group").node().getBBox().height - (f ? n / 2 : 0) || 0, k = o.select(".label-group").node().getBBox().height - (f ? n / 2 : 0) || 0, C = o.select(".members-group").node().getBBox().height - (f ? n / 2 : 0) || 0;
  if (s.members.length > 0 || s.methods.length > 0 || f) {
    const A = p.line(
      E.x,
      L + k + b + n,
      E.x + E.width,
      L + k + b + n,
      g
    );
    o.insert(() => A).attr("class", "divider").attr("style", d);
  }
  if (f || s.members.length > 0 || s.methods.length > 0) {
    const A = p.line(
      E.x,
      L + k + C + b + i * 2 + n,
      E.x + E.width,
      L + k + C + b + n + i * 2,
      g
    );
    o.insert(() => A).attr("class", "divider").attr("style", d);
  }
  if (s.look !== "handDrawn" && o.selectAll("path").attr("style", d), T.select(":nth-child(2)").attr("style", d), o.selectAll(".divider").select("path").attr("style", d), e.labelStyle ? o.selectAll("span").attr("style", e.labelStyle) : o.selectAll("span").attr("style", d), !a) {
    const A = RegExp(/color\s*:\s*([^;]*)/), R = A.exec(d);
    if (R) {
      const _ = R[0].replace("color", "fill");
      o.selectAll("tspan").attr("style", _);
    } else if (u) {
      const _ = A.exec(u);
      if (_) {
        const O = _[0].replace("color", "fill");
        o.selectAll("tspan").attr("style", O);
      }
    }
  }
  return Mt(e, T), e.intersect = function(A) {
    return kt.rect(e, A);
  }, o;
}
x(s$, "classBox");
async function o$(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const i = e, a = e, s = 20, o = 20, l = "verifyMethod" in e, u = Ft(e), h = t.insert("g").attr("class", u).attr("id", e.domId ?? e.id);
  let d;
  l ? d = await zs(
    h,
    `&lt;&lt;${i.type}&gt;&gt;`,
    0,
    e.labelStyle
  ) : d = await zs(h, "&lt;&lt;Element&gt;&gt;", 0, e.labelStyle);
  let f = d;
  const p = await zs(
    h,
    i.name,
    f,
    e.labelStyle + "; font-weight: bold;"
  );
  if (f += p + o, l) {
    const L = await zs(
      h,
      `${i.requirementId ? `ID: ${i.requirementId}` : ""}`,
      f,
      e.labelStyle
    );
    f += L;
    const k = await zs(
      h,
      `${i.text ? `Text: ${i.text}` : ""}`,
      f,
      e.labelStyle
    );
    f += k;
    const C = await zs(
      h,
      `${i.risk ? `Risk: ${i.risk}` : ""}`,
      f,
      e.labelStyle
    );
    f += C, await zs(
      h,
      `${i.verifyMethod ? `Verification: ${i.verifyMethod}` : ""}`,
      f,
      e.labelStyle
    );
  } else {
    const L = await zs(
      h,
      `${a.type ? `Type: ${a.type}` : ""}`,
      f,
      e.labelStyle
    );
    f += L, await zs(
      h,
      `${a.docRef ? `Doc Ref: ${a.docRef}` : ""}`,
      f,
      e.labelStyle
    );
  }
  const g = (h.node()?.getBBox().width ?? 200) + s, m = (h.node()?.getBBox().height ?? 200) + s, v = -g / 2, y = -m / 2, b = Lt.svg(h), w = Rt(e, {});
  e.look !== "handDrawn" && (w.roughness = 0, w.fillStyle = "solid");
  const T = b.rectangle(v, y, g, m, w), E = h.insert(() => T, ":first-child");
  if (E.attr("class", "basic label-container").attr("style", n), h.selectAll(".label").each((L, k, C) => {
    const A = Qe(C[k]), R = A.attr("transform");
    let _ = 0, O = 0;
    if (R) {
      const N = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(R);
      N && (_ = parseFloat(N[1]), O = parseFloat(N[2]));
    }
    const P = O - m / 2;
    let S = v + s / 2;
    (k === 0 || k === 1) && (S = _), A.attr("transform", `translate(${S}, ${P + s})`);
  }), f > d + p + o) {
    const L = b.line(
      v,
      y + d + p + o,
      v + g,
      y + d + p + o,
      w
    );
    h.insert(() => L).attr("style", n);
  }
  return Mt(e, E), e.intersect = function(L) {
    return kt.rect(e, L);
  }, h;
}
x(o$, "requirementBox");
async function zs(t, e, r, n = "") {
  if (e === "")
    return 0;
  const i = t.insert("g").attr("class", "label").attr("style", n), a = we(), s = a.htmlLabels ?? !0, o = await La(
    i,
    hE(ao(e)),
    {
      width: zi(e, a) + 50,
      // Add room for error when splitting text into multiple lines
      classes: "markdown-node-label",
      useHtmlLabels: s,
      style: n
    },
    a
  );
  let l;
  if (s) {
    const u = o.children[0], h = Qe(o);
    l = u.getBoundingClientRect(), h.attr("width", l.width), h.attr("height", l.height);
  } else {
    const u = o.children[0];
    for (const h of u.children)
      h.textContent = h.textContent.replaceAll("&gt;", ">").replaceAll("&lt;", "<"), n && h.setAttribute("style", n);
    l = o.getBBox(), l.height += 6;
  }
  return i.attr("transform", `translate(${-l.width / 2},${-l.height / 2 + r})`), l.height;
}
x(zs, "addText");
var Yle = /* @__PURE__ */ x((t) => {
  switch (t) {
    case "Very High":
      return "red";
    case "High":
      return "orange";
    case "Medium":
      return null;
    // no stroke
    case "Low":
      return "blue";
    case "Very Low":
      return "lightblue";
  }
}, "colorFromPriority");
async function l$(t, e, { config: r }) {
  const { labelStyles: n, nodeStyles: i } = St(e);
  e.labelStyle = n || "";
  const a = 10, s = e.width;
  e.width = (e.width ?? 200) - 10;
  const {
    shapeSvg: o,
    bbox: l,
    label: u
  } = await Ut(t, e, Ft(e)), h = e.padding || 10;
  let d = "", f;
  "ticket" in e && e.ticket && r?.kanban?.ticketBaseUrl && (d = r?.kanban?.ticketBaseUrl.replace("#TICKET#", e.ticket), f = o.insert("svg:a", ":first-child").attr("class", "kanban-ticket-link").attr("xlink:href", d).attr("target", "_blank"));
  const p = {
    useHtmlLabels: e.useHtmlLabels,
    labelStyle: e.labelStyle || "",
    width: e.width,
    img: e.img,
    padding: e.padding || 8,
    centerLabel: !1
  };
  let g, m;
  f ? { label: g, bbox: m } = await l4(
    f,
    "ticket" in e && e.ticket || "",
    p
  ) : { label: g, bbox: m } = await l4(
    o,
    "ticket" in e && e.ticket || "",
    p
  );
  const { label: v, bbox: y } = await l4(
    o,
    "assigned" in e && e.assigned || "",
    p
  );
  e.width = s;
  const b = 10, w = e?.width || 0, T = Math.max(m.height, y.height) / 2, E = Math.max(l.height + b * 2, e?.height || 0) + T, L = -w / 2, k = -E / 2;
  u.attr(
    "transform",
    "translate(" + (h - w / 2) + ", " + (-T - l.height / 2) + ")"
  ), g.attr(
    "transform",
    "translate(" + (h - w / 2) + ", " + (-T + l.height / 2) + ")"
  ), v.attr(
    "transform",
    "translate(" + (h + w / 2 - y.width - 2 * a) + ", " + (-T + l.height / 2) + ")"
  );
  let C;
  const { rx: A, ry: R } = e, { cssStyles: _ } = e;
  if (e.look === "handDrawn") {
    const O = Lt.svg(o), P = Rt(e, {}), S = A || R ? O.path(fc(L, k, w, E, A || 0), P) : O.rectangle(L, k, w, E, P);
    C = o.insert(() => S, ":first-child"), C.attr("class", "basic label-container").attr("style", _ || null);
  } else {
    C = o.insert("rect", ":first-child"), C.attr("class", "basic label-container __APA__").attr("style", i).attr("rx", A ?? 5).attr("ry", R ?? 5).attr("x", L).attr("y", k).attr("width", w).attr("height", E);
    const O = "priority" in e && e.priority;
    if (O) {
      const P = o.append("line"), S = L + 2, M = k + Math.floor((A ?? 0) / 2), N = k + E - Math.floor((A ?? 0) / 2);
      P.attr("x1", S).attr("y1", M).attr("x2", S).attr("y2", N).attr("stroke-width", "4").attr("stroke", Yle(O));
    }
  }
  return Mt(e, C), e.height = E, e.intersect = function(O) {
    return kt.rect(e, O);
  }, o;
}
x(l$, "kanbanItem");
async function c$(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, halfPadding: s, label: o } = await Ut(
    t,
    e,
    Ft(e)
  ), l = a.width + 10 * s, u = a.height + 8 * s, h = 0.15 * l, { cssStyles: d } = e, f = a.width + 20, p = a.height + 20, g = Math.max(l, f), m = Math.max(u, p);
  o.attr("transform", `translate(${-a.width / 2}, ${-a.height / 2})`);
  let v;
  const y = `M0 0 
    a${h},${h} 1 0,0 ${g * 0.25},${-1 * m * 0.1}
    a${h},${h} 1 0,0 ${g * 0.25},0
    a${h},${h} 1 0,0 ${g * 0.25},0
    a${h},${h} 1 0,0 ${g * 0.25},${m * 0.1}

    a${h},${h} 1 0,0 ${g * 0.15},${m * 0.33}
    a${h * 0.8},${h * 0.8} 1 0,0 0,${m * 0.34}
    a${h},${h} 1 0,0 ${-1 * g * 0.15},${m * 0.33}

    a${h},${h} 1 0,0 ${-1 * g * 0.25},${m * 0.15}
    a${h},${h} 1 0,0 ${-1 * g * 0.25},0
    a${h},${h} 1 0,0 ${-1 * g * 0.25},0
    a${h},${h} 1 0,0 ${-1 * g * 0.25},${-1 * m * 0.15}

    a${h},${h} 1 0,0 ${-1 * g * 0.1},${-1 * m * 0.33}
    a${h * 0.8},${h * 0.8} 1 0,0 0,${-1 * m * 0.34}
    a${h},${h} 1 0,0 ${g * 0.1},${-1 * m * 0.33}
  H0 V0 Z`;
  if (e.look === "handDrawn") {
    const b = Lt.svg(i), w = Rt(e, {}), T = b.path(y, w);
    v = i.insert(() => T, ":first-child"), v.attr("class", "basic label-container").attr("style", ki(d));
  } else
    v = i.insert("path", ":first-child").attr("class", "basic label-container").attr("style", n).attr("d", y);
  return v.attr("transform", `translate(${-g / 2}, ${-m / 2})`), Mt(e, v), e.calcIntersect = function(b, w) {
    return kt.rect(b, w);
  }, e.intersect = function(b) {
    return ie.info("Bang intersect", e, b), kt.rect(e, b);
  }, i;
}
x(c$, "bang");
async function u$(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, halfPadding: s, label: o } = await Ut(
    t,
    e,
    Ft(e)
  ), l = a.width + 2 * s, u = a.height + 2 * s, h = 0.15 * l, d = 0.25 * l, f = 0.35 * l, p = 0.2 * l, { cssStyles: g } = e;
  let m;
  const v = `M0 0 
    a${h},${h} 0 0,1 ${l * 0.25},${-1 * l * 0.1}
    a${f},${f} 1 0,1 ${l * 0.4},${-1 * l * 0.1}
    a${d},${d} 1 0,1 ${l * 0.35},${l * 0.2}

    a${h},${h} 1 0,1 ${l * 0.15},${u * 0.35}
    a${p},${p} 1 0,1 ${-1 * l * 0.15},${u * 0.65}

    a${d},${h} 1 0,1 ${-1 * l * 0.25},${l * 0.15}
    a${f},${f} 1 0,1 ${-1 * l * 0.5},0
    a${h},${h} 1 0,1 ${-1 * l * 0.25},${-1 * l * 0.15}

    a${h},${h} 1 0,1 ${-1 * l * 0.1},${-1 * u * 0.35}
    a${p},${p} 1 0,1 ${l * 0.1},${-1 * u * 0.65}
  H0 V0 Z`;
  if (e.look === "handDrawn") {
    const y = Lt.svg(i), b = Rt(e, {}), w = y.path(v, b);
    m = i.insert(() => w, ":first-child"), m.attr("class", "basic label-container").attr("style", ki(g));
  } else
    m = i.insert("path", ":first-child").attr("class", "basic label-container").attr("style", n).attr("d", v);
  return o.attr("transform", `translate(${-a.width / 2}, ${-a.height / 2})`), m.attr("transform", `translate(${-l / 2}, ${-u / 2})`), Mt(e, m), e.calcIntersect = function(y, b) {
    return kt.rect(y, b);
  }, e.intersect = function(y) {
    return ie.info("Cloud intersect", e, y), kt.rect(e, y);
  }, i;
}
x(u$, "cloud");
async function h$(t, e) {
  const { labelStyles: r, nodeStyles: n } = St(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, halfPadding: s, label: o } = await Ut(
    t,
    e,
    Ft(e)
  ), l = a.width + 8 * s, u = a.height + 2 * s, h = 5, d = `
    M${-l / 2} ${u / 2 - h}
    v${-u + 2 * h}
    q0,-${h} ${h},-${h}
    h${l - 2 * h}
    q${h},0 ${h},${h}
    v${u - 2 * h}
    q0,${h} -${h},${h}
    h${-l + 2 * h}
    q-${h},0 -${h},-${h}
    Z
  `, f = i.append("path").attr("id", "node-" + e.id).attr("class", "node-bkg node-" + e.type).attr("style", n).attr("d", d);
  return i.append("line").attr("class", "node-line-").attr("x1", -l / 2).attr("y1", u / 2).attr("x2", l / 2).attr("y2", u / 2), o.attr("transform", `translate(${-a.width / 2}, ${-a.height / 2})`), i.append(() => o.node()), Mt(e, f), e.calcIntersect = function(p, g) {
    return kt.rect(p, g);
  }, e.intersect = function(p) {
    return kt.rect(e, p);
  }, i;
}
x(h$, "defaultMindmapNode");
async function d$(t, e) {
  const r = {
    padding: e.padding ?? 0
  };
  return ak(t, e, r);
}
x(d$, "mindmapCircle");
var Xle = [
  {
    semanticName: "Process",
    name: "Rectangle",
    shortName: "rect",
    description: "Standard process shape",
    aliases: ["proc", "process", "rectangle"],
    internalAliases: ["squareRect"],
    handler: UF
  },
  {
    semanticName: "Event",
    name: "Rounded Rectangle",
    shortName: "rounded",
    description: "Represents an event",
    aliases: ["event"],
    internalAliases: ["roundedRect"],
    handler: zF
  },
  {
    semanticName: "Terminal Point",
    name: "Stadium",
    shortName: "stadium",
    description: "Terminal point",
    aliases: ["terminal", "pill"],
    handler: HF
  },
  {
    semanticName: "Subprocess",
    name: "Framed Rectangle",
    shortName: "fr-rect",
    description: "Subprocess",
    aliases: ["subprocess", "subproc", "framed-rectangle", "subroutine"],
    handler: XF
  },
  {
    semanticName: "Database",
    name: "Cylinder",
    shortName: "cyl",
    description: "Database storage",
    aliases: ["db", "database", "cylinder"],
    handler: fF
  },
  {
    semanticName: "Start",
    name: "Circle",
    shortName: "circle",
    description: "Starting point",
    aliases: ["circ"],
    handler: ak
  },
  {
    semanticName: "Bang",
    name: "Bang",
    shortName: "bang",
    description: "Bang",
    aliases: ["bang"],
    handler: c$
  },
  {
    semanticName: "Cloud",
    name: "Cloud",
    shortName: "cloud",
    description: "cloud",
    aliases: ["cloud"],
    handler: u$
  },
  {
    semanticName: "Decision",
    name: "Diamond",
    shortName: "diam",
    description: "Decision-making step",
    aliases: ["decision", "diamond", "question"],
    handler: BF
  },
  {
    semanticName: "Prepare Conditional",
    name: "Hexagon",
    shortName: "hex",
    description: "Preparation or condition step",
    aliases: ["hexagon", "prepare"],
    handler: bF
  },
  {
    semanticName: "Data Input/Output",
    name: "Lean Right",
    shortName: "lean-r",
    description: "Represents input or output",
    aliases: ["lean-right", "in-out"],
    internalAliases: ["lean_right"],
    handler: RF
  },
  {
    semanticName: "Data Input/Output",
    name: "Lean Left",
    shortName: "lean-l",
    description: "Represents output or input",
    aliases: ["lean-left", "out-in"],
    internalAliases: ["lean_left"],
    handler: LF
  },
  {
    semanticName: "Priority Action",
    name: "Trapezoid Base Bottom",
    shortName: "trap-b",
    description: "Priority action",
    aliases: ["priority", "trapezoid-bottom", "trapezoid"],
    handler: JF
  },
  {
    semanticName: "Manual Operation",
    name: "Trapezoid Base Top",
    shortName: "trap-t",
    description: "Represents a manual task",
    aliases: ["manual", "trapezoid-top", "inv-trapezoid"],
    internalAliases: ["inv_trapezoid"],
    handler: AF
  },
  {
    semanticName: "Stop",
    name: "Double Circle",
    shortName: "dbl-circ",
    description: "Represents a stop point",
    aliases: ["double-circle"],
    internalAliases: ["doublecircle"],
    handler: gF
  },
  {
    semanticName: "Text Block",
    name: "Text Block",
    shortName: "text",
    description: "Text block",
    handler: ZF
  },
  {
    semanticName: "Card",
    name: "Notched Rectangle",
    shortName: "notch-rect",
    description: "Represents a card",
    aliases: ["card", "notched-rectangle"],
    handler: aF
  },
  {
    semanticName: "Lined/Shaded Process",
    name: "Lined Rectangle",
    shortName: "lin-rect",
    description: "Lined process shape",
    aliases: ["lined-rectangle", "lined-process", "lin-proc", "shaded-process"],
    handler: GF
  },
  {
    semanticName: "Start",
    name: "Small Circle",
    shortName: "sm-circ",
    description: "Small starting point",
    aliases: ["start", "small-circle"],
    internalAliases: ["stateStart"],
    handler: YF
  },
  {
    semanticName: "Stop",
    name: "Framed Circle",
    shortName: "fr-circ",
    description: "Stop point",
    aliases: ["stop", "framed-circle"],
    internalAliases: ["stateEnd"],
    handler: WF
  },
  {
    semanticName: "Fork/Join",
    name: "Filled Rectangle",
    shortName: "fork",
    description: "Fork or join in process flow",
    aliases: ["join"],
    internalAliases: ["forkJoin"],
    handler: yF
  },
  {
    semanticName: "Collate",
    name: "Hourglass",
    shortName: "hourglass",
    description: "Represents a collate operation",
    aliases: ["hourglass", "collate"],
    handler: wF
  },
  {
    semanticName: "Comment",
    name: "Curly Brace",
    shortName: "brace",
    description: "Adds a comment",
    aliases: ["comment", "brace-l"],
    handler: cF
  },
  {
    semanticName: "Comment Right",
    name: "Curly Brace",
    shortName: "brace-r",
    description: "Adds a comment",
    handler: uF
  },
  {
    semanticName: "Comment with braces on both sides",
    name: "Curly Braces",
    shortName: "braces",
    description: "Adds a comment",
    handler: hF
  },
  {
    semanticName: "Com Link",
    name: "Lightning Bolt",
    shortName: "bolt",
    description: "Communication link",
    aliases: ["com-link", "lightning-bolt"],
    handler: MF
  },
  {
    semanticName: "Document",
    name: "Document",
    shortName: "doc",
    description: "Represents a document",
    aliases: ["doc", "document"],
    handler: r$
  },
  {
    semanticName: "Delay",
    name: "Half-Rounded Rectangle",
    shortName: "delay",
    description: "Represents a delay",
    aliases: ["half-rounded-rectangle"],
    handler: xF
  },
  {
    semanticName: "Direct Access Storage",
    name: "Horizontal Cylinder",
    shortName: "h-cyl",
    description: "Direct access storage",
    aliases: ["das", "horizontal-cylinder"],
    handler: QF
  },
  {
    semanticName: "Disk Storage",
    name: "Lined Cylinder",
    shortName: "lin-cyl",
    description: "Disk storage",
    aliases: ["disk", "lined-cylinder"],
    handler: NF
  },
  {
    semanticName: "Display",
    name: "Curved Trapezoid",
    shortName: "curv-trap",
    description: "Represents a display",
    aliases: ["curved-trapezoid", "display"],
    handler: dF
  },
  {
    semanticName: "Divided Process",
    name: "Divided Rectangle",
    shortName: "div-rect",
    description: "Divided process shape",
    aliases: ["div-proc", "divided-rectangle", "divided-process"],
    handler: pF
  },
  {
    semanticName: "Extract",
    name: "Triangle",
    shortName: "tri",
    description: "Extraction process",
    aliases: ["extract", "triangle"],
    handler: t$
  },
  {
    semanticName: "Internal Storage",
    name: "Window Pane",
    shortName: "win-pane",
    description: "Internal storage",
    aliases: ["internal-storage", "window-pane"],
    handler: i$
  },
  {
    semanticName: "Junction",
    name: "Filled Circle",
    shortName: "f-circ",
    description: "Junction point",
    aliases: ["junction", "filled-circle"],
    handler: mF
  },
  {
    semanticName: "Loop Limit",
    name: "Trapezoidal Pentagon",
    shortName: "notch-pent",
    description: "Loop limit step",
    aliases: ["loop-limit", "notched-pentagon"],
    handler: e$
  },
  {
    semanticName: "Manual File",
    name: "Flipped Triangle",
    shortName: "flip-tri",
    description: "Manual file operation",
    aliases: ["manual-file", "flipped-triangle"],
    handler: vF
  },
  {
    semanticName: "Manual Input",
    name: "Sloped Rectangle",
    shortName: "sl-rect",
    description: "Manual input step",
    aliases: ["manual-input", "sloped-rectangle"],
    handler: VF
  },
  {
    semanticName: "Multi-Document",
    name: "Stacked Document",
    shortName: "docs",
    description: "Multiple documents",
    aliases: ["documents", "st-doc", "stacked-document"],
    handler: OF
  },
  {
    semanticName: "Multi-Process",
    name: "Stacked Rectangle",
    shortName: "st-rect",
    description: "Multiple processes",
    aliases: ["procs", "processes", "stacked-rectangle"],
    handler: DF
  },
  {
    semanticName: "Stored Data",
    name: "Bow Tie Rectangle",
    shortName: "bow-rect",
    description: "Stored data",
    aliases: ["stored-data", "bow-tie-rectangle"],
    handler: iF
  },
  {
    semanticName: "Summary",
    name: "Crossed Circle",
    shortName: "cross-circ",
    description: "Summary",
    aliases: ["summary", "crossed-circle"],
    handler: lF
  },
  {
    semanticName: "Tagged Document",
    name: "Tagged Document",
    shortName: "tag-doc",
    description: "Tagged document",
    aliases: ["tag-doc", "tagged-document"],
    handler: KF
  },
  {
    semanticName: "Tagged Process",
    name: "Tagged Rectangle",
    shortName: "tag-rect",
    description: "Tagged process",
    aliases: ["tagged-rectangle", "tag-proc", "tagged-process"],
    handler: jF
  },
  {
    semanticName: "Paper Tape",
    name: "Flag",
    shortName: "flag",
    description: "Paper tape",
    aliases: ["paper-tape"],
    handler: n$
  },
  {
    semanticName: "Odd",
    name: "Odd",
    shortName: "odd",
    description: "Odd shape",
    internalAliases: ["rect_left_inv_arrow"],
    handler: FF
  },
  {
    semanticName: "Lined Document",
    name: "Lined Document",
    shortName: "lin-doc",
    description: "Lined document",
    aliases: ["lined-document"],
    handler: IF
  }
], jle = /* @__PURE__ */ x(() => {
  const e = [
    ...Object.entries({
      // States
      state: qF,
      choice: sF,
      note: PF,
      // Rectangles
      rectWithTitle: $F,
      labelRect: _F,
      // Icons
      iconSquare: SF,
      iconCircle: EF,
      icon: TF,
      iconRounded: kF,
      imageSquare: CF,
      anchor: nF,
      // Kanban diagram
      kanbanItem: l$,
      //Mindmap diagram
      mindmapCircle: d$,
      defaultMindmapNode: h$,
      // class diagram
      classBox: s$,
      // er diagram
      erBox: sk,
      // Requirement diagram
      requirementBox: o$
    }),
    ...Xle.flatMap((r) => [
      r.shortName,
      ..."aliases" in r ? r.aliases : [],
      ..."internalAliases" in r ? r.internalAliases : []
    ].map((i) => [i, r.handler]))
  ];
  return Object.fromEntries(e);
}, "generateShapeMap"), f$ = jle();
function p$(t) {
  return t in f$;
}
x(p$, "isValidShape");
var ox = /* @__PURE__ */ new Map();
async function lx(t, e, r) {
  let n, i;
  e.shape === "rect" && (e.rx && e.ry ? e.shape = "roundedRect" : e.shape = "squareRect");
  const a = e.shape ? f$[e.shape] : void 0;
  if (!a)
    throw new Error(`No such shape: ${e.shape}. Please check your syntax.`);
  if (e.link) {
    let s;
    r.config.securityLevel === "sandbox" ? s = "_top" : e.linkTarget && (s = e.linkTarget || "_blank"), n = t.insert("svg:a").attr("xlink:href", e.link).attr("target", s ?? null), i = await a(n, e, r);
  } else
    i = await a(t, e, r), n = i;
  return e.tooltip && i.attr("title", e.tooltip), ox.set(e.id, n), e.haveCallback && n.attr("class", n.attr("class") + " clickable"), n;
}
x(lx, "insertNode");
var Kle = /* @__PURE__ */ x((t, e) => {
  ox.set(e.id, t);
}, "setNodeElem"), Zle = /* @__PURE__ */ x(() => {
  ox.clear();
}, "clear"), Ww = /* @__PURE__ */ x((t) => {
  const e = ox.get(t.id);
  ie.trace(
    "Transforming node",
    t.diff,
    t,
    "translate(" + (t.x - t.width / 2 - 5) + ", " + t.width / 2 + ")"
  );
  const r = 8, n = t.diff || 0;
  return t.clusterNode ? e.attr(
    "transform",
    "translate(" + (t.x + n - t.width / 2) + ", " + (t.y - t.height / 2 - r) + ")"
  ) : e.attr("transform", "translate(" + t.x + ", " + t.y + ")"), n;
}, "positionNode"), Qle = /* @__PURE__ */ x((t, e, r, n, i, a) => {
  e.arrowTypeStart && D8(t, "start", e.arrowTypeStart, r, n, i, a), e.arrowTypeEnd && D8(t, "end", e.arrowTypeEnd, r, n, i, a);
}, "addEdgeMarkers"), Jle = {
  arrow_cross: { type: "cross", fill: !1 },
  arrow_point: { type: "point", fill: !0 },
  arrow_barb: { type: "barb", fill: !0 },
  arrow_circle: { type: "circle", fill: !1 },
  aggregation: { type: "aggregation", fill: !1 },
  extension: { type: "extension", fill: !1 },
  composition: { type: "composition", fill: !0 },
  dependency: { type: "dependency", fill: !0 },
  lollipop: { type: "lollipop", fill: !1 },
  only_one: { type: "onlyOne", fill: !1 },
  zero_or_one: { type: "zeroOrOne", fill: !1 },
  one_or_more: { type: "oneOrMore", fill: !1 },
  zero_or_more: { type: "zeroOrMore", fill: !1 },
  requirement_arrow: { type: "requirement_arrow", fill: !1 },
  requirement_contains: { type: "requirement_contains", fill: !1 }
}, D8 = /* @__PURE__ */ x((t, e, r, n, i, a, s) => {
  const o = Jle[r];
  if (!o) {
    ie.warn(`Unknown arrow type: ${r}`);
    return;
  }
  const l = o.type, h = `${i}_${a}-${l}${e === "start" ? "Start" : "End"}`;
  if (s && s.trim() !== "") {
    const d = s.replace(/[^\dA-Za-z]/g, "_"), f = `${h}_${d}`;
    if (!document.getElementById(f)) {
      const p = document.getElementById(h);
      if (p) {
        const g = p.cloneNode(!0);
        g.id = f, g.querySelectorAll("path, circle, line").forEach((v) => {
          v.setAttribute("stroke", s), o.fill && v.setAttribute("fill", s);
        }), p.parentNode?.appendChild(g);
      }
    }
    t.attr(`marker-${e}`, `url(${n}#${f})`);
  } else
    t.attr(`marker-${e}`, `url(${n}#${h})`);
}, "addEdgeMarker"), fy = /* @__PURE__ */ new Map(), ai = /* @__PURE__ */ new Map(), ece = /* @__PURE__ */ x(() => {
  fy.clear(), ai.clear();
}, "clear"), p1 = /* @__PURE__ */ x((t) => t ? t.reduce((r, n) => r + ";" + n, "") : "", "getLabelStyles"), g$ = /* @__PURE__ */ x(async (t, e) => {
  let r = Nr(we().flowchart.htmlLabels);
  const { labelStyles: n } = St(e);
  e.labelStyle = n;
  const i = await La(t, e.label, {
    style: e.labelStyle,
    useHtmlLabels: r,
    addSvgBackground: !0,
    isNode: !1
  });
  ie.info("abc82", e, e.labelType);
  const a = t.insert("g").attr("class", "edgeLabel"), s = a.insert("g").attr("class", "label").attr("data-id", e.id);
  s.node().appendChild(i);
  let o = i.getBBox();
  if (r) {
    const u = i.children[0], h = Qe(i);
    o = u.getBoundingClientRect(), h.attr("width", o.width), h.attr("height", o.height);
  }
  s.attr("transform", "translate(" + -o.width / 2 + ", " + -o.height / 2 + ")"), fy.set(e.id, a), e.width = o.width, e.height = o.height;
  let l;
  if (e.startLabelLeft) {
    const u = await au(
      e.startLabelLeft,
      p1(e.labelStyle)
    ), h = t.insert("g").attr("class", "edgeTerminals"), d = h.insert("g").attr("class", "inner");
    l = d.node().appendChild(u);
    const f = u.getBBox();
    d.attr("transform", "translate(" + -f.width / 2 + ", " + -f.height / 2 + ")"), ai.get(e.id) || ai.set(e.id, {}), ai.get(e.id).startLeft = h, Zf(l, e.startLabelLeft);
  }
  if (e.startLabelRight) {
    const u = await au(
      e.startLabelRight,
      p1(e.labelStyle)
    ), h = t.insert("g").attr("class", "edgeTerminals"), d = h.insert("g").attr("class", "inner");
    l = h.node().appendChild(u), d.node().appendChild(u);
    const f = u.getBBox();
    d.attr("transform", "translate(" + -f.width / 2 + ", " + -f.height / 2 + ")"), ai.get(e.id) || ai.set(e.id, {}), ai.get(e.id).startRight = h, Zf(l, e.startLabelRight);
  }
  if (e.endLabelLeft) {
    const u = await au(e.endLabelLeft, p1(e.labelStyle)), h = t.insert("g").attr("class", "edgeTerminals"), d = h.insert("g").attr("class", "inner");
    l = d.node().appendChild(u);
    const f = u.getBBox();
    d.attr("transform", "translate(" + -f.width / 2 + ", " + -f.height / 2 + ")"), h.node().appendChild(u), ai.get(e.id) || ai.set(e.id, {}), ai.get(e.id).endLeft = h, Zf(l, e.endLabelLeft);
  }
  if (e.endLabelRight) {
    const u = await au(e.endLabelRight, p1(e.labelStyle)), h = t.insert("g").attr("class", "edgeTerminals"), d = h.insert("g").attr("class", "inner");
    l = d.node().appendChild(u);
    const f = u.getBBox();
    d.attr("transform", "translate(" + -f.width / 2 + ", " + -f.height / 2 + ")"), h.node().appendChild(u), ai.get(e.id) || ai.set(e.id, {}), ai.get(e.id).endRight = h, Zf(l, e.endLabelRight);
  }
  return i;
}, "insertEdgeLabel");
function Zf(t, e) {
  we().flowchart.htmlLabels && t && (t.style.width = e.length * 9 + "px", t.style.height = "12px");
}
x(Zf, "setTerminalWidth");
var m$ = /* @__PURE__ */ x((t, e) => {
  ie.debug("Moving label abc88 ", t.id, t.label, fy.get(t.id), e);
  let r = e.updatedPath ? e.updatedPath : e.originalPath;
  const n = we(), { subGraphTitleTotalMargin: i } = dg(n);
  if (t.label) {
    const a = fy.get(t.id);
    let s = t.x, o = t.y;
    if (r) {
      const l = Zt.calcLabelPosition(r);
      ie.debug(
        "Moving label " + t.label + " from (",
        s,
        ",",
        o,
        ") to (",
        l.x,
        ",",
        l.y,
        ") abc88"
      ), e.updatedPath && (s = l.x, o = l.y);
    }
    a.attr("transform", `translate(${s}, ${o + i / 2})`);
  }
  if (t.startLabelLeft) {
    const a = ai.get(t.id).startLeft;
    let s = t.x, o = t.y;
    if (r) {
      const l = Zt.calcTerminalLabelPosition(t.arrowTypeStart ? 10 : 0, "start_left", r);
      s = l.x, o = l.y;
    }
    a.attr("transform", `translate(${s}, ${o})`);
  }
  if (t.startLabelRight) {
    const a = ai.get(t.id).startRight;
    let s = t.x, o = t.y;
    if (r) {
      const l = Zt.calcTerminalLabelPosition(
        t.arrowTypeStart ? 10 : 0,
        "start_right",
        r
      );
      s = l.x, o = l.y;
    }
    a.attr("transform", `translate(${s}, ${o})`);
  }
  if (t.endLabelLeft) {
    const a = ai.get(t.id).endLeft;
    let s = t.x, o = t.y;
    if (r) {
      const l = Zt.calcTerminalLabelPosition(t.arrowTypeEnd ? 10 : 0, "end_left", r);
      s = l.x, o = l.y;
    }
    a.attr("transform", `translate(${s}, ${o})`);
  }
  if (t.endLabelRight) {
    const a = ai.get(t.id).endRight;
    let s = t.x, o = t.y;
    if (r) {
      const l = Zt.calcTerminalLabelPosition(t.arrowTypeEnd ? 10 : 0, "end_right", r);
      s = l.x, o = l.y;
    }
    a.attr("transform", `translate(${s}, ${o})`);
  }
}, "positionEdgeLabel"), tce = /* @__PURE__ */ x((t, e) => {
  const r = t.x, n = t.y, i = Math.abs(e.x - r), a = Math.abs(e.y - n), s = t.width / 2, o = t.height / 2;
  return i >= s || a >= o;
}, "outsideNode"), rce = /* @__PURE__ */ x((t, e, r) => {
  ie.debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(e)}
  insidePoint : ${JSON.stringify(r)}
  node        : x:${t.x} y:${t.y} w:${t.width} h:${t.height}`);
  const n = t.x, i = t.y, a = Math.abs(n - r.x), s = t.width / 2;
  let o = r.x < e.x ? s - a : s + a;
  const l = t.height / 2, u = Math.abs(e.y - r.y), h = Math.abs(e.x - r.x);
  if (Math.abs(i - e.y) * s > Math.abs(n - e.x) * l) {
    let d = r.y < e.y ? e.y - l - i : i - l - e.y;
    o = h * d / u;
    const f = {
      x: r.x < e.x ? r.x + o : r.x - h + o,
      y: r.y < e.y ? r.y + u - d : r.y - u + d
    };
    return o === 0 && (f.x = e.x, f.y = e.y), h === 0 && (f.x = e.x), u === 0 && (f.y = e.y), ie.debug(`abc89 top/bottom calc, Q ${u}, q ${d}, R ${h}, r ${o}`, f), f;
  } else {
    r.x < e.x ? o = e.x - s - n : o = n - s - e.x;
    let d = u * o / h, f = r.x < e.x ? r.x + h - o : r.x - h + o, p = r.y < e.y ? r.y + d : r.y - d;
    return ie.debug(`sides calc abc89, Q ${u}, q ${d}, R ${h}, r ${o}`, { _x: f, _y: p }), o === 0 && (f = e.x, p = e.y), h === 0 && (f = e.x), u === 0 && (p = e.y), { x: f, y: p };
  }
}, "intersection"), O8 = /* @__PURE__ */ x((t, e) => {
  ie.warn("abc88 cutPathAtIntersect", t, e);
  let r = [], n = t[0], i = !1;
  return t.forEach((a) => {
    if (ie.info("abc88 checking point", a, e), !tce(e, a) && !i) {
      const s = rce(e, n, a);
      ie.debug("abc88 inside", a, n, s), ie.debug("abc88 intersection", s, e);
      let o = !1;
      r.forEach((l) => {
        o = o || l.x === s.x && l.y === s.y;
      }), r.some((l) => l.x === s.x && l.y === s.y) ? ie.warn("abc88 no intersect", s, r) : r.push(s), i = !0;
    } else
      ie.warn("abc88 outside", a, n), n = a, i || r.push(a);
  }), ie.debug("returning points", r), r;
}, "cutPathAtIntersect");
function v$(t) {
  const e = [], r = [];
  for (let n = 1; n < t.length - 1; n++) {
    const i = t[n - 1], a = t[n], s = t[n + 1];
    (i.x === a.x && a.y === s.y && Math.abs(a.x - s.x) > 5 && Math.abs(a.y - i.y) > 5 || i.y === a.y && a.x === s.x && Math.abs(a.x - i.x) > 5 && Math.abs(a.y - s.y) > 5) && (e.push(a), r.push(n));
  }
  return { cornerPoints: e, cornerPointPositions: r };
}
x(v$, "extractCornerPoints");
var P8 = /* @__PURE__ */ x(function(t, e, r) {
  const n = e.x - t.x, i = e.y - t.y, a = Math.sqrt(n * n + i * i), s = r / a;
  return { x: e.x - s * n, y: e.y - s * i };
}, "findAdjacentPoint"), nce = /* @__PURE__ */ x(function(t) {
  const { cornerPointPositions: e } = v$(t), r = [];
  for (let n = 0; n < t.length; n++)
    if (e.includes(n)) {
      const i = t[n - 1], a = t[n + 1], s = t[n], o = P8(i, s, 5), l = P8(a, s, 5), u = l.x - o.x, h = l.y - o.y;
      r.push(o);
      const d = Math.sqrt(2) * 2;
      let f = { x: s.x, y: s.y };
      if (Math.abs(a.x - i.x) > 10 && Math.abs(a.y - i.y) >= 10) {
        ie.debug(
          "Corner point fixing",
          Math.abs(a.x - i.x),
          Math.abs(a.y - i.y)
        );
        const p = 5;
        s.x === o.x ? f = {
          x: u < 0 ? o.x - p + d : o.x + p - d,
          y: h < 0 ? o.y - d : o.y + d
        } : f = {
          x: u < 0 ? o.x - d : o.x + d,
          y: h < 0 ? o.y - p + d : o.y + p - d
        };
      } else
        ie.debug(
          "Corner point skipping fixing",
          Math.abs(a.x - i.x),
          Math.abs(a.y - i.y)
        );
      r.push(f, l);
    } else
      r.push(t[n]);
  return r;
}, "fixCorners"), ice = /* @__PURE__ */ x((t, e, r) => {
  const n = t - e - r, i = 2, a = 2, s = i + a, o = Math.floor(n / s), l = Array(o).fill(`${i} ${a}`).join(" ");
  return `0 ${e} ${l} ${r}`;
}, "generateDashArray"), y$ = /* @__PURE__ */ x(function(t, e, r, n, i, a, s, o = !1) {
  const { handDrawnSeed: l } = we();
  let u = e.points, h = !1;
  const d = i;
  var f = a;
  const p = [];
  for (const S in e.cssCompiledStyles)
    DE(S) || p.push(e.cssCompiledStyles[S]);
  ie.debug("UIO intersect check", e.points, f.x, d.x), f.intersect && d.intersect && !o && (u = u.slice(1, e.points.length - 1), u.unshift(d.intersect(u[0])), ie.debug(
    "Last point UIO",
    e.start,
    "-->",
    e.end,
    u[u.length - 1],
    f,
    f.intersect(u[u.length - 1])
  ), u.push(f.intersect(u[u.length - 1])));
  const g = btoa(JSON.stringify(u));
  e.toCluster && (ie.info("to cluster abc88", r.get(e.toCluster)), u = O8(e.points, r.get(e.toCluster).node), h = !0), e.fromCluster && (ie.debug(
    "from cluster abc88",
    r.get(e.fromCluster),
    JSON.stringify(u, null, 2)
  ), u = O8(u.reverse(), r.get(e.fromCluster).node).reverse(), h = !0);
  let m = u.filter((S) => !Number.isNaN(S.y));
  m = nce(m);
  let v = jh;
  switch (v = Hv, e.curve) {
    case "linear":
      v = Hv;
      break;
    case "basis":
      v = jh;
      break;
    case "cardinal":
      v = UD;
      break;
    case "bumpX":
      v = FD;
      break;
    case "bumpY":
      v = $D;
      break;
    case "catmullRom":
      v = qD;
      break;
    case "monotoneX":
      v = ZD;
      break;
    case "monotoneY":
      v = QD;
      break;
    case "natural":
      v = eO;
      break;
    case "step":
      v = tO;
      break;
    case "stepAfter":
      v = nO;
      break;
    case "stepBefore":
      v = rO;
      break;
    default:
      v = jh;
  }
  const { x: y, y: b } = $P(e), w = gp().x(y).y(b).curve(v);
  let T;
  switch (e.thickness) {
    case "normal":
      T = "edge-thickness-normal";
      break;
    case "thick":
      T = "edge-thickness-thick";
      break;
    case "invisible":
      T = "edge-thickness-invisible";
      break;
    default:
      T = "edge-thickness-normal";
  }
  switch (e.pattern) {
    case "solid":
      T += " edge-pattern-solid";
      break;
    case "dotted":
      T += " edge-pattern-dotted";
      break;
    case "dashed":
      T += " edge-pattern-dashed";
      break;
    default:
      T += " edge-pattern-solid";
  }
  let E, L = e.curve === "rounded" ? x$(b$(m, e), 5) : w(m);
  const k = Array.isArray(e.style) ? e.style : [e.style];
  let C = k.find((S) => S?.startsWith("stroke:")), A = !1;
  if (e.look === "handDrawn") {
    const S = Lt.svg(t);
    Object.assign([], m);
    const M = S.path(L, {
      roughness: 0.3,
      seed: l
    });
    T += " transition", E = Qe(M).select("path").attr("id", e.id).attr("class", " " + T + (e.classes ? " " + e.classes : "")).attr("style", k ? k.reduce((D, I) => D + ";" + I, "") : "");
    let N = E.attr("d");
    E.attr("d", N), t.node().appendChild(E.node());
  } else {
    const S = p.join(";"), M = k ? k.reduce((V, H) => V + H + ";", "") : "";
    let N = "";
    e.animate && (N = " edge-animation-fast"), e.animation && (N = " edge-animation-" + e.animation);
    const D = (S ? S + ";" + M + ";" : M) + ";" + (k ? k.reduce((V, H) => V + ";" + H, "") : "");
    E = t.append("path").attr("d", L).attr("id", e.id).attr(
      "class",
      " " + T + (e.classes ? " " + e.classes : "") + (N ?? "")
    ).attr("style", D), C = D.match(/stroke:([^;]+)/)?.[1], A = e.animate === !0 || !!e.animation || S.includes("animation");
    const I = E.node(), B = typeof I.getTotalLength == "function" ? I.getTotalLength() : 0, z = e8[e.arrowTypeStart] || 0, F = e8[e.arrowTypeEnd] || 0;
    if (e.look === "neo" && !A) {
      const H = `stroke-dasharray: ${e.pattern === "dotted" || e.pattern === "dashed" ? ice(B, z, F) : `0 ${z} ${B - z - F} ${F}`}; stroke-dashoffset: 0;`;
      E.attr("style", H + E.attr("style"));
    }
  }
  E.attr("data-edge", !0), E.attr("data-et", "edge"), E.attr("data-id", e.id), E.attr("data-points", g), e.showPoints && m.forEach((S) => {
    t.append("circle").style("stroke", "red").style("fill", "red").attr("r", 1).attr("cx", S.x).attr("cy", S.y);
  });
  let R = "";
  (we().flowchart.arrowMarkerAbsolute || we().state.arrowMarkerAbsolute) && (R = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, R = R.replace(/\(/g, "\\(").replace(/\)/g, "\\)")), ie.info("arrowTypeStart", e.arrowTypeStart), ie.info("arrowTypeEnd", e.arrowTypeEnd), Qle(E, e, R, s, n, C);
  const _ = Math.floor(u.length / 2), O = u[_];
  Zt.isLabelCoordinateInPath(O, E.attr("d")) || (h = !0);
  let P = {};
  return h && (P.updatedPath = u), P.originalPath = e.points, P;
}, "insertEdge");
function x$(t, e) {
  if (t.length < 2)
    return "";
  let r = "";
  const n = t.length, i = 1e-5;
  for (let a = 0; a < n; a++) {
    const s = t[a], o = t[a - 1], l = t[a + 1];
    if (a === 0)
      r += `M${s.x},${s.y}`;
    else if (a === n - 1)
      r += `L${s.x},${s.y}`;
    else {
      const u = s.x - o.x, h = s.y - o.y, d = l.x - s.x, f = l.y - s.y, p = Math.hypot(u, h), g = Math.hypot(d, f);
      if (p < i || g < i) {
        r += `L${s.x},${s.y}`;
        continue;
      }
      const m = u / p, v = h / p, y = d / g, b = f / g, w = m * y + v * b, T = Math.max(-1, Math.min(1, w)), E = Math.acos(T);
      if (E < i || Math.abs(Math.PI - E) < i) {
        r += `L${s.x},${s.y}`;
        continue;
      }
      const L = Math.min(e / Math.sin(E / 2), p / 2, g / 2), k = s.x - m * L, C = s.y - v * L, A = s.x + y * L, R = s.y + b * L;
      r += `L${k},${C}`, r += `Q${s.x},${s.y} ${A},${R}`;
    }
  }
  return r;
}
x(x$, "generateRoundedPath");
function Yw(t, e) {
  if (!t || !e)
    return { angle: 0, deltaX: 0, deltaY: 0 };
  const r = e.x - t.x, n = e.y - t.y;
  return { angle: Math.atan2(n, r), deltaX: r, deltaY: n };
}
x(Yw, "calculateDeltaAndAngle");
function b$(t, e) {
  const r = t.map((i) => ({ ...i }));
  if (t.length >= 2 && xi[e.arrowTypeStart]) {
    const i = xi[e.arrowTypeStart], a = t[0], s = t[1], { angle: o } = Yw(a, s), l = i * Math.cos(o), u = i * Math.sin(o);
    r[0].x = a.x + l, r[0].y = a.y + u;
  }
  const n = t.length;
  if (n >= 2 && xi[e.arrowTypeEnd]) {
    const i = xi[e.arrowTypeEnd], a = t[n - 1], s = t[n - 2], { angle: o } = Yw(s, a), l = i * Math.cos(o), u = i * Math.sin(o);
    r[n - 1].x = a.x - l, r[n - 1].y = a.y - u;
  }
  return r;
}
x(b$, "applyMarkerOffsetsToPoints");
var ace = /* @__PURE__ */ x((t, e, r, n) => {
  e.forEach((i) => {
    wce[i](t, r, n);
  });
}, "insertMarkers"), sce = /* @__PURE__ */ x((t, e, r) => {
  ie.trace("Making markers for ", r), t.append("defs").append("marker").attr("id", r + "_" + e + "-extensionStart").attr("class", "marker extension " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-extensionEnd").attr("class", "marker extension " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
}, "extension"), oce = /* @__PURE__ */ x((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-compositionStart").attr("class", "marker composition " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-compositionEnd").attr("class", "marker composition " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "composition"), lce = /* @__PURE__ */ x((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-aggregationStart").attr("class", "marker aggregation " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-aggregationEnd").attr("class", "marker aggregation " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "aggregation"), cce = /* @__PURE__ */ x((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-dependencyStart").attr("class", "marker dependency " + e).attr("refX", 6).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-dependencyEnd").attr("class", "marker dependency " + e).attr("refX", 13).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, "dependency"), uce = /* @__PURE__ */ x((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-lollipopStart").attr("class", "marker lollipop " + e).attr("refX", 13).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6), t.append("defs").append("marker").attr("id", r + "_" + e + "-lollipopEnd").attr("class", "marker lollipop " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);
}, "lollipop"), hce = /* @__PURE__ */ x((t, e, r) => {
  t.append("marker").attr("id", r + "_" + e + "-pointEnd").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 8).attr("markerHeight", 8).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", r + "_" + e + "-pointStart").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 4.5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 8).attr("markerHeight", 8).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "point"), dce = /* @__PURE__ */ x((t, e, r) => {
  t.append("marker").attr("id", r + "_" + e + "-circleEnd").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", r + "_" + e + "-circleStart").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "circle"), fce = /* @__PURE__ */ x((t, e, r) => {
  t.append("marker").attr("id", r + "_" + e + "-crossEnd").attr("class", "marker cross " + e).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", r + "_" + e + "-crossStart").attr("class", "marker cross " + e).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
}, "cross"), pce = /* @__PURE__ */ x((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "userSpaceOnUse").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
}, "barb"), gce = /* @__PURE__ */ x((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-onlyOneStart").attr("class", "marker onlyOne " + e).attr("refX", 0).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("d", "M9,0 L9,18 M15,0 L15,18"), t.append("defs").append("marker").attr("id", r + "_" + e + "-onlyOneEnd").attr("class", "marker onlyOne " + e).attr("refX", 18).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("d", "M3,0 L3,18 M9,0 L9,18");
}, "only_one"), mce = /* @__PURE__ */ x((t, e, r) => {
  const n = t.append("defs").append("marker").attr("id", r + "_" + e + "-zeroOrOneStart").attr("class", "marker zeroOrOne " + e).attr("refX", 0).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
  n.append("circle").attr("fill", "white").attr("cx", 21).attr("cy", 9).attr("r", 6), n.append("path").attr("d", "M9,0 L9,18");
  const i = t.append("defs").append("marker").attr("id", r + "_" + e + "-zeroOrOneEnd").attr("class", "marker zeroOrOne " + e).attr("refX", 30).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
  i.append("circle").attr("fill", "white").attr("cx", 9).attr("cy", 9).attr("r", 6), i.append("path").attr("d", "M21,0 L21,18");
}, "zero_or_one"), vce = /* @__PURE__ */ x((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-oneOrMoreStart").attr("class", "marker oneOrMore " + e).attr("refX", 18).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("d", "M0,18 Q 18,0 36,18 Q 18,36 0,18 M42,9 L42,27"), t.append("defs").append("marker").attr("id", r + "_" + e + "-oneOrMoreEnd").attr("class", "marker oneOrMore " + e).attr("refX", 27).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("d", "M3,9 L3,27 M9,18 Q27,0 45,18 Q27,36 9,18");
}, "one_or_more"), yce = /* @__PURE__ */ x((t, e, r) => {
  const n = t.append("defs").append("marker").attr("id", r + "_" + e + "-zeroOrMoreStart").attr("class", "marker zeroOrMore " + e).attr("refX", 18).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
  n.append("circle").attr("fill", "white").attr("cx", 48).attr("cy", 18).attr("r", 6), n.append("path").attr("d", "M0,18 Q18,0 36,18 Q18,36 0,18");
  const i = t.append("defs").append("marker").attr("id", r + "_" + e + "-zeroOrMoreEnd").attr("class", "marker zeroOrMore " + e).attr("refX", 39).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
  i.append("circle").attr("fill", "white").attr("cx", 9).attr("cy", 18).attr("r", 6), i.append("path").attr("d", "M21,18 Q39,0 57,18 Q39,36 21,18");
}, "zero_or_more"), xce = /* @__PURE__ */ x((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-requirement_arrowEnd").attr("refX", 20).attr("refY", 10).attr("markerWidth", 20).attr("markerHeight", 20).attr("orient", "auto").append("path").attr(
    "d",
    `M0,0
      L20,10
      M20,10
      L0,20`
  );
}, "requirement_arrow"), bce = /* @__PURE__ */ x((t, e, r) => {
  const n = t.append("defs").append("marker").attr("id", r + "_" + e + "-requirement_containsStart").attr("refX", 0).attr("refY", 10).attr("markerWidth", 20).attr("markerHeight", 20).attr("orient", "auto").append("g");
  n.append("circle").attr("cx", 10).attr("cy", 10).attr("r", 9).attr("fill", "none"), n.append("line").attr("x1", 1).attr("x2", 19).attr("y1", 10).attr("y2", 10), n.append("line").attr("y1", 1).attr("y2", 19).attr("x1", 10).attr("x2", 10);
}, "requirement_contains"), wce = {
  extension: sce,
  composition: oce,
  aggregation: lce,
  dependency: cce,
  lollipop: uce,
  point: hce,
  circle: dce,
  cross: fce,
  barb: pce,
  only_one: gce,
  zero_or_one: mce,
  one_or_more: vce,
  zero_or_more: yce,
  requirement_arrow: xce,
  requirement_contains: bce
}, w$ = ace, Tce = {
  common: at,
  getConfig: pr,
  insertCluster: ik,
  insertEdge: y$,
  insertEdgeLabel: g$,
  insertMarkers: w$,
  insertNode: lx,
  interpolateToCurve: $E,
  labelHelper: Ut,
  log: ie,
  positionEdgeLabel: m$
}, Sp = {}, T$ = /* @__PURE__ */ x((t) => {
  for (const e of t)
    Sp[e.name] = e;
}, "registerLayoutLoaders"), Ece = /* @__PURE__ */ x(() => {
  T$([
    {
      name: "dagre",
      loader: /* @__PURE__ */ x(async () => await Promise.resolve().then(() => tye), "loader")
    },
    {
      name: "cose-bilkent",
      loader: /* @__PURE__ */ x(async () => await Promise.resolve().then(() => V5e), "loader")
    }
  ]);
}, "registerDefaultLayoutLoaders");
Ece();
var Kd = /* @__PURE__ */ x(async (t, e) => {
  if (!(t.layoutAlgorithm in Sp))
    throw new Error(`Unknown layout algorithm: ${t.layoutAlgorithm}`);
  const r = Sp[t.layoutAlgorithm];
  return (await r.loader()).render(t, e, Tce, {
    algorithm: r.algorithm
  });
}, "render"), mg = /* @__PURE__ */ x((t = "", { fallback: e = "dagre" } = {}) => {
  if (t in Sp)
    return t;
  if (e in Sp)
    return ie.warn(`Layout algorithm ${t} is not registered. Using ${e} as fallback.`), e;
  throw new Error(`Both layout algorithms ${t} and ${e} are not registered.`);
}, "getRegisteredLayoutAlgorithm"), E$ = "comm", k$ = "rule", S$ = "decl", kce = "@import", Sce = "@namespace", Cce = "@keyframes", Ace = "@layer", C$ = Math.abs, ok = String.fromCharCode;
function A$(t) {
  return t.trim();
}
function Lm(t, e, r) {
  return t.replace(e, r);
}
function _ce(t, e, r) {
  return t.indexOf(e, r);
}
function Zh(t, e) {
  return t.charCodeAt(e) | 0;
}
function kd(t, e, r) {
  return t.slice(e, r);
}
function Us(t) {
  return t.length;
}
function Lce(t) {
  return t.length;
}
function g1(t, e) {
  return e.push(t), t;
}
var cx = 1, Sd = 1, _$ = 0, Ja = 0, Sn = 0, Zd = "";
function lk(t, e, r, n, i, a, s, o) {
  return { value: t, root: e, parent: r, type: n, props: i, children: a, line: cx, column: Sd, length: s, return: "", siblings: o };
}
function Rce() {
  return Sn;
}
function Mce() {
  return Sn = Ja > 0 ? Zh(Zd, --Ja) : 0, Sd--, Sn === 10 && (Sd = 1, cx--), Sn;
}
function xs() {
  return Sn = Ja < _$ ? Zh(Zd, Ja++) : 0, Sd++, Sn === 10 && (Sd = 1, cx++), Sn;
}
function Ml() {
  return Zh(Zd, Ja);
}
function Rm() {
  return Ja;
}
function ux(t, e) {
  return kd(Zd, t, e);
}
function Cp(t) {
  switch (t) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function Nce(t) {
  return cx = Sd = 1, _$ = Us(Zd = t), Ja = 0, [];
}
function Ice(t) {
  return Zd = "", t;
}
function c4(t) {
  return A$(ux(Ja - 1, Xw(t === 91 ? t + 2 : t === 40 ? t + 1 : t)));
}
function Dce(t) {
  for (; (Sn = Ml()) && Sn < 33; )
    xs();
  return Cp(t) > 2 || Cp(Sn) > 3 ? "" : " ";
}
function Oce(t, e) {
  for (; --e && xs() && !(Sn < 48 || Sn > 102 || Sn > 57 && Sn < 65 || Sn > 70 && Sn < 97); )
    ;
  return ux(t, Rm() + (e < 6 && Ml() == 32 && xs() == 32));
}
function Xw(t) {
  for (; xs(); )
    switch (Sn) {
      // ] ) " '
      case t:
        return Ja;
      // " '
      case 34:
      case 39:
        t !== 34 && t !== 39 && Xw(Sn);
        break;
      // (
      case 40:
        t === 41 && Xw(t);
        break;
      // \
      case 92:
        xs();
        break;
    }
  return Ja;
}
function Pce(t, e) {
  for (; xs() && t + Sn !== 57; )
    if (t + Sn === 84 && Ml() === 47)
      break;
  return "/*" + ux(e, Ja - 1) + "*" + ok(t === 47 ? t : xs());
}
function Bce(t) {
  for (; !Cp(Ml()); )
    xs();
  return ux(t, Ja);
}
function Fce(t) {
  return Ice(Mm("", null, null, null, [""], t = Nce(t), 0, [0], t));
}
function Mm(t, e, r, n, i, a, s, o, l) {
  for (var u = 0, h = 0, d = s, f = 0, p = 0, g = 0, m = 1, v = 1, y = 1, b = 0, w = "", T = i, E = a, L = n, k = w; v; )
    switch (g = b, b = xs()) {
      // (
      case 40:
        if (g != 108 && Zh(k, d - 1) == 58) {
          _ce(k += Lm(c4(b), "&", "&\f"), "&\f", C$(u ? o[u - 1] : 0)) != -1 && (y = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        k += c4(b);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        k += Dce(g);
        break;
      // \
      case 92:
        k += Oce(Rm() - 1, 7);
        continue;
      // /
      case 47:
        switch (Ml()) {
          case 42:
          case 47:
            g1($ce(Pce(xs(), Rm()), e, r, l), l), (Cp(g || 1) == 5 || Cp(Ml() || 1) == 5) && Us(k) && kd(k, -1, void 0) !== " " && (k += " ");
            break;
          default:
            k += "/";
        }
        break;
      // {
      case 123 * m:
        o[u++] = Us(k) * y;
      // } ; \0
      case 125 * m:
      case 59:
      case 0:
        switch (b) {
          // \0 }
          case 0:
          case 125:
            v = 0;
          // ;
          case 59 + h:
            y == -1 && (k = Lm(k, /\f/g, "")), p > 0 && (Us(k) - d || m === 0 && g === 47) && g1(p > 32 ? F8(k + ";", n, r, d - 1, l) : F8(Lm(k, " ", "") + ";", n, r, d - 2, l), l);
            break;
          // @ ;
          case 59:
            k += ";";
          // { rule/at-rule
          default:
            if (g1(L = B8(k, e, r, u, h, i, o, w, T = [], E = [], d, a), a), b === 123)
              if (h === 0)
                Mm(k, e, L, L, T, a, d, o, E);
              else {
                switch (f) {
                  // c(ontainer)
                  case 99:
                    if (Zh(k, 3) === 110) break;
                  // l(ayer)
                  case 108:
                    if (Zh(k, 2) === 97) break;
                  default:
                    h = 0;
                  // d(ocument) m(edia) s(upports)
                  case 100:
                  case 109:
                  case 115:
                }
                h ? Mm(t, L, L, n && g1(B8(t, L, L, 0, 0, i, o, w, i, T = [], d, E), E), i, E, d, o, n ? T : E) : Mm(k, L, L, L, [""], E, 0, o, E);
              }
        }
        u = h = p = 0, m = y = 1, w = k = "", d = s;
        break;
      // :
      case 58:
        d = 1 + Us(k), p = g;
      default:
        if (m < 1) {
          if (b == 123)
            --m;
          else if (b == 125 && m++ == 0 && Mce() == 125)
            continue;
        }
        switch (k += ok(b), b * m) {
          // &
          case 38:
            y = h > 0 ? 1 : (k += "\f", -1);
            break;
          // ,
          case 44:
            o[u++] = (Us(k) - 1) * y, y = 1;
            break;
          // @
          case 64:
            Ml() === 45 && (k += c4(xs())), f = Ml(), h = d = Us(w = k += Bce(Rm())), b++;
            break;
          // -
          case 45:
            g === 45 && Us(k) == 2 && (m = 0);
        }
    }
  return a;
}
function B8(t, e, r, n, i, a, s, o, l, u, h, d) {
  for (var f = i - 1, p = i === 0 ? a : [""], g = Lce(p), m = 0, v = 0, y = 0; m < n; ++m)
    for (var b = 0, w = kd(t, f + 1, f = C$(v = s[m])), T = t; b < g; ++b)
      (T = A$(v > 0 ? p[b] + " " + w : Lm(w, /&\f/g, p[b]))) && (l[y++] = T);
  return lk(t, e, r, i === 0 ? k$ : o, l, u, h, d);
}
function $ce(t, e, r, n) {
  return lk(t, e, r, E$, ok(Rce()), kd(t, 2, -2), 0, n);
}
function F8(t, e, r, n, i) {
  return lk(t, e, r, S$, kd(t, 0, n), kd(t, n + 1, -1), n, i);
}
function jw(t, e) {
  for (var r = "", n = 0; n < t.length; n++)
    r += e(t[n], n, t, e) || "";
  return r;
}
function zce(t, e, r, n) {
  switch (t.type) {
    case Ace:
      if (t.children.length) break;
    case kce:
    case Sce:
    case S$:
      return t.return = t.return || t.value;
    case E$:
      return "";
    case Cce:
      return t.return = t.value + "{" + jw(t.children, n) + "}";
    case k$:
      if (!Us(t.value = t.props.join(","))) return "";
  }
  return Us(r = jw(t.children, n)) ? t.return = t.value + "{" + r + "}" : "";
}
var Gce = WP(Object.keys, Object), Vce = Object.prototype, Uce = Vce.hasOwnProperty;
function L$(t) {
  if (!j2(t))
    return Gce(t);
  var e = [];
  for (var r in Object(t))
    Uce.call(t, r) && r != "constructor" && e.push(r);
  return e;
}
var Kw = Wu(uo, "DataView"), Zw = Wu(uo, "Promise"), Qh = Wu(uo, "Set"), Qw = Wu(uo, "WeakMap"), $8 = "[object Map]", Hce = "[object Object]", z8 = "[object Promise]", G8 = "[object Set]", V8 = "[object WeakMap]", U8 = "[object DataView]", qce = qu(Kw), Wce = qu(Tp), Yce = qu(Zw), Xce = qu(Qh), jce = qu(Qw), Ga = Hu;
(Kw && Ga(new Kw(new ArrayBuffer(1))) != U8 || Tp && Ga(new Tp()) != $8 || Zw && Ga(Zw.resolve()) != z8 || Qh && Ga(new Qh()) != G8 || Qw && Ga(new Qw()) != V8) && (Ga = function(t) {
  var e = Hu(t), r = e == Hce ? t.constructor : void 0, n = r ? qu(r) : "";
  if (n)
    switch (n) {
      case qce:
        return U8;
      case Wce:
        return $8;
      case Yce:
        return z8;
      case Xce:
        return G8;
      case jce:
        return V8;
    }
  return e;
});
var Kce = "[object Map]", Zce = "[object Set]", Qce = Object.prototype, Jce = Qce.hasOwnProperty;
function Ap(t) {
  if (t == null)
    return !0;
  if (dc(t) && (An(t) || typeof t == "string" || typeof t.splice == "function" || Td(t) || Z2(t) || wd(t)))
    return !t.length;
  var e = Ga(t);
  if (e == Kce || e == Zce)
    return !t.size;
  if (j2(t))
    return !L$(t).length;
  for (var r in t)
    if (Jce.call(t, r))
      return !1;
  return !0;
}
var R$ = "c4", eue = /* @__PURE__ */ x((t) => /^\s*C4Context|C4Container|C4Component|C4Dynamic|C4Deployment/.test(t), "detector"), tue = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => Fwe);
  return { id: R$, diagram: t };
}, "loader"), rue = {
  id: R$,
  detector: eue,
  loader: tue
}, nue = rue, M$ = "flowchart", iue = /* @__PURE__ */ x((t, e) => e?.flowchart?.defaultRenderer === "dagre-wrapper" || e?.flowchart?.defaultRenderer === "elk" ? !1 : /^\s*graph/.test(t), "detector"), aue = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => kS);
  return { id: M$, diagram: t };
}, "loader"), sue = {
  id: M$,
  detector: iue,
  loader: aue
}, oue = sue, N$ = "flowchart-v2", lue = /* @__PURE__ */ x((t, e) => e?.flowchart?.defaultRenderer === "dagre-d3" ? !1 : (e?.flowchart?.defaultRenderer === "elk" && (e.layout = "elk"), /^\s*graph/.test(t) && e?.flowchart?.defaultRenderer === "dagre-wrapper" ? !0 : /^\s*flowchart/.test(t)), "detector"), cue = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => kS);
  return { id: N$, diagram: t };
}, "loader"), uue = {
  id: N$,
  detector: lue,
  loader: cue
}, hue = uue, I$ = "er", due = /* @__PURE__ */ x((t) => /^\s*erDiagram/.test(t), "detector"), fue = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => iTe);
  return { id: I$, diagram: t };
}, "loader"), pue = {
  id: I$,
  detector: due,
  loader: fue
}, gue = pue, D$ = "gitGraph", mue = /* @__PURE__ */ x((t) => /^\s*gitGraph/.test(t), "detector"), vue = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => HRe);
  return { id: D$, diagram: t };
}, "loader"), yue = {
  id: D$,
  detector: mue,
  loader: vue
}, xue = yue, O$ = "gantt", bue = /* @__PURE__ */ x((t) => /^\s*gantt/.test(t), "detector"), wue = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => ZMe);
  return { id: O$, diagram: t };
}, "loader"), Tue = {
  id: O$,
  detector: bue,
  loader: wue
}, Eue = Tue, P$ = "info", kue = /* @__PURE__ */ x((t) => /^\s*info/.test(t), "detector"), Sue = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => aNe);
  return { id: P$, diagram: t };
}, "loader"), Cue = {
  id: P$,
  detector: kue,
  loader: Sue
}, B$ = "pie", Aue = /* @__PURE__ */ x((t) => /^\s*pie/.test(t), "detector"), _ue = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => TNe);
  return { id: B$, diagram: t };
}, "loader"), Lue = {
  id: B$,
  detector: Aue,
  loader: _ue
}, F$ = "quadrantChart", Rue = /* @__PURE__ */ x((t) => /^\s*quadrantChart/.test(t), "detector"), Mue = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => MNe);
  return { id: F$, diagram: t };
}, "loader"), Nue = {
  id: F$,
  detector: Rue,
  loader: Mue
}, Iue = Nue, $$ = "xychart", Due = /* @__PURE__ */ x((t) => /^\s*xychart(-beta)?/.test(t), "detector"), Oue = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => WNe);
  return { id: $$, diagram: t };
}, "loader"), Pue = {
  id: $$,
  detector: Due,
  loader: Oue
}, Bue = Pue, z$ = "requirement", Fue = /* @__PURE__ */ x((t) => /^\s*requirement(Diagram)?/.test(t), "detector"), $ue = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => JNe);
  return { id: z$, diagram: t };
}, "loader"), zue = {
  id: z$,
  detector: Fue,
  loader: $ue
}, Gue = zue, G$ = "sequence", Vue = /* @__PURE__ */ x((t) => /^\s*sequenceDiagram/.test(t), "detector"), Uue = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => zIe);
  return { id: G$, diagram: t };
}, "loader"), Hue = {
  id: G$,
  detector: Vue,
  loader: Uue
}, que = Hue, V$ = "class", Wue = /* @__PURE__ */ x((t, e) => e?.class?.defaultRenderer === "dagre-wrapper" ? !1 : /^\s*classDiagram/.test(t), "detector"), Yue = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => WIe);
  return { id: V$, diagram: t };
}, "loader"), Xue = {
  id: V$,
  detector: Wue,
  loader: Yue
}, jue = Xue, U$ = "classDiagram", Kue = /* @__PURE__ */ x((t, e) => /^\s*classDiagram/.test(t) && e?.class?.defaultRenderer === "dagre-wrapper" ? !0 : /^\s*classDiagram-v2/.test(t), "detector"), Zue = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => XIe);
  return { id: U$, diagram: t };
}, "loader"), Que = {
  id: U$,
  detector: Kue,
  loader: Zue
}, Jue = Que, H$ = "state", ehe = /* @__PURE__ */ x((t, e) => e?.state?.defaultRenderer === "dagre-wrapper" ? !1 : /^\s*stateDiagram/.test(t), "detector"), the = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => BDe);
  return { id: H$, diagram: t };
}, "loader"), rhe = {
  id: H$,
  detector: ehe,
  loader: the
}, nhe = rhe, q$ = "stateDiagram", ihe = /* @__PURE__ */ x((t, e) => !!(/^\s*stateDiagram-v2/.test(t) || /^\s*stateDiagram/.test(t) && e?.state?.defaultRenderer === "dagre-wrapper"), "detector"), ahe = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => $De);
  return { id: q$, diagram: t };
}, "loader"), she = {
  id: q$,
  detector: ihe,
  loader: ahe
}, ohe = she, W$ = "journey", lhe = /* @__PURE__ */ x((t) => /^\s*journey/.test(t), "detector"), che = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => oOe);
  return { id: W$, diagram: t };
}, "loader"), uhe = {
  id: W$,
  detector: lhe,
  loader: che
}, hhe = uhe, dhe = /* @__PURE__ */ x((t, e, r) => {
  ie.debug(`rendering svg for syntax error
`);
  const n = ll(e), i = n.append("g");
  n.attr("viewBox", "0 0 2412 512"), Xi(n, 100, 512, !0), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m411.313,123.313c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32-9.375,9.375-20.688-20.688c-12.484-12.5-32.766-12.5-45.25,0l-16,16c-1.261,1.261-2.304,2.648-3.31,4.051-21.739-8.561-45.324-13.426-70.065-13.426-105.867,0-192,86.133-192,192s86.133,192 192,192 192-86.133 192-192c0-24.741-4.864-48.327-13.426-70.065 1.402-1.007 2.79-2.049 4.051-3.31l16-16c12.5-12.492 12.5-32.758 0-45.25l-20.688-20.688 9.375-9.375 32.001-31.999zm-219.313,100.687c-52.938,0-96,43.063-96,96 0,8.836-7.164,16-16,16s-16-7.164-16-16c0-70.578 57.422-128 128-128 8.836,0 16,7.164 16,16s-7.164,16-16,16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m459.02,148.98c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l16,16c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16.001-16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m340.395,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16-16c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l15.999,16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m400,64c8.844,0 16-7.164 16-16v-32c0-8.836-7.156-16-16-16-8.844,0-16,7.164-16,16v32c0,8.836 7.156,16 16,16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m496,96.586h-32c-8.844,0-16,7.164-16,16 0,8.836 7.156,16 16,16h32c8.844,0 16-7.164 16-16 0-8.836-7.156-16-16-16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m436.98,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688l32-32c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32c-6.251,6.25-6.251,16.375-0.001,22.625z"
  ), i.append("text").attr("class", "error-text").attr("x", 1440).attr("y", 250).attr("font-size", "150px").style("text-anchor", "middle").text("Syntax error in text"), i.append("text").attr("class", "error-text").attr("x", 1250).attr("y", 400).attr("font-size", "100px").style("text-anchor", "middle").text(`mermaid version ${r}`);
}, "draw"), Y$ = { draw: dhe }, fhe = Y$, phe = {
  db: {},
  renderer: Y$,
  parser: {
    parse: /* @__PURE__ */ x(() => {
    }, "parse")
  }
}, ghe = phe, X$ = "flowchart-elk", mhe = /* @__PURE__ */ x((t, e = {}) => (
  // If diagram explicitly states flowchart-elk
  /^\s*flowchart-elk/.test(t) || // If a flowchart/graph diagram has their default renderer set to elk
  /^\s*(flowchart|graph)/.test(t) && e?.flowchart?.defaultRenderer === "elk" ? (e.layout = "elk", !0) : !1
), "detector"), vhe = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => kS);
  return { id: X$, diagram: t };
}, "loader"), yhe = {
  id: X$,
  detector: mhe,
  loader: vhe
}, xhe = yhe, j$ = "timeline", bhe = /* @__PURE__ */ x((t) => /^\s*timeline/.test(t), "detector"), whe = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => LOe);
  return { id: j$, diagram: t };
}, "loader"), The = {
  id: j$,
  detector: bhe,
  loader: whe
}, Ehe = The, K$ = "mindmap", khe = /* @__PURE__ */ x((t) => /^\s*mindmap/.test(t), "detector"), She = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => UOe);
  return { id: K$, diagram: t };
}, "loader"), Che = {
  id: K$,
  detector: khe,
  loader: She
}, Ahe = Che, Z$ = "kanban", _he = /* @__PURE__ */ x((t) => /^\s*kanban/.test(t), "detector"), Lhe = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => cPe);
  return { id: Z$, diagram: t };
}, "loader"), Rhe = {
  id: Z$,
  detector: _he,
  loader: Lhe
}, Mhe = Rhe, Q$ = "sankey", Nhe = /* @__PURE__ */ x((t) => /^\s*sankey(-beta)?/.test(t), "detector"), Ihe = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => YPe);
  return { id: Q$, diagram: t };
}, "loader"), Dhe = {
  id: Q$,
  detector: Nhe,
  loader: Ihe
}, Ohe = Dhe, J$ = "packet", Phe = /* @__PURE__ */ x((t) => /^\s*packet(-beta)?/.test(t), "detector"), Bhe = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => iBe);
  return { id: J$, diagram: t };
}, "loader"), Fhe = {
  id: J$,
  detector: Phe,
  loader: Bhe
}, ez = "radar", $he = /* @__PURE__ */ x((t) => /^\s*radar-beta/.test(t), "detector"), zhe = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => SBe);
  return { id: ez, diagram: t };
}, "loader"), Ghe = {
  id: ez,
  detector: $he,
  loader: zhe
}, tz = "block", Vhe = /* @__PURE__ */ x((t) => /^\s*block(-beta)?/.test(t), "detector"), Uhe = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => ZFe);
  return { id: tz, diagram: t };
}, "loader"), Hhe = {
  id: tz,
  detector: Vhe,
  loader: Uhe
}, qhe = Hhe, rz = "architecture", Whe = /* @__PURE__ */ x((t) => /^\s*architecture/.test(t), "detector"), Yhe = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => S$e);
  return { id: rz, diagram: t };
}, "loader"), Xhe = {
  id: rz,
  detector: Whe,
  loader: Yhe
}, jhe = Xhe, nz = "treemap", Khe = /* @__PURE__ */ x((t) => /^\s*treemap/.test(t), "detector"), Zhe = /* @__PURE__ */ x(async () => {
  const { diagram: t } = await Promise.resolve().then(() => P$e);
  return { id: nz, diagram: t };
}, "loader"), Qhe = {
  id: nz,
  detector: Khe,
  loader: Zhe
}, H8 = !1, hx = /* @__PURE__ */ x(() => {
  H8 || (H8 = !0, _v("error", ghe, (t) => t.toLowerCase().trim() === "error"), _v(
    "---",
    // --- diagram type may appear if YAML front-matter is not parsed correctly
    {
      db: {
        clear: /* @__PURE__ */ x(() => {
        }, "clear")
      },
      styles: {},
      // should never be used
      renderer: {
        draw: /* @__PURE__ */ x(() => {
        }, "draw")
      },
      parser: {
        parse: /* @__PURE__ */ x(() => {
          throw new Error(
            "Diagrams beginning with --- are not valid. If you were trying to use a YAML front-matter, please ensure that you've correctly opened and closed the YAML front-matter with un-indented `---` blocks"
          );
        }, "parse")
      },
      init: /* @__PURE__ */ x(() => null, "init")
      // no op
    },
    (t) => t.toLowerCase().trimStart().startsWith("---")
  ), Q5(xhe, Ahe, jhe), Q5(
    nue,
    Mhe,
    Jue,
    jue,
    gue,
    Eue,
    Cue,
    Lue,
    Gue,
    que,
    hue,
    oue,
    Ehe,
    xue,
    ohe,
    nhe,
    hhe,
    Iue,
    Ohe,
    Fhe,
    Bue,
    qhe,
    Ghe,
    Qhe
  ));
}, "addDiagrams"), Jhe = /* @__PURE__ */ x(async () => {
  ie.debug("Loading registered diagrams");
  const e = (await Promise.allSettled(
    Object.entries(du).map(async ([r, { detector: n, loader: i }]) => {
      if (i)
        try {
          nw(r);
        } catch {
          try {
            const { diagram: a, id: s } = await i();
            _v(s, a, n);
          } catch (a) {
            throw ie.error(`Failed to load external diagram with key ${r}. Removing from detectors.`), delete du[r], a;
          }
        }
    })
  )).filter((r) => r.status === "rejected");
  if (e.length > 0) {
    ie.error(`Failed to load ${e.length} external diagrams`);
    for (const r of e)
      ie.error(r);
    throw new Error(`Failed to load ${e.length} external diagrams`);
  }
}, "loadRegisteredDiagrams"), ede = "graphics-document document";
function iz(t, e) {
  t.attr("role", ede), e !== "" && t.attr("aria-roledescription", e);
}
x(iz, "setA11yDiagramInfo");
function az(t, e, r, n) {
  if (t.insert !== void 0) {
    if (r) {
      const i = `chart-desc-${n}`;
      t.attr("aria-describedby", i), t.insert("desc", ":first-child").attr("id", i).text(r);
    }
    if (e) {
      const i = `chart-title-${n}`;
      t.attr("aria-labelledby", i), t.insert("title", ":first-child").attr("id", i).text(e);
    }
  }
}
x(az, "addSVGa11yTitleDescription");
var Jw = class sz {
  constructor(e, r, n, i, a) {
    this.type = e, this.text = r, this.db = n, this.parser = i, this.renderer = a;
  }
  static {
    x(this, "Diagram");
  }
  static async fromText(e, r = {}) {
    const n = pr(), i = aE(e, n);
    e = ioe(e) + `
`;
    try {
      nw(i);
    } catch {
      const u = uK(i);
      if (!u)
        throw new CI(`Diagram ${i} not found.`);
      const { id: h, diagram: d } = await u();
      _v(h, d);
    }
    const { db: a, parser: s, renderer: o, init: l } = nw(i);
    return s.parser && (s.parser.yy = a), a.clear?.(), l?.(n), r.title && a.setDiagramTitle?.(r.title), await s.parse(e), new sz(i, e, a, s, o);
  }
  async render(e, r) {
    await this.renderer.draw(this.text, e, r, this);
  }
  getParser() {
    return this.parser;
  }
  getType() {
    return this.type;
  }
}, q8 = [], tde = /* @__PURE__ */ x(() => {
  q8.forEach((t) => {
    t();
  }), q8 = [];
}, "attachFunctions"), rde = /* @__PURE__ */ x((t) => t.replace(/^\s*%%(?!{)[^\n]+\n?/gm, "").trimStart(), "cleanupComments");
function oz(t) {
  const e = t.match(SI);
  if (!e)
    return {
      text: t,
      metadata: {}
    };
  let r = q2(e[1], {
    // To support config, we need JSON schema.
    // https://www.yaml.org/spec/1.2/spec.html#id2803231
    schema: H2
  }) ?? {};
  r = typeof r == "object" && !Array.isArray(r) ? r : {};
  const n = {};
  return r.displayMode && (n.displayMode = r.displayMode.toString()), r.title && (n.title = r.title.toString()), r.config && (n.config = r.config), {
    text: t.slice(e[0].length),
    metadata: n
  };
}
x(oz, "extractFrontMatter");
var nde = /* @__PURE__ */ x((t) => t.replace(/\r\n?/g, `
`).replace(
  /<(\w+)([^>]*)>/g,
  (e, r, n) => "<" + r + n.replace(/="([^"]*)"/g, "='$1'") + ">"
), "cleanupText"), ide = /* @__PURE__ */ x((t) => {
  const { text: e, metadata: r } = oz(t), { displayMode: n, title: i, config: a = {} } = r;
  return n && (a.gantt || (a.gantt = {}), a.gantt.displayMode = n), { title: i, config: a, text: e };
}, "processFrontmatter"), ade = /* @__PURE__ */ x((t) => {
  const e = Zt.detectInit(t) ?? {}, r = Zt.detectDirective(t, "wrap");
  return Array.isArray(r) ? e.wrap = r.some(({ type: n }) => n === "wrap") : r?.type === "wrap" && (e.wrap = !0), {
    text: Xse(t),
    directive: e
  };
}, "processDirectives");
function ck(t) {
  const e = nde(t), r = ide(e), n = ade(r.text), i = Hi(r.config, n.directive);
  return t = rde(n.text), {
    code: t,
    title: r.title,
    config: i
  };
}
x(ck, "preprocessDiagram");
function lz(t) {
  const e = new TextEncoder().encode(t), r = Array.from(e, (n) => String.fromCodePoint(n)).join("");
  return btoa(r);
}
x(lz, "toBase64");
var sde = 5e4, ode = "graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa", lde = "sandbox", cde = "loose", ude = "http://www.w3.org/2000/svg", hde = "http://www.w3.org/1999/xlink", dde = "http://www.w3.org/1999/xhtml", fde = "100%", pde = "100%", gde = "border:0;margin:0;", mde = "margin:0", vde = "allow-top-navigation-by-user-activation allow-popups", yde = 'The "iframe" tag is not supported by your browser.', xde = ["foreignobject"], bde = ["dominant-baseline"];
function uk(t) {
  const e = ck(t);
  return Cv(), SK(e.config ?? {}), e;
}
x(uk, "processAndSetConfigs");
async function cz(t, e) {
  hx();
  try {
    const { code: r, config: n } = uk(t);
    return { diagramType: (await hz(r)).type, config: n };
  } catch (r) {
    if (e?.suppressErrors)
      return !1;
    throw r;
  }
}
x(cz, "parse");
var W8 = /* @__PURE__ */ x((t, e, r = []) => `
.${t} ${e} { ${r.join(" !important; ")} !important; }`, "cssImportantStyles"), wde = /* @__PURE__ */ x((t, e = /* @__PURE__ */ new Map()) => {
  let r = "";
  if (t.themeCSS !== void 0 && (r += `
${t.themeCSS}`), t.fontFamily !== void 0 && (r += `
:root { --mermaid-font-family: ${t.fontFamily}}`), t.altFontFamily !== void 0 && (r += `
:root { --mermaid-alt-font-family: ${t.altFontFamily}}`), e instanceof Map) {
    const s = t.htmlLabels ?? t.flowchart?.htmlLabels ? ["> *", "span"] : ["rect", "polygon", "ellipse", "circle", "path"];
    e.forEach((o) => {
      Ap(o.styles) || s.forEach((l) => {
        r += W8(o.id, l, o.styles);
      }), Ap(o.textStyles) || (r += W8(
        o.id,
        "tspan",
        (o?.textStyles || []).map((l) => l.replace("color", "fill"))
      ));
    });
  }
  return r;
}, "createCssStyles"), Tde = /* @__PURE__ */ x((t, e, r, n) => {
  const i = wde(t, r), a = HK(e, i, t.themeVariables);
  return jw(Fce(`${n}{${a}}`), zce);
}, "createUserStyles"), Ede = /* @__PURE__ */ x((t = "", e, r) => {
  let n = t;
  return !r && !e && (n = n.replace(
    /marker-end="url\([\d+./:=?A-Za-z-]*?#/g,
    'marker-end="url(#'
  )), n = ao(n), n = n.replace(/<br>/g, "<br/>"), n;
}, "cleanUpSvgCode"), kde = /* @__PURE__ */ x((t = "", e) => {
  const r = e?.viewBox?.baseVal?.height ? e.viewBox.baseVal.height + "px" : pde, n = lz(`<body style="${mde}">${t}</body>`);
  return `<iframe style="width:${fde};height:${r};${gde}" src="data:text/html;charset=UTF-8;base64,${n}" sandbox="${vde}">
  ${yde}
</iframe>`;
}, "putIntoIFrame"), Y8 = /* @__PURE__ */ x((t, e, r, n, i) => {
  const a = t.append("div");
  a.attr("id", r), n && a.attr("style", n);
  const s = a.append("svg").attr("id", e).attr("width", "100%").attr("xmlns", ude);
  return i && s.attr("xmlns:xlink", i), s.append("g"), t;
}, "appendDivSvgG");
function eT(t, e) {
  return t.append("iframe").attr("id", e).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
}
x(eT, "sandboxedIframe");
var Sde = /* @__PURE__ */ x((t, e, r, n) => {
  t.getElementById(e)?.remove(), t.getElementById(r)?.remove(), t.getElementById(n)?.remove();
}, "removeExistingElements"), Cde = /* @__PURE__ */ x(async function(t, e, r) {
  hx();
  const n = uk(e);
  e = n.code;
  const i = pr();
  ie.debug(i), e.length > (i?.maxTextSize ?? sde) && (e = ode);
  const a = "#" + t, s = "i" + t, o = "#" + s, l = "d" + t, u = "#" + l, h = /* @__PURE__ */ x(() => {
    const P = Qe(f ? o : u).node();
    P && "remove" in P && P.remove();
  }, "removeTempElements");
  let d = Qe("body");
  const f = i.securityLevel === lde, p = i.securityLevel === cde, g = i.fontFamily;
  if (r !== void 0) {
    if (r && (r.innerHTML = ""), f) {
      const O = eT(Qe(r), s);
      d = Qe(O.nodes()[0].contentDocument.body), d.node().style.margin = 0;
    } else
      d = Qe(r);
    Y8(d, t, l, `font-family: ${g}`, hde);
  } else {
    if (Sde(document, t, l, s), f) {
      const O = eT(Qe("body"), s);
      d = Qe(O.nodes()[0].contentDocument.body), d.node().style.margin = 0;
    } else
      d = Qe("body");
    Y8(d, t, l);
  }
  let m, v;
  try {
    m = await Jw.fromText(e, { title: n.title });
  } catch (O) {
    if (i.suppressErrorRendering)
      throw h(), O;
    m = await Jw.fromText("error"), v = O;
  }
  const y = d.select(u).node(), b = m.type, w = y.firstChild, T = w.firstChild, E = m.renderer.getClasses?.(e, m), L = Tde(i, b, E, a), k = document.createElement("style");
  k.innerHTML = L, w.insertBefore(k, T);
  try {
    await m.renderer.draw(e, t, X5.version, m);
  } catch (O) {
    throw i.suppressErrorRendering ? h() : fhe.draw(e, t, X5.version), O;
  }
  const C = d.select(`${u} svg`), A = m.db.getAccTitle?.(), R = m.db.getAccDescription?.();
  dz(b, C, A, R), d.select(`[id="${t}"]`).selectAll("foreignobject > *").attr("xmlns", dde);
  let _ = d.select(u).node().innerHTML;
  if (ie.debug("config.arrowMarkerAbsolute", i.arrowMarkerAbsolute), _ = Ede(_, f, Nr(i.arrowMarkerAbsolute)), f) {
    const O = d.select(u + " svg").node();
    _ = kde(_, O);
  } else p || (_ = ud.sanitize(_, {
    ADD_TAGS: xde,
    ADD_ATTR: bde,
    HTML_INTEGRATION_POINTS: { foreignobject: !0 }
  }));
  if (tde(), v)
    throw v;
  return h(), {
    diagramType: b,
    svg: _,
    bindFunctions: m.db.bindFunctions
  };
}, "render");
function uz(t = {}) {
  const e = mn({}, t);
  e?.fontFamily && !e.themeVariables?.fontFamily && (e.themeVariables || (e.themeVariables = {}), e.themeVariables.fontFamily = e.fontFamily), EK(e), e?.theme && e.theme in Ho ? e.themeVariables = Ho[e.theme].getThemeVariables(
    e.themeVariables
  ) : e && (e.themeVariables = Ho.default.getThemeVariables(e.themeVariables));
  const r = typeof e == "object" ? TK(e) : RI();
  nE(r.logLevel), hx();
}
x(uz, "initialize");
var hz = /* @__PURE__ */ x((t, e = {}) => {
  const { code: r } = ck(t);
  return Jw.fromText(r, e);
}, "getDiagramFromText");
function dz(t, e, r, n) {
  iz(e, t), az(e, r, n, e.attr("id"));
}
x(dz, "addA11yInfo");
var Tu = Object.freeze({
  render: Cde,
  parse: cz,
  getDiagramFromText: hz,
  initialize: uz,
  getConfig: pr,
  setConfig: MI,
  getSiteConfig: RI,
  updateSiteConfig: kK,
  reset: /* @__PURE__ */ x(() => {
    Cv();
  }, "reset"),
  globalReset: /* @__PURE__ */ x(() => {
    Cv(hd);
  }, "globalReset"),
  defaultConfig: hd
});
nE(pr().logLevel);
Cv(pr());
var Ade = /* @__PURE__ */ x((t, e, r) => {
  ie.warn(t), HE(t) ? (r && r(t.str, t.hash), e.push({ ...t, message: t.str, error: t })) : (r && r(t), t instanceof Error && e.push({
    str: t.message,
    message: t.message,
    hash: t.name,
    error: t
  }));
}, "handleError"), fz = /* @__PURE__ */ x(async function(t = {
  querySelector: ".mermaid"
}) {
  try {
    await _de(t);
  } catch (e) {
    if (HE(e) && ie.error(e.str), Jo.parseError && Jo.parseError(e), !t.suppressErrors)
      throw ie.error("Use the suppressErrors option to suppress these errors"), e;
  }
}, "run"), _de = /* @__PURE__ */ x(async function({ postRenderCallback: t, querySelector: e, nodes: r } = {
  querySelector: ".mermaid"
}) {
  const n = Tu.getConfig();
  ie.debug(`${t ? "" : "No "}Callback function found`);
  let i;
  if (r)
    i = r;
  else if (e)
    i = document.querySelectorAll(e);
  else
    throw new Error("Nodes and querySelector are both undefined");
  ie.debug(`Found ${i.length} diagrams`), n?.startOnLoad !== void 0 && (ie.debug("Start On Load: " + n?.startOnLoad), Tu.updateSiteConfig({ startOnLoad: n?.startOnLoad }));
  const a = new Zt.InitIDGenerator(n.deterministicIds, n.deterministicIDSeed);
  let s;
  const o = [];
  for (const l of Array.from(i)) {
    if (ie.info("Rendering diagram: " + l.id), l.getAttribute("data-processed"))
      continue;
    l.setAttribute("data-processed", "true");
    const u = `mermaid-${a.next()}`;
    s = l.innerHTML, s = CB(Zt.entityDecode(s)).trim().replace(/<br\s*\/?>/gi, "<br/>");
    const h = Zt.detectInit(s);
    h && ie.debug("Detected early reinit: ", h);
    try {
      const { svg: d, bindFunctions: f } = await vz(u, s, l);
      l.innerHTML = d, t && await t(u), f && f(l);
    } catch (d) {
      Ade(d, o, Jo.parseError);
    }
  }
  if (o.length > 0)
    throw o[0];
}, "runThrowsErrors"), pz = /* @__PURE__ */ x(function(t) {
  Tu.initialize(t);
}, "initialize"), Lde = /* @__PURE__ */ x(async function(t, e, r) {
  ie.warn("mermaid.init is deprecated. Please use run instead."), t && pz(t);
  const n = { postRenderCallback: r, querySelector: ".mermaid" };
  typeof e == "string" ? n.querySelector = e : e && (e instanceof HTMLElement ? n.nodes = [e] : n.nodes = e), await fz(n);
}, "init"), Rde = /* @__PURE__ */ x(async (t, {
  lazyLoad: e = !0
} = {}) => {
  hx(), Q5(...t), e === !1 && await Jhe();
}, "registerExternalDiagrams"), gz = /* @__PURE__ */ x(function() {
  if (Jo.startOnLoad) {
    const { startOnLoad: t } = Tu.getConfig();
    t && Jo.run().catch((e) => ie.error("Mermaid failed to initialize", e));
  }
}, "contentLoaded");
typeof document < "u" && window.addEventListener("load", gz, !1);
var Mde = /* @__PURE__ */ x(function(t) {
  Jo.parseError = t;
}, "setParseErrorHandler"), py = [], u4 = !1, mz = /* @__PURE__ */ x(async () => {
  if (!u4) {
    for (u4 = !0; py.length > 0; ) {
      const t = py.shift();
      if (t)
        try {
          await t();
        } catch (e) {
          ie.error("Error executing queue", e);
        }
    }
    u4 = !1;
  }
}, "executeQueue"), Nde = /* @__PURE__ */ x(async (t, e) => new Promise((r, n) => {
  const i = /* @__PURE__ */ x(() => new Promise((a, s) => {
    Tu.parse(t, e).then(
      (o) => {
        a(o), r(o);
      },
      (o) => {
        ie.error("Error parsing", o), Jo.parseError?.(o), s(o), n(o);
      }
    );
  }), "performCall");
  py.push(i), mz().catch(n);
}), "parse"), vz = /* @__PURE__ */ x((t, e, r) => new Promise((n, i) => {
  const a = /* @__PURE__ */ x(() => new Promise((s, o) => {
    Tu.render(t, e, r).then(
      (l) => {
        s(l), n(l);
      },
      (l) => {
        ie.error("Error parsing", l), Jo.parseError?.(l), o(l), i(l);
      }
    );
  }), "performCall");
  py.push(a), mz().catch(i);
}), "render"), Ide = /* @__PURE__ */ x(() => Object.keys(du).map((t) => ({
  id: t
})), "getRegisteredDiagramsMetadata"), Jo = {
  startOnLoad: !0,
  mermaidAPI: Tu,
  parse: Nde,
  render: vz,
  init: Lde,
  run: fz,
  registerExternalDiagrams: Rde,
  registerLayoutLoaders: T$,
  initialize: pz,
  parseError: void 0,
  contentLoaded: gz,
  setParseErrorHandler: Mde,
  detectType: aE,
  registerIconPacks: LB,
  getRegisteredDiagramsMetadata: Ide
}, X8 = Jo;
function Dde(t, e, { signal: r, edges: n } = {}) {
  let i, a = null;
  const s = n != null && n.includes("leading"), o = n == null || n.includes("trailing"), l = () => {
    a !== null && (t.apply(i, a), i = void 0, a = null);
  }, u = () => {
    o && l(), p();
  };
  let h = null;
  const d = () => {
    h != null && clearTimeout(h), h = setTimeout(() => {
      h = null, u();
    }, e);
  }, f = () => {
    h !== null && (clearTimeout(h), h = null);
  }, p = () => {
    f(), i = void 0, a = null;
  }, g = () => {
    l();
  }, m = function(...v) {
    if (r?.aborted)
      return;
    i = this, a = v;
    const y = h == null;
    d(), s && y && l();
  };
  return m.schedule = d, m.cancel = p, m.flush = g, r?.addEventListener("abort", p, { once: !0 }), m;
}
function Ode(t, e = 0, r = {}) {
  typeof r != "object" && (r = {});
  const { leading: n = !1, trailing: i = !0, maxWait: a } = r, s = Array(2);
  n && (s[0] = "leading"), i && (s[1] = "trailing");
  let o, l = null;
  const u = Dde(function(...f) {
    o = t.apply(this, f), l = null;
  }, e, { edges: s }), h = function(...f) {
    return a != null && (l === null && (l = Date.now()), Date.now() - l >= a) ? (o = t.apply(this, f), l = Date.now(), u.cancel(), u.schedule(), o) : (u.apply(this, f), o);
  }, d = () => (u.flush(), o);
  return h.cancel = u.cancel, h.flush = d, h;
}
function hk(t, e) {
  const r = t.model.document.selection, n = r.getSelectedElement() || r.getLastPosition().parent;
  return !!(n && n.is("element", "mermaid") && n.getAttribute("displayMode") === e);
}
class Pde extends S2 {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor, r = e.model.document.selection, n = r.getSelectedElement();
    n && n.name === "mermaid" || r.getLastPosition().findAncestor("mermaid") ? this.isEnabled = !!n : this.isEnabled = !1, this.value = hk(e, "preview");
  }
  /**
   * @inheritDoc
   */
  execute() {
    const r = this.editor.model, n = this.editor.model.document.selection, i = n.getSelectedElement() || n.getLastPosition().parent;
    r.change((a) => {
      i.getAttribute("displayMode") !== "preview" && a.setAttribute("displayMode", "preview", i);
    });
  }
}
class Bde extends S2 {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor, r = e.model.document.selection, n = r.getSelectedElement();
    n && n.name === "mermaid" || r.getLastPosition().findAncestor("mermaid") ? this.isEnabled = !!n : this.isEnabled = !1, this.value = hk(e, "source");
  }
  /**
   * @inheritDoc
   */
  execute() {
    const r = this.editor.model, n = this.editor.model.document.selection, i = n.getSelectedElement() || n.getLastPosition().parent;
    r.change((a) => {
      i.getAttribute("displayMode") !== "source" && a.setAttribute("displayMode", "source", i);
    });
  }
}
class Fde extends S2 {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor, r = e.model.document.selection, n = r.getSelectedElement();
    n && n.name === "mermaid" || r.getLastPosition().findAncestor("mermaid") ? this.isEnabled = !!n : this.isEnabled = !1, this.value = hk(e, "split");
  }
  /**
   * @inheritDoc
   */
  execute() {
    const r = this.editor.model, n = this.editor.model.document.selection, i = n.getSelectedElement() || n.getLastPosition().parent;
    r.change((a) => {
      i.getAttribute("displayMode") !== "split" && a.setAttribute("displayMode", "split", i);
    });
  }
}
const $de = `flowchart TB
A --> B
B --> C`;
class zde extends S2 {
  /**
   * @inheritDoc
   */
  refresh() {
    const r = this.editor.model.document.selection.getSelectedElement();
    r && r.name === "mermaid" ? this.isEnabled = !1 : this.isEnabled = !0;
  }
  /**
   * @inheritDoc
   */
  execute() {
    const r = this.editor.model;
    let n;
    return r.change((i) => {
      n = i.createElement("mermaid", {
        displayMode: "split",
        source: $de
      }), r.insertContent(n);
    }), n;
  }
}
const Gde = 300;
class Vde extends C2 {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "MermaidEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    this._registerCommands(), this._defineConverters();
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    X8.initialize({
      startOnLoad: !1
    }), this.editor.model.schema.register("mermaid", {
      allowAttributes: ["displayMode", "source"],
      allowWhere: "$block",
      isObject: !0
    });
  }
  /**
   * @inheritDoc
  */
  _registerCommands() {
    const e = this.editor;
    e.commands.add("mermaidPreviewCommand", new Pde(e)), e.commands.add("mermaidSplitViewCommand", new Fde(e)), e.commands.add("mermaidSourceViewCommand", new Bde(e)), e.commands.add("insertMermaidCommand", new zde(e));
  }
  /**
   * Adds converters.
   */
  _defineConverters() {
    const e = this.editor;
    e.data.downcastDispatcher.on("insert:mermaid", this._mermaidDataDowncast.bind(this)), e.editing.downcastDispatcher.on("insert:mermaid", this._mermaidDowncast.bind(this)), e.editing.downcastDispatcher.on("attribute:source:mermaid", this._sourceAttributeDowncast.bind(this)), e.data.upcastDispatcher.on("element:code", this._mermaidUpcast.bind(this), { priority: "high" }), e.conversion.for("editingDowncast").attributeToAttribute({
      model: {
        name: "mermaid",
        key: "displayMode"
      },
      view: (r) => ({
        key: "class",
        value: "ck-mermaid__" + r + "-mode"
      })
    });
  }
  _mermaidDataDowncast(e, r, n) {
    const i = this.editor.model, { writer: a, mapper: s } = n;
    if (!n.consumable.consume(r.item, "insert"))
      return;
    const o = s.toViewPosition(i.createPositionBefore(r.item)), l = a.createContainerElement("code", {
      class: "language-mermaid"
    }), u = a.createContainerElement("pre", {
      spellcheck: "false"
    }), h = a.createText(r.item.getAttribute("source"));
    a.insert(i.createPositionAt(l, "end"), h), a.insert(i.createPositionAt(u, "end"), l), a.insert(o, u), s.bindElements(r.item, l);
  }
  _mermaidDowncast(e, r, n) {
    const { writer: i, mapper: a, consumable: s } = n, { editor: o } = this, { model: l, t: u } = o, h = this;
    if (!s.consume(r.item, "insert"))
      return;
    const d = a.toViewPosition(l.createPositionBefore(r.item)), f = {
      class: ["ck-mermaid__wrapper"]
    }, p = {
      class: ["ck-mermaid__editing-view"],
      placeholder: u("Insert mermaid source code"),
      "data-cke-ignore-events": !0
    }, g = i.createContainerElement("div", f), m = i.createUIElement("textarea", p, y), v = i.createUIElement("div", { class: ["ck-mermaid__preview"] }, b);
    return i.insert(i.createPositionAt(g, "start"), v), i.insert(i.createPositionAt(g, "start"), m), i.insert(d, g), a.bindElements(r.item, g), Lj(g, i, {
      label: u("Mermaid widget"),
      hasSelectionHandle: !0
    });
    function y(w) {
      const T = this.toDomElement(w);
      T.value = r.item.getAttribute("source");
      const E = Ode((L) => {
        o.model.change((k) => {
          k.setAttribute("source", L.target.value, r.item);
        });
      }, Gde);
      return T.addEventListener("input", E), T.addEventListener("focus", () => {
        const L = o.model;
        L.document.selection.getSelectedElement() !== r.item && L.change((C) => C.setSelection(r.item, "on"));
      }, !0), T;
    }
    function b(w) {
      const T = r.item.getAttribute("source"), E = this.toDomElement(w);
      return h._renderMermaid(E, T), E;
    }
  }
  _sourceAttributeDowncast(e, r, n) {
    const i = r.attributeNewValue, a = this.editor.editing.view.domConverter;
    if (i) {
      const s = n.mapper.toViewElement(r.item);
      for (const o of s.getChildren())
        if (o.name === "textarea" && o.hasClass("ck-mermaid__editing-view")) {
          const l = a.viewToDom(o, window.document);
          l.value != i && (l.value = i);
        } else if (o.name === "div" && o.hasClass("ck-mermaid__preview")) {
          const l = a.viewToDom(o, window.document);
          l && this._renderMermaid(l, i);
        }
    }
  }
  _mermaidUpcast(e, r, n) {
    const i = r.viewItem, a = !i.parent || !i.parent.is("element", "pre"), s = r.modelCursor.findAncestor("code"), { consumable: o, writer: l } = n;
    if (!i.hasClass("language-mermaid") || a || s || !o.test(i, { name: !0 }))
      return;
    const u = Array.from(i.getChildren()).filter((d) => d.is("$text")).map((d) => d.data).join(""), h = l.createElement("mermaid", {
      source: u,
      displayMode: "split"
    });
    n.safeInsert(h, r.modelCursor) && (o.consume(i, { name: !0 }), n.updateConversionResult(h, r));
  }
  /**
   * Renders Mermaid (a parsed `source`) in a given `domElement`.
   */
  _renderMermaid(e, r) {
    const n = `ck-mermaid-${Rj()}`;
    return X8.render(n, r).then(({ svg: i }) => {
      e.innerHTML = i;
    }).catch((i) => {
      e.innerText = i.message, Mj.document.getElementById(n).parentNode.remove();
    });
  }
}
class Ude extends C2 {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [K7];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "MermaidToolbar";
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const e = this.editor, r = e.t, n = e.plugins.get(K7), i = ["mermaidSourceView", "mermaidSplitView", "mermaidPreview", "|", "mermaidInfo"];
    i && n.register("mermaidToolbar", {
      ariaLabel: r("Mermaid toolbar"),
      items: i,
      getRelatedElement: (a) => Hde(a)
    });
  }
}
function Hde(t) {
  const e = t.getSelectedElement();
  return e && e.hasClass("ck-mermaid__wrapper") ? e : null;
}
const qde = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><path d="m8 11.5 3.004-3.004 3.003 3.004-3.003 3.004z"/><path fill-rule="evenodd" d="M9.504 2.863v3h3v-3zm-1 4h5v-5h-5z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M11.004 14.504 8 11.5l2.504-2.504V6.07h1v2.926l2.503 2.504zM9.414 11.5l1.59-1.59 1.59 1.59-1.59 1.59zM6.837 4.999h2.625v-1h-2.57a2.5 2.5 0 1 0-2.974 2.814V9h-2v5h5V9h-2V6.813c.934-.19 1.68-.9 1.919-1.814m-3.919-.636a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0m0 5.637v3h3v-3z" clip-rule="evenodd"/></svg>', Wde = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><path d="M13.8 11.609V13.4a.4.4 0 0 1-.4.4H2.6a.4.4 0 0 1-.4-.4v-1.791H1V13.4A1.6 1.6 0 0 0 2.6 15h10.8a1.6 1.6 0 0 0 1.6-1.6v-1.791zm0-6.612H15V2.6A1.6 1.6 0 0 0 13.4 1H2.6A1.6 1.6 0 0 0 1 2.6v2.397h1.2V2.6c0-.22.18-.4.4-.4h10.8c.22 0 .4.18.4.4z"/><path d="M8 11.095q-2.88 0-5.749-2.757L2 8.095l.251-.242c3.815-3.677 7.683-3.677 11.498 0l.251.242-.251.243Q10.886 11.095 8 11.096Zm-5.02-3c3.375 3.1 6.665 3.1 10.04 0-3.375-3.1-6.665-3.095-10.04 0"/><path fill-rule="evenodd" d="M13.514 8.095Q8 13.41 2.486 8.095q5.514-5.313 11.028 0m-3.586 0A1.926 1.926 0 0 1 8 10.02a1.926 1.926 0 0 1-1.928-1.924c0-1.062.863-1.924 1.928-1.924s1.928.862 1.928 1.924Z" clip-rule="evenodd"/><path d="M8 8.861a.767.767 0 1 0 .002-1.533A.767.767 0 0 0 8 8.86Z"/></svg>', Yde = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><path fill-rule="evenodd" d="M13.8 3.076H8.588V13.8H13.4a.4.4 0 0 0 .4-.4zm-6.412 0H2.2V13.4c0 .22.18.4.4.4h4.788zM2.6 1A1.6 1.6 0 0 0 1 2.6v10.8A1.6 1.6 0 0 0 2.6 15h10.8a1.6 1.6 0 0 0 1.6-1.6V2.6A1.6 1.6 0 0 0 13.4 1z" clip-rule="evenodd"/></svg>', Xde = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><path d="M11.609 2.2H13.4c.22 0 .4.18.4.4v10.8a.4.4 0 0 1-.4.4h-1.791V15H13.4a1.6 1.6 0 0 0 1.6-1.6V2.6A1.6 1.6 0 0 0 13.4 1h-1.791zm-6.612 0V1H2.6A1.6 1.6 0 0 0 1 2.6v10.8A1.6 1.6 0 0 0 2.6 15h2.397v-1.2H2.6a.4.4 0 0 1-.4-.4V2.6c0-.22.18-.4.4-.4z"/><path d="M3.511 4.778a.75.75 0 0 1 .75-.75h3.697a.75.75 0 1 1 0 1.5H4.26a.75.75 0 0 1-.75-.75Zm3.084 2.851a.75.75 0 0 1 .75-.75h3.588a.75.75 0 0 1 0 1.5H7.345a.75.75 0 0 1-.75-.75m0 2.851a.75.75 0 0 1 .75-.75h1.143a.75.75 0 1 1 0 1.5H7.345a.75.75 0 0 1-.75-.75M3.511 7.629a.75.75 0 0 1 .75-.75h.983a.75.75 0 1 1 0 1.5h-.983a.75.75 0 0 1-.75-.75m0 2.851a.75.75 0 0 1 .75-.75h.983a.75.75 0 1 1 0 1.5h-.983a.75.75 0 0 1-.75-.75"/></svg>', jde = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><path d="M8 1.219C4.254 1.219 1.219 4.28 1.219 8A6.78 6.78 0 0 0 8 14.781c3.719 0 6.781-3.035 6.781-6.781 0-3.719-3.062-6.781-6.781-6.781m0 12.25A5.45 5.45 0 0 1 2.531 8 5.467 5.467 0 0 1 8 2.531c3.008 0 5.469 2.461 5.469 5.469A5.467 5.467 0 0 1 8 13.469m0-9.242c-.656 0-1.148.52-1.148 1.148 0 .656.492 1.148 1.148 1.148.629 0 1.148-.492 1.148-1.148 0-.629-.52-1.148-1.148-1.148m1.531 6.945v-.656a.35.35 0 0 0-.328-.329h-.328V7.454a.35.35 0 0 0-.328-.328h-1.75a.33.33 0 0 0-.328.328v.656c0 .192.136.329.328.329h.328v1.75h-.328a.333.333 0 0 0-.328.328v.656c0 .191.136.328.328.328h2.406a.33.33 0 0 0 .328-.328Z"/></svg>';
class Kde extends C2 {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "MermaidUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    this._addButtons();
  }
  /**
   * Adds all mermaid-related buttons.
   *
   * @private
   */
  _addButtons() {
    const e = this.editor;
    this._addInsertMermaidButton(), this._addMermaidInfoButton(), this._createToolbarButton(e, "mermaidPreview", "Preview", Wde), this._createToolbarButton(e, "mermaidSourceView", "Source view", Xde), this._createToolbarButton(e, "mermaidSplitView", "Split view", Yde);
  }
  /**
   * Adds the button for inserting mermaid.
   *
   * @private
   */
  _addInsertMermaidButton() {
    const e = this.editor, r = e.t, n = e.editing.view;
    e.ui.componentFactory.add("mermaid", (i) => {
      const a = new Nb(i), s = e.commands.get("insertMermaidCommand");
      return a.set({
        label: r("Insert Mermaid diagram"),
        icon: qde,
        tooltip: !0
      }), a.bind("isOn", "isEnabled").to(s, "value", "isEnabled"), s.listenTo(a, "execute", () => {
        const o = e.execute("insertMermaidCommand"), l = e.editing.mapper.toViewElement(o);
        if (n.scrollToTheSelection(), n.focus(), l) {
          const u = n.domConverter.viewToDom(l, document);
          u && u.querySelector(".ck-mermaid__editing-view").focus();
        }
      }), a;
    });
  }
  /**
   * Adds the button linking to the mermaid guide.
   */
  _addMermaidInfoButton() {
    const e = this.editor, r = e.t;
    e.ui.componentFactory.add("mermaidInfo", (n) => {
      const i = new Nb(n), a = "https://ckeditor.com/blog/basic-overview-of-creating-flowcharts-using-mermaid/";
      return i.set({
        label: r("Read more about Mermaid diagram syntax"),
        icon: jde,
        tooltip: !0
      }), i.on("execute", () => {
        window.open(a, "_blank", "noopener");
      }), i;
    });
  }
  /**
   * Adds the mermaid balloon toolbar button.
   */
  _createToolbarButton(e, r, n, i) {
    const a = e.t;
    e.ui.componentFactory.add(r, (s) => {
      const o = new Nb(s), l = e.commands.get(`${r}Command`);
      return o.set({
        label: a(n),
        icon: i,
        tooltip: !0
      }), o.bind("isOn", "isEnabled").to(l, "value", "isEnabled"), l.listenTo(o, "execute", () => {
        e.execute(`${r}Command`), e.editing.view.scrollToTheSelection(), e.editing.view.focus();
      }), o;
    });
  }
}
class tze extends C2 {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Vde, Ude, Kde];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Mermaid";
  }
}
class ta {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(e, r, n) {
    this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = e, this.start = r, this.end = n;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(e, r) {
    return r ? !e || !e.loc || !r.loc || e.loc.lexer !== r.loc.lexer ? null : new ta(e.loc.lexer, e.loc.start, r.loc.end) : e && e.loc;
  }
}
class Ea {
  // don't expand the token
  // used in \noexpand
  constructor(e, r) {
    this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = e, this.loc = r;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(e, r) {
    return new Ea(r, ta.range(this, e));
  }
}
class ot {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(e, r) {
    this.name = void 0, this.position = void 0, this.length = void 0, this.rawMessage = void 0;
    var n = "KaTeX parse error: " + e, i, a, s = r && r.loc;
    if (s && s.start <= s.end) {
      var o = s.lexer.input;
      i = s.start, a = s.end, i === o.length ? n += " at end of input: " : n += " at position " + (i + 1) + ": ";
      var l = o.slice(i, a).replace(/[^]/g, "$&"), u;
      i > 15 ? u = "" + o.slice(i - 15, i) : u = o.slice(0, i);
      var h;
      a + 15 < o.length ? h = o.slice(a, a + 15) + "" : h = o.slice(a), n += u + l + h;
    }
    var d = new Error(n);
    return d.name = "ParseError", d.__proto__ = ot.prototype, d.position = i, i != null && a != null && (d.length = a - i), d.rawMessage = e, d;
  }
}
ot.prototype.__proto__ = Error.prototype;
var Zde = function(e, r) {
  return e === void 0 ? r : e;
}, Qde = /([A-Z])/g, Jde = function(e) {
  return e.replace(Qde, "-$1").toLowerCase();
}, efe = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
}, tfe = /[&><"']/g;
function rfe(t) {
  return String(t).replace(tfe, (e) => efe[e]);
}
var yz = function t(e) {
  return e.type === "ordgroup" || e.type === "color" ? e.body.length === 1 ? t(e.body[0]) : e : e.type === "font" ? t(e.body) : e;
}, nfe = function(e) {
  var r = yz(e);
  return r.type === "mathord" || r.type === "textord" || r.type === "atom";
}, ife = function(e) {
  if (!e)
    throw new Error("Expected non-null, but got " + String(e));
  return e;
}, afe = function(e) {
  var r = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(e);
  return r ? r[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(r[1]) ? null : r[1].toLowerCase() : "_relative";
}, Tr = {
  deflt: Zde,
  escape: rfe,
  hyphenate: Jde,
  getBaseElem: yz,
  isCharacterBox: nfe,
  protocolFromUrl: afe
}, Z0 = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: !0,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
    cliProcessor: (t) => "#" + t
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (t, e) => (e.push(t), e)
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: (t) => Math.max(0, t),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: !1
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: 1 / 0,
    description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
    processor: (t) => Math.max(0, t),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1e3,
    description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
    processor: (t) => Math.max(0, t),
    cli: "-e, --max-expand <n>",
    cliProcessor: (t) => t === "Infinity" ? 1 / 0 : parseInt(t)
  },
  globalGroup: {
    type: "boolean",
    cli: !1
  }
};
function sfe(t) {
  if (t.default)
    return t.default;
  var e = t.type, r = Array.isArray(e) ? e[0] : e;
  if (typeof r != "string")
    return r.enum[0];
  switch (r) {
    case "boolean":
      return !1;
    case "string":
      return "";
    case "number":
      return 0;
    case "object":
      return {};
  }
}
class dk {
  constructor(e) {
    this.displayMode = void 0, this.output = void 0, this.leqno = void 0, this.fleqn = void 0, this.throwOnError = void 0, this.errorColor = void 0, this.macros = void 0, this.minRuleThickness = void 0, this.colorIsTextColor = void 0, this.strict = void 0, this.trust = void 0, this.maxSize = void 0, this.maxExpand = void 0, this.globalGroup = void 0, e = e || {};
    for (var r in Z0)
      if (Z0.hasOwnProperty(r)) {
        var n = Z0[r];
        this[r] = e[r] !== void 0 ? n.processor ? n.processor(e[r]) : e[r] : sfe(n);
      }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */
  reportNonstrict(e, r, n) {
    var i = this.strict;
    if (typeof i == "function" && (i = i(e, r, n)), !(!i || i === "ignore")) {
      if (i === !0 || i === "error")
        throw new ot("LaTeX-incompatible input and strict mode is set to 'error': " + (r + " [" + e + "]"), n);
      i === "warn" ? typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (r + " [" + e + "]")) : typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + r + " [" + e + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  useStrictBehavior(e, r, n) {
    var i = this.strict;
    if (typeof i == "function")
      try {
        i = i(e, r, n);
      } catch {
        i = "error";
      }
    return !i || i === "ignore" ? !1 : i === !0 || i === "error" ? !0 : i === "warn" ? (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (r + " [" + e + "]")), !1) : (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + r + " [" + e + "]")), !1);
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(e) {
    if (e.url && !e.protocol) {
      var r = Tr.protocolFromUrl(e.url);
      if (r == null)
        return !1;
      e.protocol = r;
    }
    var n = typeof this.trust == "function" ? this.trust(e) : this.trust;
    return !!n;
  }
}
class bl {
  constructor(e, r, n) {
    this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = e, this.size = r, this.cramped = n;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return qs[ofe[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return qs[lfe[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return qs[cfe[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return qs[ufe[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return qs[hfe[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return qs[dfe[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
}
var fk = 0, gy = 1, Jh = 2, Wo = 3, _p = 4, Ya = 5, Cd = 6, $i = 7, qs = [new bl(fk, 0, !1), new bl(gy, 0, !0), new bl(Jh, 1, !1), new bl(Wo, 1, !0), new bl(_p, 2, !1), new bl(Ya, 2, !0), new bl(Cd, 3, !1), new bl($i, 3, !0)], ofe = [_p, Ya, _p, Ya, Cd, $i, Cd, $i], lfe = [Ya, Ya, Ya, Ya, $i, $i, $i, $i], cfe = [Jh, Wo, _p, Ya, Cd, $i, Cd, $i], ufe = [Wo, Wo, Ya, Ya, $i, $i, $i, $i], hfe = [gy, gy, Wo, Wo, Ya, Ya, $i, $i], dfe = [fk, gy, Jh, Wo, Jh, Wo, Jh, Wo], zt = {
  DISPLAY: qs[fk],
  TEXT: qs[Jh],
  SCRIPT: qs[_p],
  SCRIPTSCRIPT: qs[Cd]
}, tT = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900097F)
  // Bengali (098009FF)
  // Gurmukhi (0A000A7F)
  // Gujarati (0A800AFF)
  // Oriya (0B000B7F)
  // Tamil (0B800BFF)
  // Telugu (0C000C7F)
  // Kannada (0C800CFF)
  // Malayalam (0D000D7F)
  // Sinhala (0D800DFF)
  // Thai (0E000E7F)
  // Lao (0E800EFF)
  // Tibetan (0F000FFF)
  // Myanmar (1000109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function ffe(t) {
  for (var e = 0; e < tT.length; e++)
    for (var r = tT[e], n = 0; n < r.blocks.length; n++) {
      var i = r.blocks[n];
      if (t >= i[0] && t <= i[1])
        return r.name;
    }
  return null;
}
var Nm = [];
tT.forEach((t) => t.blocks.forEach((e) => Nm.push(...e)));
function xz(t) {
  for (var e = 0; e < Nm.length; e += 2)
    if (t >= Nm[e] && t <= Nm[e + 1])
      return !0;
  return !1;
}
var vh = 80, pfe = function(e, r) {
  return "M95," + (622 + e + r) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + e / 2.075 + " -" + e + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + e) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + e) + " " + r + "h400000v" + (40 + e) + "h-400000z";
}, gfe = function(e, r) {
  return "M263," + (601 + e + r) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + e / 2.084 + " -" + e + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + e) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + e) + " " + r + "h400000v" + (40 + e) + "h-400000z";
}, mfe = function(e, r) {
  return "M983 " + (10 + e + r) + `
l` + e / 3.13 + " -" + e + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + e) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + e) + " " + r + "h400000v" + (40 + e) + "h-400000z";
}, vfe = function(e, r) {
  return "M424," + (2398 + e + r) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + e / 4.223 + " -" + e + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + e) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + e) + " " + r + `
h400000v` + (40 + e) + "h-400000z";
}, yfe = function(e, r) {
  return "M473," + (2713 + e + r) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + e / 5.298 + " -" + e + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + e) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + e) + " " + r + "h400000v" + (40 + e) + "H1017.7z";
}, xfe = function(e) {
  var r = e / 2;
  return "M400000 " + e + " H0 L" + r + " 0 l65 45 L145 " + (e - 80) + " H400000z";
}, bfe = function(e, r, n) {
  var i = n - 54 - r - e;
  return "M702 " + (e + r) + "H400000" + (40 + e) + `
H742v` + i + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + r + "H400000v" + (40 + e) + "H742z";
}, wfe = function(e, r, n) {
  r = 1e3 * r;
  var i = "";
  switch (e) {
    case "sqrtMain":
      i = pfe(r, vh);
      break;
    case "sqrtSize1":
      i = gfe(r, vh);
      break;
    case "sqrtSize2":
      i = mfe(r, vh);
      break;
    case "sqrtSize3":
      i = vfe(r, vh);
      break;
    case "sqrtSize4":
      i = yfe(r, vh);
      break;
    case "sqrtTall":
      i = bfe(r, vh, n);
  }
  return i;
}, Tfe = function(e, r) {
  switch (e) {
    case "":
      return "M291 0 H417 V" + r + " H291z M291 0 H417 V" + r + " H291z";
    case "":
      return "M145 0 H188 V" + r + " H145z M145 0 H188 V" + r + " H145z";
    case "":
      return "M145 0 H188 V" + r + " H145z M145 0 H188 V" + r + " H145z" + ("M367 0 H410 V" + r + " H367z M367 0 H410 V" + r + " H367z");
    case "":
      return "M457 0 H583 V" + r + " H457z M457 0 H583 V" + r + " H457z";
    case "":
      return "M319 0 H403 V" + r + " H319z M319 0 H403 V" + r + " H319z";
    case "":
      return "M263 0 H347 V" + r + " H263z M263 0 H347 V" + r + " H263z";
    case "":
      return "M384 0 H504 V" + r + " H384z M384 0 H504 V" + r + " H384z";
    case "":
      return "M312 0 H355 V" + r + " H312z M312 0 H355 V" + r + " H312z";
    case "":
      return "M257 0 H300 V" + r + " H257z M257 0 H300 V" + r + " H257z" + ("M478 0 H521 V" + r + " H478z M478 0 H521 V" + r + " H478z");
    default:
      return "";
  }
}, j8 = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
  leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
  leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
  leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
  leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
  leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
  leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
  leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
  longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
  midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
  midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
  oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
  oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
  oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
  oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
  rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
  rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
  rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
  rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
  rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
  rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
  rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
  rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
  rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
  righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
  rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
  rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
  twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
  // ditto tilde2, tilde3, & tilde4
  tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
  tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
  tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
  // ditto widehat2, widehat3, & widehat4
  widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  // widecheck paths are all inverted versions of widehat
  widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
  widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
  rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
  shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
  shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
}, Efe = function(e, r) {
  switch (e) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + r + ` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` + r + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + r + ` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` + r + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + r + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -r + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + r + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + r + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -r + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + r + ` v585 h43z
M367 15 v585 v` + r + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -r + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` + r + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + r + ` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` + r + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + r + ` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` + r + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + r + ` v602 h84z
M403 1759 V0 H319 V1759 v` + r + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + r + ` v602 h84z
M347 1759 V0 h-84 V1759 v` + r + " v602 h84z";
    case "lparen":
      return `M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` + (r + 84) + `c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` + (r + 92) + `c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`;
    case "rparen":
      return `M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` + (r + 9) + `
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` + (r + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
class vg {
  // Never used; needed for satisfying interface.
  constructor(e) {
    this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = e, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {};
  }
  hasClass(e) {
    return this.classes.includes(e);
  }
  /** Convert the fragment into a node. */
  toNode() {
    for (var e = document.createDocumentFragment(), r = 0; r < this.children.length; r++)
      e.appendChild(this.children[r].toNode());
    return e;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    for (var e = "", r = 0; r < this.children.length; r++)
      e += this.children[r].toMarkup();
    return e;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var e = (r) => r.toText();
    return this.children.map(e).join("");
  }
}
var Ys = {
  "AMS-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68889, 0, 0, 0.72222],
    66: [0, 0.68889, 0, 0, 0.66667],
    67: [0, 0.68889, 0, 0, 0.72222],
    68: [0, 0.68889, 0, 0, 0.72222],
    69: [0, 0.68889, 0, 0, 0.66667],
    70: [0, 0.68889, 0, 0, 0.61111],
    71: [0, 0.68889, 0, 0, 0.77778],
    72: [0, 0.68889, 0, 0, 0.77778],
    73: [0, 0.68889, 0, 0, 0.38889],
    74: [0.16667, 0.68889, 0, 0, 0.5],
    75: [0, 0.68889, 0, 0, 0.77778],
    76: [0, 0.68889, 0, 0, 0.66667],
    77: [0, 0.68889, 0, 0, 0.94445],
    78: [0, 0.68889, 0, 0, 0.72222],
    79: [0.16667, 0.68889, 0, 0, 0.77778],
    80: [0, 0.68889, 0, 0, 0.61111],
    81: [0.16667, 0.68889, 0, 0, 0.77778],
    82: [0, 0.68889, 0, 0, 0.72222],
    83: [0, 0.68889, 0, 0, 0.55556],
    84: [0, 0.68889, 0, 0, 0.66667],
    85: [0, 0.68889, 0, 0, 0.72222],
    86: [0, 0.68889, 0, 0, 0.72222],
    87: [0, 0.68889, 0, 0, 1],
    88: [0, 0.68889, 0, 0, 0.72222],
    89: [0, 0.68889, 0, 0, 0.72222],
    90: [0, 0.68889, 0, 0, 0.66667],
    107: [0, 0.68889, 0, 0, 0.55556],
    160: [0, 0, 0, 0, 0.25],
    165: [0, 0.675, 0.025, 0, 0.75],
    174: [0.15559, 0.69224, 0, 0, 0.94666],
    240: [0, 0.68889, 0, 0, 0.55556],
    295: [0, 0.68889, 0, 0, 0.54028],
    710: [0, 0.825, 0, 0, 2.33334],
    732: [0, 0.9, 0, 0, 2.33334],
    770: [0, 0.825, 0, 0, 2.33334],
    771: [0, 0.9, 0, 0, 2.33334],
    989: [0.08167, 0.58167, 0, 0, 0.77778],
    1008: [0, 0.43056, 0.04028, 0, 0.66667],
    8245: [0, 0.54986, 0, 0, 0.275],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8487: [0, 0.68889, 0, 0, 0.72222],
    8498: [0, 0.68889, 0, 0, 0.55556],
    8502: [0, 0.68889, 0, 0, 0.66667],
    8503: [0, 0.68889, 0, 0, 0.44445],
    8504: [0, 0.68889, 0, 0, 0.66667],
    8513: [0, 0.68889, 0, 0, 0.63889],
    8592: [-0.03598, 0.46402, 0, 0, 0.5],
    8594: [-0.03598, 0.46402, 0, 0, 0.5],
    8602: [-0.13313, 0.36687, 0, 0, 1],
    8603: [-0.13313, 0.36687, 0, 0, 1],
    8606: [0.01354, 0.52239, 0, 0, 1],
    8608: [0.01354, 0.52239, 0, 0, 1],
    8610: [0.01354, 0.52239, 0, 0, 1.11111],
    8611: [0.01354, 0.52239, 0, 0, 1.11111],
    8619: [0, 0.54986, 0, 0, 1],
    8620: [0, 0.54986, 0, 0, 1],
    8621: [-0.13313, 0.37788, 0, 0, 1.38889],
    8622: [-0.13313, 0.36687, 0, 0, 1],
    8624: [0, 0.69224, 0, 0, 0.5],
    8625: [0, 0.69224, 0, 0, 0.5],
    8630: [0, 0.43056, 0, 0, 1],
    8631: [0, 0.43056, 0, 0, 1],
    8634: [0.08198, 0.58198, 0, 0, 0.77778],
    8635: [0.08198, 0.58198, 0, 0, 0.77778],
    8638: [0.19444, 0.69224, 0, 0, 0.41667],
    8639: [0.19444, 0.69224, 0, 0, 0.41667],
    8642: [0.19444, 0.69224, 0, 0, 0.41667],
    8643: [0.19444, 0.69224, 0, 0, 0.41667],
    8644: [0.1808, 0.675, 0, 0, 1],
    8646: [0.1808, 0.675, 0, 0, 1],
    8647: [0.1808, 0.675, 0, 0, 1],
    8648: [0.19444, 0.69224, 0, 0, 0.83334],
    8649: [0.1808, 0.675, 0, 0, 1],
    8650: [0.19444, 0.69224, 0, 0, 0.83334],
    8651: [0.01354, 0.52239, 0, 0, 1],
    8652: [0.01354, 0.52239, 0, 0, 1],
    8653: [-0.13313, 0.36687, 0, 0, 1],
    8654: [-0.13313, 0.36687, 0, 0, 1],
    8655: [-0.13313, 0.36687, 0, 0, 1],
    8666: [0.13667, 0.63667, 0, 0, 1],
    8667: [0.13667, 0.63667, 0, 0, 1],
    8669: [-0.13313, 0.37788, 0, 0, 1],
    8672: [-0.064, 0.437, 0, 0, 1.334],
    8674: [-0.064, 0.437, 0, 0, 1.334],
    8705: [0, 0.825, 0, 0, 0.5],
    8708: [0, 0.68889, 0, 0, 0.55556],
    8709: [0.08167, 0.58167, 0, 0, 0.77778],
    8717: [0, 0.43056, 0, 0, 0.42917],
    8722: [-0.03598, 0.46402, 0, 0, 0.5],
    8724: [0.08198, 0.69224, 0, 0, 0.77778],
    8726: [0.08167, 0.58167, 0, 0, 0.77778],
    8733: [0, 0.69224, 0, 0, 0.77778],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8737: [0, 0.69224, 0, 0, 0.72222],
    8738: [0.03517, 0.52239, 0, 0, 0.72222],
    8739: [0.08167, 0.58167, 0, 0, 0.22222],
    8740: [0.25142, 0.74111, 0, 0, 0.27778],
    8741: [0.08167, 0.58167, 0, 0, 0.38889],
    8742: [0.25142, 0.74111, 0, 0, 0.5],
    8756: [0, 0.69224, 0, 0, 0.66667],
    8757: [0, 0.69224, 0, 0, 0.66667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8765: [-0.13313, 0.37788, 0, 0, 0.77778],
    8769: [-0.13313, 0.36687, 0, 0, 0.77778],
    8770: [-0.03625, 0.46375, 0, 0, 0.77778],
    8774: [0.30274, 0.79383, 0, 0, 0.77778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8778: [0.08167, 0.58167, 0, 0, 0.77778],
    8782: [0.06062, 0.54986, 0, 0, 0.77778],
    8783: [0.06062, 0.54986, 0, 0, 0.77778],
    8785: [0.08198, 0.58198, 0, 0, 0.77778],
    8786: [0.08198, 0.58198, 0, 0, 0.77778],
    8787: [0.08198, 0.58198, 0, 0, 0.77778],
    8790: [0, 0.69224, 0, 0, 0.77778],
    8791: [0.22958, 0.72958, 0, 0, 0.77778],
    8796: [0.08198, 0.91667, 0, 0, 0.77778],
    8806: [0.25583, 0.75583, 0, 0, 0.77778],
    8807: [0.25583, 0.75583, 0, 0, 0.77778],
    8808: [0.25142, 0.75726, 0, 0, 0.77778],
    8809: [0.25142, 0.75726, 0, 0, 0.77778],
    8812: [0.25583, 0.75583, 0, 0, 0.5],
    8814: [0.20576, 0.70576, 0, 0, 0.77778],
    8815: [0.20576, 0.70576, 0, 0, 0.77778],
    8816: [0.30274, 0.79383, 0, 0, 0.77778],
    8817: [0.30274, 0.79383, 0, 0, 0.77778],
    8818: [0.22958, 0.72958, 0, 0, 0.77778],
    8819: [0.22958, 0.72958, 0, 0, 0.77778],
    8822: [0.1808, 0.675, 0, 0, 0.77778],
    8823: [0.1808, 0.675, 0, 0, 0.77778],
    8828: [0.13667, 0.63667, 0, 0, 0.77778],
    8829: [0.13667, 0.63667, 0, 0, 0.77778],
    8830: [0.22958, 0.72958, 0, 0, 0.77778],
    8831: [0.22958, 0.72958, 0, 0, 0.77778],
    8832: [0.20576, 0.70576, 0, 0, 0.77778],
    8833: [0.20576, 0.70576, 0, 0, 0.77778],
    8840: [0.30274, 0.79383, 0, 0, 0.77778],
    8841: [0.30274, 0.79383, 0, 0, 0.77778],
    8842: [0.13597, 0.63597, 0, 0, 0.77778],
    8843: [0.13597, 0.63597, 0, 0, 0.77778],
    8847: [0.03517, 0.54986, 0, 0, 0.77778],
    8848: [0.03517, 0.54986, 0, 0, 0.77778],
    8858: [0.08198, 0.58198, 0, 0, 0.77778],
    8859: [0.08198, 0.58198, 0, 0, 0.77778],
    8861: [0.08198, 0.58198, 0, 0, 0.77778],
    8862: [0, 0.675, 0, 0, 0.77778],
    8863: [0, 0.675, 0, 0, 0.77778],
    8864: [0, 0.675, 0, 0, 0.77778],
    8865: [0, 0.675, 0, 0, 0.77778],
    8872: [0, 0.69224, 0, 0, 0.61111],
    8873: [0, 0.69224, 0, 0, 0.72222],
    8874: [0, 0.69224, 0, 0, 0.88889],
    8876: [0, 0.68889, 0, 0, 0.61111],
    8877: [0, 0.68889, 0, 0, 0.61111],
    8878: [0, 0.68889, 0, 0, 0.72222],
    8879: [0, 0.68889, 0, 0, 0.72222],
    8882: [0.03517, 0.54986, 0, 0, 0.77778],
    8883: [0.03517, 0.54986, 0, 0, 0.77778],
    8884: [0.13667, 0.63667, 0, 0, 0.77778],
    8885: [0.13667, 0.63667, 0, 0, 0.77778],
    8888: [0, 0.54986, 0, 0, 1.11111],
    8890: [0.19444, 0.43056, 0, 0, 0.55556],
    8891: [0.19444, 0.69224, 0, 0, 0.61111],
    8892: [0.19444, 0.69224, 0, 0, 0.61111],
    8901: [0, 0.54986, 0, 0, 0.27778],
    8903: [0.08167, 0.58167, 0, 0, 0.77778],
    8905: [0.08167, 0.58167, 0, 0, 0.77778],
    8906: [0.08167, 0.58167, 0, 0, 0.77778],
    8907: [0, 0.69224, 0, 0, 0.77778],
    8908: [0, 0.69224, 0, 0, 0.77778],
    8909: [-0.03598, 0.46402, 0, 0, 0.77778],
    8910: [0, 0.54986, 0, 0, 0.76042],
    8911: [0, 0.54986, 0, 0, 0.76042],
    8912: [0.03517, 0.54986, 0, 0, 0.77778],
    8913: [0.03517, 0.54986, 0, 0, 0.77778],
    8914: [0, 0.54986, 0, 0, 0.66667],
    8915: [0, 0.54986, 0, 0, 0.66667],
    8916: [0, 0.69224, 0, 0, 0.66667],
    8918: [0.0391, 0.5391, 0, 0, 0.77778],
    8919: [0.0391, 0.5391, 0, 0, 0.77778],
    8920: [0.03517, 0.54986, 0, 0, 1.33334],
    8921: [0.03517, 0.54986, 0, 0, 1.33334],
    8922: [0.38569, 0.88569, 0, 0, 0.77778],
    8923: [0.38569, 0.88569, 0, 0, 0.77778],
    8926: [0.13667, 0.63667, 0, 0, 0.77778],
    8927: [0.13667, 0.63667, 0, 0, 0.77778],
    8928: [0.30274, 0.79383, 0, 0, 0.77778],
    8929: [0.30274, 0.79383, 0, 0, 0.77778],
    8934: [0.23222, 0.74111, 0, 0, 0.77778],
    8935: [0.23222, 0.74111, 0, 0, 0.77778],
    8936: [0.23222, 0.74111, 0, 0, 0.77778],
    8937: [0.23222, 0.74111, 0, 0, 0.77778],
    8938: [0.20576, 0.70576, 0, 0, 0.77778],
    8939: [0.20576, 0.70576, 0, 0, 0.77778],
    8940: [0.30274, 0.79383, 0, 0, 0.77778],
    8941: [0.30274, 0.79383, 0, 0, 0.77778],
    8994: [0.19444, 0.69224, 0, 0, 0.77778],
    8995: [0.19444, 0.69224, 0, 0, 0.77778],
    9416: [0.15559, 0.69224, 0, 0, 0.90222],
    9484: [0, 0.69224, 0, 0, 0.5],
    9488: [0, 0.69224, 0, 0, 0.5],
    9492: [0, 0.37788, 0, 0, 0.5],
    9496: [0, 0.37788, 0, 0, 0.5],
    9585: [0.19444, 0.68889, 0, 0, 0.88889],
    9586: [0.19444, 0.74111, 0, 0, 0.88889],
    9632: [0, 0.675, 0, 0, 0.77778],
    9633: [0, 0.675, 0, 0, 0.77778],
    9650: [0, 0.54986, 0, 0, 0.72222],
    9651: [0, 0.54986, 0, 0, 0.72222],
    9654: [0.03517, 0.54986, 0, 0, 0.77778],
    9660: [0, 0.54986, 0, 0, 0.72222],
    9661: [0, 0.54986, 0, 0, 0.72222],
    9664: [0.03517, 0.54986, 0, 0, 0.77778],
    9674: [0.11111, 0.69224, 0, 0, 0.66667],
    9733: [0.19444, 0.69224, 0, 0, 0.94445],
    10003: [0, 0.69224, 0, 0, 0.83334],
    10016: [0, 0.69224, 0, 0, 0.83334],
    10731: [0.11111, 0.69224, 0, 0, 0.66667],
    10846: [0.19444, 0.75583, 0, 0, 0.61111],
    10877: [0.13667, 0.63667, 0, 0, 0.77778],
    10878: [0.13667, 0.63667, 0, 0, 0.77778],
    10885: [0.25583, 0.75583, 0, 0, 0.77778],
    10886: [0.25583, 0.75583, 0, 0, 0.77778],
    10887: [0.13597, 0.63597, 0, 0, 0.77778],
    10888: [0.13597, 0.63597, 0, 0, 0.77778],
    10889: [0.26167, 0.75726, 0, 0, 0.77778],
    10890: [0.26167, 0.75726, 0, 0, 0.77778],
    10891: [0.48256, 0.98256, 0, 0, 0.77778],
    10892: [0.48256, 0.98256, 0, 0, 0.77778],
    10901: [0.13667, 0.63667, 0, 0, 0.77778],
    10902: [0.13667, 0.63667, 0, 0, 0.77778],
    10933: [0.25142, 0.75726, 0, 0, 0.77778],
    10934: [0.25142, 0.75726, 0, 0, 0.77778],
    10935: [0.26167, 0.75726, 0, 0, 0.77778],
    10936: [0.26167, 0.75726, 0, 0, 0.77778],
    10937: [0.26167, 0.75726, 0, 0, 0.77778],
    10938: [0.26167, 0.75726, 0, 0, 0.77778],
    10949: [0.25583, 0.75583, 0, 0, 0.77778],
    10950: [0.25583, 0.75583, 0, 0, 0.77778],
    10955: [0.28481, 0.79383, 0, 0, 0.77778],
    10956: [0.28481, 0.79383, 0, 0, 0.77778],
    57350: [0.08167, 0.58167, 0, 0, 0.22222],
    57351: [0.08167, 0.58167, 0, 0, 0.38889],
    57352: [0.08167, 0.58167, 0, 0, 0.77778],
    57353: [0, 0.43056, 0.04028, 0, 0.66667],
    57356: [0.25142, 0.75726, 0, 0, 0.77778],
    57357: [0.25142, 0.75726, 0, 0, 0.77778],
    57358: [0.41951, 0.91951, 0, 0, 0.77778],
    57359: [0.30274, 0.79383, 0, 0, 0.77778],
    57360: [0.30274, 0.79383, 0, 0, 0.77778],
    57361: [0.41951, 0.91951, 0, 0, 0.77778],
    57366: [0.25142, 0.75726, 0, 0, 0.77778],
    57367: [0.25142, 0.75726, 0, 0, 0.77778],
    57368: [0.25142, 0.75726, 0, 0, 0.77778],
    57369: [0.25142, 0.75726, 0, 0, 0.77778],
    57370: [0.13597, 0.63597, 0, 0, 0.77778],
    57371: [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68333, 0, 0.19445, 0.79847],
    66: [0, 0.68333, 0.03041, 0.13889, 0.65681],
    67: [0, 0.68333, 0.05834, 0.13889, 0.52653],
    68: [0, 0.68333, 0.02778, 0.08334, 0.77139],
    69: [0, 0.68333, 0.08944, 0.11111, 0.52778],
    70: [0, 0.68333, 0.09931, 0.11111, 0.71875],
    71: [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    72: [0, 0.68333, 965e-5, 0.11111, 0.84452],
    73: [0, 0.68333, 0.07382, 0, 0.54452],
    74: [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    75: [0, 0.68333, 0.01445, 0.05556, 0.76195],
    76: [0, 0.68333, 0, 0.13889, 0.68972],
    77: [0, 0.68333, 0, 0.13889, 1.2009],
    78: [0, 0.68333, 0.14736, 0.08334, 0.82049],
    79: [0, 0.68333, 0.02778, 0.11111, 0.79611],
    80: [0, 0.68333, 0.08222, 0.08334, 0.69556],
    81: [0.09722, 0.68333, 0, 0.11111, 0.81667],
    82: [0, 0.68333, 0, 0.08334, 0.8475],
    83: [0, 0.68333, 0.075, 0.13889, 0.60556],
    84: [0, 0.68333, 0.25417, 0, 0.54464],
    85: [0, 0.68333, 0.09931, 0.08334, 0.62583],
    86: [0, 0.68333, 0.08222, 0, 0.61278],
    87: [0, 0.68333, 0.08222, 0.08334, 0.98778],
    88: [0, 0.68333, 0.14643, 0.13889, 0.7133],
    89: [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    90: [0, 0.68333, 0.07944, 0.13889, 0.72473],
    160: [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69141, 0, 0, 0.29574],
    34: [0, 0.69141, 0, 0, 0.21471],
    38: [0, 0.69141, 0, 0, 0.73786],
    39: [0, 0.69141, 0, 0, 0.21201],
    40: [0.24982, 0.74947, 0, 0, 0.38865],
    41: [0.24982, 0.74947, 0, 0, 0.38865],
    42: [0, 0.62119, 0, 0, 0.27764],
    43: [0.08319, 0.58283, 0, 0, 0.75623],
    44: [0, 0.10803, 0, 0, 0.27764],
    45: [0.08319, 0.58283, 0, 0, 0.75623],
    46: [0, 0.10803, 0, 0, 0.27764],
    47: [0.24982, 0.74947, 0, 0, 0.50181],
    48: [0, 0.47534, 0, 0, 0.50181],
    49: [0, 0.47534, 0, 0, 0.50181],
    50: [0, 0.47534, 0, 0, 0.50181],
    51: [0.18906, 0.47534, 0, 0, 0.50181],
    52: [0.18906, 0.47534, 0, 0, 0.50181],
    53: [0.18906, 0.47534, 0, 0, 0.50181],
    54: [0, 0.69141, 0, 0, 0.50181],
    55: [0.18906, 0.47534, 0, 0, 0.50181],
    56: [0, 0.69141, 0, 0, 0.50181],
    57: [0.18906, 0.47534, 0, 0, 0.50181],
    58: [0, 0.47534, 0, 0, 0.21606],
    59: [0.12604, 0.47534, 0, 0, 0.21606],
    61: [-0.13099, 0.36866, 0, 0, 0.75623],
    63: [0, 0.69141, 0, 0, 0.36245],
    65: [0, 0.69141, 0, 0, 0.7176],
    66: [0, 0.69141, 0, 0, 0.88397],
    67: [0, 0.69141, 0, 0, 0.61254],
    68: [0, 0.69141, 0, 0, 0.83158],
    69: [0, 0.69141, 0, 0, 0.66278],
    70: [0.12604, 0.69141, 0, 0, 0.61119],
    71: [0, 0.69141, 0, 0, 0.78539],
    72: [0.06302, 0.69141, 0, 0, 0.7203],
    73: [0, 0.69141, 0, 0, 0.55448],
    74: [0.12604, 0.69141, 0, 0, 0.55231],
    75: [0, 0.69141, 0, 0, 0.66845],
    76: [0, 0.69141, 0, 0, 0.66602],
    77: [0, 0.69141, 0, 0, 1.04953],
    78: [0, 0.69141, 0, 0, 0.83212],
    79: [0, 0.69141, 0, 0, 0.82699],
    80: [0.18906, 0.69141, 0, 0, 0.82753],
    81: [0.03781, 0.69141, 0, 0, 0.82699],
    82: [0, 0.69141, 0, 0, 0.82807],
    83: [0, 0.69141, 0, 0, 0.82861],
    84: [0, 0.69141, 0, 0, 0.66899],
    85: [0, 0.69141, 0, 0, 0.64576],
    86: [0, 0.69141, 0, 0, 0.83131],
    87: [0, 0.69141, 0, 0, 1.04602],
    88: [0, 0.69141, 0, 0, 0.71922],
    89: [0.18906, 0.69141, 0, 0, 0.83293],
    90: [0.12604, 0.69141, 0, 0, 0.60201],
    91: [0.24982, 0.74947, 0, 0, 0.27764],
    93: [0.24982, 0.74947, 0, 0, 0.27764],
    94: [0, 0.69141, 0, 0, 0.49965],
    97: [0, 0.47534, 0, 0, 0.50046],
    98: [0, 0.69141, 0, 0, 0.51315],
    99: [0, 0.47534, 0, 0, 0.38946],
    100: [0, 0.62119, 0, 0, 0.49857],
    101: [0, 0.47534, 0, 0, 0.40053],
    102: [0.18906, 0.69141, 0, 0, 0.32626],
    103: [0.18906, 0.47534, 0, 0, 0.5037],
    104: [0.18906, 0.69141, 0, 0, 0.52126],
    105: [0, 0.69141, 0, 0, 0.27899],
    106: [0, 0.69141, 0, 0, 0.28088],
    107: [0, 0.69141, 0, 0, 0.38946],
    108: [0, 0.69141, 0, 0, 0.27953],
    109: [0, 0.47534, 0, 0, 0.76676],
    110: [0, 0.47534, 0, 0, 0.52666],
    111: [0, 0.47534, 0, 0, 0.48885],
    112: [0.18906, 0.52396, 0, 0, 0.50046],
    113: [0.18906, 0.47534, 0, 0, 0.48912],
    114: [0, 0.47534, 0, 0, 0.38919],
    115: [0, 0.47534, 0, 0, 0.44266],
    116: [0, 0.62119, 0, 0, 0.33301],
    117: [0, 0.47534, 0, 0, 0.5172],
    118: [0, 0.52396, 0, 0, 0.5118],
    119: [0, 0.52396, 0, 0, 0.77351],
    120: [0.18906, 0.47534, 0, 0, 0.38865],
    121: [0.18906, 0.47534, 0, 0, 0.49884],
    122: [0.18906, 0.47534, 0, 0, 0.39054],
    160: [0, 0, 0, 0, 0.25],
    8216: [0, 0.69141, 0, 0, 0.21471],
    8217: [0, 0.69141, 0, 0, 0.21471],
    58112: [0, 0.62119, 0, 0, 0.49749],
    58113: [0, 0.62119, 0, 0, 0.4983],
    58114: [0.18906, 0.69141, 0, 0, 0.33328],
    58115: [0.18906, 0.69141, 0, 0, 0.32923],
    58116: [0.18906, 0.47534, 0, 0, 0.50343],
    58117: [0, 0.69141, 0, 0, 0.33301],
    58118: [0, 0.62119, 0, 0, 0.33409],
    58119: [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.35],
    34: [0, 0.69444, 0, 0, 0.60278],
    35: [0.19444, 0.69444, 0, 0, 0.95833],
    36: [0.05556, 0.75, 0, 0, 0.575],
    37: [0.05556, 0.75, 0, 0, 0.95833],
    38: [0, 0.69444, 0, 0, 0.89444],
    39: [0, 0.69444, 0, 0, 0.31944],
    40: [0.25, 0.75, 0, 0, 0.44722],
    41: [0.25, 0.75, 0, 0, 0.44722],
    42: [0, 0.75, 0, 0, 0.575],
    43: [0.13333, 0.63333, 0, 0, 0.89444],
    44: [0.19444, 0.15556, 0, 0, 0.31944],
    45: [0, 0.44444, 0, 0, 0.38333],
    46: [0, 0.15556, 0, 0, 0.31944],
    47: [0.25, 0.75, 0, 0, 0.575],
    48: [0, 0.64444, 0, 0, 0.575],
    49: [0, 0.64444, 0, 0, 0.575],
    50: [0, 0.64444, 0, 0, 0.575],
    51: [0, 0.64444, 0, 0, 0.575],
    52: [0, 0.64444, 0, 0, 0.575],
    53: [0, 0.64444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0, 0.64444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0, 0.64444, 0, 0, 0.575],
    58: [0, 0.44444, 0, 0, 0.31944],
    59: [0.19444, 0.44444, 0, 0, 0.31944],
    60: [0.08556, 0.58556, 0, 0, 0.89444],
    61: [-0.10889, 0.39111, 0, 0, 0.89444],
    62: [0.08556, 0.58556, 0, 0, 0.89444],
    63: [0, 0.69444, 0, 0, 0.54305],
    64: [0, 0.69444, 0, 0, 0.89444],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0, 0, 0.81805],
    67: [0, 0.68611, 0, 0, 0.83055],
    68: [0, 0.68611, 0, 0, 0.88194],
    69: [0, 0.68611, 0, 0, 0.75555],
    70: [0, 0.68611, 0, 0, 0.72361],
    71: [0, 0.68611, 0, 0, 0.90416],
    72: [0, 0.68611, 0, 0, 0.9],
    73: [0, 0.68611, 0, 0, 0.43611],
    74: [0, 0.68611, 0, 0, 0.59444],
    75: [0, 0.68611, 0, 0, 0.90138],
    76: [0, 0.68611, 0, 0, 0.69166],
    77: [0, 0.68611, 0, 0, 1.09166],
    78: [0, 0.68611, 0, 0, 0.9],
    79: [0, 0.68611, 0, 0, 0.86388],
    80: [0, 0.68611, 0, 0, 0.78611],
    81: [0.19444, 0.68611, 0, 0, 0.86388],
    82: [0, 0.68611, 0, 0, 0.8625],
    83: [0, 0.68611, 0, 0, 0.63889],
    84: [0, 0.68611, 0, 0, 0.8],
    85: [0, 0.68611, 0, 0, 0.88472],
    86: [0, 0.68611, 0.01597, 0, 0.86944],
    87: [0, 0.68611, 0.01597, 0, 1.18888],
    88: [0, 0.68611, 0, 0, 0.86944],
    89: [0, 0.68611, 0.02875, 0, 0.86944],
    90: [0, 0.68611, 0, 0, 0.70277],
    91: [0.25, 0.75, 0, 0, 0.31944],
    92: [0.25, 0.75, 0, 0, 0.575],
    93: [0.25, 0.75, 0, 0, 0.31944],
    94: [0, 0.69444, 0, 0, 0.575],
    95: [0.31, 0.13444, 0.03194, 0, 0.575],
    97: [0, 0.44444, 0, 0, 0.55902],
    98: [0, 0.69444, 0, 0, 0.63889],
    99: [0, 0.44444, 0, 0, 0.51111],
    100: [0, 0.69444, 0, 0, 0.63889],
    101: [0, 0.44444, 0, 0, 0.52708],
    102: [0, 0.69444, 0.10903, 0, 0.35139],
    103: [0.19444, 0.44444, 0.01597, 0, 0.575],
    104: [0, 0.69444, 0, 0, 0.63889],
    105: [0, 0.69444, 0, 0, 0.31944],
    106: [0.19444, 0.69444, 0, 0, 0.35139],
    107: [0, 0.69444, 0, 0, 0.60694],
    108: [0, 0.69444, 0, 0, 0.31944],
    109: [0, 0.44444, 0, 0, 0.95833],
    110: [0, 0.44444, 0, 0, 0.63889],
    111: [0, 0.44444, 0, 0, 0.575],
    112: [0.19444, 0.44444, 0, 0, 0.63889],
    113: [0.19444, 0.44444, 0, 0, 0.60694],
    114: [0, 0.44444, 0, 0, 0.47361],
    115: [0, 0.44444, 0, 0, 0.45361],
    116: [0, 0.63492, 0, 0, 0.44722],
    117: [0, 0.44444, 0, 0, 0.63889],
    118: [0, 0.44444, 0.01597, 0, 0.60694],
    119: [0, 0.44444, 0.01597, 0, 0.83055],
    120: [0, 0.44444, 0, 0, 0.60694],
    121: [0.19444, 0.44444, 0.01597, 0, 0.60694],
    122: [0, 0.44444, 0, 0, 0.51111],
    123: [0.25, 0.75, 0, 0, 0.575],
    124: [0.25, 0.75, 0, 0, 0.31944],
    125: [0.25, 0.75, 0, 0, 0.575],
    126: [0.35, 0.34444, 0, 0, 0.575],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.86853],
    168: [0, 0.69444, 0, 0, 0.575],
    172: [0, 0.44444, 0, 0, 0.76666],
    176: [0, 0.69444, 0, 0, 0.86944],
    177: [0.13333, 0.63333, 0, 0, 0.89444],
    184: [0.17014, 0, 0, 0, 0.51111],
    198: [0, 0.68611, 0, 0, 1.04166],
    215: [0.13333, 0.63333, 0, 0, 0.89444],
    216: [0.04861, 0.73472, 0, 0, 0.89444],
    223: [0, 0.69444, 0, 0, 0.59722],
    230: [0, 0.44444, 0, 0, 0.83055],
    247: [0.13333, 0.63333, 0, 0, 0.89444],
    248: [0.09722, 0.54167, 0, 0, 0.575],
    305: [0, 0.44444, 0, 0, 0.31944],
    338: [0, 0.68611, 0, 0, 1.16944],
    339: [0, 0.44444, 0, 0, 0.89444],
    567: [0.19444, 0.44444, 0, 0, 0.35139],
    710: [0, 0.69444, 0, 0, 0.575],
    711: [0, 0.63194, 0, 0, 0.575],
    713: [0, 0.59611, 0, 0, 0.575],
    714: [0, 0.69444, 0, 0, 0.575],
    715: [0, 0.69444, 0, 0, 0.575],
    728: [0, 0.69444, 0, 0, 0.575],
    729: [0, 0.69444, 0, 0, 0.31944],
    730: [0, 0.69444, 0, 0, 0.86944],
    732: [0, 0.69444, 0, 0, 0.575],
    733: [0, 0.69444, 0, 0, 0.575],
    915: [0, 0.68611, 0, 0, 0.69166],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0, 0, 0.89444],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0, 0, 0.76666],
    928: [0, 0.68611, 0, 0, 0.9],
    931: [0, 0.68611, 0, 0, 0.83055],
    933: [0, 0.68611, 0, 0, 0.89444],
    934: [0, 0.68611, 0, 0, 0.83055],
    936: [0, 0.68611, 0, 0, 0.89444],
    937: [0, 0.68611, 0, 0, 0.83055],
    8211: [0, 0.44444, 0.03194, 0, 0.575],
    8212: [0, 0.44444, 0.03194, 0, 1.14999],
    8216: [0, 0.69444, 0, 0, 0.31944],
    8217: [0, 0.69444, 0, 0, 0.31944],
    8220: [0, 0.69444, 0, 0, 0.60278],
    8221: [0, 0.69444, 0, 0, 0.60278],
    8224: [0.19444, 0.69444, 0, 0, 0.51111],
    8225: [0.19444, 0.69444, 0, 0, 0.51111],
    8242: [0, 0.55556, 0, 0, 0.34444],
    8407: [0, 0.72444, 0.15486, 0, 0.575],
    8463: [0, 0.69444, 0, 0, 0.66759],
    8465: [0, 0.69444, 0, 0, 0.83055],
    8467: [0, 0.69444, 0, 0, 0.47361],
    8472: [0.19444, 0.44444, 0, 0, 0.74027],
    8476: [0, 0.69444, 0, 0, 0.83055],
    8501: [0, 0.69444, 0, 0, 0.70277],
    8592: [-0.10889, 0.39111, 0, 0, 1.14999],
    8593: [0.19444, 0.69444, 0, 0, 0.575],
    8594: [-0.10889, 0.39111, 0, 0, 1.14999],
    8595: [0.19444, 0.69444, 0, 0, 0.575],
    8596: [-0.10889, 0.39111, 0, 0, 1.14999],
    8597: [0.25, 0.75, 0, 0, 0.575],
    8598: [0.19444, 0.69444, 0, 0, 1.14999],
    8599: [0.19444, 0.69444, 0, 0, 1.14999],
    8600: [0.19444, 0.69444, 0, 0, 1.14999],
    8601: [0.19444, 0.69444, 0, 0, 1.14999],
    8636: [-0.10889, 0.39111, 0, 0, 1.14999],
    8637: [-0.10889, 0.39111, 0, 0, 1.14999],
    8640: [-0.10889, 0.39111, 0, 0, 1.14999],
    8641: [-0.10889, 0.39111, 0, 0, 1.14999],
    8656: [-0.10889, 0.39111, 0, 0, 1.14999],
    8657: [0.19444, 0.69444, 0, 0, 0.70277],
    8658: [-0.10889, 0.39111, 0, 0, 1.14999],
    8659: [0.19444, 0.69444, 0, 0, 0.70277],
    8660: [-0.10889, 0.39111, 0, 0, 1.14999],
    8661: [0.25, 0.75, 0, 0, 0.70277],
    8704: [0, 0.69444, 0, 0, 0.63889],
    8706: [0, 0.69444, 0.06389, 0, 0.62847],
    8707: [0, 0.69444, 0, 0, 0.63889],
    8709: [0.05556, 0.75, 0, 0, 0.575],
    8711: [0, 0.68611, 0, 0, 0.95833],
    8712: [0.08556, 0.58556, 0, 0, 0.76666],
    8715: [0.08556, 0.58556, 0, 0, 0.76666],
    8722: [0.13333, 0.63333, 0, 0, 0.89444],
    8723: [0.13333, 0.63333, 0, 0, 0.89444],
    8725: [0.25, 0.75, 0, 0, 0.575],
    8726: [0.25, 0.75, 0, 0, 0.575],
    8727: [-0.02778, 0.47222, 0, 0, 0.575],
    8728: [-0.02639, 0.47361, 0, 0, 0.575],
    8729: [-0.02639, 0.47361, 0, 0, 0.575],
    8730: [0.18, 0.82, 0, 0, 0.95833],
    8733: [0, 0.44444, 0, 0, 0.89444],
    8734: [0, 0.44444, 0, 0, 1.14999],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.31944],
    8741: [0.25, 0.75, 0, 0, 0.575],
    8743: [0, 0.55556, 0, 0, 0.76666],
    8744: [0, 0.55556, 0, 0, 0.76666],
    8745: [0, 0.55556, 0, 0, 0.76666],
    8746: [0, 0.55556, 0, 0, 0.76666],
    8747: [0.19444, 0.69444, 0.12778, 0, 0.56875],
    8764: [-0.10889, 0.39111, 0, 0, 0.89444],
    8768: [0.19444, 0.69444, 0, 0, 0.31944],
    8771: [222e-5, 0.50222, 0, 0, 0.89444],
    8773: [0.027, 0.638, 0, 0, 0.894],
    8776: [0.02444, 0.52444, 0, 0, 0.89444],
    8781: [222e-5, 0.50222, 0, 0, 0.89444],
    8801: [222e-5, 0.50222, 0, 0, 0.89444],
    8804: [0.19667, 0.69667, 0, 0, 0.89444],
    8805: [0.19667, 0.69667, 0, 0, 0.89444],
    8810: [0.08556, 0.58556, 0, 0, 1.14999],
    8811: [0.08556, 0.58556, 0, 0, 1.14999],
    8826: [0.08556, 0.58556, 0, 0, 0.89444],
    8827: [0.08556, 0.58556, 0, 0, 0.89444],
    8834: [0.08556, 0.58556, 0, 0, 0.89444],
    8835: [0.08556, 0.58556, 0, 0, 0.89444],
    8838: [0.19667, 0.69667, 0, 0, 0.89444],
    8839: [0.19667, 0.69667, 0, 0, 0.89444],
    8846: [0, 0.55556, 0, 0, 0.76666],
    8849: [0.19667, 0.69667, 0, 0, 0.89444],
    8850: [0.19667, 0.69667, 0, 0, 0.89444],
    8851: [0, 0.55556, 0, 0, 0.76666],
    8852: [0, 0.55556, 0, 0, 0.76666],
    8853: [0.13333, 0.63333, 0, 0, 0.89444],
    8854: [0.13333, 0.63333, 0, 0, 0.89444],
    8855: [0.13333, 0.63333, 0, 0, 0.89444],
    8856: [0.13333, 0.63333, 0, 0, 0.89444],
    8857: [0.13333, 0.63333, 0, 0, 0.89444],
    8866: [0, 0.69444, 0, 0, 0.70277],
    8867: [0, 0.69444, 0, 0, 0.70277],
    8868: [0, 0.69444, 0, 0, 0.89444],
    8869: [0, 0.69444, 0, 0, 0.89444],
    8900: [-0.02639, 0.47361, 0, 0, 0.575],
    8901: [-0.02639, 0.47361, 0, 0, 0.31944],
    8902: [-0.02778, 0.47222, 0, 0, 0.575],
    8968: [0.25, 0.75, 0, 0, 0.51111],
    8969: [0.25, 0.75, 0, 0, 0.51111],
    8970: [0.25, 0.75, 0, 0, 0.51111],
    8971: [0.25, 0.75, 0, 0, 0.51111],
    8994: [-0.13889, 0.36111, 0, 0, 1.14999],
    8995: [-0.13889, 0.36111, 0, 0, 1.14999],
    9651: [0.19444, 0.69444, 0, 0, 1.02222],
    9657: [-0.02778, 0.47222, 0, 0, 0.575],
    9661: [0.19444, 0.69444, 0, 0, 1.02222],
    9667: [-0.02778, 0.47222, 0, 0, 0.575],
    9711: [0.19444, 0.69444, 0, 0, 1.14999],
    9824: [0.12963, 0.69444, 0, 0, 0.89444],
    9825: [0.12963, 0.69444, 0, 0, 0.89444],
    9826: [0.12963, 0.69444, 0, 0, 0.89444],
    9827: [0.12963, 0.69444, 0, 0, 0.89444],
    9837: [0, 0.75, 0, 0, 0.44722],
    9838: [0.19444, 0.69444, 0, 0, 0.44722],
    9839: [0.19444, 0.69444, 0, 0, 0.44722],
    10216: [0.25, 0.75, 0, 0, 0.44722],
    10217: [0.25, 0.75, 0, 0, 0.44722],
    10815: [0, 0.68611, 0, 0, 0.9],
    10927: [0.19667, 0.69667, 0, 0, 0.89444],
    10928: [0.19667, 0.69667, 0, 0, 0.89444],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.11417, 0, 0.38611],
    34: [0, 0.69444, 0.07939, 0, 0.62055],
    35: [0.19444, 0.69444, 0.06833, 0, 0.94444],
    37: [0.05556, 0.75, 0.12861, 0, 0.94444],
    38: [0, 0.69444, 0.08528, 0, 0.88555],
    39: [0, 0.69444, 0.12945, 0, 0.35555],
    40: [0.25, 0.75, 0.15806, 0, 0.47333],
    41: [0.25, 0.75, 0.03306, 0, 0.47333],
    42: [0, 0.75, 0.14333, 0, 0.59111],
    43: [0.10333, 0.60333, 0.03306, 0, 0.88555],
    44: [0.19444, 0.14722, 0, 0, 0.35555],
    45: [0, 0.44444, 0.02611, 0, 0.41444],
    46: [0, 0.14722, 0, 0, 0.35555],
    47: [0.25, 0.75, 0.15806, 0, 0.59111],
    48: [0, 0.64444, 0.13167, 0, 0.59111],
    49: [0, 0.64444, 0.13167, 0, 0.59111],
    50: [0, 0.64444, 0.13167, 0, 0.59111],
    51: [0, 0.64444, 0.13167, 0, 0.59111],
    52: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    53: [0, 0.64444, 0.13167, 0, 0.59111],
    54: [0, 0.64444, 0.13167, 0, 0.59111],
    55: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    56: [0, 0.64444, 0.13167, 0, 0.59111],
    57: [0, 0.64444, 0.13167, 0, 0.59111],
    58: [0, 0.44444, 0.06695, 0, 0.35555],
    59: [0.19444, 0.44444, 0.06695, 0, 0.35555],
    61: [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    63: [0, 0.69444, 0.11472, 0, 0.59111],
    64: [0, 0.69444, 0.09208, 0, 0.88555],
    65: [0, 0.68611, 0, 0, 0.86555],
    66: [0, 0.68611, 0.0992, 0, 0.81666],
    67: [0, 0.68611, 0.14208, 0, 0.82666],
    68: [0, 0.68611, 0.09062, 0, 0.87555],
    69: [0, 0.68611, 0.11431, 0, 0.75666],
    70: [0, 0.68611, 0.12903, 0, 0.72722],
    71: [0, 0.68611, 0.07347, 0, 0.89527],
    72: [0, 0.68611, 0.17208, 0, 0.8961],
    73: [0, 0.68611, 0.15681, 0, 0.47166],
    74: [0, 0.68611, 0.145, 0, 0.61055],
    75: [0, 0.68611, 0.14208, 0, 0.89499],
    76: [0, 0.68611, 0, 0, 0.69777],
    77: [0, 0.68611, 0.17208, 0, 1.07277],
    78: [0, 0.68611, 0.17208, 0, 0.8961],
    79: [0, 0.68611, 0.09062, 0, 0.85499],
    80: [0, 0.68611, 0.0992, 0, 0.78721],
    81: [0.19444, 0.68611, 0.09062, 0, 0.85499],
    82: [0, 0.68611, 0.02559, 0, 0.85944],
    83: [0, 0.68611, 0.11264, 0, 0.64999],
    84: [0, 0.68611, 0.12903, 0, 0.7961],
    85: [0, 0.68611, 0.17208, 0, 0.88083],
    86: [0, 0.68611, 0.18625, 0, 0.86555],
    87: [0, 0.68611, 0.18625, 0, 1.15999],
    88: [0, 0.68611, 0.15681, 0, 0.86555],
    89: [0, 0.68611, 0.19803, 0, 0.86555],
    90: [0, 0.68611, 0.14208, 0, 0.70888],
    91: [0.25, 0.75, 0.1875, 0, 0.35611],
    93: [0.25, 0.75, 0.09972, 0, 0.35611],
    94: [0, 0.69444, 0.06709, 0, 0.59111],
    95: [0.31, 0.13444, 0.09811, 0, 0.59111],
    97: [0, 0.44444, 0.09426, 0, 0.59111],
    98: [0, 0.69444, 0.07861, 0, 0.53222],
    99: [0, 0.44444, 0.05222, 0, 0.53222],
    100: [0, 0.69444, 0.10861, 0, 0.59111],
    101: [0, 0.44444, 0.085, 0, 0.53222],
    102: [0.19444, 0.69444, 0.21778, 0, 0.4],
    103: [0.19444, 0.44444, 0.105, 0, 0.53222],
    104: [0, 0.69444, 0.09426, 0, 0.59111],
    105: [0, 0.69326, 0.11387, 0, 0.35555],
    106: [0.19444, 0.69326, 0.1672, 0, 0.35555],
    107: [0, 0.69444, 0.11111, 0, 0.53222],
    108: [0, 0.69444, 0.10861, 0, 0.29666],
    109: [0, 0.44444, 0.09426, 0, 0.94444],
    110: [0, 0.44444, 0.09426, 0, 0.64999],
    111: [0, 0.44444, 0.07861, 0, 0.59111],
    112: [0.19444, 0.44444, 0.07861, 0, 0.59111],
    113: [0.19444, 0.44444, 0.105, 0, 0.53222],
    114: [0, 0.44444, 0.11111, 0, 0.50167],
    115: [0, 0.44444, 0.08167, 0, 0.48694],
    116: [0, 0.63492, 0.09639, 0, 0.385],
    117: [0, 0.44444, 0.09426, 0, 0.62055],
    118: [0, 0.44444, 0.11111, 0, 0.53222],
    119: [0, 0.44444, 0.11111, 0, 0.76777],
    120: [0, 0.44444, 0.12583, 0, 0.56055],
    121: [0.19444, 0.44444, 0.105, 0, 0.56166],
    122: [0, 0.44444, 0.13889, 0, 0.49055],
    126: [0.35, 0.34444, 0.11472, 0, 0.59111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0.11473, 0, 0.59111],
    176: [0, 0.69444, 0, 0, 0.94888],
    184: [0.17014, 0, 0, 0, 0.53222],
    198: [0, 0.68611, 0.11431, 0, 1.02277],
    216: [0.04861, 0.73472, 0.09062, 0, 0.88555],
    223: [0.19444, 0.69444, 0.09736, 0, 0.665],
    230: [0, 0.44444, 0.085, 0, 0.82666],
    248: [0.09722, 0.54167, 0.09458, 0, 0.59111],
    305: [0, 0.44444, 0.09426, 0, 0.35555],
    338: [0, 0.68611, 0.11431, 0, 1.14054],
    339: [0, 0.44444, 0.085, 0, 0.82666],
    567: [0.19444, 0.44444, 0.04611, 0, 0.385],
    710: [0, 0.69444, 0.06709, 0, 0.59111],
    711: [0, 0.63194, 0.08271, 0, 0.59111],
    713: [0, 0.59444, 0.10444, 0, 0.59111],
    714: [0, 0.69444, 0.08528, 0, 0.59111],
    715: [0, 0.69444, 0, 0, 0.59111],
    728: [0, 0.69444, 0.10333, 0, 0.59111],
    729: [0, 0.69444, 0.12945, 0, 0.35555],
    730: [0, 0.69444, 0, 0, 0.94888],
    732: [0, 0.69444, 0.11472, 0, 0.59111],
    733: [0, 0.69444, 0.11472, 0, 0.59111],
    915: [0, 0.68611, 0.12903, 0, 0.69777],
    916: [0, 0.68611, 0, 0, 0.94444],
    920: [0, 0.68611, 0.09062, 0, 0.88555],
    923: [0, 0.68611, 0, 0, 0.80666],
    926: [0, 0.68611, 0.15092, 0, 0.76777],
    928: [0, 0.68611, 0.17208, 0, 0.8961],
    931: [0, 0.68611, 0.11431, 0, 0.82666],
    933: [0, 0.68611, 0.10778, 0, 0.88555],
    934: [0, 0.68611, 0.05632, 0, 0.82666],
    936: [0, 0.68611, 0.10778, 0, 0.88555],
    937: [0, 0.68611, 0.0992, 0, 0.82666],
    8211: [0, 0.44444, 0.09811, 0, 0.59111],
    8212: [0, 0.44444, 0.09811, 0, 1.18221],
    8216: [0, 0.69444, 0.12945, 0, 0.35555],
    8217: [0, 0.69444, 0.12945, 0, 0.35555],
    8220: [0, 0.69444, 0.16772, 0, 0.62055],
    8221: [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.12417, 0, 0.30667],
    34: [0, 0.69444, 0.06961, 0, 0.51444],
    35: [0.19444, 0.69444, 0.06616, 0, 0.81777],
    37: [0.05556, 0.75, 0.13639, 0, 0.81777],
    38: [0, 0.69444, 0.09694, 0, 0.76666],
    39: [0, 0.69444, 0.12417, 0, 0.30667],
    40: [0.25, 0.75, 0.16194, 0, 0.40889],
    41: [0.25, 0.75, 0.03694, 0, 0.40889],
    42: [0, 0.75, 0.14917, 0, 0.51111],
    43: [0.05667, 0.56167, 0.03694, 0, 0.76666],
    44: [0.19444, 0.10556, 0, 0, 0.30667],
    45: [0, 0.43056, 0.02826, 0, 0.35778],
    46: [0, 0.10556, 0, 0, 0.30667],
    47: [0.25, 0.75, 0.16194, 0, 0.51111],
    48: [0, 0.64444, 0.13556, 0, 0.51111],
    49: [0, 0.64444, 0.13556, 0, 0.51111],
    50: [0, 0.64444, 0.13556, 0, 0.51111],
    51: [0, 0.64444, 0.13556, 0, 0.51111],
    52: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    53: [0, 0.64444, 0.13556, 0, 0.51111],
    54: [0, 0.64444, 0.13556, 0, 0.51111],
    55: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    56: [0, 0.64444, 0.13556, 0, 0.51111],
    57: [0, 0.64444, 0.13556, 0, 0.51111],
    58: [0, 0.43056, 0.0582, 0, 0.30667],
    59: [0.19444, 0.43056, 0.0582, 0, 0.30667],
    61: [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    63: [0, 0.69444, 0.1225, 0, 0.51111],
    64: [0, 0.69444, 0.09597, 0, 0.76666],
    65: [0, 0.68333, 0, 0, 0.74333],
    66: [0, 0.68333, 0.10257, 0, 0.70389],
    67: [0, 0.68333, 0.14528, 0, 0.71555],
    68: [0, 0.68333, 0.09403, 0, 0.755],
    69: [0, 0.68333, 0.12028, 0, 0.67833],
    70: [0, 0.68333, 0.13305, 0, 0.65277],
    71: [0, 0.68333, 0.08722, 0, 0.77361],
    72: [0, 0.68333, 0.16389, 0, 0.74333],
    73: [0, 0.68333, 0.15806, 0, 0.38555],
    74: [0, 0.68333, 0.14028, 0, 0.525],
    75: [0, 0.68333, 0.14528, 0, 0.76888],
    76: [0, 0.68333, 0, 0, 0.62722],
    77: [0, 0.68333, 0.16389, 0, 0.89666],
    78: [0, 0.68333, 0.16389, 0, 0.74333],
    79: [0, 0.68333, 0.09403, 0, 0.76666],
    80: [0, 0.68333, 0.10257, 0, 0.67833],
    81: [0.19444, 0.68333, 0.09403, 0, 0.76666],
    82: [0, 0.68333, 0.03868, 0, 0.72944],
    83: [0, 0.68333, 0.11972, 0, 0.56222],
    84: [0, 0.68333, 0.13305, 0, 0.71555],
    85: [0, 0.68333, 0.16389, 0, 0.74333],
    86: [0, 0.68333, 0.18361, 0, 0.74333],
    87: [0, 0.68333, 0.18361, 0, 0.99888],
    88: [0, 0.68333, 0.15806, 0, 0.74333],
    89: [0, 0.68333, 0.19383, 0, 0.74333],
    90: [0, 0.68333, 0.14528, 0, 0.61333],
    91: [0.25, 0.75, 0.1875, 0, 0.30667],
    93: [0.25, 0.75, 0.10528, 0, 0.30667],
    94: [0, 0.69444, 0.06646, 0, 0.51111],
    95: [0.31, 0.12056, 0.09208, 0, 0.51111],
    97: [0, 0.43056, 0.07671, 0, 0.51111],
    98: [0, 0.69444, 0.06312, 0, 0.46],
    99: [0, 0.43056, 0.05653, 0, 0.46],
    100: [0, 0.69444, 0.10333, 0, 0.51111],
    101: [0, 0.43056, 0.07514, 0, 0.46],
    102: [0.19444, 0.69444, 0.21194, 0, 0.30667],
    103: [0.19444, 0.43056, 0.08847, 0, 0.46],
    104: [0, 0.69444, 0.07671, 0, 0.51111],
    105: [0, 0.65536, 0.1019, 0, 0.30667],
    106: [0.19444, 0.65536, 0.14467, 0, 0.30667],
    107: [0, 0.69444, 0.10764, 0, 0.46],
    108: [0, 0.69444, 0.10333, 0, 0.25555],
    109: [0, 0.43056, 0.07671, 0, 0.81777],
    110: [0, 0.43056, 0.07671, 0, 0.56222],
    111: [0, 0.43056, 0.06312, 0, 0.51111],
    112: [0.19444, 0.43056, 0.06312, 0, 0.51111],
    113: [0.19444, 0.43056, 0.08847, 0, 0.46],
    114: [0, 0.43056, 0.10764, 0, 0.42166],
    115: [0, 0.43056, 0.08208, 0, 0.40889],
    116: [0, 0.61508, 0.09486, 0, 0.33222],
    117: [0, 0.43056, 0.07671, 0, 0.53666],
    118: [0, 0.43056, 0.10764, 0, 0.46],
    119: [0, 0.43056, 0.10764, 0, 0.66444],
    120: [0, 0.43056, 0.12042, 0, 0.46389],
    121: [0.19444, 0.43056, 0.08847, 0, 0.48555],
    122: [0, 0.43056, 0.12292, 0, 0.40889],
    126: [0.35, 0.31786, 0.11585, 0, 0.51111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.66786, 0.10474, 0, 0.51111],
    176: [0, 0.69444, 0, 0, 0.83129],
    184: [0.17014, 0, 0, 0, 0.46],
    198: [0, 0.68333, 0.12028, 0, 0.88277],
    216: [0.04861, 0.73194, 0.09403, 0, 0.76666],
    223: [0.19444, 0.69444, 0.10514, 0, 0.53666],
    230: [0, 0.43056, 0.07514, 0, 0.71555],
    248: [0.09722, 0.52778, 0.09194, 0, 0.51111],
    338: [0, 0.68333, 0.12028, 0, 0.98499],
    339: [0, 0.43056, 0.07514, 0, 0.71555],
    710: [0, 0.69444, 0.06646, 0, 0.51111],
    711: [0, 0.62847, 0.08295, 0, 0.51111],
    713: [0, 0.56167, 0.10333, 0, 0.51111],
    714: [0, 0.69444, 0.09694, 0, 0.51111],
    715: [0, 0.69444, 0, 0, 0.51111],
    728: [0, 0.69444, 0.10806, 0, 0.51111],
    729: [0, 0.66786, 0.11752, 0, 0.30667],
    730: [0, 0.69444, 0, 0, 0.83129],
    732: [0, 0.66786, 0.11585, 0, 0.51111],
    733: [0, 0.69444, 0.1225, 0, 0.51111],
    915: [0, 0.68333, 0.13305, 0, 0.62722],
    916: [0, 0.68333, 0, 0, 0.81777],
    920: [0, 0.68333, 0.09403, 0, 0.76666],
    923: [0, 0.68333, 0, 0, 0.69222],
    926: [0, 0.68333, 0.15294, 0, 0.66444],
    928: [0, 0.68333, 0.16389, 0, 0.74333],
    931: [0, 0.68333, 0.12028, 0, 0.71555],
    933: [0, 0.68333, 0.11111, 0, 0.76666],
    934: [0, 0.68333, 0.05986, 0, 0.71555],
    936: [0, 0.68333, 0.11111, 0, 0.76666],
    937: [0, 0.68333, 0.10257, 0, 0.71555],
    8211: [0, 0.43056, 0.09208, 0, 0.51111],
    8212: [0, 0.43056, 0.09208, 0, 1.02222],
    8216: [0, 0.69444, 0.12417, 0, 0.30667],
    8217: [0, 0.69444, 0.12417, 0, 0.30667],
    8220: [0, 0.69444, 0.1685, 0, 0.51444],
    8221: [0, 0.69444, 0.06961, 0, 0.51444],
    8463: [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.27778],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.77778],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.19444, 0.10556, 0, 0, 0.27778],
    45: [0, 0.43056, 0, 0, 0.33333],
    46: [0, 0.10556, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.64444, 0, 0, 0.5],
    49: [0, 0.64444, 0, 0, 0.5],
    50: [0, 0.64444, 0, 0, 0.5],
    51: [0, 0.64444, 0, 0, 0.5],
    52: [0, 0.64444, 0, 0, 0.5],
    53: [0, 0.64444, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0, 0.64444, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0, 0.64444, 0, 0, 0.5],
    58: [0, 0.43056, 0, 0, 0.27778],
    59: [0.19444, 0.43056, 0, 0, 0.27778],
    60: [0.0391, 0.5391, 0, 0, 0.77778],
    61: [-0.13313, 0.36687, 0, 0, 0.77778],
    62: [0.0391, 0.5391, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.77778],
    65: [0, 0.68333, 0, 0, 0.75],
    66: [0, 0.68333, 0, 0, 0.70834],
    67: [0, 0.68333, 0, 0, 0.72222],
    68: [0, 0.68333, 0, 0, 0.76389],
    69: [0, 0.68333, 0, 0, 0.68056],
    70: [0, 0.68333, 0, 0, 0.65278],
    71: [0, 0.68333, 0, 0, 0.78472],
    72: [0, 0.68333, 0, 0, 0.75],
    73: [0, 0.68333, 0, 0, 0.36111],
    74: [0, 0.68333, 0, 0, 0.51389],
    75: [0, 0.68333, 0, 0, 0.77778],
    76: [0, 0.68333, 0, 0, 0.625],
    77: [0, 0.68333, 0, 0, 0.91667],
    78: [0, 0.68333, 0, 0, 0.75],
    79: [0, 0.68333, 0, 0, 0.77778],
    80: [0, 0.68333, 0, 0, 0.68056],
    81: [0.19444, 0.68333, 0, 0, 0.77778],
    82: [0, 0.68333, 0, 0, 0.73611],
    83: [0, 0.68333, 0, 0, 0.55556],
    84: [0, 0.68333, 0, 0, 0.72222],
    85: [0, 0.68333, 0, 0, 0.75],
    86: [0, 0.68333, 0.01389, 0, 0.75],
    87: [0, 0.68333, 0.01389, 0, 1.02778],
    88: [0, 0.68333, 0, 0, 0.75],
    89: [0, 0.68333, 0.025, 0, 0.75],
    90: [0, 0.68333, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.27778],
    92: [0.25, 0.75, 0, 0, 0.5],
    93: [0.25, 0.75, 0, 0, 0.27778],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.31, 0.12056, 0.02778, 0, 0.5],
    97: [0, 0.43056, 0, 0, 0.5],
    98: [0, 0.69444, 0, 0, 0.55556],
    99: [0, 0.43056, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.55556],
    101: [0, 0.43056, 0, 0, 0.44445],
    102: [0, 0.69444, 0.07778, 0, 0.30556],
    103: [0.19444, 0.43056, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.55556],
    105: [0, 0.66786, 0, 0, 0.27778],
    106: [0.19444, 0.66786, 0, 0, 0.30556],
    107: [0, 0.69444, 0, 0, 0.52778],
    108: [0, 0.69444, 0, 0, 0.27778],
    109: [0, 0.43056, 0, 0, 0.83334],
    110: [0, 0.43056, 0, 0, 0.55556],
    111: [0, 0.43056, 0, 0, 0.5],
    112: [0.19444, 0.43056, 0, 0, 0.55556],
    113: [0.19444, 0.43056, 0, 0, 0.52778],
    114: [0, 0.43056, 0, 0, 0.39167],
    115: [0, 0.43056, 0, 0, 0.39445],
    116: [0, 0.61508, 0, 0, 0.38889],
    117: [0, 0.43056, 0, 0, 0.55556],
    118: [0, 0.43056, 0.01389, 0, 0.52778],
    119: [0, 0.43056, 0.01389, 0, 0.72222],
    120: [0, 0.43056, 0, 0, 0.52778],
    121: [0.19444, 0.43056, 0.01389, 0, 0.52778],
    122: [0, 0.43056, 0, 0, 0.44445],
    123: [0.25, 0.75, 0, 0, 0.5],
    124: [0.25, 0.75, 0, 0, 0.27778],
    125: [0.25, 0.75, 0, 0, 0.5],
    126: [0.35, 0.31786, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.76909],
    167: [0.19444, 0.69444, 0, 0, 0.44445],
    168: [0, 0.66786, 0, 0, 0.5],
    172: [0, 0.43056, 0, 0, 0.66667],
    176: [0, 0.69444, 0, 0, 0.75],
    177: [0.08333, 0.58333, 0, 0, 0.77778],
    182: [0.19444, 0.69444, 0, 0, 0.61111],
    184: [0.17014, 0, 0, 0, 0.44445],
    198: [0, 0.68333, 0, 0, 0.90278],
    215: [0.08333, 0.58333, 0, 0, 0.77778],
    216: [0.04861, 0.73194, 0, 0, 0.77778],
    223: [0, 0.69444, 0, 0, 0.5],
    230: [0, 0.43056, 0, 0, 0.72222],
    247: [0.08333, 0.58333, 0, 0, 0.77778],
    248: [0.09722, 0.52778, 0, 0, 0.5],
    305: [0, 0.43056, 0, 0, 0.27778],
    338: [0, 0.68333, 0, 0, 1.01389],
    339: [0, 0.43056, 0, 0, 0.77778],
    567: [0.19444, 0.43056, 0, 0, 0.30556],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.62847, 0, 0, 0.5],
    713: [0, 0.56778, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.66786, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.75],
    732: [0, 0.66786, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.68333, 0, 0, 0.625],
    916: [0, 0.68333, 0, 0, 0.83334],
    920: [0, 0.68333, 0, 0, 0.77778],
    923: [0, 0.68333, 0, 0, 0.69445],
    926: [0, 0.68333, 0, 0, 0.66667],
    928: [0, 0.68333, 0, 0, 0.75],
    931: [0, 0.68333, 0, 0, 0.72222],
    933: [0, 0.68333, 0, 0, 0.77778],
    934: [0, 0.68333, 0, 0, 0.72222],
    936: [0, 0.68333, 0, 0, 0.77778],
    937: [0, 0.68333, 0, 0, 0.72222],
    8211: [0, 0.43056, 0.02778, 0, 0.5],
    8212: [0, 0.43056, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5],
    8224: [0.19444, 0.69444, 0, 0, 0.44445],
    8225: [0.19444, 0.69444, 0, 0, 0.44445],
    8230: [0, 0.123, 0, 0, 1.172],
    8242: [0, 0.55556, 0, 0, 0.275],
    8407: [0, 0.71444, 0.15382, 0, 0.5],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8465: [0, 0.69444, 0, 0, 0.72222],
    8467: [0, 0.69444, 0, 0.11111, 0.41667],
    8472: [0.19444, 0.43056, 0, 0.11111, 0.63646],
    8476: [0, 0.69444, 0, 0, 0.72222],
    8501: [0, 0.69444, 0, 0, 0.61111],
    8592: [-0.13313, 0.36687, 0, 0, 1],
    8593: [0.19444, 0.69444, 0, 0, 0.5],
    8594: [-0.13313, 0.36687, 0, 0, 1],
    8595: [0.19444, 0.69444, 0, 0, 0.5],
    8596: [-0.13313, 0.36687, 0, 0, 1],
    8597: [0.25, 0.75, 0, 0, 0.5],
    8598: [0.19444, 0.69444, 0, 0, 1],
    8599: [0.19444, 0.69444, 0, 0, 1],
    8600: [0.19444, 0.69444, 0, 0, 1],
    8601: [0.19444, 0.69444, 0, 0, 1],
    8614: [0.011, 0.511, 0, 0, 1],
    8617: [0.011, 0.511, 0, 0, 1.126],
    8618: [0.011, 0.511, 0, 0, 1.126],
    8636: [-0.13313, 0.36687, 0, 0, 1],
    8637: [-0.13313, 0.36687, 0, 0, 1],
    8640: [-0.13313, 0.36687, 0, 0, 1],
    8641: [-0.13313, 0.36687, 0, 0, 1],
    8652: [0.011, 0.671, 0, 0, 1],
    8656: [-0.13313, 0.36687, 0, 0, 1],
    8657: [0.19444, 0.69444, 0, 0, 0.61111],
    8658: [-0.13313, 0.36687, 0, 0, 1],
    8659: [0.19444, 0.69444, 0, 0, 0.61111],
    8660: [-0.13313, 0.36687, 0, 0, 1],
    8661: [0.25, 0.75, 0, 0, 0.61111],
    8704: [0, 0.69444, 0, 0, 0.55556],
    8706: [0, 0.69444, 0.05556, 0.08334, 0.5309],
    8707: [0, 0.69444, 0, 0, 0.55556],
    8709: [0.05556, 0.75, 0, 0, 0.5],
    8711: [0, 0.68333, 0, 0, 0.83334],
    8712: [0.0391, 0.5391, 0, 0, 0.66667],
    8715: [0.0391, 0.5391, 0, 0, 0.66667],
    8722: [0.08333, 0.58333, 0, 0, 0.77778],
    8723: [0.08333, 0.58333, 0, 0, 0.77778],
    8725: [0.25, 0.75, 0, 0, 0.5],
    8726: [0.25, 0.75, 0, 0, 0.5],
    8727: [-0.03472, 0.46528, 0, 0, 0.5],
    8728: [-0.05555, 0.44445, 0, 0, 0.5],
    8729: [-0.05555, 0.44445, 0, 0, 0.5],
    8730: [0.2, 0.8, 0, 0, 0.83334],
    8733: [0, 0.43056, 0, 0, 0.77778],
    8734: [0, 0.43056, 0, 0, 1],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.27778],
    8741: [0.25, 0.75, 0, 0, 0.5],
    8743: [0, 0.55556, 0, 0, 0.66667],
    8744: [0, 0.55556, 0, 0, 0.66667],
    8745: [0, 0.55556, 0, 0, 0.66667],
    8746: [0, 0.55556, 0, 0, 0.66667],
    8747: [0.19444, 0.69444, 0.11111, 0, 0.41667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8768: [0.19444, 0.69444, 0, 0, 0.27778],
    8771: [-0.03625, 0.46375, 0, 0, 0.77778],
    8773: [-0.022, 0.589, 0, 0, 0.778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8781: [-0.03625, 0.46375, 0, 0, 0.77778],
    8784: [-0.133, 0.673, 0, 0, 0.778],
    8801: [-0.03625, 0.46375, 0, 0, 0.77778],
    8804: [0.13597, 0.63597, 0, 0, 0.77778],
    8805: [0.13597, 0.63597, 0, 0, 0.77778],
    8810: [0.0391, 0.5391, 0, 0, 1],
    8811: [0.0391, 0.5391, 0, 0, 1],
    8826: [0.0391, 0.5391, 0, 0, 0.77778],
    8827: [0.0391, 0.5391, 0, 0, 0.77778],
    8834: [0.0391, 0.5391, 0, 0, 0.77778],
    8835: [0.0391, 0.5391, 0, 0, 0.77778],
    8838: [0.13597, 0.63597, 0, 0, 0.77778],
    8839: [0.13597, 0.63597, 0, 0, 0.77778],
    8846: [0, 0.55556, 0, 0, 0.66667],
    8849: [0.13597, 0.63597, 0, 0, 0.77778],
    8850: [0.13597, 0.63597, 0, 0, 0.77778],
    8851: [0, 0.55556, 0, 0, 0.66667],
    8852: [0, 0.55556, 0, 0, 0.66667],
    8853: [0.08333, 0.58333, 0, 0, 0.77778],
    8854: [0.08333, 0.58333, 0, 0, 0.77778],
    8855: [0.08333, 0.58333, 0, 0, 0.77778],
    8856: [0.08333, 0.58333, 0, 0, 0.77778],
    8857: [0.08333, 0.58333, 0, 0, 0.77778],
    8866: [0, 0.69444, 0, 0, 0.61111],
    8867: [0, 0.69444, 0, 0, 0.61111],
    8868: [0, 0.69444, 0, 0, 0.77778],
    8869: [0, 0.69444, 0, 0, 0.77778],
    8872: [0.249, 0.75, 0, 0, 0.867],
    8900: [-0.05555, 0.44445, 0, 0, 0.5],
    8901: [-0.05555, 0.44445, 0, 0, 0.27778],
    8902: [-0.03472, 0.46528, 0, 0, 0.5],
    8904: [5e-3, 0.505, 0, 0, 0.9],
    8942: [0.03, 0.903, 0, 0, 0.278],
    8943: [-0.19, 0.313, 0, 0, 1.172],
    8945: [-0.1, 0.823, 0, 0, 1.282],
    8968: [0.25, 0.75, 0, 0, 0.44445],
    8969: [0.25, 0.75, 0, 0, 0.44445],
    8970: [0.25, 0.75, 0, 0, 0.44445],
    8971: [0.25, 0.75, 0, 0, 0.44445],
    8994: [-0.14236, 0.35764, 0, 0, 1],
    8995: [-0.14236, 0.35764, 0, 0, 1],
    9136: [0.244, 0.744, 0, 0, 0.412],
    9137: [0.244, 0.745, 0, 0, 0.412],
    9651: [0.19444, 0.69444, 0, 0, 0.88889],
    9657: [-0.03472, 0.46528, 0, 0, 0.5],
    9661: [0.19444, 0.69444, 0, 0, 0.88889],
    9667: [-0.03472, 0.46528, 0, 0, 0.5],
    9711: [0.19444, 0.69444, 0, 0, 1],
    9824: [0.12963, 0.69444, 0, 0, 0.77778],
    9825: [0.12963, 0.69444, 0, 0, 0.77778],
    9826: [0.12963, 0.69444, 0, 0, 0.77778],
    9827: [0.12963, 0.69444, 0, 0, 0.77778],
    9837: [0, 0.75, 0, 0, 0.38889],
    9838: [0.19444, 0.69444, 0, 0, 0.38889],
    9839: [0.19444, 0.69444, 0, 0, 0.38889],
    10216: [0.25, 0.75, 0, 0, 0.38889],
    10217: [0.25, 0.75, 0, 0, 0.38889],
    10222: [0.244, 0.744, 0, 0, 0.412],
    10223: [0.244, 0.745, 0, 0, 0.412],
    10229: [0.011, 0.511, 0, 0, 1.609],
    10230: [0.011, 0.511, 0, 0, 1.638],
    10231: [0.011, 0.511, 0, 0, 1.859],
    10232: [0.024, 0.525, 0, 0, 1.609],
    10233: [0.024, 0.525, 0, 0, 1.638],
    10234: [0.024, 0.525, 0, 0, 1.858],
    10236: [0.011, 0.511, 0, 0, 1.638],
    10815: [0, 0.68333, 0, 0, 0.75],
    10927: [0.13597, 0.63597, 0, 0, 0.77778],
    10928: [0.13597, 0.63597, 0, 0, 0.77778],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.44444, 0, 0, 0.575],
    49: [0, 0.44444, 0, 0, 0.575],
    50: [0, 0.44444, 0, 0, 0.575],
    51: [0.19444, 0.44444, 0, 0, 0.575],
    52: [0.19444, 0.44444, 0, 0, 0.575],
    53: [0.19444, 0.44444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0.19444, 0.44444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0.19444, 0.44444, 0, 0, 0.575],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0.04835, 0, 0.8664],
    67: [0, 0.68611, 0.06979, 0, 0.81694],
    68: [0, 0.68611, 0.03194, 0, 0.93812],
    69: [0, 0.68611, 0.05451, 0, 0.81007],
    70: [0, 0.68611, 0.15972, 0, 0.68889],
    71: [0, 0.68611, 0, 0, 0.88673],
    72: [0, 0.68611, 0.08229, 0, 0.98229],
    73: [0, 0.68611, 0.07778, 0, 0.51111],
    74: [0, 0.68611, 0.10069, 0, 0.63125],
    75: [0, 0.68611, 0.06979, 0, 0.97118],
    76: [0, 0.68611, 0, 0, 0.75555],
    77: [0, 0.68611, 0.11424, 0, 1.14201],
    78: [0, 0.68611, 0.11424, 0, 0.95034],
    79: [0, 0.68611, 0.03194, 0, 0.83666],
    80: [0, 0.68611, 0.15972, 0, 0.72309],
    81: [0.19444, 0.68611, 0, 0, 0.86861],
    82: [0, 0.68611, 421e-5, 0, 0.87235],
    83: [0, 0.68611, 0.05382, 0, 0.69271],
    84: [0, 0.68611, 0.15972, 0, 0.63663],
    85: [0, 0.68611, 0.11424, 0, 0.80027],
    86: [0, 0.68611, 0.25555, 0, 0.67778],
    87: [0, 0.68611, 0.15972, 0, 1.09305],
    88: [0, 0.68611, 0.07778, 0, 0.94722],
    89: [0, 0.68611, 0.25555, 0, 0.67458],
    90: [0, 0.68611, 0.06979, 0, 0.77257],
    97: [0, 0.44444, 0, 0, 0.63287],
    98: [0, 0.69444, 0, 0, 0.52083],
    99: [0, 0.44444, 0, 0, 0.51342],
    100: [0, 0.69444, 0, 0, 0.60972],
    101: [0, 0.44444, 0, 0, 0.55361],
    102: [0.19444, 0.69444, 0.11042, 0, 0.56806],
    103: [0.19444, 0.44444, 0.03704, 0, 0.5449],
    104: [0, 0.69444, 0, 0, 0.66759],
    105: [0, 0.69326, 0, 0, 0.4048],
    106: [0.19444, 0.69326, 0.0622, 0, 0.47083],
    107: [0, 0.69444, 0.01852, 0, 0.6037],
    108: [0, 0.69444, 88e-4, 0, 0.34815],
    109: [0, 0.44444, 0, 0, 1.0324],
    110: [0, 0.44444, 0, 0, 0.71296],
    111: [0, 0.44444, 0, 0, 0.58472],
    112: [0.19444, 0.44444, 0, 0, 0.60092],
    113: [0.19444, 0.44444, 0.03704, 0, 0.54213],
    114: [0, 0.44444, 0.03194, 0, 0.5287],
    115: [0, 0.44444, 0, 0, 0.53125],
    116: [0, 0.63492, 0, 0, 0.41528],
    117: [0, 0.44444, 0, 0, 0.68102],
    118: [0, 0.44444, 0.03704, 0, 0.56666],
    119: [0, 0.44444, 0.02778, 0, 0.83148],
    120: [0, 0.44444, 0, 0, 0.65903],
    121: [0.19444, 0.44444, 0.03704, 0, 0.59028],
    122: [0, 0.44444, 0.04213, 0, 0.55509],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68611, 0.15972, 0, 0.65694],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0.03194, 0, 0.86722],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0.07458, 0, 0.84125],
    928: [0, 0.68611, 0.08229, 0, 0.98229],
    931: [0, 0.68611, 0.05451, 0, 0.88507],
    933: [0, 0.68611, 0.15972, 0, 0.67083],
    934: [0, 0.68611, 0, 0, 0.76666],
    936: [0, 0.68611, 0.11653, 0, 0.71402],
    937: [0, 0.68611, 0.04835, 0, 0.8789],
    945: [0, 0.44444, 0, 0, 0.76064],
    946: [0.19444, 0.69444, 0.03403, 0, 0.65972],
    947: [0.19444, 0.44444, 0.06389, 0, 0.59003],
    948: [0, 0.69444, 0.03819, 0, 0.52222],
    949: [0, 0.44444, 0, 0, 0.52882],
    950: [0.19444, 0.69444, 0.06215, 0, 0.50833],
    951: [0.19444, 0.44444, 0.03704, 0, 0.6],
    952: [0, 0.69444, 0.03194, 0, 0.5618],
    953: [0, 0.44444, 0, 0, 0.41204],
    954: [0, 0.44444, 0, 0, 0.66759],
    955: [0, 0.69444, 0, 0, 0.67083],
    956: [0.19444, 0.44444, 0, 0, 0.70787],
    957: [0, 0.44444, 0.06898, 0, 0.57685],
    958: [0.19444, 0.69444, 0.03021, 0, 0.50833],
    959: [0, 0.44444, 0, 0, 0.58472],
    960: [0, 0.44444, 0.03704, 0, 0.68241],
    961: [0.19444, 0.44444, 0, 0, 0.6118],
    962: [0.09722, 0.44444, 0.07917, 0, 0.42361],
    963: [0, 0.44444, 0.03704, 0, 0.68588],
    964: [0, 0.44444, 0.13472, 0, 0.52083],
    965: [0, 0.44444, 0.03704, 0, 0.63055],
    966: [0.19444, 0.44444, 0, 0, 0.74722],
    967: [0.19444, 0.44444, 0, 0, 0.71805],
    968: [0.19444, 0.69444, 0.03704, 0, 0.75833],
    969: [0, 0.44444, 0.03704, 0, 0.71782],
    977: [0, 0.69444, 0, 0, 0.69155],
    981: [0.19444, 0.69444, 0, 0, 0.7125],
    982: [0, 0.44444, 0.03194, 0, 0.975],
    1009: [0.19444, 0.44444, 0, 0, 0.6118],
    1013: [0, 0.44444, 0, 0, 0.48333],
    57649: [0, 0.44444, 0, 0, 0.39352],
    57911: [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.43056, 0, 0, 0.5],
    49: [0, 0.43056, 0, 0, 0.5],
    50: [0, 0.43056, 0, 0, 0.5],
    51: [0.19444, 0.43056, 0, 0, 0.5],
    52: [0.19444, 0.43056, 0, 0, 0.5],
    53: [0.19444, 0.43056, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0.19444, 0.43056, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0.19444, 0.43056, 0, 0, 0.5],
    65: [0, 0.68333, 0, 0.13889, 0.75],
    66: [0, 0.68333, 0.05017, 0.08334, 0.75851],
    67: [0, 0.68333, 0.07153, 0.08334, 0.71472],
    68: [0, 0.68333, 0.02778, 0.05556, 0.82792],
    69: [0, 0.68333, 0.05764, 0.08334, 0.7382],
    70: [0, 0.68333, 0.13889, 0.08334, 0.64306],
    71: [0, 0.68333, 0, 0.08334, 0.78625],
    72: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    73: [0, 0.68333, 0.07847, 0.11111, 0.43958],
    74: [0, 0.68333, 0.09618, 0.16667, 0.55451],
    75: [0, 0.68333, 0.07153, 0.05556, 0.84931],
    76: [0, 0.68333, 0, 0.02778, 0.68056],
    77: [0, 0.68333, 0.10903, 0.08334, 0.97014],
    78: [0, 0.68333, 0.10903, 0.08334, 0.80347],
    79: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    80: [0, 0.68333, 0.13889, 0.08334, 0.64201],
    81: [0.19444, 0.68333, 0, 0.08334, 0.79056],
    82: [0, 0.68333, 773e-5, 0.08334, 0.75929],
    83: [0, 0.68333, 0.05764, 0.08334, 0.6132],
    84: [0, 0.68333, 0.13889, 0.08334, 0.58438],
    85: [0, 0.68333, 0.10903, 0.02778, 0.68278],
    86: [0, 0.68333, 0.22222, 0, 0.58333],
    87: [0, 0.68333, 0.13889, 0, 0.94445],
    88: [0, 0.68333, 0.07847, 0.08334, 0.82847],
    89: [0, 0.68333, 0.22222, 0, 0.58056],
    90: [0, 0.68333, 0.07153, 0.08334, 0.68264],
    97: [0, 0.43056, 0, 0, 0.52859],
    98: [0, 0.69444, 0, 0, 0.42917],
    99: [0, 0.43056, 0, 0.05556, 0.43276],
    100: [0, 0.69444, 0, 0.16667, 0.52049],
    101: [0, 0.43056, 0, 0.05556, 0.46563],
    102: [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    103: [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    104: [0, 0.69444, 0, 0, 0.57616],
    105: [0, 0.65952, 0, 0, 0.34451],
    106: [0.19444, 0.65952, 0.05724, 0, 0.41181],
    107: [0, 0.69444, 0.03148, 0, 0.5206],
    108: [0, 0.69444, 0.01968, 0.08334, 0.29838],
    109: [0, 0.43056, 0, 0, 0.87801],
    110: [0, 0.43056, 0, 0, 0.60023],
    111: [0, 0.43056, 0, 0.05556, 0.48472],
    112: [0.19444, 0.43056, 0, 0.08334, 0.50313],
    113: [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    114: [0, 0.43056, 0.02778, 0.05556, 0.45116],
    115: [0, 0.43056, 0, 0.05556, 0.46875],
    116: [0, 0.61508, 0, 0.08334, 0.36111],
    117: [0, 0.43056, 0, 0.02778, 0.57246],
    118: [0, 0.43056, 0.03588, 0.02778, 0.48472],
    119: [0, 0.43056, 0.02691, 0.08334, 0.71592],
    120: [0, 0.43056, 0, 0.02778, 0.57153],
    121: [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    122: [0, 0.43056, 0.04398, 0.05556, 0.46505],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68333, 0.13889, 0.08334, 0.61528],
    916: [0, 0.68333, 0, 0.16667, 0.83334],
    920: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    923: [0, 0.68333, 0, 0.16667, 0.69445],
    926: [0, 0.68333, 0.07569, 0.08334, 0.74236],
    928: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    931: [0, 0.68333, 0.05764, 0.08334, 0.77986],
    933: [0, 0.68333, 0.13889, 0.05556, 0.58333],
    934: [0, 0.68333, 0, 0.08334, 0.66667],
    936: [0, 0.68333, 0.11, 0.05556, 0.61222],
    937: [0, 0.68333, 0.05017, 0.08334, 0.7724],
    945: [0, 0.43056, 37e-4, 0.02778, 0.6397],
    946: [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    947: [0.19444, 0.43056, 0.05556, 0, 0.51773],
    948: [0, 0.69444, 0.03785, 0.05556, 0.44444],
    949: [0, 0.43056, 0, 0.08334, 0.46632],
    950: [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    951: [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    952: [0, 0.69444, 0.02778, 0.08334, 0.46944],
    953: [0, 0.43056, 0, 0.05556, 0.35394],
    954: [0, 0.43056, 0, 0, 0.57616],
    955: [0, 0.69444, 0, 0, 0.58334],
    956: [0.19444, 0.43056, 0, 0.02778, 0.60255],
    957: [0, 0.43056, 0.06366, 0.02778, 0.49398],
    958: [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    959: [0, 0.43056, 0, 0.05556, 0.48472],
    960: [0, 0.43056, 0.03588, 0, 0.57003],
    961: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    962: [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    963: [0, 0.43056, 0.03588, 0, 0.57141],
    964: [0, 0.43056, 0.1132, 0.02778, 0.43715],
    965: [0, 0.43056, 0.03588, 0.02778, 0.54028],
    966: [0.19444, 0.43056, 0, 0.08334, 0.65417],
    967: [0.19444, 0.43056, 0, 0.05556, 0.62569],
    968: [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    969: [0, 0.43056, 0.03588, 0, 0.62245],
    977: [0, 0.69444, 0, 0.08334, 0.59144],
    981: [0.19444, 0.69444, 0, 0.08334, 0.59583],
    982: [0, 0.43056, 0.02778, 0, 0.82813],
    1009: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    1013: [0, 0.43056, 0, 0.05556, 0.4059],
    57649: [0, 0.43056, 0, 0.02778, 0.32246],
    57911: [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.36667],
    34: [0, 0.69444, 0, 0, 0.55834],
    35: [0.19444, 0.69444, 0, 0, 0.91667],
    36: [0.05556, 0.75, 0, 0, 0.55],
    37: [0.05556, 0.75, 0, 0, 1.02912],
    38: [0, 0.69444, 0, 0, 0.83056],
    39: [0, 0.69444, 0, 0, 0.30556],
    40: [0.25, 0.75, 0, 0, 0.42778],
    41: [0.25, 0.75, 0, 0, 0.42778],
    42: [0, 0.75, 0, 0, 0.55],
    43: [0.11667, 0.61667, 0, 0, 0.85556],
    44: [0.10556, 0.13056, 0, 0, 0.30556],
    45: [0, 0.45833, 0, 0, 0.36667],
    46: [0, 0.13056, 0, 0, 0.30556],
    47: [0.25, 0.75, 0, 0, 0.55],
    48: [0, 0.69444, 0, 0, 0.55],
    49: [0, 0.69444, 0, 0, 0.55],
    50: [0, 0.69444, 0, 0, 0.55],
    51: [0, 0.69444, 0, 0, 0.55],
    52: [0, 0.69444, 0, 0, 0.55],
    53: [0, 0.69444, 0, 0, 0.55],
    54: [0, 0.69444, 0, 0, 0.55],
    55: [0, 0.69444, 0, 0, 0.55],
    56: [0, 0.69444, 0, 0, 0.55],
    57: [0, 0.69444, 0, 0, 0.55],
    58: [0, 0.45833, 0, 0, 0.30556],
    59: [0.10556, 0.45833, 0, 0, 0.30556],
    61: [-0.09375, 0.40625, 0, 0, 0.85556],
    63: [0, 0.69444, 0, 0, 0.51945],
    64: [0, 0.69444, 0, 0, 0.73334],
    65: [0, 0.69444, 0, 0, 0.73334],
    66: [0, 0.69444, 0, 0, 0.73334],
    67: [0, 0.69444, 0, 0, 0.70278],
    68: [0, 0.69444, 0, 0, 0.79445],
    69: [0, 0.69444, 0, 0, 0.64167],
    70: [0, 0.69444, 0, 0, 0.61111],
    71: [0, 0.69444, 0, 0, 0.73334],
    72: [0, 0.69444, 0, 0, 0.79445],
    73: [0, 0.69444, 0, 0, 0.33056],
    74: [0, 0.69444, 0, 0, 0.51945],
    75: [0, 0.69444, 0, 0, 0.76389],
    76: [0, 0.69444, 0, 0, 0.58056],
    77: [0, 0.69444, 0, 0, 0.97778],
    78: [0, 0.69444, 0, 0, 0.79445],
    79: [0, 0.69444, 0, 0, 0.79445],
    80: [0, 0.69444, 0, 0, 0.70278],
    81: [0.10556, 0.69444, 0, 0, 0.79445],
    82: [0, 0.69444, 0, 0, 0.70278],
    83: [0, 0.69444, 0, 0, 0.61111],
    84: [0, 0.69444, 0, 0, 0.73334],
    85: [0, 0.69444, 0, 0, 0.76389],
    86: [0, 0.69444, 0.01528, 0, 0.73334],
    87: [0, 0.69444, 0.01528, 0, 1.03889],
    88: [0, 0.69444, 0, 0, 0.73334],
    89: [0, 0.69444, 0.0275, 0, 0.73334],
    90: [0, 0.69444, 0, 0, 0.67223],
    91: [0.25, 0.75, 0, 0, 0.34306],
    93: [0.25, 0.75, 0, 0, 0.34306],
    94: [0, 0.69444, 0, 0, 0.55],
    95: [0.35, 0.10833, 0.03056, 0, 0.55],
    97: [0, 0.45833, 0, 0, 0.525],
    98: [0, 0.69444, 0, 0, 0.56111],
    99: [0, 0.45833, 0, 0, 0.48889],
    100: [0, 0.69444, 0, 0, 0.56111],
    101: [0, 0.45833, 0, 0, 0.51111],
    102: [0, 0.69444, 0.07639, 0, 0.33611],
    103: [0.19444, 0.45833, 0.01528, 0, 0.55],
    104: [0, 0.69444, 0, 0, 0.56111],
    105: [0, 0.69444, 0, 0, 0.25556],
    106: [0.19444, 0.69444, 0, 0, 0.28611],
    107: [0, 0.69444, 0, 0, 0.53056],
    108: [0, 0.69444, 0, 0, 0.25556],
    109: [0, 0.45833, 0, 0, 0.86667],
    110: [0, 0.45833, 0, 0, 0.56111],
    111: [0, 0.45833, 0, 0, 0.55],
    112: [0.19444, 0.45833, 0, 0, 0.56111],
    113: [0.19444, 0.45833, 0, 0, 0.56111],
    114: [0, 0.45833, 0.01528, 0, 0.37222],
    115: [0, 0.45833, 0, 0, 0.42167],
    116: [0, 0.58929, 0, 0, 0.40417],
    117: [0, 0.45833, 0, 0, 0.56111],
    118: [0, 0.45833, 0.01528, 0, 0.5],
    119: [0, 0.45833, 0.01528, 0, 0.74445],
    120: [0, 0.45833, 0, 0, 0.5],
    121: [0.19444, 0.45833, 0.01528, 0, 0.5],
    122: [0, 0.45833, 0, 0, 0.47639],
    126: [0.35, 0.34444, 0, 0, 0.55],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0, 0, 0.55],
    176: [0, 0.69444, 0, 0, 0.73334],
    180: [0, 0.69444, 0, 0, 0.55],
    184: [0.17014, 0, 0, 0, 0.48889],
    305: [0, 0.45833, 0, 0, 0.25556],
    567: [0.19444, 0.45833, 0, 0, 0.28611],
    710: [0, 0.69444, 0, 0, 0.55],
    711: [0, 0.63542, 0, 0, 0.55],
    713: [0, 0.63778, 0, 0, 0.55],
    728: [0, 0.69444, 0, 0, 0.55],
    729: [0, 0.69444, 0, 0, 0.30556],
    730: [0, 0.69444, 0, 0, 0.73334],
    732: [0, 0.69444, 0, 0, 0.55],
    733: [0, 0.69444, 0, 0, 0.55],
    915: [0, 0.69444, 0, 0, 0.58056],
    916: [0, 0.69444, 0, 0, 0.91667],
    920: [0, 0.69444, 0, 0, 0.85556],
    923: [0, 0.69444, 0, 0, 0.67223],
    926: [0, 0.69444, 0, 0, 0.73334],
    928: [0, 0.69444, 0, 0, 0.79445],
    931: [0, 0.69444, 0, 0, 0.79445],
    933: [0, 0.69444, 0, 0, 0.85556],
    934: [0, 0.69444, 0, 0, 0.79445],
    936: [0, 0.69444, 0, 0, 0.85556],
    937: [0, 0.69444, 0, 0, 0.79445],
    8211: [0, 0.45833, 0.03056, 0, 0.55],
    8212: [0, 0.45833, 0.03056, 0, 1.10001],
    8216: [0, 0.69444, 0, 0, 0.30556],
    8217: [0, 0.69444, 0, 0, 0.30556],
    8220: [0, 0.69444, 0, 0, 0.55834],
    8221: [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.05733, 0, 0.31945],
    34: [0, 0.69444, 316e-5, 0, 0.5],
    35: [0.19444, 0.69444, 0.05087, 0, 0.83334],
    36: [0.05556, 0.75, 0.11156, 0, 0.5],
    37: [0.05556, 0.75, 0.03126, 0, 0.83334],
    38: [0, 0.69444, 0.03058, 0, 0.75834],
    39: [0, 0.69444, 0.07816, 0, 0.27778],
    40: [0.25, 0.75, 0.13164, 0, 0.38889],
    41: [0.25, 0.75, 0.02536, 0, 0.38889],
    42: [0, 0.75, 0.11775, 0, 0.5],
    43: [0.08333, 0.58333, 0.02536, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0.01946, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0.13164, 0, 0.5],
    48: [0, 0.65556, 0.11156, 0, 0.5],
    49: [0, 0.65556, 0.11156, 0, 0.5],
    50: [0, 0.65556, 0.11156, 0, 0.5],
    51: [0, 0.65556, 0.11156, 0, 0.5],
    52: [0, 0.65556, 0.11156, 0, 0.5],
    53: [0, 0.65556, 0.11156, 0, 0.5],
    54: [0, 0.65556, 0.11156, 0, 0.5],
    55: [0, 0.65556, 0.11156, 0, 0.5],
    56: [0, 0.65556, 0.11156, 0, 0.5],
    57: [0, 0.65556, 0.11156, 0, 0.5],
    58: [0, 0.44444, 0.02502, 0, 0.27778],
    59: [0.125, 0.44444, 0.02502, 0, 0.27778],
    61: [-0.13, 0.37, 0.05087, 0, 0.77778],
    63: [0, 0.69444, 0.11809, 0, 0.47222],
    64: [0, 0.69444, 0.07555, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0.08293, 0, 0.66667],
    67: [0, 0.69444, 0.11983, 0, 0.63889],
    68: [0, 0.69444, 0.07555, 0, 0.72223],
    69: [0, 0.69444, 0.11983, 0, 0.59722],
    70: [0, 0.69444, 0.13372, 0, 0.56945],
    71: [0, 0.69444, 0.11983, 0, 0.66667],
    72: [0, 0.69444, 0.08094, 0, 0.70834],
    73: [0, 0.69444, 0.13372, 0, 0.27778],
    74: [0, 0.69444, 0.08094, 0, 0.47222],
    75: [0, 0.69444, 0.11983, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0.08094, 0, 0.875],
    78: [0, 0.69444, 0.08094, 0, 0.70834],
    79: [0, 0.69444, 0.07555, 0, 0.73611],
    80: [0, 0.69444, 0.08293, 0, 0.63889],
    81: [0.125, 0.69444, 0.07555, 0, 0.73611],
    82: [0, 0.69444, 0.08293, 0, 0.64584],
    83: [0, 0.69444, 0.09205, 0, 0.55556],
    84: [0, 0.69444, 0.13372, 0, 0.68056],
    85: [0, 0.69444, 0.08094, 0, 0.6875],
    86: [0, 0.69444, 0.1615, 0, 0.66667],
    87: [0, 0.69444, 0.1615, 0, 0.94445],
    88: [0, 0.69444, 0.13372, 0, 0.66667],
    89: [0, 0.69444, 0.17261, 0, 0.66667],
    90: [0, 0.69444, 0.11983, 0, 0.61111],
    91: [0.25, 0.75, 0.15942, 0, 0.28889],
    93: [0.25, 0.75, 0.08719, 0, 0.28889],
    94: [0, 0.69444, 0.0799, 0, 0.5],
    95: [0.35, 0.09444, 0.08616, 0, 0.5],
    97: [0, 0.44444, 981e-5, 0, 0.48056],
    98: [0, 0.69444, 0.03057, 0, 0.51667],
    99: [0, 0.44444, 0.08336, 0, 0.44445],
    100: [0, 0.69444, 0.09483, 0, 0.51667],
    101: [0, 0.44444, 0.06778, 0, 0.44445],
    102: [0, 0.69444, 0.21705, 0, 0.30556],
    103: [0.19444, 0.44444, 0.10836, 0, 0.5],
    104: [0, 0.69444, 0.01778, 0, 0.51667],
    105: [0, 0.67937, 0.09718, 0, 0.23889],
    106: [0.19444, 0.67937, 0.09162, 0, 0.26667],
    107: [0, 0.69444, 0.08336, 0, 0.48889],
    108: [0, 0.69444, 0.09483, 0, 0.23889],
    109: [0, 0.44444, 0.01778, 0, 0.79445],
    110: [0, 0.44444, 0.01778, 0, 0.51667],
    111: [0, 0.44444, 0.06613, 0, 0.5],
    112: [0.19444, 0.44444, 0.0389, 0, 0.51667],
    113: [0.19444, 0.44444, 0.04169, 0, 0.51667],
    114: [0, 0.44444, 0.10836, 0, 0.34167],
    115: [0, 0.44444, 0.0778, 0, 0.38333],
    116: [0, 0.57143, 0.07225, 0, 0.36111],
    117: [0, 0.44444, 0.04169, 0, 0.51667],
    118: [0, 0.44444, 0.10836, 0, 0.46111],
    119: [0, 0.44444, 0.10836, 0, 0.68334],
    120: [0, 0.44444, 0.09169, 0, 0.46111],
    121: [0.19444, 0.44444, 0.10836, 0, 0.46111],
    122: [0, 0.44444, 0.08752, 0, 0.43472],
    126: [0.35, 0.32659, 0.08826, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0.06385, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.73752],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0.04169, 0, 0.23889],
    567: [0.19444, 0.44444, 0.04169, 0, 0.26667],
    710: [0, 0.69444, 0.0799, 0, 0.5],
    711: [0, 0.63194, 0.08432, 0, 0.5],
    713: [0, 0.60889, 0.08776, 0, 0.5],
    714: [0, 0.69444, 0.09205, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0.09483, 0, 0.5],
    729: [0, 0.67937, 0.07774, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.73752],
    732: [0, 0.67659, 0.08826, 0, 0.5],
    733: [0, 0.69444, 0.09205, 0, 0.5],
    915: [0, 0.69444, 0.13372, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0.07555, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0.12816, 0, 0.66667],
    928: [0, 0.69444, 0.08094, 0, 0.70834],
    931: [0, 0.69444, 0.11983, 0, 0.72222],
    933: [0, 0.69444, 0.09031, 0, 0.77778],
    934: [0, 0.69444, 0.04603, 0, 0.72222],
    936: [0, 0.69444, 0.09031, 0, 0.77778],
    937: [0, 0.69444, 0.08293, 0, 0.72222],
    8211: [0, 0.44444, 0.08616, 0, 0.5],
    8212: [0, 0.44444, 0.08616, 0, 1],
    8216: [0, 0.69444, 0.07816, 0, 0.27778],
    8217: [0, 0.69444, 0.07816, 0, 0.27778],
    8220: [0, 0.69444, 0.14205, 0, 0.5],
    8221: [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.31945],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.75834],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.65556, 0, 0, 0.5],
    49: [0, 0.65556, 0, 0, 0.5],
    50: [0, 0.65556, 0, 0, 0.5],
    51: [0, 0.65556, 0, 0, 0.5],
    52: [0, 0.65556, 0, 0, 0.5],
    53: [0, 0.65556, 0, 0, 0.5],
    54: [0, 0.65556, 0, 0, 0.5],
    55: [0, 0.65556, 0, 0, 0.5],
    56: [0, 0.65556, 0, 0, 0.5],
    57: [0, 0.65556, 0, 0, 0.5],
    58: [0, 0.44444, 0, 0, 0.27778],
    59: [0.125, 0.44444, 0, 0, 0.27778],
    61: [-0.13, 0.37, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0, 0, 0.66667],
    67: [0, 0.69444, 0, 0, 0.63889],
    68: [0, 0.69444, 0, 0, 0.72223],
    69: [0, 0.69444, 0, 0, 0.59722],
    70: [0, 0.69444, 0, 0, 0.56945],
    71: [0, 0.69444, 0, 0, 0.66667],
    72: [0, 0.69444, 0, 0, 0.70834],
    73: [0, 0.69444, 0, 0, 0.27778],
    74: [0, 0.69444, 0, 0, 0.47222],
    75: [0, 0.69444, 0, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0, 0, 0.875],
    78: [0, 0.69444, 0, 0, 0.70834],
    79: [0, 0.69444, 0, 0, 0.73611],
    80: [0, 0.69444, 0, 0, 0.63889],
    81: [0.125, 0.69444, 0, 0, 0.73611],
    82: [0, 0.69444, 0, 0, 0.64584],
    83: [0, 0.69444, 0, 0, 0.55556],
    84: [0, 0.69444, 0, 0, 0.68056],
    85: [0, 0.69444, 0, 0, 0.6875],
    86: [0, 0.69444, 0.01389, 0, 0.66667],
    87: [0, 0.69444, 0.01389, 0, 0.94445],
    88: [0, 0.69444, 0, 0, 0.66667],
    89: [0, 0.69444, 0.025, 0, 0.66667],
    90: [0, 0.69444, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.28889],
    93: [0.25, 0.75, 0, 0, 0.28889],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.35, 0.09444, 0.02778, 0, 0.5],
    97: [0, 0.44444, 0, 0, 0.48056],
    98: [0, 0.69444, 0, 0, 0.51667],
    99: [0, 0.44444, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.51667],
    101: [0, 0.44444, 0, 0, 0.44445],
    102: [0, 0.69444, 0.06944, 0, 0.30556],
    103: [0.19444, 0.44444, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.51667],
    105: [0, 0.67937, 0, 0, 0.23889],
    106: [0.19444, 0.67937, 0, 0, 0.26667],
    107: [0, 0.69444, 0, 0, 0.48889],
    108: [0, 0.69444, 0, 0, 0.23889],
    109: [0, 0.44444, 0, 0, 0.79445],
    110: [0, 0.44444, 0, 0, 0.51667],
    111: [0, 0.44444, 0, 0, 0.5],
    112: [0.19444, 0.44444, 0, 0, 0.51667],
    113: [0.19444, 0.44444, 0, 0, 0.51667],
    114: [0, 0.44444, 0.01389, 0, 0.34167],
    115: [0, 0.44444, 0, 0, 0.38333],
    116: [0, 0.57143, 0, 0, 0.36111],
    117: [0, 0.44444, 0, 0, 0.51667],
    118: [0, 0.44444, 0.01389, 0, 0.46111],
    119: [0, 0.44444, 0.01389, 0, 0.68334],
    120: [0, 0.44444, 0, 0, 0.46111],
    121: [0.19444, 0.44444, 0.01389, 0, 0.46111],
    122: [0, 0.44444, 0, 0, 0.43472],
    126: [0.35, 0.32659, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.66667],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0, 0, 0.23889],
    567: [0.19444, 0.44444, 0, 0, 0.26667],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.63194, 0, 0, 0.5],
    713: [0, 0.60889, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.67937, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.66667],
    732: [0, 0.67659, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.69444, 0, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0, 0, 0.66667],
    928: [0, 0.69444, 0, 0, 0.70834],
    931: [0, 0.69444, 0, 0, 0.72222],
    933: [0, 0.69444, 0, 0, 0.77778],
    934: [0, 0.69444, 0, 0, 0.72222],
    936: [0, 0.69444, 0, 0, 0.77778],
    937: [0, 0.69444, 0, 0, 0.72222],
    8211: [0, 0.44444, 0.02778, 0, 0.5],
    8212: [0, 0.44444, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.7, 0.22925, 0, 0.80253],
    66: [0, 0.7, 0.04087, 0, 0.90757],
    67: [0, 0.7, 0.1689, 0, 0.66619],
    68: [0, 0.7, 0.09371, 0, 0.77443],
    69: [0, 0.7, 0.18583, 0, 0.56162],
    70: [0, 0.7, 0.13634, 0, 0.89544],
    71: [0, 0.7, 0.17322, 0, 0.60961],
    72: [0, 0.7, 0.29694, 0, 0.96919],
    73: [0, 0.7, 0.19189, 0, 0.80907],
    74: [0.27778, 0.7, 0.19189, 0, 1.05159],
    75: [0, 0.7, 0.31259, 0, 0.91364],
    76: [0, 0.7, 0.19189, 0, 0.87373],
    77: [0, 0.7, 0.15981, 0, 1.08031],
    78: [0, 0.7, 0.3525, 0, 0.9015],
    79: [0, 0.7, 0.08078, 0, 0.73787],
    80: [0, 0.7, 0.08078, 0, 1.01262],
    81: [0, 0.7, 0.03305, 0, 0.88282],
    82: [0, 0.7, 0.06259, 0, 0.85],
    83: [0, 0.7, 0.19189, 0, 0.86767],
    84: [0, 0.7, 0.29087, 0, 0.74697],
    85: [0, 0.7, 0.25815, 0, 0.79996],
    86: [0, 0.7, 0.27523, 0, 0.62204],
    87: [0, 0.7, 0.27523, 0, 0.80532],
    88: [0, 0.7, 0.26006, 0, 0.94445],
    89: [0, 0.7, 0.2939, 0, 0.70961],
    90: [0, 0.7, 0.24037, 0, 0.8212],
    160: [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.35001, 0.85, 0, 0, 0.45834],
    41: [0.35001, 0.85, 0, 0, 0.45834],
    47: [0.35001, 0.85, 0, 0, 0.57778],
    91: [0.35001, 0.85, 0, 0, 0.41667],
    92: [0.35001, 0.85, 0, 0, 0.57778],
    93: [0.35001, 0.85, 0, 0, 0.41667],
    123: [0.35001, 0.85, 0, 0, 0.58334],
    125: [0.35001, 0.85, 0, 0, 0.58334],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.72222, 0, 0, 0.55556],
    732: [0, 0.72222, 0, 0, 0.55556],
    770: [0, 0.72222, 0, 0, 0.55556],
    771: [0, 0.72222, 0, 0, 0.55556],
    8214: [-99e-5, 0.601, 0, 0, 0.77778],
    8593: [1e-5, 0.6, 0, 0, 0.66667],
    8595: [1e-5, 0.6, 0, 0, 0.66667],
    8657: [1e-5, 0.6, 0, 0, 0.77778],
    8659: [1e-5, 0.6, 0, 0, 0.77778],
    8719: [0.25001, 0.75, 0, 0, 0.94445],
    8720: [0.25001, 0.75, 0, 0, 0.94445],
    8721: [0.25001, 0.75, 0, 0, 1.05556],
    8730: [0.35001, 0.85, 0, 0, 1],
    8739: [-599e-5, 0.606, 0, 0, 0.33333],
    8741: [-599e-5, 0.606, 0, 0, 0.55556],
    8747: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8748: [0.306, 0.805, 0.19445, 0, 0.47222],
    8749: [0.306, 0.805, 0.19445, 0, 0.47222],
    8750: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8896: [0.25001, 0.75, 0, 0, 0.83334],
    8897: [0.25001, 0.75, 0, 0, 0.83334],
    8898: [0.25001, 0.75, 0, 0, 0.83334],
    8899: [0.25001, 0.75, 0, 0, 0.83334],
    8968: [0.35001, 0.85, 0, 0, 0.47222],
    8969: [0.35001, 0.85, 0, 0, 0.47222],
    8970: [0.35001, 0.85, 0, 0, 0.47222],
    8971: [0.35001, 0.85, 0, 0, 0.47222],
    9168: [-99e-5, 0.601, 0, 0, 0.66667],
    10216: [0.35001, 0.85, 0, 0, 0.47222],
    10217: [0.35001, 0.85, 0, 0, 0.47222],
    10752: [0.25001, 0.75, 0, 0, 1.11111],
    10753: [0.25001, 0.75, 0, 0, 1.11111],
    10754: [0.25001, 0.75, 0, 0, 1.11111],
    10756: [0.25001, 0.75, 0, 0, 0.83334],
    10758: [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.65002, 1.15, 0, 0, 0.59722],
    41: [0.65002, 1.15, 0, 0, 0.59722],
    47: [0.65002, 1.15, 0, 0, 0.81111],
    91: [0.65002, 1.15, 0, 0, 0.47222],
    92: [0.65002, 1.15, 0, 0, 0.81111],
    93: [0.65002, 1.15, 0, 0, 0.47222],
    123: [0.65002, 1.15, 0, 0, 0.66667],
    125: [0.65002, 1.15, 0, 0, 0.66667],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1],
    732: [0, 0.75, 0, 0, 1],
    770: [0, 0.75, 0, 0, 1],
    771: [0, 0.75, 0, 0, 1],
    8719: [0.55001, 1.05, 0, 0, 1.27778],
    8720: [0.55001, 1.05, 0, 0, 1.27778],
    8721: [0.55001, 1.05, 0, 0, 1.44445],
    8730: [0.65002, 1.15, 0, 0, 1],
    8747: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8748: [0.862, 1.36, 0.44445, 0, 0.55556],
    8749: [0.862, 1.36, 0.44445, 0, 0.55556],
    8750: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8896: [0.55001, 1.05, 0, 0, 1.11111],
    8897: [0.55001, 1.05, 0, 0, 1.11111],
    8898: [0.55001, 1.05, 0, 0, 1.11111],
    8899: [0.55001, 1.05, 0, 0, 1.11111],
    8968: [0.65002, 1.15, 0, 0, 0.52778],
    8969: [0.65002, 1.15, 0, 0, 0.52778],
    8970: [0.65002, 1.15, 0, 0, 0.52778],
    8971: [0.65002, 1.15, 0, 0, 0.52778],
    10216: [0.65002, 1.15, 0, 0, 0.61111],
    10217: [0.65002, 1.15, 0, 0, 0.61111],
    10752: [0.55001, 1.05, 0, 0, 1.51112],
    10753: [0.55001, 1.05, 0, 0, 1.51112],
    10754: [0.55001, 1.05, 0, 0, 1.51112],
    10756: [0.55001, 1.05, 0, 0, 1.11111],
    10758: [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.95003, 1.45, 0, 0, 0.73611],
    41: [0.95003, 1.45, 0, 0, 0.73611],
    47: [0.95003, 1.45, 0, 0, 1.04445],
    91: [0.95003, 1.45, 0, 0, 0.52778],
    92: [0.95003, 1.45, 0, 0, 1.04445],
    93: [0.95003, 1.45, 0, 0, 0.52778],
    123: [0.95003, 1.45, 0, 0, 0.75],
    125: [0.95003, 1.45, 0, 0, 0.75],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1.44445],
    732: [0, 0.75, 0, 0, 1.44445],
    770: [0, 0.75, 0, 0, 1.44445],
    771: [0, 0.75, 0, 0, 1.44445],
    8730: [0.95003, 1.45, 0, 0, 1],
    8968: [0.95003, 1.45, 0, 0, 0.58334],
    8969: [0.95003, 1.45, 0, 0, 0.58334],
    8970: [0.95003, 1.45, 0, 0, 0.58334],
    8971: [0.95003, 1.45, 0, 0, 0.58334],
    10216: [0.95003, 1.45, 0, 0, 0.75],
    10217: [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [1.25003, 1.75, 0, 0, 0.79167],
    41: [1.25003, 1.75, 0, 0, 0.79167],
    47: [1.25003, 1.75, 0, 0, 1.27778],
    91: [1.25003, 1.75, 0, 0, 0.58334],
    92: [1.25003, 1.75, 0, 0, 1.27778],
    93: [1.25003, 1.75, 0, 0, 0.58334],
    123: [1.25003, 1.75, 0, 0, 0.80556],
    125: [1.25003, 1.75, 0, 0, 0.80556],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.825, 0, 0, 1.8889],
    732: [0, 0.825, 0, 0, 1.8889],
    770: [0, 0.825, 0, 0, 1.8889],
    771: [0, 0.825, 0, 0, 1.8889],
    8730: [1.25003, 1.75, 0, 0, 1],
    8968: [1.25003, 1.75, 0, 0, 0.63889],
    8969: [1.25003, 1.75, 0, 0, 0.63889],
    8970: [1.25003, 1.75, 0, 0, 0.63889],
    8971: [1.25003, 1.75, 0, 0, 0.63889],
    9115: [0.64502, 1.155, 0, 0, 0.875],
    9116: [1e-5, 0.6, 0, 0, 0.875],
    9117: [0.64502, 1.155, 0, 0, 0.875],
    9118: [0.64502, 1.155, 0, 0, 0.875],
    9119: [1e-5, 0.6, 0, 0, 0.875],
    9120: [0.64502, 1.155, 0, 0, 0.875],
    9121: [0.64502, 1.155, 0, 0, 0.66667],
    9122: [-99e-5, 0.601, 0, 0, 0.66667],
    9123: [0.64502, 1.155, 0, 0, 0.66667],
    9124: [0.64502, 1.155, 0, 0, 0.66667],
    9125: [-99e-5, 0.601, 0, 0, 0.66667],
    9126: [0.64502, 1.155, 0, 0, 0.66667],
    9127: [1e-5, 0.9, 0, 0, 0.88889],
    9128: [0.65002, 1.15, 0, 0, 0.88889],
    9129: [0.90001, 0, 0, 0, 0.88889],
    9130: [0, 0.3, 0, 0, 0.88889],
    9131: [1e-5, 0.9, 0, 0, 0.88889],
    9132: [0.65002, 1.15, 0, 0, 0.88889],
    9133: [0.90001, 0, 0, 0, 0.88889],
    9143: [0.88502, 0.915, 0, 0, 1.05556],
    10216: [1.25003, 1.75, 0, 0, 0.80556],
    10217: [1.25003, 1.75, 0, 0, 0.80556],
    57344: [-499e-5, 0.605, 0, 0, 1.05556],
    57345: [-499e-5, 0.605, 0, 0, 1.05556],
    57680: [0, 0.12, 0, 0, 0.45],
    57681: [0, 0.12, 0, 0, 0.45],
    57682: [0, 0.12, 0, 0, 0.45],
    57683: [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    32: [0, 0, 0, 0, 0.525],
    33: [0, 0.61111, 0, 0, 0.525],
    34: [0, 0.61111, 0, 0, 0.525],
    35: [0, 0.61111, 0, 0, 0.525],
    36: [0.08333, 0.69444, 0, 0, 0.525],
    37: [0.08333, 0.69444, 0, 0, 0.525],
    38: [0, 0.61111, 0, 0, 0.525],
    39: [0, 0.61111, 0, 0, 0.525],
    40: [0.08333, 0.69444, 0, 0, 0.525],
    41: [0.08333, 0.69444, 0, 0, 0.525],
    42: [0, 0.52083, 0, 0, 0.525],
    43: [-0.08056, 0.53055, 0, 0, 0.525],
    44: [0.13889, 0.125, 0, 0, 0.525],
    45: [-0.08056, 0.53055, 0, 0, 0.525],
    46: [0, 0.125, 0, 0, 0.525],
    47: [0.08333, 0.69444, 0, 0, 0.525],
    48: [0, 0.61111, 0, 0, 0.525],
    49: [0, 0.61111, 0, 0, 0.525],
    50: [0, 0.61111, 0, 0, 0.525],
    51: [0, 0.61111, 0, 0, 0.525],
    52: [0, 0.61111, 0, 0, 0.525],
    53: [0, 0.61111, 0, 0, 0.525],
    54: [0, 0.61111, 0, 0, 0.525],
    55: [0, 0.61111, 0, 0, 0.525],
    56: [0, 0.61111, 0, 0, 0.525],
    57: [0, 0.61111, 0, 0, 0.525],
    58: [0, 0.43056, 0, 0, 0.525],
    59: [0.13889, 0.43056, 0, 0, 0.525],
    60: [-0.05556, 0.55556, 0, 0, 0.525],
    61: [-0.19549, 0.41562, 0, 0, 0.525],
    62: [-0.05556, 0.55556, 0, 0, 0.525],
    63: [0, 0.61111, 0, 0, 0.525],
    64: [0, 0.61111, 0, 0, 0.525],
    65: [0, 0.61111, 0, 0, 0.525],
    66: [0, 0.61111, 0, 0, 0.525],
    67: [0, 0.61111, 0, 0, 0.525],
    68: [0, 0.61111, 0, 0, 0.525],
    69: [0, 0.61111, 0, 0, 0.525],
    70: [0, 0.61111, 0, 0, 0.525],
    71: [0, 0.61111, 0, 0, 0.525],
    72: [0, 0.61111, 0, 0, 0.525],
    73: [0, 0.61111, 0, 0, 0.525],
    74: [0, 0.61111, 0, 0, 0.525],
    75: [0, 0.61111, 0, 0, 0.525],
    76: [0, 0.61111, 0, 0, 0.525],
    77: [0, 0.61111, 0, 0, 0.525],
    78: [0, 0.61111, 0, 0, 0.525],
    79: [0, 0.61111, 0, 0, 0.525],
    80: [0, 0.61111, 0, 0, 0.525],
    81: [0.13889, 0.61111, 0, 0, 0.525],
    82: [0, 0.61111, 0, 0, 0.525],
    83: [0, 0.61111, 0, 0, 0.525],
    84: [0, 0.61111, 0, 0, 0.525],
    85: [0, 0.61111, 0, 0, 0.525],
    86: [0, 0.61111, 0, 0, 0.525],
    87: [0, 0.61111, 0, 0, 0.525],
    88: [0, 0.61111, 0, 0, 0.525],
    89: [0, 0.61111, 0, 0, 0.525],
    90: [0, 0.61111, 0, 0, 0.525],
    91: [0.08333, 0.69444, 0, 0, 0.525],
    92: [0.08333, 0.69444, 0, 0, 0.525],
    93: [0.08333, 0.69444, 0, 0, 0.525],
    94: [0, 0.61111, 0, 0, 0.525],
    95: [0.09514, 0, 0, 0, 0.525],
    96: [0, 0.61111, 0, 0, 0.525],
    97: [0, 0.43056, 0, 0, 0.525],
    98: [0, 0.61111, 0, 0, 0.525],
    99: [0, 0.43056, 0, 0, 0.525],
    100: [0, 0.61111, 0, 0, 0.525],
    101: [0, 0.43056, 0, 0, 0.525],
    102: [0, 0.61111, 0, 0, 0.525],
    103: [0.22222, 0.43056, 0, 0, 0.525],
    104: [0, 0.61111, 0, 0, 0.525],
    105: [0, 0.61111, 0, 0, 0.525],
    106: [0.22222, 0.61111, 0, 0, 0.525],
    107: [0, 0.61111, 0, 0, 0.525],
    108: [0, 0.61111, 0, 0, 0.525],
    109: [0, 0.43056, 0, 0, 0.525],
    110: [0, 0.43056, 0, 0, 0.525],
    111: [0, 0.43056, 0, 0, 0.525],
    112: [0.22222, 0.43056, 0, 0, 0.525],
    113: [0.22222, 0.43056, 0, 0, 0.525],
    114: [0, 0.43056, 0, 0, 0.525],
    115: [0, 0.43056, 0, 0, 0.525],
    116: [0, 0.55358, 0, 0, 0.525],
    117: [0, 0.43056, 0, 0, 0.525],
    118: [0, 0.43056, 0, 0, 0.525],
    119: [0, 0.43056, 0, 0, 0.525],
    120: [0, 0.43056, 0, 0, 0.525],
    121: [0.22222, 0.43056, 0, 0, 0.525],
    122: [0, 0.43056, 0, 0, 0.525],
    123: [0.08333, 0.69444, 0, 0, 0.525],
    124: [0.08333, 0.69444, 0, 0, 0.525],
    125: [0.08333, 0.69444, 0, 0, 0.525],
    126: [0, 0.61111, 0, 0, 0.525],
    127: [0, 0.61111, 0, 0, 0.525],
    160: [0, 0, 0, 0, 0.525],
    176: [0, 0.61111, 0, 0, 0.525],
    184: [0.19445, 0, 0, 0, 0.525],
    305: [0, 0.43056, 0, 0, 0.525],
    567: [0.22222, 0.43056, 0, 0, 0.525],
    711: [0, 0.56597, 0, 0, 0.525],
    713: [0, 0.56555, 0, 0, 0.525],
    714: [0, 0.61111, 0, 0, 0.525],
    715: [0, 0.61111, 0, 0, 0.525],
    728: [0, 0.61111, 0, 0, 0.525],
    730: [0, 0.61111, 0, 0, 0.525],
    770: [0, 0.61111, 0, 0, 0.525],
    771: [0, 0.61111, 0, 0, 0.525],
    776: [0, 0.61111, 0, 0, 0.525],
    915: [0, 0.61111, 0, 0, 0.525],
    916: [0, 0.61111, 0, 0, 0.525],
    920: [0, 0.61111, 0, 0, 0.525],
    923: [0, 0.61111, 0, 0, 0.525],
    926: [0, 0.61111, 0, 0, 0.525],
    928: [0, 0.61111, 0, 0, 0.525],
    931: [0, 0.61111, 0, 0, 0.525],
    933: [0, 0.61111, 0, 0, 0.525],
    934: [0, 0.61111, 0, 0, 0.525],
    936: [0, 0.61111, 0, 0, 0.525],
    937: [0, 0.61111, 0, 0, 0.525],
    8216: [0, 0.61111, 0, 0, 0.525],
    8217: [0, 0.61111, 0, 0, 0.525],
    8242: [0, 0.61111, 0, 0, 0.525],
    9251: [0.11111, 0.21944, 0, 0, 0.525]
  }
}, m1 = {
  slant: [0.25, 0.25, 0.25],
  // sigma1
  space: [0, 0, 0],
  // sigma2
  stretch: [0, 0, 0],
  // sigma3
  shrink: [0, 0, 0],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1, 1.171, 1.472],
  // sigma6
  extraSpace: [0, 0, 0],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.15, 0.143, 0.2],
  // sigma16
  sub2: [0.247, 0.286, 0.4],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.05, 0.071, 0.1],
  // sigma19
  delim1: [2.39, 1.7, 1.98],
  // sigma20
  delim2: [1.01, 1.157, 1.42],
  // sigma21
  axisHeight: [0.25, 0.25, 0.25],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.scss; if you change it make sure the
  // values match.
  ptPerEm: [10, 10, 10],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04]
  // 0.4 pt / ptPerEm
}, K8 = {
  // Latin-1
  : "A",
  : "D",
  : "o",
  : "a",
  : "d",
  : "o",
  // Cyrillic
  : "A",
  : "B",
  : "B",
  : "F",
  : "A",
  : "E",
  : "K",
  : "3",
  : "N",
  : "N",
  : "K",
  : "N",
  : "M",
  : "H",
  : "O",
  : "N",
  : "P",
  : "C",
  : "T",
  : "y",
  : "O",
  : "X",
  : "U",
  : "h",
  : "W",
  : "W",
  : "B",
  : "X",
  : "B",
  : "3",
  : "X",
  : "R",
  : "a",
  : "b",
  : "a",
  : "r",
  : "y",
  : "e",
  : "m",
  : "e",
  : "n",
  : "n",
  : "n",
  : "n",
  : "m",
  : "n",
  : "o",
  : "n",
  : "p",
  : "c",
  : "o",
  : "y",
  : "b",
  : "x",
  : "n",
  : "n",
  : "w",
  : "w",
  : "a",
  : "m",
  : "a",
  : "e",
  : "m",
  : "r"
};
function bz(t, e) {
  Ys[t] = e;
}
function pk(t, e, r) {
  if (!Ys[e])
    throw new Error("Font metrics not found for font: " + e + ".");
  var n = t.charCodeAt(0), i = Ys[e][n];
  if (!i && t[0] in K8 && (n = K8[t[0]].charCodeAt(0), i = Ys[e][n]), !i && r === "text" && xz(n) && (i = Ys[e][77]), i)
    return {
      depth: i[0],
      height: i[1],
      italic: i[2],
      skew: i[3],
      width: i[4]
    };
}
var h4 = {};
function kfe(t) {
  var e;
  if (t >= 5 ? e = 0 : t >= 3 ? e = 1 : e = 2, !h4[e]) {
    var r = h4[e] = {
      cssEmPerMu: m1.quad[e] / 18
    };
    for (var n in m1)
      m1.hasOwnProperty(n) && (r[n] = m1[n][e]);
  }
  return h4[e];
}
var Sfe = [
  // Each element contains [textsize, scriptsize, scriptscriptsize].
  // The size mappings are taken from TeX with \normalsize=10pt.
  [1, 1, 1],
  // size1: [5, 5, 5]              \tiny
  [2, 1, 1],
  // size2: [6, 5, 5]
  [3, 1, 1],
  // size3: [7, 5, 5]              \scriptsize
  [4, 2, 1],
  // size4: [8, 6, 5]              \footnotesize
  [5, 2, 1],
  // size5: [9, 6, 5]              \small
  [6, 3, 1],
  // size6: [10, 7, 5]             \normalsize
  [7, 4, 2],
  // size7: [12, 8, 6]             \large
  [8, 6, 3],
  // size8: [14.4, 10, 7]          \Large
  [9, 7, 6],
  // size9: [17.28, 12, 10]        \LARGE
  [10, 8, 7],
  // size10: [20.74, 14.4, 12]     \huge
  [11, 10, 9]
  // size11: [24.88, 20.74, 17.28] \HUGE
], Z8 = [
  // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
  // you change size indexes, change that function.
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
], Q8 = function(e, r) {
  return r.size < 2 ? e : Sfe[e - 1][r.size - 1];
};
class Io {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
  /**
   * The base size index.
   */
  constructor(e) {
    this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = e.style, this.color = e.color, this.size = e.size || Io.BASESIZE, this.textSize = e.textSize || this.size, this.phantom = !!e.phantom, this.font = e.font || "", this.fontFamily = e.fontFamily || "", this.fontWeight = e.fontWeight || "", this.fontShape = e.fontShape || "", this.sizeMultiplier = Z8[this.size - 1], this.maxSize = e.maxSize, this.minRuleThickness = e.minRuleThickness, this._fontMetrics = void 0;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */
  extend(e) {
    var r = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var n in e)
      e.hasOwnProperty(n) && (r[n] = e[n]);
    return new Io(r);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  havingStyle(e) {
    return this.style === e ? this : this.extend({
      style: e,
      size: Q8(this.textSize, e)
    });
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  havingSize(e) {
    return this.size === e && this.textSize === e ? this : this.extend({
      style: this.style.text(),
      size: e,
      textSize: e,
      sizeMultiplier: Z8[e - 1]
    });
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  havingBaseStyle(e) {
    e = e || this.style.text();
    var r = Q8(Io.BASESIZE, e);
    return this.size === r && this.textSize === Io.BASESIZE && this.style === e ? this : this.extend({
      style: e,
      size: r
    });
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  havingBaseSizing() {
    var e;
    switch (this.style.id) {
      case 4:
      case 5:
        e = 3;
        break;
      case 6:
      case 7:
        e = 1;
        break;
      default:
        e = 6;
    }
    return this.extend({
      style: this.style.text(),
      size: e
    });
  }
  /**
   * Create a new options object with the given color.
   */
  withColor(e) {
    return this.extend({
      color: e
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  withPhantom() {
    return this.extend({
      phantom: !0
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(e) {
    return this.extend({
      font: e
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  withTextFontFamily(e) {
    return this.extend({
      fontFamily: e,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontWeight(e) {
    return this.extend({
      fontWeight: e,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontShape(e) {
    return this.extend({
      fontShape: e,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  sizingClasses(e) {
    return e.size !== this.size ? ["sizing", "reset-size" + e.size, "size" + this.size] : [];
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  baseSizingClasses() {
    return this.size !== Io.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + Io.BASESIZE] : [];
  }
  /**
   * Return the font metrics for this size.
   */
  fontMetrics() {
    return this._fontMetrics || (this._fontMetrics = kfe(this.size)), this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  getColor() {
    return this.phantom ? "transparent" : this.color;
  }
}
Io.BASESIZE = 6;
var rT = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  pt: 1,
  // TeX point
  mm: 7227 / 2540,
  // millimeter
  cm: 7227 / 254,
  // centimeter
  in: 72.27,
  // inch
  bp: 803 / 800,
  // big (PostScript) points
  pc: 12,
  // pica
  dd: 1238 / 1157,
  // didot
  cc: 14856 / 1157,
  // cicero (12 didot)
  nd: 685 / 642,
  // new didot
  nc: 1370 / 107,
  // new cicero (12 new didot)
  sp: 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  px: 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
}, Cfe = {
  ex: !0,
  em: !0,
  mu: !0
}, wz = function(e) {
  return typeof e != "string" && (e = e.unit), e in rT || e in Cfe || e === "ex";
}, tn = function(e, r) {
  var n;
  if (e.unit in rT)
    n = rT[e.unit] / r.fontMetrics().ptPerEm / r.sizeMultiplier;
  else if (e.unit === "mu")
    n = r.fontMetrics().cssEmPerMu;
  else {
    var i;
    if (r.style.isTight() ? i = r.havingStyle(r.style.text()) : i = r, e.unit === "ex")
      n = i.fontMetrics().xHeight;
    else if (e.unit === "em")
      n = i.fontMetrics().quad;
    else
      throw new ot("Invalid unit: '" + e.unit + "'");
    i !== r && (n *= i.sizeMultiplier / r.sizeMultiplier);
  }
  return Math.min(e.number * n, r.maxSize);
}, pt = function(e) {
  return +e.toFixed(4) + "em";
}, Xl = function(e) {
  return e.filter((r) => r).join(" ");
}, Tz = function(e, r, n) {
  if (this.classes = e || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = n || {}, r) {
    r.style.isTight() && this.classes.push("mtight");
    var i = r.getColor();
    i && (this.style.color = i);
  }
}, Ez = function(e) {
  var r = document.createElement(e);
  r.className = Xl(this.classes);
  for (var n in this.style)
    this.style.hasOwnProperty(n) && (r.style[n] = this.style[n]);
  for (var i in this.attributes)
    this.attributes.hasOwnProperty(i) && r.setAttribute(i, this.attributes[i]);
  for (var a = 0; a < this.children.length; a++)
    r.appendChild(this.children[a].toNode());
  return r;
}, Afe = /[\s"'>/=\x00-\x1f]/, kz = function(e) {
  var r = "<" + e;
  this.classes.length && (r += ' class="' + Tr.escape(Xl(this.classes)) + '"');
  var n = "";
  for (var i in this.style)
    this.style.hasOwnProperty(i) && (n += Tr.hyphenate(i) + ":" + this.style[i] + ";");
  n && (r += ' style="' + Tr.escape(n) + '"');
  for (var a in this.attributes)
    if (this.attributes.hasOwnProperty(a)) {
      if (Afe.test(a))
        throw new ot("Invalid attribute name '" + a + "'");
      r += " " + a + '="' + Tr.escape(this.attributes[a]) + '"';
    }
  r += ">";
  for (var s = 0; s < this.children.length; s++)
    r += this.children[s].toMarkup();
  return r += "</" + e + ">", r;
};
class yg {
  constructor(e, r, n, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, Tz.call(this, e, n, i), this.children = r || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(e, r) {
    this.attributes[e] = r;
  }
  hasClass(e) {
    return this.classes.includes(e);
  }
  toNode() {
    return Ez.call(this, "span");
  }
  toMarkup() {
    return kz.call(this, "span");
  }
}
class gk {
  constructor(e, r, n, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, Tz.call(this, r, i), this.children = n || [], this.setAttribute("href", e);
  }
  setAttribute(e, r) {
    this.attributes[e] = r;
  }
  hasClass(e) {
    return this.classes.includes(e);
  }
  toNode() {
    return Ez.call(this, "a");
  }
  toMarkup() {
    return kz.call(this, "a");
  }
}
class _fe {
  constructor(e, r, n) {
    this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = r, this.src = e, this.classes = ["mord"], this.style = n;
  }
  hasClass(e) {
    return this.classes.includes(e);
  }
  toNode() {
    var e = document.createElement("img");
    e.src = this.src, e.alt = this.alt, e.className = "mord";
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (e.style[r] = this.style[r]);
    return e;
  }
  toMarkup() {
    var e = '<img src="' + Tr.escape(this.src) + '"' + (' alt="' + Tr.escape(this.alt) + '"'), r = "";
    for (var n in this.style)
      this.style.hasOwnProperty(n) && (r += Tr.hyphenate(n) + ":" + this.style[n] + ";");
    return r && (e += ' style="' + Tr.escape(r) + '"'), e += "'/>", e;
  }
}
var Lfe = {
  : "",
  : "",
  : "",
  // '': '\u0131\u0304', // enable when we add Extended Latin
  : ""
};
class es {
  constructor(e, r, n, i, a, s, o, l) {
    this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = e, this.height = r || 0, this.depth = n || 0, this.italic = i || 0, this.skew = a || 0, this.width = s || 0, this.classes = o || [], this.style = l || {}, this.maxFontSize = 0;
    var u = ffe(this.text.charCodeAt(0));
    u && this.classes.push(u + "_fallback"), /[]/.test(this.text) && (this.text = Lfe[this.text]);
  }
  hasClass(e) {
    return this.classes.includes(e);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var e = document.createTextNode(this.text), r = null;
    this.italic > 0 && (r = document.createElement("span"), r.style.marginRight = pt(this.italic)), this.classes.length > 0 && (r = r || document.createElement("span"), r.className = Xl(this.classes));
    for (var n in this.style)
      this.style.hasOwnProperty(n) && (r = r || document.createElement("span"), r.style[n] = this.style[n]);
    return r ? (r.appendChild(e), r) : e;
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var e = !1, r = "<span";
    this.classes.length && (e = !0, r += ' class="', r += Tr.escape(Xl(this.classes)), r += '"');
    var n = "";
    this.italic > 0 && (n += "margin-right:" + this.italic + "em;");
    for (var i in this.style)
      this.style.hasOwnProperty(i) && (n += Tr.hyphenate(i) + ":" + this.style[i] + ";");
    n && (e = !0, r += ' style="' + Tr.escape(n) + '"');
    var a = Tr.escape(this.text);
    return e ? (r += ">", r += a, r += "</span>", r) : a;
  }
}
class el {
  constructor(e, r) {
    this.children = void 0, this.attributes = void 0, this.children = e || [], this.attributes = r || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", r = document.createElementNS(e, "svg");
    for (var n in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, n) && r.setAttribute(n, this.attributes[n]);
    for (var i = 0; i < this.children.length; i++)
      r.appendChild(this.children[i].toNode());
    return r;
  }
  toMarkup() {
    var e = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && (e += " " + r + '="' + Tr.escape(this.attributes[r]) + '"');
    e += ">";
    for (var n = 0; n < this.children.length; n++)
      e += this.children[n].toMarkup();
    return e += "</svg>", e;
  }
}
class jl {
  constructor(e, r) {
    this.pathName = void 0, this.alternate = void 0, this.pathName = e, this.alternate = r;
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", r = document.createElementNS(e, "path");
    return this.alternate ? r.setAttribute("d", this.alternate) : r.setAttribute("d", j8[this.pathName]), r;
  }
  toMarkup() {
    return this.alternate ? '<path d="' + Tr.escape(this.alternate) + '"/>' : '<path d="' + Tr.escape(j8[this.pathName]) + '"/>';
  }
}
class nT {
  constructor(e) {
    this.attributes = void 0, this.attributes = e || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", r = document.createElementNS(e, "line");
    for (var n in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, n) && r.setAttribute(n, this.attributes[n]);
    return r;
  }
  toMarkup() {
    var e = "<line";
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && (e += " " + r + '="' + Tr.escape(this.attributes[r]) + '"');
    return e += "/>", e;
  }
}
function J8(t) {
  if (t instanceof es)
    return t;
  throw new Error("Expected symbolNode but got " + String(t) + ".");
}
function Rfe(t) {
  if (t instanceof yg)
    return t;
  throw new Error("Expected span<HtmlDomNode> but got " + String(t) + ".");
}
var Mfe = {
  bin: 1,
  close: 1,
  inner: 1,
  open: 1,
  punct: 1,
  rel: 1
}, Nfe = {
  "accent-token": 1,
  mathord: 1,
  "op-token": 1,
  spacing: 1,
  textord: 1
}, Gr = {
  math: {},
  text: {}
};
function G(t, e, r, n, i, a) {
  Gr[t][i] = {
    font: e,
    group: r,
    replace: n
  }, a && n && (Gr[t][n] = Gr[t][i]);
}
var U = "math", tt = "text", ne = "main", ye = "ams", Qr = "accent-token", Ct = "bin", ji = "close", Qd = "inner", $t = "mathord", Rn = "op-token", Ra = "open", dx = "punct", xe = "rel", hl = "spacing", Le = "textord";
G(U, ne, xe, "", "\\equiv", !0);
G(U, ne, xe, "", "\\prec", !0);
G(U, ne, xe, "", "\\succ", !0);
G(U, ne, xe, "", "\\sim", !0);
G(U, ne, xe, "", "\\perp");
G(U, ne, xe, "", "\\preceq", !0);
G(U, ne, xe, "", "\\succeq", !0);
G(U, ne, xe, "", "\\simeq", !0);
G(U, ne, xe, "", "\\mid", !0);
G(U, ne, xe, "", "\\ll", !0);
G(U, ne, xe, "", "\\gg", !0);
G(U, ne, xe, "", "\\asymp", !0);
G(U, ne, xe, "", "\\parallel");
G(U, ne, xe, "", "\\bowtie", !0);
G(U, ne, xe, "", "\\smile", !0);
G(U, ne, xe, "", "\\sqsubseteq", !0);
G(U, ne, xe, "", "\\sqsupseteq", !0);
G(U, ne, xe, "", "\\doteq", !0);
G(U, ne, xe, "", "\\frown", !0);
G(U, ne, xe, "", "\\ni", !0);
G(U, ne, xe, "", "\\propto", !0);
G(U, ne, xe, "", "\\vdash", !0);
G(U, ne, xe, "", "\\dashv", !0);
G(U, ne, xe, "", "\\owns");
G(U, ne, dx, ".", "\\ldotp");
G(U, ne, dx, "", "\\cdotp");
G(U, ne, Le, "#", "\\#");
G(tt, ne, Le, "#", "\\#");
G(U, ne, Le, "&", "\\&");
G(tt, ne, Le, "&", "\\&");
G(U, ne, Le, "", "\\aleph", !0);
G(U, ne, Le, "", "\\forall", !0);
G(U, ne, Le, "", "\\hbar", !0);
G(U, ne, Le, "", "\\exists", !0);
G(U, ne, Le, "", "\\nabla", !0);
G(U, ne, Le, "", "\\flat", !0);
G(U, ne, Le, "", "\\ell", !0);
G(U, ne, Le, "", "\\natural", !0);
G(U, ne, Le, "", "\\clubsuit", !0);
G(U, ne, Le, "", "\\wp", !0);
G(U, ne, Le, "", "\\sharp", !0);
G(U, ne, Le, "", "\\diamondsuit", !0);
G(U, ne, Le, "", "\\Re", !0);
G(U, ne, Le, "", "\\heartsuit", !0);
G(U, ne, Le, "", "\\Im", !0);
G(U, ne, Le, "", "\\spadesuit", !0);
G(U, ne, Le, "", "\\S", !0);
G(tt, ne, Le, "", "\\S");
G(U, ne, Le, "", "\\P", !0);
G(tt, ne, Le, "", "\\P");
G(U, ne, Le, "", "\\dag");
G(tt, ne, Le, "", "\\dag");
G(tt, ne, Le, "", "\\textdagger");
G(U, ne, Le, "", "\\ddag");
G(tt, ne, Le, "", "\\ddag");
G(tt, ne, Le, "", "\\textdaggerdbl");
G(U, ne, ji, "", "\\rmoustache", !0);
G(U, ne, Ra, "", "\\lmoustache", !0);
G(U, ne, ji, "", "\\rgroup", !0);
G(U, ne, Ra, "", "\\lgroup", !0);
G(U, ne, Ct, "", "\\mp", !0);
G(U, ne, Ct, "", "\\ominus", !0);
G(U, ne, Ct, "", "\\uplus", !0);
G(U, ne, Ct, "", "\\sqcap", !0);
G(U, ne, Ct, "", "\\ast");
G(U, ne, Ct, "", "\\sqcup", !0);
G(U, ne, Ct, "", "\\bigcirc", !0);
G(U, ne, Ct, "", "\\bullet", !0);
G(U, ne, Ct, "", "\\ddagger");
G(U, ne, Ct, "", "\\wr", !0);
G(U, ne, Ct, "", "\\amalg");
G(U, ne, Ct, "&", "\\And");
G(U, ne, xe, "", "\\longleftarrow", !0);
G(U, ne, xe, "", "\\Leftarrow", !0);
G(U, ne, xe, "", "\\Longleftarrow", !0);
G(U, ne, xe, "", "\\longrightarrow", !0);
G(U, ne, xe, "", "\\Rightarrow", !0);
G(U, ne, xe, "", "\\Longrightarrow", !0);
G(U, ne, xe, "", "\\leftrightarrow", !0);
G(U, ne, xe, "", "\\longleftrightarrow", !0);
G(U, ne, xe, "", "\\Leftrightarrow", !0);
G(U, ne, xe, "", "\\Longleftrightarrow", !0);
G(U, ne, xe, "", "\\mapsto", !0);
G(U, ne, xe, "", "\\longmapsto", !0);
G(U, ne, xe, "", "\\nearrow", !0);
G(U, ne, xe, "", "\\hookleftarrow", !0);
G(U, ne, xe, "", "\\hookrightarrow", !0);
G(U, ne, xe, "", "\\searrow", !0);
G(U, ne, xe, "", "\\leftharpoonup", !0);
G(U, ne, xe, "", "\\rightharpoonup", !0);
G(U, ne, xe, "", "\\swarrow", !0);
G(U, ne, xe, "", "\\leftharpoondown", !0);
G(U, ne, xe, "", "\\rightharpoondown", !0);
G(U, ne, xe, "", "\\nwarrow", !0);
G(U, ne, xe, "", "\\rightleftharpoons", !0);
G(U, ye, xe, "", "\\nless", !0);
G(U, ye, xe, "", "\\@nleqslant");
G(U, ye, xe, "", "\\@nleqq");
G(U, ye, xe, "", "\\lneq", !0);
G(U, ye, xe, "", "\\lneqq", !0);
G(U, ye, xe, "", "\\@lvertneqq");
G(U, ye, xe, "", "\\lnsim", !0);
G(U, ye, xe, "", "\\lnapprox", !0);
G(U, ye, xe, "", "\\nprec", !0);
G(U, ye, xe, "", "\\npreceq", !0);
G(U, ye, xe, "", "\\precnsim", !0);
G(U, ye, xe, "", "\\precnapprox", !0);
G(U, ye, xe, "", "\\nsim", !0);
G(U, ye, xe, "", "\\@nshortmid");
G(U, ye, xe, "", "\\nmid", !0);
G(U, ye, xe, "", "\\nvdash", !0);
G(U, ye, xe, "", "\\nvDash", !0);
G(U, ye, xe, "", "\\ntriangleleft");
G(U, ye, xe, "", "\\ntrianglelefteq", !0);
G(U, ye, xe, "", "\\subsetneq", !0);
G(U, ye, xe, "", "\\@varsubsetneq");
G(U, ye, xe, "", "\\subsetneqq", !0);
G(U, ye, xe, "", "\\@varsubsetneqq");
G(U, ye, xe, "", "\\ngtr", !0);
G(U, ye, xe, "", "\\@ngeqslant");
G(U, ye, xe, "", "\\@ngeqq");
G(U, ye, xe, "", "\\gneq", !0);
G(U, ye, xe, "", "\\gneqq", !0);
G(U, ye, xe, "", "\\@gvertneqq");
G(U, ye, xe, "", "\\gnsim", !0);
G(U, ye, xe, "", "\\gnapprox", !0);
G(U, ye, xe, "", "\\nsucc", !0);
G(U, ye, xe, "", "\\nsucceq", !0);
G(U, ye, xe, "", "\\succnsim", !0);
G(U, ye, xe, "", "\\succnapprox", !0);
G(U, ye, xe, "", "\\ncong", !0);
G(U, ye, xe, "", "\\@nshortparallel");
G(U, ye, xe, "", "\\nparallel", !0);
G(U, ye, xe, "", "\\nVDash", !0);
G(U, ye, xe, "", "\\ntriangleright");
G(U, ye, xe, "", "\\ntrianglerighteq", !0);
G(U, ye, xe, "", "\\@nsupseteqq");
G(U, ye, xe, "", "\\supsetneq", !0);
G(U, ye, xe, "", "\\@varsupsetneq");
G(U, ye, xe, "", "\\supsetneqq", !0);
G(U, ye, xe, "", "\\@varsupsetneqq");
G(U, ye, xe, "", "\\nVdash", !0);
G(U, ye, xe, "", "\\precneqq", !0);
G(U, ye, xe, "", "\\succneqq", !0);
G(U, ye, xe, "", "\\@nsubseteqq");
G(U, ye, Ct, "", "\\unlhd");
G(U, ye, Ct, "", "\\unrhd");
G(U, ye, xe, "", "\\nleftarrow", !0);
G(U, ye, xe, "", "\\nrightarrow", !0);
G(U, ye, xe, "", "\\nLeftarrow", !0);
G(U, ye, xe, "", "\\nRightarrow", !0);
G(U, ye, xe, "", "\\nleftrightarrow", !0);
G(U, ye, xe, "", "\\nLeftrightarrow", !0);
G(U, ye, xe, "", "\\vartriangle");
G(U, ye, Le, "", "\\hslash");
G(U, ye, Le, "", "\\triangledown");
G(U, ye, Le, "", "\\lozenge");
G(U, ye, Le, "", "\\circledS");
G(U, ye, Le, "", "\\circledR");
G(tt, ye, Le, "", "\\circledR");
G(U, ye, Le, "", "\\measuredangle", !0);
G(U, ye, Le, "", "\\nexists");
G(U, ye, Le, "", "\\mho");
G(U, ye, Le, "", "\\Finv", !0);
G(U, ye, Le, "", "\\Game", !0);
G(U, ye, Le, "", "\\backprime");
G(U, ye, Le, "", "\\blacktriangle");
G(U, ye, Le, "", "\\blacktriangledown");
G(U, ye, Le, "", "\\blacksquare");
G(U, ye, Le, "", "\\blacklozenge");
G(U, ye, Le, "", "\\bigstar");
G(U, ye, Le, "", "\\sphericalangle", !0);
G(U, ye, Le, "", "\\complement", !0);
G(U, ye, Le, "", "\\eth", !0);
G(tt, ne, Le, "", "");
G(U, ye, Le, "", "\\diagup");
G(U, ye, Le, "", "\\diagdown");
G(U, ye, Le, "", "\\square");
G(U, ye, Le, "", "\\Box");
G(U, ye, Le, "", "\\Diamond");
G(U, ye, Le, "", "\\yen", !0);
G(tt, ye, Le, "", "\\yen", !0);
G(U, ye, Le, "", "\\checkmark", !0);
G(tt, ye, Le, "", "\\checkmark");
G(U, ye, Le, "", "\\beth", !0);
G(U, ye, Le, "", "\\daleth", !0);
G(U, ye, Le, "", "\\gimel", !0);
G(U, ye, Le, "", "\\digamma", !0);
G(U, ye, Le, "", "\\varkappa");
G(U, ye, Ra, "", "\\@ulcorner", !0);
G(U, ye, ji, "", "\\@urcorner", !0);
G(U, ye, Ra, "", "\\@llcorner", !0);
G(U, ye, ji, "", "\\@lrcorner", !0);
G(U, ye, xe, "", "\\leqq", !0);
G(U, ye, xe, "", "\\leqslant", !0);
G(U, ye, xe, "", "\\eqslantless", !0);
G(U, ye, xe, "", "\\lesssim", !0);
G(U, ye, xe, "", "\\lessapprox", !0);
G(U, ye, xe, "", "\\approxeq", !0);
G(U, ye, Ct, "", "\\lessdot");
G(U, ye, xe, "", "\\lll", !0);
G(U, ye, xe, "", "\\lessgtr", !0);
G(U, ye, xe, "", "\\lesseqgtr", !0);
G(U, ye, xe, "", "\\lesseqqgtr", !0);
G(U, ye, xe, "", "\\doteqdot");
G(U, ye, xe, "", "\\risingdotseq", !0);
G(U, ye, xe, "", "\\fallingdotseq", !0);
G(U, ye, xe, "", "\\backsim", !0);
G(U, ye, xe, "", "\\backsimeq", !0);
G(U, ye, xe, "", "\\subseteqq", !0);
G(U, ye, xe, "", "\\Subset", !0);
G(U, ye, xe, "", "\\sqsubset", !0);
G(U, ye, xe, "", "\\preccurlyeq", !0);
G(U, ye, xe, "", "\\curlyeqprec", !0);
G(U, ye, xe, "", "\\precsim", !0);
G(U, ye, xe, "", "\\precapprox", !0);
G(U, ye, xe, "", "\\vartriangleleft");
G(U, ye, xe, "", "\\trianglelefteq");
G(U, ye, xe, "", "\\vDash", !0);
G(U, ye, xe, "", "\\Vvdash", !0);
G(U, ye, xe, "", "\\smallsmile");
G(U, ye, xe, "", "\\smallfrown");
G(U, ye, xe, "", "\\bumpeq", !0);
G(U, ye, xe, "", "\\Bumpeq", !0);
G(U, ye, xe, "", "\\geqq", !0);
G(U, ye, xe, "", "\\geqslant", !0);
G(U, ye, xe, "", "\\eqslantgtr", !0);
G(U, ye, xe, "", "\\gtrsim", !0);
G(U, ye, xe, "", "\\gtrapprox", !0);
G(U, ye, Ct, "", "\\gtrdot");
G(U, ye, xe, "", "\\ggg", !0);
G(U, ye, xe, "", "\\gtrless", !0);
G(U, ye, xe, "", "\\gtreqless", !0);
G(U, ye, xe, "", "\\gtreqqless", !0);
G(U, ye, xe, "", "\\eqcirc", !0);
G(U, ye, xe, "", "\\circeq", !0);
G(U, ye, xe, "", "\\triangleq", !0);
G(U, ye, xe, "", "\\thicksim");
G(U, ye, xe, "", "\\thickapprox");
G(U, ye, xe, "", "\\supseteqq", !0);
G(U, ye, xe, "", "\\Supset", !0);
G(U, ye, xe, "", "\\sqsupset", !0);
G(U, ye, xe, "", "\\succcurlyeq", !0);
G(U, ye, xe, "", "\\curlyeqsucc", !0);
G(U, ye, xe, "", "\\succsim", !0);
G(U, ye, xe, "", "\\succapprox", !0);
G(U, ye, xe, "", "\\vartriangleright");
G(U, ye, xe, "", "\\trianglerighteq");
G(U, ye, xe, "", "\\Vdash", !0);
G(U, ye, xe, "", "\\shortmid");
G(U, ye, xe, "", "\\shortparallel");
G(U, ye, xe, "", "\\between", !0);
G(U, ye, xe, "", "\\pitchfork", !0);
G(U, ye, xe, "", "\\varpropto");
G(U, ye, xe, "", "\\blacktriangleleft");
G(U, ye, xe, "", "\\therefore", !0);
G(U, ye, xe, "", "\\backepsilon");
G(U, ye, xe, "", "\\blacktriangleright");
G(U, ye, xe, "", "\\because", !0);
G(U, ye, xe, "", "\\llless");
G(U, ye, xe, "", "\\gggtr");
G(U, ye, Ct, "", "\\lhd");
G(U, ye, Ct, "", "\\rhd");
G(U, ye, xe, "", "\\eqsim", !0);
G(U, ne, xe, "", "\\Join");
G(U, ye, xe, "", "\\Doteq", !0);
G(U, ye, Ct, "", "\\dotplus", !0);
G(U, ye, Ct, "", "\\smallsetminus");
G(U, ye, Ct, "", "\\Cap", !0);
G(U, ye, Ct, "", "\\Cup", !0);
G(U, ye, Ct, "", "\\doublebarwedge", !0);
G(U, ye, Ct, "", "\\boxminus", !0);
G(U, ye, Ct, "", "\\boxplus", !0);
G(U, ye, Ct, "", "\\divideontimes", !0);
G(U, ye, Ct, "", "\\ltimes", !0);
G(U, ye, Ct, "", "\\rtimes", !0);
G(U, ye, Ct, "", "\\leftthreetimes", !0);
G(U, ye, Ct, "", "\\rightthreetimes", !0);
G(U, ye, Ct, "", "\\curlywedge", !0);
G(U, ye, Ct, "", "\\curlyvee", !0);
G(U, ye, Ct, "", "\\circleddash", !0);
G(U, ye, Ct, "", "\\circledast", !0);
G(U, ye, Ct, "", "\\centerdot");
G(U, ye, Ct, "", "\\intercal", !0);
G(U, ye, Ct, "", "\\doublecap");
G(U, ye, Ct, "", "\\doublecup");
G(U, ye, Ct, "", "\\boxtimes", !0);
G(U, ye, xe, "", "\\dashrightarrow", !0);
G(U, ye, xe, "", "\\dashleftarrow", !0);
G(U, ye, xe, "", "\\leftleftarrows", !0);
G(U, ye, xe, "", "\\leftrightarrows", !0);
G(U, ye, xe, "", "\\Lleftarrow", !0);
G(U, ye, xe, "", "\\twoheadleftarrow", !0);
G(U, ye, xe, "", "\\leftarrowtail", !0);
G(U, ye, xe, "", "\\looparrowleft", !0);
G(U, ye, xe, "", "\\leftrightharpoons", !0);
G(U, ye, xe, "", "\\curvearrowleft", !0);
G(U, ye, xe, "", "\\circlearrowleft", !0);
G(U, ye, xe, "", "\\Lsh", !0);
G(U, ye, xe, "", "\\upuparrows", !0);
G(U, ye, xe, "", "\\upharpoonleft", !0);
G(U, ye, xe, "", "\\downharpoonleft", !0);
G(U, ne, xe, "", "\\origof", !0);
G(U, ne, xe, "", "\\imageof", !0);
G(U, ye, xe, "", "\\multimap", !0);
G(U, ye, xe, "", "\\leftrightsquigarrow", !0);
G(U, ye, xe, "", "\\rightrightarrows", !0);
G(U, ye, xe, "", "\\rightleftarrows", !0);
G(U, ye, xe, "", "\\twoheadrightarrow", !0);
G(U, ye, xe, "", "\\rightarrowtail", !0);
G(U, ye, xe, "", "\\looparrowright", !0);
G(U, ye, xe, "", "\\curvearrowright", !0);
G(U, ye, xe, "", "\\circlearrowright", !0);
G(U, ye, xe, "", "\\Rsh", !0);
G(U, ye, xe, "", "\\downdownarrows", !0);
G(U, ye, xe, "", "\\upharpoonright", !0);
G(U, ye, xe, "", "\\downharpoonright", !0);
G(U, ye, xe, "", "\\rightsquigarrow", !0);
G(U, ye, xe, "", "\\leadsto");
G(U, ye, xe, "", "\\Rrightarrow", !0);
G(U, ye, xe, "", "\\restriction");
G(U, ne, Le, "", "`");
G(U, ne, Le, "$", "\\$");
G(tt, ne, Le, "$", "\\$");
G(tt, ne, Le, "$", "\\textdollar");
G(U, ne, Le, "%", "\\%");
G(tt, ne, Le, "%", "\\%");
G(U, ne, Le, "_", "\\_");
G(tt, ne, Le, "_", "\\_");
G(tt, ne, Le, "_", "\\textunderscore");
G(U, ne, Le, "", "\\angle", !0);
G(U, ne, Le, "", "\\infty", !0);
G(U, ne, Le, "", "\\prime");
G(U, ne, Le, "", "\\triangle");
G(U, ne, Le, "", "\\Gamma", !0);
G(U, ne, Le, "", "\\Delta", !0);
G(U, ne, Le, "", "\\Theta", !0);
G(U, ne, Le, "", "\\Lambda", !0);
G(U, ne, Le, "", "\\Xi", !0);
G(U, ne, Le, "", "\\Pi", !0);
G(U, ne, Le, "", "\\Sigma", !0);
G(U, ne, Le, "", "\\Upsilon", !0);
G(U, ne, Le, "", "\\Phi", !0);
G(U, ne, Le, "", "\\Psi", !0);
G(U, ne, Le, "", "\\Omega", !0);
G(U, ne, Le, "A", "");
G(U, ne, Le, "B", "");
G(U, ne, Le, "E", "");
G(U, ne, Le, "Z", "");
G(U, ne, Le, "H", "");
G(U, ne, Le, "I", "");
G(U, ne, Le, "K", "");
G(U, ne, Le, "M", "");
G(U, ne, Le, "N", "");
G(U, ne, Le, "O", "");
G(U, ne, Le, "P", "");
G(U, ne, Le, "T", "");
G(U, ne, Le, "X", "");
G(U, ne, Le, "", "\\neg", !0);
G(U, ne, Le, "", "\\lnot");
G(U, ne, Le, "", "\\top");
G(U, ne, Le, "", "\\bot");
G(U, ne, Le, "", "\\emptyset");
G(U, ye, Le, "", "\\varnothing");
G(U, ne, $t, "", "\\alpha", !0);
G(U, ne, $t, "", "\\beta", !0);
G(U, ne, $t, "", "\\gamma", !0);
G(U, ne, $t, "", "\\delta", !0);
G(U, ne, $t, "", "\\epsilon", !0);
G(U, ne, $t, "", "\\zeta", !0);
G(U, ne, $t, "", "\\eta", !0);
G(U, ne, $t, "", "\\theta", !0);
G(U, ne, $t, "", "\\iota", !0);
G(U, ne, $t, "", "\\kappa", !0);
G(U, ne, $t, "", "\\lambda", !0);
G(U, ne, $t, "", "\\mu", !0);
G(U, ne, $t, "", "\\nu", !0);
G(U, ne, $t, "", "\\xi", !0);
G(U, ne, $t, "", "\\omicron", !0);
G(U, ne, $t, "", "\\pi", !0);
G(U, ne, $t, "", "\\rho", !0);
G(U, ne, $t, "", "\\sigma", !0);
G(U, ne, $t, "", "\\tau", !0);
G(U, ne, $t, "", "\\upsilon", !0);
G(U, ne, $t, "", "\\phi", !0);
G(U, ne, $t, "", "\\chi", !0);
G(U, ne, $t, "", "\\psi", !0);
G(U, ne, $t, "", "\\omega", !0);
G(U, ne, $t, "", "\\varepsilon", !0);
G(U, ne, $t, "", "\\vartheta", !0);
G(U, ne, $t, "", "\\varpi", !0);
G(U, ne, $t, "", "\\varrho", !0);
G(U, ne, $t, "", "\\varsigma", !0);
G(U, ne, $t, "", "\\varphi", !0);
G(U, ne, Ct, "", "*", !0);
G(U, ne, Ct, "+", "+");
G(U, ne, Ct, "", "-", !0);
G(U, ne, Ct, "", "\\cdot", !0);
G(U, ne, Ct, "", "\\circ", !0);
G(U, ne, Ct, "", "\\div", !0);
G(U, ne, Ct, "", "\\pm", !0);
G(U, ne, Ct, "", "\\times", !0);
G(U, ne, Ct, "", "\\cap", !0);
G(U, ne, Ct, "", "\\cup", !0);
G(U, ne, Ct, "", "\\setminus", !0);
G(U, ne, Ct, "", "\\land");
G(U, ne, Ct, "", "\\lor");
G(U, ne, Ct, "", "\\wedge", !0);
G(U, ne, Ct, "", "\\vee", !0);
G(U, ne, Le, "", "\\surd");
G(U, ne, Ra, "", "\\langle", !0);
G(U, ne, Ra, "", "\\lvert");
G(U, ne, Ra, "", "\\lVert");
G(U, ne, ji, "?", "?");
G(U, ne, ji, "!", "!");
G(U, ne, ji, "", "\\rangle", !0);
G(U, ne, ji, "", "\\rvert");
G(U, ne, ji, "", "\\rVert");
G(U, ne, xe, "=", "=");
G(U, ne, xe, ":", ":");
G(U, ne, xe, "", "\\approx", !0);
G(U, ne, xe, "", "\\cong", !0);
G(U, ne, xe, "", "\\ge");
G(U, ne, xe, "", "\\geq", !0);
G(U, ne, xe, "", "\\gets");
G(U, ne, xe, ">", "\\gt", !0);
G(U, ne, xe, "", "\\in", !0);
G(U, ne, xe, "", "\\@not");
G(U, ne, xe, "", "\\subset", !0);
G(U, ne, xe, "", "\\supset", !0);
G(U, ne, xe, "", "\\subseteq", !0);
G(U, ne, xe, "", "\\supseteq", !0);
G(U, ye, xe, "", "\\nsubseteq", !0);
G(U, ye, xe, "", "\\nsupseteq", !0);
G(U, ne, xe, "", "\\models");
G(U, ne, xe, "", "\\leftarrow", !0);
G(U, ne, xe, "", "\\le");
G(U, ne, xe, "", "\\leq", !0);
G(U, ne, xe, "<", "\\lt", !0);
G(U, ne, xe, "", "\\rightarrow", !0);
G(U, ne, xe, "", "\\to");
G(U, ye, xe, "", "\\ngeq", !0);
G(U, ye, xe, "", "\\nleq", !0);
G(U, ne, hl, "", "\\ ");
G(U, ne, hl, "", "\\space");
G(U, ne, hl, "", "\\nobreakspace");
G(tt, ne, hl, "", "\\ ");
G(tt, ne, hl, "", " ");
G(tt, ne, hl, "", "\\space");
G(tt, ne, hl, "", "\\nobreakspace");
G(U, ne, hl, null, "\\nobreak");
G(U, ne, hl, null, "\\allowbreak");
G(U, ne, dx, ",", ",");
G(U, ne, dx, ";", ";");
G(U, ye, Ct, "", "\\barwedge", !0);
G(U, ye, Ct, "", "\\veebar", !0);
G(U, ne, Ct, "", "\\odot", !0);
G(U, ne, Ct, "", "\\oplus", !0);
G(U, ne, Ct, "", "\\otimes", !0);
G(U, ne, Le, "", "\\partial", !0);
G(U, ne, Ct, "", "\\oslash", !0);
G(U, ye, Ct, "", "\\circledcirc", !0);
G(U, ye, Ct, "", "\\boxdot", !0);
G(U, ne, Ct, "", "\\bigtriangleup");
G(U, ne, Ct, "", "\\bigtriangledown");
G(U, ne, Ct, "", "\\dagger");
G(U, ne, Ct, "", "\\diamond");
G(U, ne, Ct, "", "\\star");
G(U, ne, Ct, "", "\\triangleleft");
G(U, ne, Ct, "", "\\triangleright");
G(U, ne, Ra, "{", "\\{");
G(tt, ne, Le, "{", "\\{");
G(tt, ne, Le, "{", "\\textbraceleft");
G(U, ne, ji, "}", "\\}");
G(tt, ne, Le, "}", "\\}");
G(tt, ne, Le, "}", "\\textbraceright");
G(U, ne, Ra, "{", "\\lbrace");
G(U, ne, ji, "}", "\\rbrace");
G(U, ne, Ra, "[", "\\lbrack", !0);
G(tt, ne, Le, "[", "\\lbrack", !0);
G(U, ne, ji, "]", "\\rbrack", !0);
G(tt, ne, Le, "]", "\\rbrack", !0);
G(U, ne, Ra, "(", "\\lparen", !0);
G(U, ne, ji, ")", "\\rparen", !0);
G(tt, ne, Le, "<", "\\textless", !0);
G(tt, ne, Le, ">", "\\textgreater", !0);
G(U, ne, Ra, "", "\\lfloor", !0);
G(U, ne, ji, "", "\\rfloor", !0);
G(U, ne, Ra, "", "\\lceil", !0);
G(U, ne, ji, "", "\\rceil", !0);
G(U, ne, Le, "\\", "\\backslash");
G(U, ne, Le, "", "|");
G(U, ne, Le, "", "\\vert");
G(tt, ne, Le, "|", "\\textbar", !0);
G(U, ne, Le, "", "\\|");
G(U, ne, Le, "", "\\Vert");
G(tt, ne, Le, "", "\\textbardbl");
G(tt, ne, Le, "~", "\\textasciitilde");
G(tt, ne, Le, "\\", "\\textbackslash");
G(tt, ne, Le, "^", "\\textasciicircum");
G(U, ne, xe, "", "\\uparrow", !0);
G(U, ne, xe, "", "\\Uparrow", !0);
G(U, ne, xe, "", "\\downarrow", !0);
G(U, ne, xe, "", "\\Downarrow", !0);
G(U, ne, xe, "", "\\updownarrow", !0);
G(U, ne, xe, "", "\\Updownarrow", !0);
G(U, ne, Rn, "", "\\coprod");
G(U, ne, Rn, "", "\\bigvee");
G(U, ne, Rn, "", "\\bigwedge");
G(U, ne, Rn, "", "\\biguplus");
G(U, ne, Rn, "", "\\bigcap");
G(U, ne, Rn, "", "\\bigcup");
G(U, ne, Rn, "", "\\int");
G(U, ne, Rn, "", "\\intop");
G(U, ne, Rn, "", "\\iint");
G(U, ne, Rn, "", "\\iiint");
G(U, ne, Rn, "", "\\prod");
G(U, ne, Rn, "", "\\sum");
G(U, ne, Rn, "", "\\bigotimes");
G(U, ne, Rn, "", "\\bigoplus");
G(U, ne, Rn, "", "\\bigodot");
G(U, ne, Rn, "", "\\oint");
G(U, ne, Rn, "", "\\oiint");
G(U, ne, Rn, "", "\\oiiint");
G(U, ne, Rn, "", "\\bigsqcup");
G(U, ne, Rn, "", "\\smallint");
G(tt, ne, Qd, "", "\\textellipsis");
G(U, ne, Qd, "", "\\mathellipsis");
G(tt, ne, Qd, "", "\\ldots", !0);
G(U, ne, Qd, "", "\\ldots", !0);
G(U, ne, Qd, "", "\\@cdots", !0);
G(U, ne, Qd, "", "\\ddots", !0);
G(U, ne, Le, "", "\\varvdots");
G(tt, ne, Le, "", "\\varvdots");
G(U, ne, Qr, "", "\\acute");
G(U, ne, Qr, "", "\\grave");
G(U, ne, Qr, "", "\\ddot");
G(U, ne, Qr, "~", "\\tilde");
G(U, ne, Qr, "", "\\bar");
G(U, ne, Qr, "", "\\breve");
G(U, ne, Qr, "", "\\check");
G(U, ne, Qr, "^", "\\hat");
G(U, ne, Qr, "", "\\vec");
G(U, ne, Qr, "", "\\dot");
G(U, ne, Qr, "", "\\mathring");
G(U, ne, $t, "", "\\@imath");
G(U, ne, $t, "", "\\@jmath");
G(U, ne, Le, "", "");
G(U, ne, Le, "", "");
G(tt, ne, Le, "", "\\i", !0);
G(tt, ne, Le, "", "\\j", !0);
G(tt, ne, Le, "", "\\ss", !0);
G(tt, ne, Le, "", "\\ae", !0);
G(tt, ne, Le, "", "\\oe", !0);
G(tt, ne, Le, "", "\\o", !0);
G(tt, ne, Le, "", "\\AE", !0);
G(tt, ne, Le, "", "\\OE", !0);
G(tt, ne, Le, "", "\\O", !0);
G(tt, ne, Qr, "", "\\'");
G(tt, ne, Qr, "", "\\`");
G(tt, ne, Qr, "", "\\^");
G(tt, ne, Qr, "", "\\~");
G(tt, ne, Qr, "", "\\=");
G(tt, ne, Qr, "", "\\u");
G(tt, ne, Qr, "", "\\.");
G(tt, ne, Qr, "", "\\c");
G(tt, ne, Qr, "", "\\r");
G(tt, ne, Qr, "", "\\v");
G(tt, ne, Qr, "", '\\"');
G(tt, ne, Qr, "", "\\H");
G(tt, ne, Qr, "", "\\textcircled");
var Sz = {
  "--": !0,
  "---": !0,
  "``": !0,
  "''": !0
};
G(tt, ne, Le, "", "--", !0);
G(tt, ne, Le, "", "\\textendash");
G(tt, ne, Le, "", "---", !0);
G(tt, ne, Le, "", "\\textemdash");
G(tt, ne, Le, "", "`", !0);
G(tt, ne, Le, "", "\\textquoteleft");
G(tt, ne, Le, "", "'", !0);
G(tt, ne, Le, "", "\\textquoteright");
G(tt, ne, Le, "", "``", !0);
G(tt, ne, Le, "", "\\textquotedblleft");
G(tt, ne, Le, "", "''", !0);
G(tt, ne, Le, "", "\\textquotedblright");
G(U, ne, Le, "", "\\degree", !0);
G(tt, ne, Le, "", "\\degree");
G(tt, ne, Le, "", "\\textdegree", !0);
G(U, ne, Le, "", "\\pounds");
G(U, ne, Le, "", "\\mathsterling", !0);
G(tt, ne, Le, "", "\\pounds");
G(tt, ne, Le, "", "\\textsterling", !0);
G(U, ye, Le, "", "\\maltese");
G(tt, ye, Le, "", "\\maltese");
var eA = '0123456789/@."';
for (var d4 = 0; d4 < eA.length; d4++) {
  var tA = eA.charAt(d4);
  G(U, ne, Le, tA, tA);
}
var rA = '0123456789!@*()-=+";:?/.,';
for (var f4 = 0; f4 < rA.length; f4++) {
  var nA = rA.charAt(f4);
  G(tt, ne, Le, nA, nA);
}
var my = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (var p4 = 0; p4 < my.length; p4++) {
  var v1 = my.charAt(p4);
  G(U, ne, $t, v1, v1), G(tt, ne, Le, v1, v1);
}
G(U, ye, Le, "C", "");
G(tt, ye, Le, "C", "");
G(U, ye, Le, "H", "");
G(tt, ye, Le, "H", "");
G(U, ye, Le, "N", "");
G(tt, ye, Le, "N", "");
G(U, ye, Le, "P", "");
G(tt, ye, Le, "P", "");
G(U, ye, Le, "Q", "");
G(tt, ye, Le, "Q", "");
G(U, ye, Le, "R", "");
G(tt, ye, Le, "R", "");
G(U, ye, Le, "Z", "");
G(tt, ye, Le, "Z", "");
G(U, ne, $t, "h", "");
G(tt, ne, $t, "h", "");
var Yt = "";
for (var Mi = 0; Mi < my.length; Mi++) {
  var on = my.charAt(Mi);
  Yt = String.fromCharCode(55349, 56320 + Mi), G(U, ne, $t, on, Yt), G(tt, ne, Le, on, Yt), Yt = String.fromCharCode(55349, 56372 + Mi), G(U, ne, $t, on, Yt), G(tt, ne, Le, on, Yt), Yt = String.fromCharCode(55349, 56424 + Mi), G(U, ne, $t, on, Yt), G(tt, ne, Le, on, Yt), Yt = String.fromCharCode(55349, 56580 + Mi), G(U, ne, $t, on, Yt), G(tt, ne, Le, on, Yt), Yt = String.fromCharCode(55349, 56684 + Mi), G(U, ne, $t, on, Yt), G(tt, ne, Le, on, Yt), Yt = String.fromCharCode(55349, 56736 + Mi), G(U, ne, $t, on, Yt), G(tt, ne, Le, on, Yt), Yt = String.fromCharCode(55349, 56788 + Mi), G(U, ne, $t, on, Yt), G(tt, ne, Le, on, Yt), Yt = String.fromCharCode(55349, 56840 + Mi), G(U, ne, $t, on, Yt), G(tt, ne, Le, on, Yt), Yt = String.fromCharCode(55349, 56944 + Mi), G(U, ne, $t, on, Yt), G(tt, ne, Le, on, Yt), Mi < 26 && (Yt = String.fromCharCode(55349, 56632 + Mi), G(U, ne, $t, on, Yt), G(tt, ne, Le, on, Yt), Yt = String.fromCharCode(55349, 56476 + Mi), G(U, ne, $t, on, Yt), G(tt, ne, Le, on, Yt));
}
Yt = "";
G(U, ne, $t, "k", Yt);
G(tt, ne, Le, "k", Yt);
for (var Pc = 0; Pc < 10; Pc++) {
  var wl = Pc.toString();
  Yt = String.fromCharCode(55349, 57294 + Pc), G(U, ne, $t, wl, Yt), G(tt, ne, Le, wl, Yt), Yt = String.fromCharCode(55349, 57314 + Pc), G(U, ne, $t, wl, Yt), G(tt, ne, Le, wl, Yt), Yt = String.fromCharCode(55349, 57324 + Pc), G(U, ne, $t, wl, Yt), G(tt, ne, Le, wl, Yt), Yt = String.fromCharCode(55349, 57334 + Pc), G(U, ne, $t, wl, Yt), G(tt, ne, Le, wl, Yt);
}
var iT = "";
for (var g4 = 0; g4 < iT.length; g4++) {
  var y1 = iT.charAt(g4);
  G(U, ne, $t, y1, y1), G(tt, ne, Le, y1, y1);
}
var x1 = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  // Note that we are using a bold font, but font metrics for regular Fraktur.
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // A-Z bold Fraktur
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // a-z bold Fraktur
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
], iA = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
], Ife = function(e, r) {
  var n = e.charCodeAt(0), i = e.charCodeAt(1), a = (n - 55296) * 1024 + (i - 56320) + 65536, s = r === "math" ? 0 : 1;
  if (119808 <= a && a < 120484) {
    var o = Math.floor((a - 119808) / 26);
    return [x1[o][2], x1[o][s]];
  } else if (120782 <= a && a <= 120831) {
    var l = Math.floor((a - 120782) / 10);
    return [iA[l][2], iA[l][s]];
  } else {
    if (a === 120485 || a === 120486)
      return [x1[0][2], x1[0][s]];
    if (120486 < a && a < 120782)
      return ["", ""];
    throw new ot("Unsupported character: " + e);
  }
}, fx = function(e, r, n) {
  return Gr[n][e] && Gr[n][e].replace && (e = Gr[n][e].replace), {
    value: e,
    metrics: pk(e, r, n)
  };
}, us = function(e, r, n, i, a) {
  var s = fx(e, r, n), o = s.metrics;
  e = s.value;
  var l;
  if (o) {
    var u = o.italic;
    (n === "text" || i && i.font === "mathit") && (u = 0), l = new es(e, o.height, o.depth, u, o.skew, o.width, a);
  } else
    typeof console < "u" && console.warn("No character metrics " + ("for '" + e + "' in style '" + r + "' and mode '" + n + "'")), l = new es(e, 0, 0, 0, 0, 0, a);
  if (i) {
    l.maxFontSize = i.sizeMultiplier, i.style.isTight() && l.classes.push("mtight");
    var h = i.getColor();
    h && (l.style.color = h);
  }
  return l;
}, Dfe = function(e, r, n, i) {
  return i === void 0 && (i = []), n.font === "boldsymbol" && fx(e, "Main-Bold", r).metrics ? us(e, "Main-Bold", r, n, i.concat(["mathbf"])) : e === "\\" || Gr[r][e].font === "main" ? us(e, "Main-Regular", r, n, i) : us(e, "AMS-Regular", r, n, i.concat(["amsrm"]));
}, Ofe = function(e, r, n, i, a) {
  return a !== "textord" && fx(e, "Math-BoldItalic", r).metrics ? {
    fontName: "Math-BoldItalic",
    fontClass: "boldsymbol"
  } : {
    fontName: "Main-Bold",
    fontClass: "mathbf"
  };
}, Pfe = function(e, r, n) {
  var i = e.mode, a = e.text, s = ["mord"], o = i === "math" || i === "text" && r.font, l = o ? r.font : r.fontFamily, u = "", h = "";
  if (a.charCodeAt(0) === 55349 && ([u, h] = Ife(a, i)), u.length > 0)
    return us(a, u, i, r, s.concat(h));
  if (l) {
    var d, f;
    if (l === "boldsymbol") {
      var p = Ofe(a, i, r, s, n);
      d = p.fontName, f = [p.fontClass];
    } else o ? (d = _z[l].fontName, f = [l]) : (d = b1(l, r.fontWeight, r.fontShape), f = [l, r.fontWeight, r.fontShape]);
    if (fx(a, d, i).metrics)
      return us(a, d, i, r, s.concat(f));
    if (Sz.hasOwnProperty(a) && d.slice(0, 10) === "Typewriter") {
      for (var g = [], m = 0; m < a.length; m++)
        g.push(us(a[m], d, i, r, s.concat(f)));
      return Az(g);
    }
  }
  if (n === "mathord")
    return us(a, "Math-Italic", i, r, s.concat(["mathnormal"]));
  if (n === "textord") {
    var v = Gr[i][a] && Gr[i][a].font;
    if (v === "ams") {
      var y = b1("amsrm", r.fontWeight, r.fontShape);
      return us(a, y, i, r, s.concat("amsrm", r.fontWeight, r.fontShape));
    } else if (v === "main" || !v) {
      var b = b1("textrm", r.fontWeight, r.fontShape);
      return us(a, b, i, r, s.concat(r.fontWeight, r.fontShape));
    } else {
      var w = b1(v, r.fontWeight, r.fontShape);
      return us(a, w, i, r, s.concat(w, r.fontWeight, r.fontShape));
    }
  } else
    throw new Error("unexpected type: " + n + " in makeOrd");
}, Bfe = (t, e) => {
  if (Xl(t.classes) !== Xl(e.classes) || t.skew !== e.skew || t.maxFontSize !== e.maxFontSize)
    return !1;
  if (t.classes.length === 1) {
    var r = t.classes[0];
    if (r === "mbin" || r === "mord")
      return !1;
  }
  for (var n in t.style)
    if (t.style.hasOwnProperty(n) && t.style[n] !== e.style[n])
      return !1;
  for (var i in e.style)
    if (e.style.hasOwnProperty(i) && t.style[i] !== e.style[i])
      return !1;
  return !0;
}, Ffe = (t) => {
  for (var e = 0; e < t.length - 1; e++) {
    var r = t[e], n = t[e + 1];
    r instanceof es && n instanceof es && Bfe(r, n) && (r.text += n.text, r.height = Math.max(r.height, n.height), r.depth = Math.max(r.depth, n.depth), r.italic = n.italic, t.splice(e + 1, 1), e--);
  }
  return t;
}, mk = function(e) {
  for (var r = 0, n = 0, i = 0, a = 0; a < e.children.length; a++) {
    var s = e.children[a];
    s.height > r && (r = s.height), s.depth > n && (n = s.depth), s.maxFontSize > i && (i = s.maxFontSize);
  }
  e.height = r, e.depth = n, e.maxFontSize = i;
}, ea = function(e, r, n, i) {
  var a = new yg(e, r, n, i);
  return mk(a), a;
}, Cz = (t, e, r, n) => new yg(t, e, r, n), $fe = function(e, r, n) {
  var i = ea([e], [], r);
  return i.height = Math.max(n || r.fontMetrics().defaultRuleThickness, r.minRuleThickness), i.style.borderBottomWidth = pt(i.height), i.maxFontSize = 1, i;
}, zfe = function(e, r, n, i) {
  var a = new gk(e, r, n, i);
  return mk(a), a;
}, Az = function(e) {
  var r = new vg(e);
  return mk(r), r;
}, Gfe = function(e, r) {
  return e instanceof vg ? ea([], [e], r) : e;
}, Vfe = function(e) {
  if (e.positionType === "individualShift") {
    for (var r = e.children, n = [r[0]], i = -r[0].shift - r[0].elem.depth, a = i, s = 1; s < r.length; s++) {
      var o = -r[s].shift - a - r[s].elem.depth, l = o - (r[s - 1].elem.height + r[s - 1].elem.depth);
      a = a + o, n.push({
        type: "kern",
        size: l
      }), n.push(r[s]);
    }
    return {
      children: n,
      depth: i
    };
  }
  var u;
  if (e.positionType === "top") {
    for (var h = e.positionData, d = 0; d < e.children.length; d++) {
      var f = e.children[d];
      h -= f.type === "kern" ? f.size : f.elem.height + f.elem.depth;
    }
    u = h;
  } else if (e.positionType === "bottom")
    u = -e.positionData;
  else {
    var p = e.children[0];
    if (p.type !== "elem")
      throw new Error('First child must have type "elem".');
    if (e.positionType === "shift")
      u = -p.elem.depth - e.positionData;
    else if (e.positionType === "firstBaseline")
      u = -p.elem.depth;
    else
      throw new Error("Invalid positionType " + e.positionType + ".");
  }
  return {
    children: e.children,
    depth: u
  };
}, Ufe = function(e, r) {
  for (var {
    children: n,
    depth: i
  } = Vfe(e), a = 0, s = 0; s < n.length; s++) {
    var o = n[s];
    if (o.type === "elem") {
      var l = o.elem;
      a = Math.max(a, l.maxFontSize, l.height);
    }
  }
  a += 2;
  var u = ea(["pstrut"], []);
  u.style.height = pt(a);
  for (var h = [], d = i, f = i, p = i, g = 0; g < n.length; g++) {
    var m = n[g];
    if (m.type === "kern")
      p += m.size;
    else {
      var v = m.elem, y = m.wrapperClasses || [], b = m.wrapperStyle || {}, w = ea(y, [u, v], void 0, b);
      w.style.top = pt(-a - p - v.depth), m.marginLeft && (w.style.marginLeft = m.marginLeft), m.marginRight && (w.style.marginRight = m.marginRight), h.push(w), p += v.height + v.depth;
    }
    d = Math.min(d, p), f = Math.max(f, p);
  }
  var T = ea(["vlist"], h);
  T.style.height = pt(f);
  var E;
  if (d < 0) {
    var L = ea([], []), k = ea(["vlist"], [L]);
    k.style.height = pt(-d);
    var C = ea(["vlist-s"], [new es("")]);
    E = [ea(["vlist-r"], [T, C]), ea(["vlist-r"], [k])];
  } else
    E = [ea(["vlist-r"], [T])];
  var A = ea(["vlist-t"], E);
  return E.length === 2 && A.classes.push("vlist-t2"), A.height = f, A.depth = -d, A;
}, Hfe = (t, e) => {
  var r = ea(["mspace"], [], e), n = tn(t, e);
  return r.style.marginRight = pt(n), r;
}, b1 = function(e, r, n) {
  var i = "";
  switch (e) {
    case "amsrm":
      i = "AMS";
      break;
    case "textrm":
      i = "Main";
      break;
    case "textsf":
      i = "SansSerif";
      break;
    case "texttt":
      i = "Typewriter";
      break;
    default:
      i = e;
  }
  var a;
  return r === "textbf" && n === "textit" ? a = "BoldItalic" : r === "textbf" ? a = "Bold" : r === "textit" ? a = "Italic" : a = "Regular", i + "-" + a;
}, _z = {
  // styles
  mathbf: {
    variant: "bold",
    fontName: "Main-Bold"
  },
  mathrm: {
    variant: "normal",
    fontName: "Main-Regular"
  },
  textit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathnormal: {
    variant: "italic",
    fontName: "Math-Italic"
  },
  mathsfit: {
    variant: "sans-serif-italic",
    fontName: "SansSerif-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  mathbb: {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  mathcal: {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  mathfrak: {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  mathscr: {
    variant: "script",
    fontName: "Script-Regular"
  },
  mathsf: {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  mathtt: {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
}, Lz = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
}, qfe = function(e, r) {
  var [n, i, a] = Lz[e], s = new jl(n), o = new el([s], {
    width: pt(i),
    height: pt(a),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + pt(i),
    viewBox: "0 0 " + 1e3 * i + " " + 1e3 * a,
    preserveAspectRatio: "xMinYMin"
  }), l = Cz(["overlay"], [o], r);
  return l.height = a, l.style.height = pt(a), l.style.width = pt(i), l;
}, Be = {
  fontMap: _z,
  makeSymbol: us,
  mathsym: Dfe,
  makeSpan: ea,
  makeSvgSpan: Cz,
  makeLineSpan: $fe,
  makeAnchor: zfe,
  makeFragment: Az,
  wrapFragment: Gfe,
  makeVList: Ufe,
  makeOrd: Pfe,
  makeGlue: Hfe,
  staticSvg: qfe,
  svgData: Lz,
  tryCombineChars: Ffe
}, en = {
  number: 3,
  unit: "mu"
}, Bc = {
  number: 4,
  unit: "mu"
}, So = {
  number: 5,
  unit: "mu"
}, Wfe = {
  mord: {
    mop: en,
    mbin: Bc,
    mrel: So,
    minner: en
  },
  mop: {
    mord: en,
    mop: en,
    mrel: So,
    minner: en
  },
  mbin: {
    mord: Bc,
    mop: Bc,
    mopen: Bc,
    minner: Bc
  },
  mrel: {
    mord: So,
    mop: So,
    mopen: So,
    minner: So
  },
  mopen: {},
  mclose: {
    mop: en,
    mbin: Bc,
    mrel: So,
    minner: en
  },
  mpunct: {
    mord: en,
    mop: en,
    mrel: So,
    mopen: en,
    mclose: en,
    mpunct: en,
    minner: en
  },
  minner: {
    mord: en,
    mop: en,
    mbin: Bc,
    mrel: So,
    mopen: en,
    mpunct: en,
    minner: en
  }
}, Yfe = {
  mord: {
    mop: en
  },
  mop: {
    mord: en,
    mop: en
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: en
  },
  mpunct: {},
  minner: {
    mop: en
  }
}, Rz = {}, vy = {}, yy = {};
function Tt(t) {
  for (var {
    type: e,
    names: r,
    props: n,
    handler: i,
    htmlBuilder: a,
    mathmlBuilder: s
  } = t, o = {
    type: e,
    numArgs: n.numArgs,
    argTypes: n.argTypes,
    allowedInArgument: !!n.allowedInArgument,
    allowedInText: !!n.allowedInText,
    allowedInMath: n.allowedInMath === void 0 ? !0 : n.allowedInMath,
    numOptionalArgs: n.numOptionalArgs || 0,
    infix: !!n.infix,
    primitive: !!n.primitive,
    handler: i
  }, l = 0; l < r.length; ++l)
    Rz[r[l]] = o;
  e && (a && (vy[e] = a), s && (yy[e] = s));
}
function Zu(t) {
  var {
    type: e,
    htmlBuilder: r,
    mathmlBuilder: n
  } = t;
  Tt({
    type: e,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: r,
    mathmlBuilder: n
  });
}
var xy = function(e) {
  return e.type === "ordgroup" && e.body.length === 1 ? e.body[0] : e;
}, xn = function(e) {
  return e.type === "ordgroup" ? e.body : [e];
}, tl = Be.makeSpan, Xfe = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"], jfe = ["rightmost", "mrel", "mclose", "mpunct"], Kfe = {
  display: zt.DISPLAY,
  text: zt.TEXT,
  script: zt.SCRIPT,
  scriptscript: zt.SCRIPTSCRIPT
}, Zfe = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
}, $n = function(e, r, n, i) {
  i === void 0 && (i = [null, null]);
  for (var a = [], s = 0; s < e.length; s++) {
    var o = vr(e[s], r);
    if (o instanceof vg) {
      var l = o.children;
      a.push(...l);
    } else
      a.push(o);
  }
  if (Be.tryCombineChars(a), !n)
    return a;
  var u = r;
  if (e.length === 1) {
    var h = e[0];
    h.type === "sizing" ? u = r.havingSize(h.size) : h.type === "styling" && (u = r.havingStyle(Kfe[h.style]));
  }
  var d = tl([i[0] || "leftmost"], [], r), f = tl([i[1] || "rightmost"], [], r), p = n === "root";
  return aA(a, (g, m) => {
    var v = m.classes[0], y = g.classes[0];
    v === "mbin" && jfe.includes(y) ? m.classes[0] = "mord" : y === "mbin" && Xfe.includes(v) && (g.classes[0] = "mord");
  }, {
    node: d
  }, f, p), aA(a, (g, m) => {
    var v = aT(m), y = aT(g), b = v && y ? g.hasClass("mtight") ? Yfe[v][y] : Wfe[v][y] : null;
    if (b)
      return Be.makeGlue(b, u);
  }, {
    node: d
  }, f, p), a;
}, aA = function t(e, r, n, i, a) {
  i && e.push(i);
  for (var s = 0; s < e.length; s++) {
    var o = e[s], l = Mz(o);
    if (l) {
      t(l.children, r, n, null, a);
      continue;
    }
    var u = !o.hasClass("mspace");
    if (u) {
      var h = r(o, n.node);
      h && (n.insertAfter ? n.insertAfter(h) : (e.unshift(h), s++));
    }
    u ? n.node = o : a && o.hasClass("newline") && (n.node = tl(["leftmost"])), n.insertAfter = /* @__PURE__ */ ((d) => (f) => {
      e.splice(d + 1, 0, f), s++;
    })(s);
  }
  i && e.pop();
}, Mz = function(e) {
  return e instanceof vg || e instanceof gk || e instanceof yg && e.hasClass("enclosing") ? e : null;
}, Qfe = function t(e, r) {
  var n = Mz(e);
  if (n) {
    var i = n.children;
    if (i.length) {
      if (r === "right")
        return t(i[i.length - 1], "right");
      if (r === "left")
        return t(i[0], "left");
    }
  }
  return e;
}, aT = function(e, r) {
  return e ? (r && (e = Qfe(e, r)), Zfe[e.classes[0]] || null) : null;
}, Lp = function(e, r) {
  var n = ["nulldelimiter"].concat(e.baseSizingClasses());
  return tl(r.concat(n));
}, vr = function(e, r, n) {
  if (!e)
    return tl();
  if (vy[e.type]) {
    var i = vy[e.type](e, r);
    if (n && r.size !== n.size) {
      i = tl(r.sizingClasses(n), [i], r);
      var a = r.sizeMultiplier / n.sizeMultiplier;
      i.height *= a, i.depth *= a;
    }
    return i;
  } else
    throw new ot("Got group of unknown type: '" + e.type + "'");
};
function w1(t, e) {
  var r = tl(["base"], t, e), n = tl(["strut"]);
  return n.style.height = pt(r.height + r.depth), r.depth && (n.style.verticalAlign = pt(-r.depth)), r.children.unshift(n), r;
}
function sT(t, e) {
  var r = null;
  t.length === 1 && t[0].type === "tag" && (r = t[0].tag, t = t[0].body);
  var n = $n(t, e, "root"), i;
  n.length === 2 && n[1].hasClass("tag") && (i = n.pop());
  for (var a = [], s = [], o = 0; o < n.length; o++)
    if (s.push(n[o]), n[o].hasClass("mbin") || n[o].hasClass("mrel") || n[o].hasClass("allowbreak")) {
      for (var l = !1; o < n.length - 1 && n[o + 1].hasClass("mspace") && !n[o + 1].hasClass("newline"); )
        o++, s.push(n[o]), n[o].hasClass("nobreak") && (l = !0);
      l || (a.push(w1(s, e)), s = []);
    } else n[o].hasClass("newline") && (s.pop(), s.length > 0 && (a.push(w1(s, e)), s = []), a.push(n[o]));
  s.length > 0 && a.push(w1(s, e));
  var u;
  r ? (u = w1($n(r, e, !0)), u.classes = ["tag"], a.push(u)) : i && a.push(i);
  var h = tl(["katex-html"], a);
  if (h.setAttribute("aria-hidden", "true"), u) {
    var d = u.children[0];
    d.style.height = pt(h.height + h.depth), h.depth && (d.style.verticalAlign = pt(-h.depth));
  }
  return h;
}
function Nz(t) {
  return new vg(t);
}
class wa {
  constructor(e, r, n) {
    this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = e, this.attributes = {}, this.children = r || [], this.classes = n || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(e, r) {
    this.attributes[e] = r;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(e) {
    return this.attributes[e];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && e.setAttribute(r, this.attributes[r]);
    this.classes.length > 0 && (e.className = Xl(this.classes));
    for (var n = 0; n < this.children.length; n++)
      if (this.children[n] instanceof Xs && this.children[n + 1] instanceof Xs) {
        for (var i = this.children[n].toText() + this.children[++n].toText(); this.children[n + 1] instanceof Xs; )
          i += this.children[++n].toText();
        e.appendChild(new Xs(i).toNode());
      } else
        e.appendChild(this.children[n].toNode());
    return e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var e = "<" + this.type;
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && (e += " " + r + '="', e += Tr.escape(this.attributes[r]), e += '"');
    this.classes.length > 0 && (e += ' class ="' + Tr.escape(Xl(this.classes)) + '"'), e += ">";
    for (var n = 0; n < this.children.length; n++)
      e += this.children[n].toMarkup();
    return e += "</" + this.type + ">", e;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((e) => e.toText()).join("");
  }
}
class Xs {
  constructor(e) {
    this.text = void 0, this.text = e;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return Tr.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}
class Jfe {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(e) {
    this.width = void 0, this.character = void 0, this.width = e, e >= 0.05555 && e <= 0.05556 ? this.character = "" : e >= 0.1666 && e <= 0.1667 ? this.character = "" : e >= 0.2222 && e <= 0.2223 ? this.character = "" : e >= 0.2777 && e <= 0.2778 ? this.character = "" : e >= -0.05556 && e <= -0.05555 ? this.character = "" : e >= -0.1667 && e <= -0.1666 ? this.character = "" : e >= -0.2223 && e <= -0.2222 ? this.character = "" : e >= -0.2778 && e <= -0.2777 ? this.character = "" : this.character = null;
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character)
      return document.createTextNode(this.character);
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
    return e.setAttribute("width", pt(this.width)), e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + pt(this.width) + '"/>';
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    return this.character ? this.character : " ";
  }
}
var it = {
  MathNode: wa,
  TextNode: Xs,
  SpaceNode: Jfe,
  newDocumentFragment: Nz
}, ts = function(e, r, n) {
  return Gr[r][e] && Gr[r][e].replace && e.charCodeAt(0) !== 55349 && !(Sz.hasOwnProperty(e) && n && (n.fontFamily && n.fontFamily.slice(4, 6) === "tt" || n.font && n.font.slice(4, 6) === "tt")) && (e = Gr[r][e].replace), new it.TextNode(e);
}, vk = function(e) {
  return e.length === 1 ? e[0] : new it.MathNode("mrow", e);
}, yk = function(e, r) {
  if (r.fontFamily === "texttt")
    return "monospace";
  if (r.fontFamily === "textsf")
    return r.fontShape === "textit" && r.fontWeight === "textbf" ? "sans-serif-bold-italic" : r.fontShape === "textit" ? "sans-serif-italic" : r.fontWeight === "textbf" ? "bold-sans-serif" : "sans-serif";
  if (r.fontShape === "textit" && r.fontWeight === "textbf")
    return "bold-italic";
  if (r.fontShape === "textit")
    return "italic";
  if (r.fontWeight === "textbf")
    return "bold";
  var n = r.font;
  if (!n || n === "mathnormal")
    return null;
  var i = e.mode;
  if (n === "mathit")
    return "italic";
  if (n === "boldsymbol")
    return e.type === "textord" ? "bold" : "bold-italic";
  if (n === "mathbf")
    return "bold";
  if (n === "mathbb")
    return "double-struck";
  if (n === "mathsfit")
    return "sans-serif-italic";
  if (n === "mathfrak")
    return "fraktur";
  if (n === "mathscr" || n === "mathcal")
    return "script";
  if (n === "mathsf")
    return "sans-serif";
  if (n === "mathtt")
    return "monospace";
  var a = e.text;
  if (["\\imath", "\\jmath"].includes(a))
    return null;
  Gr[i][a] && Gr[i][a].replace && (a = Gr[i][a].replace);
  var s = Be.fontMap[n].fontName;
  return pk(a, s, i) ? Be.fontMap[n].variant : null;
};
function m4(t) {
  if (!t)
    return !1;
  if (t.type === "mi" && t.children.length === 1) {
    var e = t.children[0];
    return e instanceof Xs && e.text === ".";
  } else if (t.type === "mo" && t.children.length === 1 && t.getAttribute("separator") === "true" && t.getAttribute("lspace") === "0em" && t.getAttribute("rspace") === "0em") {
    var r = t.children[0];
    return r instanceof Xs && r.text === ",";
  } else
    return !1;
}
var da = function(e, r, n) {
  if (e.length === 1) {
    var i = Pr(e[0], r);
    return n && i instanceof wa && i.type === "mo" && (i.setAttribute("lspace", "0em"), i.setAttribute("rspace", "0em")), [i];
  }
  for (var a = [], s, o = 0; o < e.length; o++) {
    var l = Pr(e[o], r);
    if (l instanceof wa && s instanceof wa) {
      if (l.type === "mtext" && s.type === "mtext" && l.getAttribute("mathvariant") === s.getAttribute("mathvariant")) {
        s.children.push(...l.children);
        continue;
      } else if (l.type === "mn" && s.type === "mn") {
        s.children.push(...l.children);
        continue;
      } else if (m4(l) && s.type === "mn") {
        s.children.push(...l.children);
        continue;
      } else if (l.type === "mn" && m4(s))
        l.children = [...s.children, ...l.children], a.pop();
      else if ((l.type === "msup" || l.type === "msub") && l.children.length >= 1 && (s.type === "mn" || m4(s))) {
        var u = l.children[0];
        u instanceof wa && u.type === "mn" && (u.children = [...s.children, ...u.children], a.pop());
      } else if (s.type === "mi" && s.children.length === 1) {
        var h = s.children[0];
        if (h instanceof Xs && h.text === "" && (l.type === "mo" || l.type === "mi" || l.type === "mn")) {
          var d = l.children[0];
          d instanceof Xs && d.text.length > 0 && (d.text = d.text.slice(0, 1) + "" + d.text.slice(1), a.pop());
        }
      }
    }
    a.push(l), s = l;
  }
  return a;
}, Kl = function(e, r, n) {
  return vk(da(e, r, n));
}, Pr = function(e, r) {
  if (!e)
    return new it.MathNode("mrow");
  if (yy[e.type]) {
    var n = yy[e.type](e, r);
    return n;
  } else
    throw new ot("Got group of unknown type: '" + e.type + "'");
};
function sA(t, e, r, n, i) {
  var a = da(t, r), s;
  a.length === 1 && a[0] instanceof wa && ["mrow", "mtable"].includes(a[0].type) ? s = a[0] : s = new it.MathNode("mrow", a);
  var o = new it.MathNode("annotation", [new it.TextNode(e)]);
  o.setAttribute("encoding", "application/x-tex");
  var l = new it.MathNode("semantics", [s, o]), u = new it.MathNode("math", [l]);
  u.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), n && u.setAttribute("display", "block");
  var h = i ? "katex" : "katex-mathml";
  return Be.makeSpan([h], [u]);
}
var Iz = function(e) {
  return new Io({
    style: e.displayMode ? zt.DISPLAY : zt.TEXT,
    maxSize: e.maxSize,
    minRuleThickness: e.minRuleThickness
  });
}, Dz = function(e, r) {
  if (r.displayMode) {
    var n = ["katex-display"];
    r.leqno && n.push("leqno"), r.fleqn && n.push("fleqn"), e = Be.makeSpan(n, [e]);
  }
  return e;
}, e0e = function(e, r, n) {
  var i = Iz(n), a;
  if (n.output === "mathml")
    return sA(e, r, i, n.displayMode, !0);
  if (n.output === "html") {
    var s = sT(e, i);
    a = Be.makeSpan(["katex"], [s]);
  } else {
    var o = sA(e, r, i, n.displayMode, !1), l = sT(e, i);
    a = Be.makeSpan(["katex"], [o, l]);
  }
  return Dz(a, n);
}, t0e = function(e, r, n) {
  var i = Iz(n), a = sT(e, i), s = Be.makeSpan(["katex"], [a]);
  return Dz(s, n);
}, r0e = {
  widehat: "^",
  widecheck: "",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "",
  underleftarrow: "",
  xleftarrow: "",
  overrightarrow: "",
  underrightarrow: "",
  xrightarrow: "",
  underbrace: "",
  overbrace: "",
  overgroup: "",
  undergroup: "",
  overleftrightarrow: "",
  underleftrightarrow: "",
  xleftrightarrow: "",
  Overrightarrow: "",
  xRightarrow: "",
  overleftharpoon: "",
  xleftharpoonup: "",
  overrightharpoon: "",
  xrightharpoonup: "",
  xLeftarrow: "",
  xLeftrightarrow: "",
  xhookleftarrow: "",
  xhookrightarrow: "",
  xmapsto: "",
  xrightharpoondown: "",
  xleftharpoondown: "",
  xrightleftharpoons: "",
  xleftrightharpoons: "",
  xtwoheadleftarrow: "",
  xtwoheadrightarrow: "",
  xlongequal: "=",
  xtofrom: "",
  xrightleftarrows: "",
  xrightequilibrium: "",
  // Not a perfect match.
  xleftequilibrium: "",
  // None better available.
  "\\cdrightarrow": "",
  "\\cdleftarrow": "",
  "\\cdlongequal": "="
}, n0e = function(e) {
  var r = new it.MathNode("mo", [new it.TextNode(r0e[e.replace(/^\\/, "")])]);
  return r.setAttribute("stretchy", "true"), r;
}, i0e = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
}, a0e = function(e) {
  return e.type === "ordgroup" ? e.body.length : 1;
}, s0e = function(e, r) {
  function n() {
    var o = 4e5, l = e.label.slice(1);
    if (["widehat", "widecheck", "widetilde", "utilde"].includes(l)) {
      var u = e, h = a0e(u.base), d, f, p;
      if (h > 5)
        l === "widehat" || l === "widecheck" ? (d = 420, o = 2364, p = 0.42, f = l + "4") : (d = 312, o = 2340, p = 0.34, f = "tilde4");
      else {
        var g = [1, 1, 2, 2, 3, 3][h];
        l === "widehat" || l === "widecheck" ? (o = [0, 1062, 2364, 2364, 2364][g], d = [0, 239, 300, 360, 420][g], p = [0, 0.24, 0.3, 0.3, 0.36, 0.42][g], f = l + g) : (o = [0, 600, 1033, 2339, 2340][g], d = [0, 260, 286, 306, 312][g], p = [0, 0.26, 0.286, 0.3, 0.306, 0.34][g], f = "tilde" + g);
      }
      var m = new jl(f), v = new el([m], {
        width: "100%",
        height: pt(p),
        viewBox: "0 0 " + o + " " + d,
        preserveAspectRatio: "none"
      });
      return {
        span: Be.makeSvgSpan([], [v], r),
        minWidth: 0,
        height: p
      };
    } else {
      var y = [], b = i0e[l], [w, T, E] = b, L = E / 1e3, k = w.length, C, A;
      if (k === 1) {
        var R = b[3];
        C = ["hide-tail"], A = [R];
      } else if (k === 2)
        C = ["halfarrow-left", "halfarrow-right"], A = ["xMinYMin", "xMaxYMin"];
      else if (k === 3)
        C = ["brace-left", "brace-center", "brace-right"], A = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      else
        throw new Error(`Correct katexImagesData or update code here to support
                    ` + k + " children.");
      for (var _ = 0; _ < k; _++) {
        var O = new jl(w[_]), P = new el([O], {
          width: "400em",
          height: pt(L),
          viewBox: "0 0 " + o + " " + E,
          preserveAspectRatio: A[_] + " slice"
        }), S = Be.makeSvgSpan([C[_]], [P], r);
        if (k === 1)
          return {
            span: S,
            minWidth: T,
            height: L
          };
        S.style.height = pt(L), y.push(S);
      }
      return {
        span: Be.makeSpan(["stretchy"], y, r),
        minWidth: T,
        height: L
      };
    }
  }
  var {
    span: i,
    minWidth: a,
    height: s
  } = n();
  return i.height = s, i.style.height = pt(s), a > 0 && (i.style.minWidth = pt(a)), i;
}, o0e = function(e, r, n, i, a) {
  var s, o = e.height + e.depth + n + i;
  if (/fbox|color|angl/.test(r)) {
    if (s = Be.makeSpan(["stretchy", r], [], a), r === "fbox") {
      var l = a.color && a.getColor();
      l && (s.style.borderColor = l);
    }
  } else {
    var u = [];
    /^[bx]cancel$/.test(r) && u.push(new nT({
      x1: "0",
      y1: "0",
      x2: "100%",
      y2: "100%",
      "stroke-width": "0.046em"
    })), /^x?cancel$/.test(r) && u.push(new nT({
      x1: "0",
      y1: "100%",
      x2: "100%",
      y2: "0",
      "stroke-width": "0.046em"
    }));
    var h = new el(u, {
      width: "100%",
      height: pt(o)
    });
    s = Be.makeSvgSpan([], [h], a);
  }
  return s.height = o, s.style.height = pt(o), s;
}, rl = {
  encloseSpan: o0e,
  mathMLnode: n0e,
  svgSpan: s0e
};
function Jt(t, e) {
  if (!t || t.type !== e)
    throw new Error("Expected node of type " + e + ", but got " + (t ? "node of type " + t.type : String(t)));
  return t;
}
function xk(t) {
  var e = px(t);
  if (!e)
    throw new Error("Expected node of symbol group type, but got " + (t ? "node of type " + t.type : String(t)));
  return e;
}
function px(t) {
  return t && (t.type === "atom" || Nfe.hasOwnProperty(t.type)) ? t : null;
}
var bk = (t, e) => {
  var r, n, i;
  t && t.type === "supsub" ? (n = Jt(t.base, "accent"), r = n.base, t.base = r, i = Rfe(vr(t, e)), t.base = n) : (n = Jt(t, "accent"), r = n.base);
  var a = vr(r, e.havingCrampedStyle()), s = n.isShifty && Tr.isCharacterBox(r), o = 0;
  if (s) {
    var l = Tr.getBaseElem(r), u = vr(l, e.havingCrampedStyle());
    o = J8(u).skew;
  }
  var h = n.label === "\\c", d = h ? a.height + a.depth : Math.min(a.height, e.fontMetrics().xHeight), f;
  if (n.isStretchy)
    f = rl.svgSpan(n, e), f = Be.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: a
      }, {
        type: "elem",
        elem: f,
        wrapperClasses: ["svg-align"],
        wrapperStyle: o > 0 ? {
          width: "calc(100% - " + pt(2 * o) + ")",
          marginLeft: pt(2 * o)
        } : void 0
      }]
    }, e);
  else {
    var p, g;
    n.label === "\\vec" ? (p = Be.staticSvg("vec", e), g = Be.svgData.vec[1]) : (p = Be.makeOrd({
      mode: n.mode,
      text: n.label
    }, e, "textord"), p = J8(p), p.italic = 0, g = p.width, h && (d += p.depth)), f = Be.makeSpan(["accent-body"], [p]);
    var m = n.label === "\\textcircled";
    m && (f.classes.push("accent-full"), d = a.height);
    var v = o;
    m || (v -= g / 2), f.style.left = pt(v), n.label === "\\textcircled" && (f.style.top = ".2em"), f = Be.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: a
      }, {
        type: "kern",
        size: -d
      }, {
        type: "elem",
        elem: f
      }]
    }, e);
  }
  var y = Be.makeSpan(["mord", "accent"], [f], e);
  return i ? (i.children[0] = y, i.height = Math.max(y.height, i.height), i.classes[0] = "mord", i) : y;
}, Oz = (t, e) => {
  var r = t.isStretchy ? rl.mathMLnode(t.label) : new it.MathNode("mo", [ts(t.label, t.mode)]), n = new it.MathNode("mover", [Pr(t.base, e), r]);
  return n.setAttribute("accent", "true"), n;
}, l0e = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((t) => "\\" + t).join("|"));
Tt({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (t, e) => {
    var r = xy(e[0]), n = !l0e.test(t.funcName), i = !n || t.funcName === "\\widehat" || t.funcName === "\\widetilde" || t.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: t.parser.mode,
      label: t.funcName,
      isStretchy: n,
      isShifty: i,
      base: r
    };
  },
  htmlBuilder: bk,
  mathmlBuilder: Oz
});
Tt({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (t, e) => {
    var r = e[0], n = t.parser.mode;
    return n === "math" && (t.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + t.funcName + " works only in text mode"), n = "text"), {
      type: "accent",
      mode: n,
      label: t.funcName,
      isStretchy: !1,
      isShifty: !0,
      base: r
    };
  },
  htmlBuilder: bk,
  mathmlBuilder: Oz
});
Tt({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0];
    return {
      type: "accentUnder",
      mode: r.mode,
      label: n,
      base: i
    };
  },
  htmlBuilder: (t, e) => {
    var r = vr(t.base, e), n = rl.svgSpan(t, e), i = t.label === "\\utilde" ? 0.12 : 0, a = Be.makeVList({
      positionType: "top",
      positionData: r.height,
      children: [{
        type: "elem",
        elem: n,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: r
      }]
    }, e);
    return Be.makeSpan(["mord", "accentunder"], [a], e);
  },
  mathmlBuilder: (t, e) => {
    var r = rl.mathMLnode(t.label), n = new it.MathNode("munder", [Pr(t.base, e), r]);
    return n.setAttribute("accentunder", "true"), n;
  }
});
var T1 = (t) => {
  var e = new it.MathNode("mpadded", t ? [t] : []);
  return e.setAttribute("width", "+0.6em"), e.setAttribute("lspace", "0.3em"), e;
};
Tt({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(t, e, r) {
    var {
      parser: n,
      funcName: i
    } = t;
    return {
      type: "xArrow",
      mode: n.mode,
      label: i,
      body: e[0],
      below: r[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(t, e) {
    var r = e.style, n = e.havingStyle(r.sup()), i = Be.wrapFragment(vr(t.body, n, e), e), a = t.label.slice(0, 2) === "\\x" ? "x" : "cd";
    i.classes.push(a + "-arrow-pad");
    var s;
    t.below && (n = e.havingStyle(r.sub()), s = Be.wrapFragment(vr(t.below, n, e), e), s.classes.push(a + "-arrow-pad"));
    var o = rl.svgSpan(t, e), l = -e.fontMetrics().axisHeight + 0.5 * o.height, u = -e.fontMetrics().axisHeight - 0.5 * o.height - 0.111;
    (i.depth > 0.25 || t.label === "\\xleftequilibrium") && (u -= i.depth);
    var h;
    if (s) {
      var d = -e.fontMetrics().axisHeight + s.height + 0.5 * o.height + 0.111;
      h = Be.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: u
        }, {
          type: "elem",
          elem: o,
          shift: l
        }, {
          type: "elem",
          elem: s,
          shift: d
        }]
      }, e);
    } else
      h = Be.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: u
        }, {
          type: "elem",
          elem: o,
          shift: l
        }]
      }, e);
    return h.children[0].children[0].children[1].classes.push("svg-align"), Be.makeSpan(["mrel", "x-arrow"], [h], e);
  },
  mathmlBuilder(t, e) {
    var r = rl.mathMLnode(t.label);
    r.setAttribute("minsize", t.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var n;
    if (t.body) {
      var i = T1(Pr(t.body, e));
      if (t.below) {
        var a = T1(Pr(t.below, e));
        n = new it.MathNode("munderover", [r, a, i]);
      } else
        n = new it.MathNode("mover", [r, i]);
    } else if (t.below) {
      var s = T1(Pr(t.below, e));
      n = new it.MathNode("munder", [r, s]);
    } else
      n = T1(), n = new it.MathNode("mover", [r, n]);
    return n;
  }
});
var c0e = Be.makeSpan;
function Pz(t, e) {
  var r = $n(t.body, e, !0);
  return c0e([t.mclass], r, e);
}
function Bz(t, e) {
  var r, n = da(t.body, e);
  return t.mclass === "minner" ? r = new it.MathNode("mpadded", n) : t.mclass === "mord" ? t.isCharacterBox ? (r = n[0], r.type = "mi") : r = new it.MathNode("mi", n) : (t.isCharacterBox ? (r = n[0], r.type = "mo") : r = new it.MathNode("mo", n), t.mclass === "mbin" ? (r.attributes.lspace = "0.22em", r.attributes.rspace = "0.22em") : t.mclass === "mpunct" ? (r.attributes.lspace = "0em", r.attributes.rspace = "0.17em") : t.mclass === "mopen" || t.mclass === "mclose" ? (r.attributes.lspace = "0em", r.attributes.rspace = "0em") : t.mclass === "minner" && (r.attributes.lspace = "0.0556em", r.attributes.width = "+0.1111em")), r;
}
Tt({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0];
    return {
      type: "mclass",
      mode: r.mode,
      mclass: "m" + n.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: xn(i),
      isCharacterBox: Tr.isCharacterBox(i)
    };
  },
  htmlBuilder: Pz,
  mathmlBuilder: Bz
});
var gx = (t) => {
  var e = t.type === "ordgroup" && t.body.length ? t.body[0] : t;
  return e.type === "atom" && (e.family === "bin" || e.family === "rel") ? "m" + e.family : "mord";
};
Tt({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "mclass",
      mode: r.mode,
      mclass: gx(e[0]),
      body: xn(e[1]),
      isCharacterBox: Tr.isCharacterBox(e[1])
    };
  }
});
Tt({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t, i = e[1], a = e[0], s;
    n !== "\\stackrel" ? s = gx(i) : s = "mrel";
    var o = {
      type: "op",
      mode: i.mode,
      limits: !0,
      alwaysHandleSupSub: !0,
      parentIsSupSub: !1,
      symbol: !1,
      suppressBaseShift: n !== "\\stackrel",
      body: xn(i)
    }, l = {
      type: "supsub",
      mode: a.mode,
      base: o,
      sup: n === "\\underset" ? null : a,
      sub: n === "\\underset" ? a : null
    };
    return {
      type: "mclass",
      mode: r.mode,
      mclass: s,
      body: [l],
      isCharacterBox: Tr.isCharacterBox(l)
    };
  },
  htmlBuilder: Pz,
  mathmlBuilder: Bz
});
Tt({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "pmb",
      mode: r.mode,
      mclass: gx(e[0]),
      body: xn(e[0])
    };
  },
  htmlBuilder(t, e) {
    var r = $n(t.body, e, !0), n = Be.makeSpan([t.mclass], r, e);
    return n.style.textShadow = "0.02em 0.01em 0.04px", n;
  },
  mathmlBuilder(t, e) {
    var r = da(t.body, e), n = new it.MathNode("mstyle", r);
    return n.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), n;
  }
});
var u0e = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  A: "\\uparrow",
  V: "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
}, oA = () => ({
  type: "styling",
  body: [],
  mode: "math",
  style: "display"
}), lA = (t) => t.type === "textord" && t.text === "@", h0e = (t, e) => (t.type === "mathord" || t.type === "atom") && t.text === e;
function d0e(t, e, r) {
  var n = u0e[t];
  switch (n) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return r.callFunction(n, [e[0]], [e[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var i = r.callFunction("\\\\cdleft", [e[0]], []), a = {
        type: "atom",
        text: n,
        mode: "math",
        family: "rel"
      }, s = r.callFunction("\\Big", [a], []), o = r.callFunction("\\\\cdright", [e[1]], []), l = {
        type: "ordgroup",
        mode: "math",
        body: [i, s, o]
      };
      return r.callFunction("\\\\cdparent", [l], []);
    }
    case "\\\\cdlongequal":
      return r.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var u = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return r.callFunction("\\Big", [u], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function f0e(t) {
  var e = [];
  for (t.gullet.beginGroup(), t.gullet.macros.set("\\cr", "\\\\\\relax"), t.gullet.beginGroup(); ; ) {
    e.push(t.parseExpression(!1, "\\\\")), t.gullet.endGroup(), t.gullet.beginGroup();
    var r = t.fetch().text;
    if (r === "&" || r === "\\\\")
      t.consume();
    else if (r === "\\end") {
      e[e.length - 1].length === 0 && e.pop();
      break;
    } else
      throw new ot("Expected \\\\ or \\cr or \\end", t.nextToken);
  }
  for (var n = [], i = [n], a = 0; a < e.length; a++) {
    for (var s = e[a], o = oA(), l = 0; l < s.length; l++)
      if (!lA(s[l]))
        o.body.push(s[l]);
      else {
        n.push(o), l += 1;
        var u = xk(s[l]).text, h = new Array(2);
        if (h[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, h[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, !("=|.".indexOf(u) > -1)) if ("<>AV".indexOf(u) > -1)
          for (var d = 0; d < 2; d++) {
            for (var f = !0, p = l + 1; p < s.length; p++) {
              if (h0e(s[p], u)) {
                f = !1, l = p;
                break;
              }
              if (lA(s[p]))
                throw new ot("Missing a " + u + " character to complete a CD arrow.", s[p]);
              h[d].body.push(s[p]);
            }
            if (f)
              throw new ot("Missing a " + u + " character to complete a CD arrow.", s[l]);
          }
        else
          throw new ot('Expected one of "<>AV=|." after @', s[l]);
        var g = d0e(u, h, t), m = {
          type: "styling",
          body: [g],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        n.push(m), o = oA();
      }
    a % 2 === 0 ? n.push(o) : n.shift(), n = [], i.push(n);
  }
  t.gullet.endGroup(), t.gullet.endGroup();
  var v = new Array(i[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body: i,
    arraystretch: 1,
    addJot: !0,
    rowGaps: [null],
    cols: v,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(i.length + 1).fill([])
  };
}
Tt({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t;
    return {
      type: "cdlabel",
      mode: r.mode,
      side: n.slice(4),
      label: e[0]
    };
  },
  htmlBuilder(t, e) {
    var r = e.havingStyle(e.style.sup()), n = Be.wrapFragment(vr(t.label, r, e), e);
    return n.classes.push("cd-label-" + t.side), n.style.bottom = pt(0.8 - n.depth), n.height = 0, n.depth = 0, n;
  },
  mathmlBuilder(t, e) {
    var r = new it.MathNode("mrow", [Pr(t.label, e)]);
    return r = new it.MathNode("mpadded", [r]), r.setAttribute("width", "0"), t.side === "left" && r.setAttribute("lspace", "-1width"), r.setAttribute("voffset", "0.7em"), r = new it.MathNode("mstyle", [r]), r.setAttribute("displaystyle", "false"), r.setAttribute("scriptlevel", "1"), r;
  }
});
Tt({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "cdlabelparent",
      mode: r.mode,
      fragment: e[0]
    };
  },
  htmlBuilder(t, e) {
    var r = Be.wrapFragment(vr(t.fragment, e), e);
    return r.classes.push("cd-vert-arrow"), r;
  },
  mathmlBuilder(t, e) {
    return new it.MathNode("mrow", [Pr(t.fragment, e)]);
  }
});
Tt({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(t, e) {
    for (var {
      parser: r
    } = t, n = Jt(e[0], "ordgroup"), i = n.body, a = "", s = 0; s < i.length; s++) {
      var o = Jt(i[s], "textord");
      a += o.text;
    }
    var l = parseInt(a), u;
    if (isNaN(l))
      throw new ot("\\@char has non-numeric argument " + a);
    if (l < 0 || l >= 1114111)
      throw new ot("\\@char with invalid code point " + a);
    return l <= 65535 ? u = String.fromCharCode(l) : (l -= 65536, u = String.fromCharCode((l >> 10) + 55296, (l & 1023) + 56320)), {
      type: "textord",
      mode: r.mode,
      text: u
    };
  }
});
var Fz = (t, e) => {
  var r = $n(t.body, e.withColor(t.color), !1);
  return Be.makeFragment(r);
}, $z = (t, e) => {
  var r = da(t.body, e.withColor(t.color)), n = new it.MathNode("mstyle", r);
  return n.setAttribute("mathcolor", t.color), n;
};
Tt({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "original"]
  },
  handler(t, e) {
    var {
      parser: r
    } = t, n = Jt(e[0], "color-token").color, i = e[1];
    return {
      type: "color",
      mode: r.mode,
      color: n,
      body: xn(i)
    };
  },
  htmlBuilder: Fz,
  mathmlBuilder: $z
});
Tt({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    argTypes: ["color"]
  },
  handler(t, e) {
    var {
      parser: r,
      breakOnTokenText: n
    } = t, i = Jt(e[0], "color-token").color;
    r.gullet.macros.set("\\current@color", i);
    var a = r.parseExpression(!0, n);
    return {
      type: "color",
      mode: r.mode,
      color: i,
      body: a
    };
  },
  htmlBuilder: Fz,
  mathmlBuilder: $z
});
Tt({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: !0
  },
  handler(t, e, r) {
    var {
      parser: n
    } = t, i = n.gullet.future().text === "[" ? n.parseSizeGroup(!0) : null, a = !n.settings.displayMode || !n.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: n.mode,
      newLine: a,
      size: i && Jt(i, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(t, e) {
    var r = Be.makeSpan(["mspace"], [], e);
    return t.newLine && (r.classes.push("newline"), t.size && (r.style.marginTop = pt(tn(t.size, e)))), r;
  },
  mathmlBuilder(t, e) {
    var r = new it.MathNode("mspace");
    return t.newLine && (r.setAttribute("linebreak", "newline"), t.size && r.setAttribute("height", pt(tn(t.size, e)))), r;
  }
});
var oT = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
}, zz = (t) => {
  var e = t.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(e))
    throw new ot("Expected a control sequence", t);
  return e;
}, p0e = (t) => {
  var e = t.gullet.popToken();
  return e.text === "=" && (e = t.gullet.popToken(), e.text === " " && (e = t.gullet.popToken())), e;
}, Gz = (t, e, r, n) => {
  var i = t.gullet.macros.get(r.text);
  i == null && (r.noexpand = !0, i = {
    tokens: [r],
    numArgs: 0,
    // reproduce the same behavior in expansion
    unexpandable: !t.gullet.isExpandable(r.text)
  }), t.gullet.macros.set(e, i, n);
};
Tt({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t;
    e.consumeSpaces();
    var n = e.fetch();
    if (oT[n.text])
      return (r === "\\global" || r === "\\\\globallong") && (n.text = oT[n.text]), Jt(e.parseFunction(), "internal");
    throw new ot("Invalid token after macro prefix", n);
  }
});
Tt({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t, n = e.gullet.popToken(), i = n.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(i))
      throw new ot("Expected a control sequence", n);
    for (var a = 0, s, o = [[]]; e.gullet.future().text !== "{"; )
      if (n = e.gullet.popToken(), n.text === "#") {
        if (e.gullet.future().text === "{") {
          s = e.gullet.future(), o[a].push("{");
          break;
        }
        if (n = e.gullet.popToken(), !/^[1-9]$/.test(n.text))
          throw new ot('Invalid argument number "' + n.text + '"');
        if (parseInt(n.text) !== a + 1)
          throw new ot('Argument number "' + n.text + '" out of order');
        a++, o.push([]);
      } else {
        if (n.text === "EOF")
          throw new ot("Expected a macro definition");
        o[a].push(n.text);
      }
    var {
      tokens: l
    } = e.gullet.consumeArg();
    return s && l.unshift(s), (r === "\\edef" || r === "\\xdef") && (l = e.gullet.expandTokens(l), l.reverse()), e.gullet.macros.set(i, {
      tokens: l,
      numArgs: a,
      delimiters: o
    }, r === oT[r]), {
      type: "internal",
      mode: e.mode
    };
  }
});
Tt({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t, n = zz(e.gullet.popToken());
    e.gullet.consumeSpaces();
    var i = p0e(e);
    return Gz(e, n, i, r === "\\\\globallet"), {
      type: "internal",
      mode: e.mode
    };
  }
});
Tt({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t, n = zz(e.gullet.popToken()), i = e.gullet.popToken(), a = e.gullet.popToken();
    return Gz(e, n, a, r === "\\\\globalfuture"), e.gullet.pushToken(a), e.gullet.pushToken(i), {
      type: "internal",
      mode: e.mode
    };
  }
});
var Qf = function(e, r, n) {
  var i = Gr.math[e] && Gr.math[e].replace, a = pk(i || e, r, n);
  if (!a)
    throw new Error("Unsupported symbol " + e + " and font size " + r + ".");
  return a;
}, wk = function(e, r, n, i) {
  var a = n.havingBaseStyle(r), s = Be.makeSpan(i.concat(a.sizingClasses(n)), [e], n), o = a.sizeMultiplier / n.sizeMultiplier;
  return s.height *= o, s.depth *= o, s.maxFontSize = a.sizeMultiplier, s;
}, Vz = function(e, r, n) {
  var i = r.havingBaseStyle(n), a = (1 - r.sizeMultiplier / i.sizeMultiplier) * r.fontMetrics().axisHeight;
  e.classes.push("delimcenter"), e.style.top = pt(a), e.height -= a, e.depth += a;
}, g0e = function(e, r, n, i, a, s) {
  var o = Be.makeSymbol(e, "Main-Regular", a, i), l = wk(o, r, i, s);
  return n && Vz(l, i, r), l;
}, m0e = function(e, r, n, i) {
  return Be.makeSymbol(e, "Size" + r + "-Regular", n, i);
}, Uz = function(e, r, n, i, a, s) {
  var o = m0e(e, r, a, i), l = wk(Be.makeSpan(["delimsizing", "size" + r], [o], i), zt.TEXT, i, s);
  return n && Vz(l, i, zt.TEXT), l;
}, v4 = function(e, r, n) {
  var i;
  r === "Size1-Regular" ? i = "delim-size1" : i = "delim-size4";
  var a = Be.makeSpan(["delimsizinginner", i], [Be.makeSpan([], [Be.makeSymbol(e, r, n)])]);
  return {
    type: "elem",
    elem: a
  };
}, y4 = function(e, r, n) {
  var i = Ys["Size4-Regular"][e.charCodeAt(0)] ? Ys["Size4-Regular"][e.charCodeAt(0)][4] : Ys["Size1-Regular"][e.charCodeAt(0)][4], a = new jl("inner", Tfe(e, Math.round(1e3 * r))), s = new el([a], {
    width: pt(i),
    height: pt(r),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + pt(i),
    viewBox: "0 0 " + 1e3 * i + " " + Math.round(1e3 * r),
    preserveAspectRatio: "xMinYMin"
  }), o = Be.makeSvgSpan([], [s], n);
  return o.height = r, o.style.height = pt(r), o.style.width = pt(i), {
    type: "elem",
    elem: o
  };
}, lT = 8e-3, E1 = {
  type: "kern",
  size: -1 * lT
}, v0e = ["|", "\\lvert", "\\rvert", "\\vert"], y0e = ["\\|", "\\lVert", "\\rVert", "\\Vert"], Hz = function(e, r, n, i, a, s) {
  var o, l, u, h, d = "", f = 0;
  o = u = h = e, l = null;
  var p = "Size1-Regular";
  e === "\\uparrow" ? u = h = "" : e === "\\Uparrow" ? u = h = "" : e === "\\downarrow" ? o = u = "" : e === "\\Downarrow" ? o = u = "" : e === "\\updownarrow" ? (o = "\\uparrow", u = "", h = "\\downarrow") : e === "\\Updownarrow" ? (o = "\\Uparrow", u = "", h = "\\Downarrow") : v0e.includes(e) ? (u = "", d = "vert", f = 333) : y0e.includes(e) ? (u = "", d = "doublevert", f = 556) : e === "[" || e === "\\lbrack" ? (o = "", u = "", h = "", p = "Size4-Regular", d = "lbrack", f = 667) : e === "]" || e === "\\rbrack" ? (o = "", u = "", h = "", p = "Size4-Regular", d = "rbrack", f = 667) : e === "\\lfloor" || e === "" ? (u = o = "", h = "", p = "Size4-Regular", d = "lfloor", f = 667) : e === "\\lceil" || e === "" ? (o = "", u = h = "", p = "Size4-Regular", d = "lceil", f = 667) : e === "\\rfloor" || e === "" ? (u = o = "", h = "", p = "Size4-Regular", d = "rfloor", f = 667) : e === "\\rceil" || e === "" ? (o = "", u = h = "", p = "Size4-Regular", d = "rceil", f = 667) : e === "(" || e === "\\lparen" ? (o = "", u = "", h = "", p = "Size4-Regular", d = "lparen", f = 875) : e === ")" || e === "\\rparen" ? (o = "", u = "", h = "", p = "Size4-Regular", d = "rparen", f = 875) : e === "\\{" || e === "\\lbrace" ? (o = "", l = "", h = "", u = "", p = "Size4-Regular") : e === "\\}" || e === "\\rbrace" ? (o = "", l = "", h = "", u = "", p = "Size4-Regular") : e === "\\lgroup" || e === "" ? (o = "", h = "", u = "", p = "Size4-Regular") : e === "\\rgroup" || e === "" ? (o = "", h = "", u = "", p = "Size4-Regular") : e === "\\lmoustache" || e === "" ? (o = "", h = "", u = "", p = "Size4-Regular") : (e === "\\rmoustache" || e === "") && (o = "", h = "", u = "", p = "Size4-Regular");
  var g = Qf(o, p, a), m = g.height + g.depth, v = Qf(u, p, a), y = v.height + v.depth, b = Qf(h, p, a), w = b.height + b.depth, T = 0, E = 1;
  if (l !== null) {
    var L = Qf(l, p, a);
    T = L.height + L.depth, E = 2;
  }
  var k = m + w + T, C = Math.max(0, Math.ceil((r - k) / (E * y))), A = k + C * E * y, R = i.fontMetrics().axisHeight;
  n && (R *= i.sizeMultiplier);
  var _ = A / 2 - R, O = [];
  if (d.length > 0) {
    var P = A - m - w, S = Math.round(A * 1e3), M = Efe(d, Math.round(P * 1e3)), N = new jl(d, M), D = (f / 1e3).toFixed(3) + "em", I = (S / 1e3).toFixed(3) + "em", B = new el([N], {
      width: D,
      height: I,
      viewBox: "0 0 " + f + " " + S
    }), z = Be.makeSvgSpan([], [B], i);
    z.height = S / 1e3, z.style.width = D, z.style.height = I, O.push({
      type: "elem",
      elem: z
    });
  } else {
    if (O.push(v4(h, p, a)), O.push(E1), l === null) {
      var F = A - m - w + 2 * lT;
      O.push(y4(u, F, i));
    } else {
      var V = (A - m - w - T) / 2 + 2 * lT;
      O.push(y4(u, V, i)), O.push(E1), O.push(v4(l, p, a)), O.push(E1), O.push(y4(u, V, i));
    }
    O.push(E1), O.push(v4(o, p, a));
  }
  var H = i.havingBaseStyle(zt.TEXT), J = Be.makeVList({
    positionType: "bottom",
    positionData: _,
    children: O
  }, H);
  return wk(Be.makeSpan(["delimsizing", "mult"], [J], H), zt.TEXT, i, s);
}, x4 = 80, b4 = 0.08, w4 = function(e, r, n, i, a) {
  var s = wfe(e, i, n), o = new jl(e, s), l = new el([o], {
    // Note: 1000:1 ratio of viewBox to document em width.
    width: "400em",
    height: pt(r),
    viewBox: "0 0 400000 " + n,
    preserveAspectRatio: "xMinYMin slice"
  });
  return Be.makeSvgSpan(["hide-tail"], [l], a);
}, x0e = function(e, r) {
  var n = r.havingBaseSizing(), i = Xz("\\surd", e * n.sizeMultiplier, Yz, n), a = n.sizeMultiplier, s = Math.max(0, r.minRuleThickness - r.fontMetrics().sqrtRuleThickness), o, l = 0, u = 0, h = 0, d;
  return i.type === "small" ? (h = 1e3 + 1e3 * s + x4, e < 1 ? a = 1 : e < 1.4 && (a = 0.7), l = (1 + s + b4) / a, u = (1 + s) / a, o = w4("sqrtMain", l, h, s, r), o.style.minWidth = "0.853em", d = 0.833 / a) : i.type === "large" ? (h = (1e3 + x4) * Q0[i.size], u = (Q0[i.size] + s) / a, l = (Q0[i.size] + s + b4) / a, o = w4("sqrtSize" + i.size, l, h, s, r), o.style.minWidth = "1.02em", d = 1 / a) : (l = e + s + b4, u = e + s, h = Math.floor(1e3 * e + s) + x4, o = w4("sqrtTall", l, h, s, r), o.style.minWidth = "0.742em", d = 1.056), o.height = u, o.style.height = pt(l), {
    span: o,
    advanceWidth: d,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (r.fontMetrics().sqrtRuleThickness + s) * a
  };
}, qz = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "", "", "\\lceil", "\\rceil", "", "", "\\surd"], b0e = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "", "", "\\lmoustache", "\\rmoustache", "", ""], Wz = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"], Q0 = [0, 1.2, 1.8, 2.4, 3], w0e = function(e, r, n, i, a) {
  if (e === "<" || e === "\\lt" || e === "" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "") && (e = "\\rangle"), qz.includes(e) || Wz.includes(e))
    return Uz(e, r, !1, n, i, a);
  if (b0e.includes(e))
    return Hz(e, Q0[r], !1, n, i, a);
  throw new ot("Illegal delimiter: '" + e + "'");
}, T0e = [{
  type: "small",
  style: zt.SCRIPTSCRIPT
}, {
  type: "small",
  style: zt.SCRIPT
}, {
  type: "small",
  style: zt.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}], E0e = [{
  type: "small",
  style: zt.SCRIPTSCRIPT
}, {
  type: "small",
  style: zt.SCRIPT
}, {
  type: "small",
  style: zt.TEXT
}, {
  type: "stack"
}], Yz = [{
  type: "small",
  style: zt.SCRIPTSCRIPT
}, {
  type: "small",
  style: zt.SCRIPT
}, {
  type: "small",
  style: zt.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}], k0e = function(e) {
  if (e.type === "small")
    return "Main-Regular";
  if (e.type === "large")
    return "Size" + e.size + "-Regular";
  if (e.type === "stack")
    return "Size4-Regular";
  throw new Error("Add support for delim type '" + e.type + "' here.");
}, Xz = function(e, r, n, i) {
  for (var a = Math.min(2, 3 - i.style.size), s = a; s < n.length && n[s].type !== "stack"; s++) {
    var o = Qf(e, k0e(n[s]), "math"), l = o.height + o.depth;
    if (n[s].type === "small") {
      var u = i.havingBaseStyle(n[s].style);
      l *= u.sizeMultiplier;
    }
    if (l > r)
      return n[s];
  }
  return n[n.length - 1];
}, jz = function(e, r, n, i, a, s) {
  e === "<" || e === "\\lt" || e === "" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "") && (e = "\\rangle");
  var o;
  Wz.includes(e) ? o = T0e : qz.includes(e) ? o = Yz : o = E0e;
  var l = Xz(e, r, o, i);
  return l.type === "small" ? g0e(e, l.style, n, i, a, s) : l.type === "large" ? Uz(e, l.size, n, i, a, s) : Hz(e, r, n, i, a, s);
}, S0e = function(e, r, n, i, a, s) {
  var o = i.fontMetrics().axisHeight * i.sizeMultiplier, l = 901, u = 5 / i.fontMetrics().ptPerEm, h = Math.max(r - o, n + o), d = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    h / 500 * l,
    2 * h - u
  );
  return jz(e, d, !0, i, a, s);
}, Yo = {
  sqrtImage: x0e,
  sizedDelim: w0e,
  sizeToMaxHeight: Q0,
  customSizedDelim: jz,
  leftRightDelim: S0e
}, cA = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
}, C0e = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "", "", "\\lceil", "\\rceil", "", "", "<", ">", "\\langle", "", "\\rangle", "", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "", "", "\\lmoustache", "\\rmoustache", "", "", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function mx(t, e) {
  var r = px(t);
  if (r && C0e.includes(r.text))
    return r;
  throw r ? new ot("Invalid delimiter '" + r.text + "' after '" + e.funcName + "'", t) : new ot("Invalid delimiter type '" + t.type + "'", t);
}
Tt({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (t, e) => {
    var r = mx(e[0], t);
    return {
      type: "delimsizing",
      mode: t.parser.mode,
      size: cA[t.funcName].size,
      mclass: cA[t.funcName].mclass,
      delim: r.text
    };
  },
  htmlBuilder: (t, e) => t.delim === "." ? Be.makeSpan([t.mclass]) : Yo.sizedDelim(t.delim, t.size, e, t.mode, [t.mclass]),
  mathmlBuilder: (t) => {
    var e = [];
    t.delim !== "." && e.push(ts(t.delim, t.mode));
    var r = new it.MathNode("mo", e);
    t.mclass === "mopen" || t.mclass === "mclose" ? r.setAttribute("fence", "true") : r.setAttribute("fence", "false"), r.setAttribute("stretchy", "true");
    var n = pt(Yo.sizeToMaxHeight[t.size]);
    return r.setAttribute("minsize", n), r.setAttribute("maxsize", n), r;
  }
});
function uA(t) {
  if (!t.body)
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
}
Tt({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (t, e) => {
    var r = t.parser.gullet.macros.get("\\current@color");
    if (r && typeof r != "string")
      throw new ot("\\current@color set to non-string in \\right");
    return {
      type: "leftright-right",
      mode: t.parser.mode,
      delim: mx(e[0], t).text,
      color: r
      // undefined if not set via \color
    };
  }
});
Tt({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (t, e) => {
    var r = mx(e[0], t), n = t.parser;
    ++n.leftrightDepth;
    var i = n.parseExpression(!1);
    --n.leftrightDepth, n.expect("\\right", !1);
    var a = Jt(n.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: n.mode,
      body: i,
      left: r.text,
      right: a.delim,
      rightColor: a.color
    };
  },
  htmlBuilder: (t, e) => {
    uA(t);
    for (var r = $n(t.body, e, !0, ["mopen", "mclose"]), n = 0, i = 0, a = !1, s = 0; s < r.length; s++)
      r[s].isMiddle ? a = !0 : (n = Math.max(r[s].height, n), i = Math.max(r[s].depth, i));
    n *= e.sizeMultiplier, i *= e.sizeMultiplier;
    var o;
    if (t.left === "." ? o = Lp(e, ["mopen"]) : o = Yo.leftRightDelim(t.left, n, i, e, t.mode, ["mopen"]), r.unshift(o), a)
      for (var l = 1; l < r.length; l++) {
        var u = r[l], h = u.isMiddle;
        h && (r[l] = Yo.leftRightDelim(h.delim, n, i, h.options, t.mode, []));
      }
    var d;
    if (t.right === ".")
      d = Lp(e, ["mclose"]);
    else {
      var f = t.rightColor ? e.withColor(t.rightColor) : e;
      d = Yo.leftRightDelim(t.right, n, i, f, t.mode, ["mclose"]);
    }
    return r.push(d), Be.makeSpan(["minner"], r, e);
  },
  mathmlBuilder: (t, e) => {
    uA(t);
    var r = da(t.body, e);
    if (t.left !== ".") {
      var n = new it.MathNode("mo", [ts(t.left, t.mode)]);
      n.setAttribute("fence", "true"), r.unshift(n);
    }
    if (t.right !== ".") {
      var i = new it.MathNode("mo", [ts(t.right, t.mode)]);
      i.setAttribute("fence", "true"), t.rightColor && i.setAttribute("mathcolor", t.rightColor), r.push(i);
    }
    return vk(r);
  }
});
Tt({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (t, e) => {
    var r = mx(e[0], t);
    if (!t.parser.leftrightDepth)
      throw new ot("\\middle without preceding \\left", r);
    return {
      type: "middle",
      mode: t.parser.mode,
      delim: r.text
    };
  },
  htmlBuilder: (t, e) => {
    var r;
    if (t.delim === ".")
      r = Lp(e, []);
    else {
      r = Yo.sizedDelim(t.delim, 1, e, t.mode, []);
      var n = {
        delim: t.delim,
        options: e
      };
      r.isMiddle = n;
    }
    return r;
  },
  mathmlBuilder: (t, e) => {
    var r = t.delim === "\\vert" || t.delim === "|" ? ts("|", "text") : ts(t.delim, t.mode), n = new it.MathNode("mo", [r]);
    return n.setAttribute("fence", "true"), n.setAttribute("lspace", "0.05em"), n.setAttribute("rspace", "0.05em"), n;
  }
});
var Tk = (t, e) => {
  var r = Be.wrapFragment(vr(t.body, e), e), n = t.label.slice(1), i = e.sizeMultiplier, a, s = 0, o = Tr.isCharacterBox(t.body);
  if (n === "sout")
    a = Be.makeSpan(["stretchy", "sout"]), a.height = e.fontMetrics().defaultRuleThickness / i, s = -0.5 * e.fontMetrics().xHeight;
  else if (n === "phase") {
    var l = tn({
      number: 0.6,
      unit: "pt"
    }, e), u = tn({
      number: 0.35,
      unit: "ex"
    }, e), h = e.havingBaseSizing();
    i = i / h.sizeMultiplier;
    var d = r.height + r.depth + l + u;
    r.style.paddingLeft = pt(d / 2 + l);
    var f = Math.floor(1e3 * d * i), p = xfe(f), g = new el([new jl("phase", p)], {
      width: "400em",
      height: pt(f / 1e3),
      viewBox: "0 0 400000 " + f,
      preserveAspectRatio: "xMinYMin slice"
    });
    a = Be.makeSvgSpan(["hide-tail"], [g], e), a.style.height = pt(d), s = r.depth + l + u;
  } else {
    /cancel/.test(n) ? o || r.classes.push("cancel-pad") : n === "angl" ? r.classes.push("anglpad") : r.classes.push("boxpad");
    var m = 0, v = 0, y = 0;
    /box/.test(n) ? (y = Math.max(
      e.fontMetrics().fboxrule,
      // default
      e.minRuleThickness
      // User override.
    ), m = e.fontMetrics().fboxsep + (n === "colorbox" ? 0 : y), v = m) : n === "angl" ? (y = Math.max(e.fontMetrics().defaultRuleThickness, e.minRuleThickness), m = 4 * y, v = Math.max(0, 0.25 - r.depth)) : (m = o ? 0.2 : 0, v = m), a = rl.encloseSpan(r, n, m, v, e), /fbox|boxed|fcolorbox/.test(n) ? (a.style.borderStyle = "solid", a.style.borderWidth = pt(y)) : n === "angl" && y !== 0.049 && (a.style.borderTopWidth = pt(y), a.style.borderRightWidth = pt(y)), s = r.depth + v, t.backgroundColor && (a.style.backgroundColor = t.backgroundColor, t.borderColor && (a.style.borderColor = t.borderColor));
  }
  var b;
  if (t.backgroundColor)
    b = Be.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: a,
          shift: s
        },
        {
          type: "elem",
          elem: r,
          shift: 0
        }
      ]
    }, e);
  else {
    var w = /cancel|phase/.test(n) ? ["svg-align"] : [];
    b = Be.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: r,
          shift: 0
        },
        {
          type: "elem",
          elem: a,
          shift: s,
          wrapperClasses: w
        }
      ]
    }, e);
  }
  return /cancel/.test(n) && (b.height = r.height, b.depth = r.depth), /cancel/.test(n) && !o ? Be.makeSpan(["mord", "cancel-lap"], [b], e) : Be.makeSpan(["mord"], [b], e);
}, Ek = (t, e) => {
  var r = 0, n = new it.MathNode(t.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [Pr(t.body, e)]);
  switch (t.label) {
    case "\\cancel":
      n.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      n.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      n.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      n.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      n.setAttribute("notation", "box");
      break;
    case "\\angl":
      n.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      if (r = e.fontMetrics().fboxsep * e.fontMetrics().ptPerEm, n.setAttribute("width", "+" + 2 * r + "pt"), n.setAttribute("height", "+" + 2 * r + "pt"), n.setAttribute("lspace", r + "pt"), n.setAttribute("voffset", r + "pt"), t.label === "\\fcolorbox") {
        var i = Math.max(
          e.fontMetrics().fboxrule,
          // default
          e.minRuleThickness
          // user override
        );
        n.setAttribute("style", "border: " + i + "em solid " + String(t.borderColor));
      }
      break;
    case "\\xcancel":
      n.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  return t.backgroundColor && n.setAttribute("mathbackground", t.backgroundColor), n;
};
Tt({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "text"]
  },
  handler(t, e, r) {
    var {
      parser: n,
      funcName: i
    } = t, a = Jt(e[0], "color-token").color, s = e[1];
    return {
      type: "enclose",
      mode: n.mode,
      label: i,
      backgroundColor: a,
      body: s
    };
  },
  htmlBuilder: Tk,
  mathmlBuilder: Ek
});
Tt({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: !0,
    argTypes: ["color", "color", "text"]
  },
  handler(t, e, r) {
    var {
      parser: n,
      funcName: i
    } = t, a = Jt(e[0], "color-token").color, s = Jt(e[1], "color-token").color, o = e[2];
    return {
      type: "enclose",
      mode: n.mode,
      label: i,
      backgroundColor: s,
      borderColor: a,
      body: o
    };
  },
  htmlBuilder: Tk,
  mathmlBuilder: Ek
});
Tt({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !0
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "enclose",
      mode: r.mode,
      label: "\\fbox",
      body: e[0]
    };
  }
});
Tt({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0];
    return {
      type: "enclose",
      mode: r.mode,
      label: n,
      body: i
    };
  },
  htmlBuilder: Tk,
  mathmlBuilder: Ek
});
Tt({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !1
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "enclose",
      mode: r.mode,
      label: "\\angl",
      body: e[0]
    };
  }
});
var Kz = {};
function ho(t) {
  for (var {
    type: e,
    names: r,
    props: n,
    handler: i,
    htmlBuilder: a,
    mathmlBuilder: s
  } = t, o = {
    type: e,
    numArgs: n.numArgs || 0,
    allowedInText: !1,
    numOptionalArgs: 0,
    handler: i
  }, l = 0; l < r.length; ++l)
    Kz[r[l]] = o;
  a && (vy[e] = a), s && (yy[e] = s);
}
var Zz = {};
function le(t, e) {
  Zz[t] = e;
}
function hA(t) {
  var e = [];
  t.consumeSpaces();
  var r = t.fetch().text;
  for (r === "\\relax" && (t.consume(), t.consumeSpaces(), r = t.fetch().text); r === "\\hline" || r === "\\hdashline"; )
    t.consume(), e.push(r === "\\hdashline"), t.consumeSpaces(), r = t.fetch().text;
  return e;
}
var vx = (t) => {
  var e = t.parser.settings;
  if (!e.displayMode)
    throw new ot("{" + t.envName + "} can be used only in display mode.");
};
function kk(t) {
  if (t.indexOf("ed") === -1)
    return t.indexOf("*") === -1;
}
function gc(t, e, r) {
  var {
    hskipBeforeAndAfter: n,
    addJot: i,
    cols: a,
    arraystretch: s,
    colSeparationType: o,
    autoTag: l,
    singleRow: u,
    emptySingleRow: h,
    maxNumCols: d,
    leqno: f
  } = e;
  if (t.gullet.beginGroup(), u || t.gullet.macros.set("\\cr", "\\\\\\relax"), !s) {
    var p = t.gullet.expandMacroAsText("\\arraystretch");
    if (p == null)
      s = 1;
    else if (s = parseFloat(p), !s || s < 0)
      throw new ot("Invalid \\arraystretch: " + p);
  }
  t.gullet.beginGroup();
  var g = [], m = [g], v = [], y = [], b = l != null ? [] : void 0;
  function w() {
    l && t.gullet.macros.set("\\@eqnsw", "1", !0);
  }
  function T() {
    b && (t.gullet.macros.get("\\df@tag") ? (b.push(t.subparse([new Ea("\\df@tag")])), t.gullet.macros.set("\\df@tag", void 0, !0)) : b.push(!!l && t.gullet.macros.get("\\@eqnsw") === "1"));
  }
  for (w(), y.push(hA(t)); ; ) {
    var E = t.parseExpression(!1, u ? "\\end" : "\\\\");
    t.gullet.endGroup(), t.gullet.beginGroup(), E = {
      type: "ordgroup",
      mode: t.mode,
      body: E
    }, r && (E = {
      type: "styling",
      mode: t.mode,
      style: r,
      body: [E]
    }), g.push(E);
    var L = t.fetch().text;
    if (L === "&") {
      if (d && g.length === d) {
        if (u || o)
          throw new ot("Too many tab characters: &", t.nextToken);
        t.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
      }
      t.consume();
    } else if (L === "\\end") {
      T(), g.length === 1 && E.type === "styling" && E.body[0].body.length === 0 && (m.length > 1 || !h) && m.pop(), y.length < m.length + 1 && y.push([]);
      break;
    } else if (L === "\\\\") {
      t.consume();
      var k = void 0;
      t.gullet.future().text !== " " && (k = t.parseSizeGroup(!0)), v.push(k ? k.value : null), T(), y.push(hA(t)), g = [], m.push(g), w();
    } else
      throw new ot("Expected & or \\\\ or \\cr or \\end", t.nextToken);
  }
  return t.gullet.endGroup(), t.gullet.endGroup(), {
    type: "array",
    mode: t.mode,
    addJot: i,
    arraystretch: s,
    body: m,
    cols: a,
    rowGaps: v,
    hskipBeforeAndAfter: n,
    hLinesBeforeRow: y,
    colSeparationType: o,
    tags: b,
    leqno: f
  };
}
function Sk(t) {
  return t.slice(0, 1) === "d" ? "display" : "text";
}
var fo = function(e, r) {
  var n, i, a = e.body.length, s = e.hLinesBeforeRow, o = 0, l = new Array(a), u = [], h = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    r.fontMetrics().arrayRuleWidth,
    r.minRuleThickness
    // User override.
  ), d = 1 / r.fontMetrics().ptPerEm, f = 5 * d;
  if (e.colSeparationType && e.colSeparationType === "small") {
    var p = r.havingStyle(zt.SCRIPT).sizeMultiplier;
    f = 0.2778 * (p / r.sizeMultiplier);
  }
  var g = e.colSeparationType === "CD" ? tn({
    number: 3,
    unit: "ex"
  }, r) : 12 * d, m = 3 * d, v = e.arraystretch * g, y = 0.7 * v, b = 0.3 * v, w = 0;
  function T(W) {
    for (var De = 0; De < W.length; ++De)
      De > 0 && (w += 0.25), u.push({
        pos: w,
        isDashed: W[De]
      });
  }
  for (T(s[0]), n = 0; n < e.body.length; ++n) {
    var E = e.body[n], L = y, k = b;
    o < E.length && (o = E.length);
    var C = new Array(E.length);
    for (i = 0; i < E.length; ++i) {
      var A = vr(E[i], r);
      k < A.depth && (k = A.depth), L < A.height && (L = A.height), C[i] = A;
    }
    var R = e.rowGaps[n], _ = 0;
    R && (_ = tn(R, r), _ > 0 && (_ += b, k < _ && (k = _), _ = 0)), e.addJot && (k += m), C.height = L, C.depth = k, w += L, C.pos = w, w += k + _, l[n] = C, T(s[n + 1]);
  }
  var O = w / 2 + r.fontMetrics().axisHeight, P = e.cols || [], S = [], M, N, D = [];
  if (e.tags && e.tags.some((W) => W))
    for (n = 0; n < a; ++n) {
      var I = l[n], B = I.pos - O, z = e.tags[n], F = void 0;
      z === !0 ? F = Be.makeSpan(["eqn-num"], [], r) : z === !1 ? F = Be.makeSpan([], [], r) : F = Be.makeSpan([], $n(z, r, !0), r), F.depth = I.depth, F.height = I.height, D.push({
        type: "elem",
        elem: F,
        shift: B
      });
    }
  for (
    i = 0, N = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    i < o || N < P.length;
    ++i, ++N
  ) {
    for (var V = P[N] || {}, H = !0; V.type === "separator"; ) {
      if (H || (M = Be.makeSpan(["arraycolsep"], []), M.style.width = pt(r.fontMetrics().doubleRuleSep), S.push(M)), V.separator === "|" || V.separator === ":") {
        var J = V.separator === "|" ? "solid" : "dashed", q = Be.makeSpan(["vertical-separator"], [], r);
        q.style.height = pt(w), q.style.borderRightWidth = pt(h), q.style.borderRightStyle = J, q.style.margin = "0 " + pt(-h / 2);
        var ae = w - O;
        ae && (q.style.verticalAlign = pt(-ae)), S.push(q);
      } else
        throw new ot("Invalid separator type: " + V.separator);
      N++, V = P[N] || {}, H = !1;
    }
    if (!(i >= o)) {
      var re = void 0;
      (i > 0 || e.hskipBeforeAndAfter) && (re = Tr.deflt(V.pregap, f), re !== 0 && (M = Be.makeSpan(["arraycolsep"], []), M.style.width = pt(re), S.push(M)));
      var pe = [];
      for (n = 0; n < a; ++n) {
        var K = l[n], Z = K[i];
        if (Z) {
          var X = K.pos - O;
          Z.depth = K.depth, Z.height = K.height, pe.push({
            type: "elem",
            elem: Z,
            shift: X
          });
        }
      }
      pe = Be.makeVList({
        positionType: "individualShift",
        children: pe
      }, r), pe = Be.makeSpan(["col-align-" + (V.align || "c")], [pe]), S.push(pe), (i < o - 1 || e.hskipBeforeAndAfter) && (re = Tr.deflt(V.postgap, f), re !== 0 && (M = Be.makeSpan(["arraycolsep"], []), M.style.width = pt(re), S.push(M)));
    }
  }
  if (l = Be.makeSpan(["mtable"], S), u.length > 0) {
    for (var Y = Be.makeLineSpan("hline", r, h), ee = Be.makeLineSpan("hdashline", r, h), j = [{
      type: "elem",
      elem: l,
      shift: 0
    }]; u.length > 0; ) {
      var fe = u.pop(), te = fe.pos - O;
      fe.isDashed ? j.push({
        type: "elem",
        elem: ee,
        shift: te
      }) : j.push({
        type: "elem",
        elem: Y,
        shift: te
      });
    }
    l = Be.makeVList({
      positionType: "individualShift",
      children: j
    }, r);
  }
  if (D.length === 0)
    return Be.makeSpan(["mord"], [l], r);
  var Ae = Be.makeVList({
    positionType: "individualShift",
    children: D
  }, r);
  return Ae = Be.makeSpan(["tag"], [Ae], r), Be.makeFragment([l, Ae]);
}, A0e = {
  c: "center ",
  l: "left ",
  r: "right "
}, po = function(e, r) {
  for (var n = [], i = new it.MathNode("mtd", [], ["mtr-glue"]), a = new it.MathNode("mtd", [], ["mml-eqn-num"]), s = 0; s < e.body.length; s++) {
    for (var o = e.body[s], l = [], u = 0; u < o.length; u++)
      l.push(new it.MathNode("mtd", [Pr(o[u], r)]));
    e.tags && e.tags[s] && (l.unshift(i), l.push(i), e.leqno ? l.unshift(a) : l.push(a)), n.push(new it.MathNode("mtr", l));
  }
  var h = new it.MathNode("mtable", n), d = e.arraystretch === 0.5 ? 0.1 : 0.16 + e.arraystretch - 1 + (e.addJot ? 0.09 : 0);
  h.setAttribute("rowspacing", pt(d));
  var f = "", p = "";
  if (e.cols && e.cols.length > 0) {
    var g = e.cols, m = "", v = !1, y = 0, b = g.length;
    g[0].type === "separator" && (f += "top ", y = 1), g[g.length - 1].type === "separator" && (f += "bottom ", b -= 1);
    for (var w = y; w < b; w++)
      g[w].type === "align" ? (p += A0e[g[w].align], v && (m += "none "), v = !0) : g[w].type === "separator" && v && (m += g[w].separator === "|" ? "solid " : "dashed ", v = !1);
    h.setAttribute("columnalign", p.trim()), /[sd]/.test(m) && h.setAttribute("columnlines", m.trim());
  }
  if (e.colSeparationType === "align") {
    for (var T = e.cols || [], E = "", L = 1; L < T.length; L++)
      E += L % 2 ? "0em " : "1em ";
    h.setAttribute("columnspacing", E.trim());
  } else e.colSeparationType === "alignat" || e.colSeparationType === "gather" ? h.setAttribute("columnspacing", "0em") : e.colSeparationType === "small" ? h.setAttribute("columnspacing", "0.2778em") : e.colSeparationType === "CD" ? h.setAttribute("columnspacing", "0.5em") : h.setAttribute("columnspacing", "1em");
  var k = "", C = e.hLinesBeforeRow;
  f += C[0].length > 0 ? "left " : "", f += C[C.length - 1].length > 0 ? "right " : "";
  for (var A = 1; A < C.length - 1; A++)
    k += C[A].length === 0 ? "none " : C[A][0] ? "dashed " : "solid ";
  return /[sd]/.test(k) && h.setAttribute("rowlines", k.trim()), f !== "" && (h = new it.MathNode("menclose", [h]), h.setAttribute("notation", f.trim())), e.arraystretch && e.arraystretch < 1 && (h = new it.MathNode("mstyle", [h]), h.setAttribute("scriptlevel", "1")), h;
}, Qz = function(e, r) {
  e.envName.indexOf("ed") === -1 && vx(e);
  var n = [], i = e.envName.indexOf("at") > -1 ? "alignat" : "align", a = e.envName === "split", s = gc(e.parser, {
    cols: n,
    addJot: !0,
    autoTag: a ? void 0 : kk(e.envName),
    emptySingleRow: !0,
    colSeparationType: i,
    maxNumCols: a ? 2 : void 0,
    leqno: e.parser.settings.leqno
  }, "display"), o, l = 0, u = {
    type: "ordgroup",
    mode: e.mode,
    body: []
  };
  if (r[0] && r[0].type === "ordgroup") {
    for (var h = "", d = 0; d < r[0].body.length; d++) {
      var f = Jt(r[0].body[d], "textord");
      h += f.text;
    }
    o = Number(h), l = o * 2;
  }
  var p = !l;
  s.body.forEach(function(y) {
    for (var b = 1; b < y.length; b += 2) {
      var w = Jt(y[b], "styling"), T = Jt(w.body[0], "ordgroup");
      T.body.unshift(u);
    }
    if (p)
      l < y.length && (l = y.length);
    else {
      var E = y.length / 2;
      if (o < E)
        throw new ot("Too many math in a row: " + ("expected " + o + ", but got " + E), y[0]);
    }
  });
  for (var g = 0; g < l; ++g) {
    var m = "r", v = 0;
    g % 2 === 1 ? m = "l" : g > 0 && p && (v = 1), n[g] = {
      type: "align",
      align: m,
      pregap: v,
      postgap: 0
    };
  }
  return s.colSeparationType = p ? "align" : "alignat", s;
};
ho({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var r = px(e[0]), n = r ? [e[0]] : Jt(e[0], "ordgroup").body, i = n.map(function(s) {
      var o = xk(s), l = o.text;
      if ("lcr".indexOf(l) !== -1)
        return {
          type: "align",
          align: l
        };
      if (l === "|")
        return {
          type: "separator",
          separator: "|"
        };
      if (l === ":")
        return {
          type: "separator",
          separator: ":"
        };
      throw new ot("Unknown column alignment: " + l, s);
    }), a = {
      cols: i,
      hskipBeforeAndAfter: !0,
      // \@preamble in lttab.dtx
      maxNumCols: i.length
    };
    return gc(t.parser, a, Sk(t.envName));
  },
  htmlBuilder: fo,
  mathmlBuilder: po
});
ho({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(t) {
    var e = {
      matrix: null,
      pmatrix: ["(", ")"],
      bmatrix: ["[", "]"],
      Bmatrix: ["\\{", "\\}"],
      vmatrix: ["|", "|"],
      Vmatrix: ["\\Vert", "\\Vert"]
    }[t.envName.replace("*", "")], r = "c", n = {
      hskipBeforeAndAfter: !1,
      cols: [{
        type: "align",
        align: r
      }]
    };
    if (t.envName.charAt(t.envName.length - 1) === "*") {
      var i = t.parser;
      if (i.consumeSpaces(), i.fetch().text === "[") {
        if (i.consume(), i.consumeSpaces(), r = i.fetch().text, "lcr".indexOf(r) === -1)
          throw new ot("Expected l or c or r", i.nextToken);
        i.consume(), i.consumeSpaces(), i.expect("]"), i.consume(), n.cols = [{
          type: "align",
          align: r
        }];
      }
    }
    var a = gc(t.parser, n, Sk(t.envName)), s = Math.max(0, ...a.body.map((o) => o.length));
    return a.cols = new Array(s).fill({
      type: "align",
      align: r
    }), e ? {
      type: "leftright",
      mode: t.mode,
      body: [a],
      left: e[0],
      right: e[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : a;
  },
  htmlBuilder: fo,
  mathmlBuilder: po
});
ho({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(t) {
    var e = {
      arraystretch: 0.5
    }, r = gc(t.parser, e, "script");
    return r.colSeparationType = "small", r;
  },
  htmlBuilder: fo,
  mathmlBuilder: po
});
ho({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var r = px(e[0]), n = r ? [e[0]] : Jt(e[0], "ordgroup").body, i = n.map(function(s) {
      var o = xk(s), l = o.text;
      if ("lc".indexOf(l) !== -1)
        return {
          type: "align",
          align: l
        };
      throw new ot("Unknown column alignment: " + l, s);
    });
    if (i.length > 1)
      throw new ot("{subarray} can contain only one column");
    var a = {
      cols: i,
      hskipBeforeAndAfter: !1,
      arraystretch: 0.5
    };
    if (a = gc(t.parser, a, "script"), a.body.length > 0 && a.body[0].length > 1)
      throw new ot("{subarray} can contain only one column");
    return a;
  },
  htmlBuilder: fo,
  mathmlBuilder: po
});
ho({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(t) {
    var e = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    }, r = gc(t.parser, e, Sk(t.envName));
    return {
      type: "leftright",
      mode: t.mode,
      body: [r],
      left: t.envName.indexOf("r") > -1 ? "." : "\\{",
      right: t.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: fo,
  mathmlBuilder: po
});
ho({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: Qz,
  htmlBuilder: fo,
  mathmlBuilder: po
});
ho({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(t) {
    ["gather", "gather*"].includes(t.envName) && vx(t);
    var e = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: !0,
      colSeparationType: "gather",
      autoTag: kk(t.envName),
      emptySingleRow: !0,
      leqno: t.parser.settings.leqno
    };
    return gc(t.parser, e, "display");
  },
  htmlBuilder: fo,
  mathmlBuilder: po
});
ho({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: Qz,
  htmlBuilder: fo,
  mathmlBuilder: po
});
ho({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(t) {
    vx(t);
    var e = {
      autoTag: kk(t.envName),
      emptySingleRow: !0,
      singleRow: !0,
      maxNumCols: 1,
      leqno: t.parser.settings.leqno
    };
    return gc(t.parser, e, "display");
  },
  htmlBuilder: fo,
  mathmlBuilder: po
});
ho({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(t) {
    return vx(t), f0e(t.parser);
  },
  htmlBuilder: fo,
  mathmlBuilder: po
});
le("\\nonumber", "\\gdef\\@eqnsw{0}");
le("\\notag", "\\nonumber");
Tt({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !0
  },
  handler(t, e) {
    throw new ot(t.funcName + " valid only within array environment");
  }
});
var dA = Kz;
Tt({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0];
    if (i.type !== "ordgroup")
      throw new ot("Invalid environment name", i);
    for (var a = "", s = 0; s < i.body.length; ++s)
      a += Jt(i.body[s], "textord").text;
    if (n === "\\begin") {
      if (!dA.hasOwnProperty(a))
        throw new ot("No such environment: " + a, i);
      var o = dA[a], {
        args: l,
        optArgs: u
      } = r.parseArguments("\\begin{" + a + "}", o), h = {
        mode: r.mode,
        envName: a,
        parser: r
      }, d = o.handler(h, l, u);
      r.expect("\\end", !1);
      var f = r.nextToken, p = Jt(r.parseFunction(), "environment");
      if (p.name !== a)
        throw new ot("Mismatch: \\begin{" + a + "} matched by \\end{" + p.name + "}", f);
      return d;
    }
    return {
      type: "environment",
      mode: r.mode,
      name: a,
      nameGroup: i
    };
  }
});
var Jz = (t, e) => {
  var r = t.font, n = e.withFont(r);
  return vr(t.body, n);
}, eG = (t, e) => {
  var r = t.font, n = e.withFont(r);
  return Pr(t.body, n);
}, fA = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
Tt({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    "\\mathsfit",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: !0
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, i = xy(e[0]), a = n;
    return a in fA && (a = fA[a]), {
      type: "font",
      mode: r.mode,
      font: a.slice(1),
      body: i
    };
  },
  htmlBuilder: Jz,
  mathmlBuilder: eG
});
Tt({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = e[0], i = Tr.isCharacterBox(n);
    return {
      type: "mclass",
      mode: r.mode,
      mclass: gx(n),
      body: [{
        type: "font",
        mode: r.mode,
        font: "boldsymbol",
        body: n
      }],
      isCharacterBox: i
    };
  }
});
Tt({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n,
      breakOnTokenText: i
    } = t, {
      mode: a
    } = r, s = r.parseExpression(!0, i), o = "math" + n.slice(1);
    return {
      type: "font",
      mode: a,
      font: o,
      body: {
        type: "ordgroup",
        mode: r.mode,
        body: s
      }
    };
  },
  htmlBuilder: Jz,
  mathmlBuilder: eG
});
var tG = (t, e) => {
  var r = e;
  return t === "display" ? r = r.id >= zt.SCRIPT.id ? r.text() : zt.DISPLAY : t === "text" && r.size === zt.DISPLAY.size ? r = zt.TEXT : t === "script" ? r = zt.SCRIPT : t === "scriptscript" && (r = zt.SCRIPTSCRIPT), r;
}, Ck = (t, e) => {
  var r = tG(t.size, e.style), n = r.fracNum(), i = r.fracDen(), a;
  a = e.havingStyle(n);
  var s = vr(t.numer, a, e);
  if (t.continued) {
    var o = 8.5 / e.fontMetrics().ptPerEm, l = 3.5 / e.fontMetrics().ptPerEm;
    s.height = s.height < o ? o : s.height, s.depth = s.depth < l ? l : s.depth;
  }
  a = e.havingStyle(i);
  var u = vr(t.denom, a, e), h, d, f;
  t.hasBarLine ? (t.barSize ? (d = tn(t.barSize, e), h = Be.makeLineSpan("frac-line", e, d)) : h = Be.makeLineSpan("frac-line", e), d = h.height, f = h.height) : (h = null, d = 0, f = e.fontMetrics().defaultRuleThickness);
  var p, g, m;
  r.size === zt.DISPLAY.size || t.size === "display" ? (p = e.fontMetrics().num1, d > 0 ? g = 3 * f : g = 7 * f, m = e.fontMetrics().denom1) : (d > 0 ? (p = e.fontMetrics().num2, g = f) : (p = e.fontMetrics().num3, g = 3 * f), m = e.fontMetrics().denom2);
  var v;
  if (h) {
    var b = e.fontMetrics().axisHeight;
    p - s.depth - (b + 0.5 * d) < g && (p += g - (p - s.depth - (b + 0.5 * d))), b - 0.5 * d - (u.height - m) < g && (m += g - (b - 0.5 * d - (u.height - m)));
    var w = -(b - 0.5 * d);
    v = Be.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: u,
        shift: m
      }, {
        type: "elem",
        elem: h,
        shift: w
      }, {
        type: "elem",
        elem: s,
        shift: -p
      }]
    }, e);
  } else {
    var y = p - s.depth - (u.height - m);
    y < g && (p += 0.5 * (g - y), m += 0.5 * (g - y)), v = Be.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: u,
        shift: m
      }, {
        type: "elem",
        elem: s,
        shift: -p
      }]
    }, e);
  }
  a = e.havingStyle(r), v.height *= a.sizeMultiplier / e.sizeMultiplier, v.depth *= a.sizeMultiplier / e.sizeMultiplier;
  var T;
  r.size === zt.DISPLAY.size ? T = e.fontMetrics().delim1 : r.size === zt.SCRIPTSCRIPT.size ? T = e.havingStyle(zt.SCRIPT).fontMetrics().delim2 : T = e.fontMetrics().delim2;
  var E, L;
  return t.leftDelim == null ? E = Lp(e, ["mopen"]) : E = Yo.customSizedDelim(t.leftDelim, T, !0, e.havingStyle(r), t.mode, ["mopen"]), t.continued ? L = Be.makeSpan([]) : t.rightDelim == null ? L = Lp(e, ["mclose"]) : L = Yo.customSizedDelim(t.rightDelim, T, !0, e.havingStyle(r), t.mode, ["mclose"]), Be.makeSpan(["mord"].concat(a.sizingClasses(e)), [E, Be.makeSpan(["mfrac"], [v]), L], e);
}, Ak = (t, e) => {
  var r = new it.MathNode("mfrac", [Pr(t.numer, e), Pr(t.denom, e)]);
  if (!t.hasBarLine)
    r.setAttribute("linethickness", "0px");
  else if (t.barSize) {
    var n = tn(t.barSize, e);
    r.setAttribute("linethickness", pt(n));
  }
  var i = tG(t.size, e.style);
  if (i.size !== e.style.size) {
    r = new it.MathNode("mstyle", [r]);
    var a = i.size === zt.DISPLAY.size ? "true" : "false";
    r.setAttribute("displaystyle", a), r.setAttribute("scriptlevel", "0");
  }
  if (t.leftDelim != null || t.rightDelim != null) {
    var s = [];
    if (t.leftDelim != null) {
      var o = new it.MathNode("mo", [new it.TextNode(t.leftDelim.replace("\\", ""))]);
      o.setAttribute("fence", "true"), s.push(o);
    }
    if (s.push(r), t.rightDelim != null) {
      var l = new it.MathNode("mo", [new it.TextNode(t.rightDelim.replace("\\", ""))]);
      l.setAttribute("fence", "true"), s.push(l);
    }
    return vk(s);
  }
  return r;
};
Tt({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // cant be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: !0
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0], a = e[1], s, o = null, l = null, u = "auto";
    switch (n) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        s = !0;
        break;
      case "\\\\atopfrac":
        s = !1;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        s = !1, o = "(", l = ")";
        break;
      case "\\\\bracefrac":
        s = !1, o = "\\{", l = "\\}";
        break;
      case "\\\\brackfrac":
        s = !1, o = "[", l = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (n) {
      case "\\dfrac":
      case "\\dbinom":
        u = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        u = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: r.mode,
      continued: !1,
      numer: i,
      denom: a,
      hasBarLine: s,
      leftDelim: o,
      rightDelim: l,
      size: u,
      barSize: null
    };
  },
  htmlBuilder: Ck,
  mathmlBuilder: Ak
});
Tt({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0], a = e[1];
    return {
      type: "genfrac",
      mode: r.mode,
      continued: !0,
      numer: i,
      denom: a,
      hasBarLine: !0,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
Tt({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: !0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r,
      token: n
    } = t, i;
    switch (r) {
      case "\\over":
        i = "\\frac";
        break;
      case "\\choose":
        i = "\\binom";
        break;
      case "\\atop":
        i = "\\\\atopfrac";
        break;
      case "\\brace":
        i = "\\\\bracefrac";
        break;
      case "\\brack":
        i = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: e.mode,
      replaceWith: i,
      token: n
    };
  }
});
var pA = ["display", "text", "script", "scriptscript"], gA = function(e) {
  var r = null;
  return e.length > 0 && (r = e, r = r === "." ? null : r), r;
};
Tt({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: !0,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(t, e) {
    var {
      parser: r
    } = t, n = e[4], i = e[5], a = xy(e[0]), s = a.type === "atom" && a.family === "open" ? gA(a.text) : null, o = xy(e[1]), l = o.type === "atom" && o.family === "close" ? gA(o.text) : null, u = Jt(e[2], "size"), h, d = null;
    u.isBlank ? h = !0 : (d = u.value, h = d.number > 0);
    var f = "auto", p = e[3];
    if (p.type === "ordgroup") {
      if (p.body.length > 0) {
        var g = Jt(p.body[0], "textord");
        f = pA[Number(g.text)];
      }
    } else
      p = Jt(p, "textord"), f = pA[Number(p.text)];
    return {
      type: "genfrac",
      mode: r.mode,
      numer: n,
      denom: i,
      continued: !1,
      hasBarLine: h,
      barSize: d,
      leftDelim: s,
      rightDelim: l,
      size: f
    };
  },
  htmlBuilder: Ck,
  mathmlBuilder: Ak
});
Tt({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: !0
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n,
      token: i
    } = t;
    return {
      type: "infix",
      mode: r.mode,
      replaceWith: "\\\\abovefrac",
      size: Jt(e[0], "size").value,
      token: i
    };
  }
});
Tt({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0], a = ife(Jt(e[1], "infix").size), s = e[2], o = a.number > 0;
    return {
      type: "genfrac",
      mode: r.mode,
      numer: i,
      denom: s,
      continued: !1,
      hasBarLine: o,
      barSize: a,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: Ck,
  mathmlBuilder: Ak
});
var rG = (t, e) => {
  var r = e.style, n, i;
  t.type === "supsub" ? (n = t.sup ? vr(t.sup, e.havingStyle(r.sup()), e) : vr(t.sub, e.havingStyle(r.sub()), e), i = Jt(t.base, "horizBrace")) : i = Jt(t, "horizBrace");
  var a = vr(i.base, e.havingBaseStyle(zt.DISPLAY)), s = rl.svgSpan(i, e), o;
  if (i.isOver ? (o = Be.makeVList({
    positionType: "firstBaseline",
    children: [{
      type: "elem",
      elem: a
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: s
    }]
  }, e), o.children[0].children[0].children[1].classes.push("svg-align")) : (o = Be.makeVList({
    positionType: "bottom",
    positionData: a.depth + 0.1 + s.height,
    children: [{
      type: "elem",
      elem: s
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: a
    }]
  }, e), o.children[0].children[0].children[0].classes.push("svg-align")), n) {
    var l = Be.makeSpan(["mord", i.isOver ? "mover" : "munder"], [o], e);
    i.isOver ? o = Be.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: l
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: n
      }]
    }, e) : o = Be.makeVList({
      positionType: "bottom",
      positionData: l.depth + 0.2 + n.height + n.depth,
      children: [{
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: l
      }]
    }, e);
  }
  return Be.makeSpan(["mord", i.isOver ? "mover" : "munder"], [o], e);
}, _0e = (t, e) => {
  var r = rl.mathMLnode(t.label);
  return new it.MathNode(t.isOver ? "mover" : "munder", [Pr(t.base, e), r]);
};
Tt({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t;
    return {
      type: "horizBrace",
      mode: r.mode,
      label: n,
      isOver: /^\\over/.test(n),
      base: e[0]
    };
  },
  htmlBuilder: rG,
  mathmlBuilder: _0e
});
Tt({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = e[1], i = Jt(e[0], "url").url;
    return r.settings.isTrusted({
      command: "\\href",
      url: i
    }) ? {
      type: "href",
      mode: r.mode,
      href: i,
      body: xn(n)
    } : r.formatUnsupportedCmd("\\href");
  },
  htmlBuilder: (t, e) => {
    var r = $n(t.body, e, !1);
    return Be.makeAnchor(t.href, [], r, e);
  },
  mathmlBuilder: (t, e) => {
    var r = Kl(t.body, e);
    return r instanceof wa || (r = new wa("mrow", [r])), r.setAttribute("href", t.href), r;
  }
});
Tt({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = Jt(e[0], "url").url;
    if (!r.settings.isTrusted({
      command: "\\url",
      url: n
    }))
      return r.formatUnsupportedCmd("\\url");
    for (var i = [], a = 0; a < n.length; a++) {
      var s = n[a];
      s === "~" && (s = "\\textasciitilde"), i.push({
        type: "textord",
        mode: "text",
        text: s
      });
    }
    var o = {
      type: "text",
      mode: r.mode,
      font: "\\texttt",
      body: i
    };
    return {
      type: "href",
      mode: r.mode,
      href: n,
      body: xn(o)
    };
  }
});
Tt({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: !0,
    primitive: !0
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "hbox",
      mode: r.mode,
      body: xn(e[0])
    };
  },
  htmlBuilder(t, e) {
    var r = $n(t.body, e, !1);
    return Be.makeFragment(r);
  },
  mathmlBuilder(t, e) {
    return new it.MathNode("mrow", da(t.body, e));
  }
});
Tt({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n,
      token: i
    } = t, a = Jt(e[0], "raw").string, s = e[1];
    r.settings.strict && r.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    var o, l = {};
    switch (n) {
      case "\\htmlClass":
        l.class = a, o = {
          command: "\\htmlClass",
          class: a
        };
        break;
      case "\\htmlId":
        l.id = a, o = {
          command: "\\htmlId",
          id: a
        };
        break;
      case "\\htmlStyle":
        l.style = a, o = {
          command: "\\htmlStyle",
          style: a
        };
        break;
      case "\\htmlData": {
        for (var u = a.split(","), h = 0; h < u.length; h++) {
          var d = u[h], f = d.indexOf("=");
          if (f < 0)
            throw new ot("\\htmlData key/value '" + d + "' missing equals sign");
          var p = d.slice(0, f), g = d.slice(f + 1);
          l["data-" + p.trim()] = g;
        }
        o = {
          command: "\\htmlData",
          attributes: l
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    return r.settings.isTrusted(o) ? {
      type: "html",
      mode: r.mode,
      attributes: l,
      body: xn(s)
    } : r.formatUnsupportedCmd(n);
  },
  htmlBuilder: (t, e) => {
    var r = $n(t.body, e, !1), n = ["enclosing"];
    t.attributes.class && n.push(...t.attributes.class.trim().split(/\s+/));
    var i = Be.makeSpan(n, r, e);
    for (var a in t.attributes)
      a !== "class" && t.attributes.hasOwnProperty(a) && i.setAttribute(a, t.attributes[a]);
    return i;
  },
  mathmlBuilder: (t, e) => Kl(t.body, e)
});
Tt({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t;
    return {
      type: "htmlmathml",
      mode: r.mode,
      html: xn(e[0]),
      mathml: xn(e[1])
    };
  },
  htmlBuilder: (t, e) => {
    var r = $n(t.html, e, !1);
    return Be.makeFragment(r);
  },
  mathmlBuilder: (t, e) => Kl(t.mathml, e)
});
var T4 = function(e) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(e))
    return {
      number: +e,
      unit: "bp"
    };
  var r = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(e);
  if (!r)
    throw new ot("Invalid size: '" + e + "' in \\includegraphics");
  var n = {
    number: +(r[1] + r[2]),
    // sign + magnitude, cast to number
    unit: r[3]
  };
  if (!wz(n))
    throw new ot("Invalid unit: '" + n.unit + "' in \\includegraphics.");
  return n;
};
Tt({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: !1
  },
  handler: (t, e, r) => {
    var {
      parser: n
    } = t, i = {
      number: 0,
      unit: "em"
    }, a = {
      number: 0.9,
      unit: "em"
    }, s = {
      number: 0,
      unit: "em"
    }, o = "";
    if (r[0])
      for (var l = Jt(r[0], "raw").string, u = l.split(","), h = 0; h < u.length; h++) {
        var d = u[h].split("=");
        if (d.length === 2) {
          var f = d[1].trim();
          switch (d[0].trim()) {
            case "alt":
              o = f;
              break;
            case "width":
              i = T4(f);
              break;
            case "height":
              a = T4(f);
              break;
            case "totalheight":
              s = T4(f);
              break;
            default:
              throw new ot("Invalid key: '" + d[0] + "' in \\includegraphics.");
          }
        }
      }
    var p = Jt(e[0], "url").url;
    return o === "" && (o = p, o = o.replace(/^.*[\\/]/, ""), o = o.substring(0, o.lastIndexOf("."))), n.settings.isTrusted({
      command: "\\includegraphics",
      url: p
    }) ? {
      type: "includegraphics",
      mode: n.mode,
      alt: o,
      width: i,
      height: a,
      totalheight: s,
      src: p
    } : n.formatUnsupportedCmd("\\includegraphics");
  },
  htmlBuilder: (t, e) => {
    var r = tn(t.height, e), n = 0;
    t.totalheight.number > 0 && (n = tn(t.totalheight, e) - r);
    var i = 0;
    t.width.number > 0 && (i = tn(t.width, e));
    var a = {
      height: pt(r + n)
    };
    i > 0 && (a.width = pt(i)), n > 0 && (a.verticalAlign = pt(-n));
    var s = new _fe(t.src, t.alt, a);
    return s.height = r, s.depth = n, s;
  },
  mathmlBuilder: (t, e) => {
    var r = new it.MathNode("mglyph", []);
    r.setAttribute("alt", t.alt);
    var n = tn(t.height, e), i = 0;
    if (t.totalheight.number > 0 && (i = tn(t.totalheight, e) - n, r.setAttribute("valign", pt(-i))), r.setAttribute("height", pt(n + i)), t.width.number > 0) {
      var a = tn(t.width, e);
      r.setAttribute("width", pt(a));
    }
    return r.setAttribute("src", t.src), r;
  }
});
Tt({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: !0,
    allowedInText: !0
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t, i = Jt(e[0], "size");
    if (r.settings.strict) {
      var a = n[1] === "m", s = i.value.unit === "mu";
      a ? (s || r.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + n + " supports only mu units, " + ("not " + i.value.unit + " units")), r.mode !== "math" && r.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + n + " works only in math mode")) : s && r.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + n + " doesn't support mu units");
    }
    return {
      type: "kern",
      mode: r.mode,
      dimension: i.value
    };
  },
  htmlBuilder(t, e) {
    return Be.makeGlue(t.dimension, e);
  },
  mathmlBuilder(t, e) {
    var r = tn(t.dimension, e);
    return new it.SpaceNode(r);
  }
});
Tt({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0];
    return {
      type: "lap",
      mode: r.mode,
      alignment: n.slice(5),
      body: i
    };
  },
  htmlBuilder: (t, e) => {
    var r;
    t.alignment === "clap" ? (r = Be.makeSpan([], [vr(t.body, e)]), r = Be.makeSpan(["inner"], [r], e)) : r = Be.makeSpan(["inner"], [vr(t.body, e)]);
    var n = Be.makeSpan(["fix"], []), i = Be.makeSpan([t.alignment], [r, n], e), a = Be.makeSpan(["strut"]);
    return a.style.height = pt(i.height + i.depth), i.depth && (a.style.verticalAlign = pt(-i.depth)), i.children.unshift(a), i = Be.makeSpan(["thinbox"], [i], e), Be.makeSpan(["mord", "vbox"], [i], e);
  },
  mathmlBuilder: (t, e) => {
    var r = new it.MathNode("mpadded", [Pr(t.body, e)]);
    if (t.alignment !== "rlap") {
      var n = t.alignment === "llap" ? "-1" : "-0.5";
      r.setAttribute("lspace", n + "width");
    }
    return r.setAttribute("width", "0px"), r;
  }
});
Tt({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(t, e) {
    var {
      funcName: r,
      parser: n
    } = t, i = n.mode;
    n.switchMode("math");
    var a = r === "\\(" ? "\\)" : "$", s = n.parseExpression(!1, a);
    return n.expect(a), n.switchMode(i), {
      type: "styling",
      mode: n.mode,
      style: "text",
      body: s
    };
  }
});
Tt({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(t, e) {
    throw new ot("Mismatched " + t.funcName);
  }
});
var mA = (t, e) => {
  switch (e.style.size) {
    case zt.DISPLAY.size:
      return t.display;
    case zt.TEXT.size:
      return t.text;
    case zt.SCRIPT.size:
      return t.script;
    case zt.SCRIPTSCRIPT.size:
      return t.scriptscript;
    default:
      return t.text;
  }
};
Tt({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t;
    return {
      type: "mathchoice",
      mode: r.mode,
      display: xn(e[0]),
      text: xn(e[1]),
      script: xn(e[2]),
      scriptscript: xn(e[3])
    };
  },
  htmlBuilder: (t, e) => {
    var r = mA(t, e), n = $n(r, e, !1);
    return Be.makeFragment(n);
  },
  mathmlBuilder: (t, e) => {
    var r = mA(t, e);
    return Kl(r, e);
  }
});
var nG = (t, e, r, n, i, a, s) => {
  t = Be.makeSpan([], [t]);
  var o = r && Tr.isCharacterBox(r), l, u;
  if (e) {
    var h = vr(e, n.havingStyle(i.sup()), n);
    u = {
      elem: h,
      kern: Math.max(n.fontMetrics().bigOpSpacing1, n.fontMetrics().bigOpSpacing3 - h.depth)
    };
  }
  if (r) {
    var d = vr(r, n.havingStyle(i.sub()), n);
    l = {
      elem: d,
      kern: Math.max(n.fontMetrics().bigOpSpacing2, n.fontMetrics().bigOpSpacing4 - d.height)
    };
  }
  var f;
  if (u && l) {
    var p = n.fontMetrics().bigOpSpacing5 + l.elem.height + l.elem.depth + l.kern + t.depth + s;
    f = Be.makeVList({
      positionType: "bottom",
      positionData: p,
      children: [{
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: l.elem,
        marginLeft: pt(-a)
      }, {
        type: "kern",
        size: l.kern
      }, {
        type: "elem",
        elem: t
      }, {
        type: "kern",
        size: u.kern
      }, {
        type: "elem",
        elem: u.elem,
        marginLeft: pt(a)
      }, {
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }]
    }, n);
  } else if (l) {
    var g = t.height - s;
    f = Be.makeVList({
      positionType: "top",
      positionData: g,
      children: [{
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: l.elem,
        marginLeft: pt(-a)
      }, {
        type: "kern",
        size: l.kern
      }, {
        type: "elem",
        elem: t
      }]
    }, n);
  } else if (u) {
    var m = t.depth + s;
    f = Be.makeVList({
      positionType: "bottom",
      positionData: m,
      children: [{
        type: "elem",
        elem: t
      }, {
        type: "kern",
        size: u.kern
      }, {
        type: "elem",
        elem: u.elem,
        marginLeft: pt(a)
      }, {
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }]
    }, n);
  } else
    return t;
  var v = [f];
  if (l && a !== 0 && !o) {
    var y = Be.makeSpan(["mspace"], [], n);
    y.style.marginRight = pt(a), v.unshift(y);
  }
  return Be.makeSpan(["mop", "op-limits"], v, n);
}, iG = ["\\smallint"], Jd = (t, e) => {
  var r, n, i = !1, a;
  t.type === "supsub" ? (r = t.sup, n = t.sub, a = Jt(t.base, "op"), i = !0) : a = Jt(t, "op");
  var s = e.style, o = !1;
  s.size === zt.DISPLAY.size && a.symbol && !iG.includes(a.name) && (o = !0);
  var l;
  if (a.symbol) {
    var u = o ? "Size2-Regular" : "Size1-Regular", h = "";
    if ((a.name === "\\oiint" || a.name === "\\oiiint") && (h = a.name.slice(1), a.name = h === "oiint" ? "\\iint" : "\\iiint"), l = Be.makeSymbol(a.name, u, "math", e, ["mop", "op-symbol", o ? "large-op" : "small-op"]), h.length > 0) {
      var d = l.italic, f = Be.staticSvg(h + "Size" + (o ? "2" : "1"), e);
      l = Be.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: l,
          shift: 0
        }, {
          type: "elem",
          elem: f,
          shift: o ? 0.08 : 0
        }]
      }, e), a.name = "\\" + h, l.classes.unshift("mop"), l.italic = d;
    }
  } else if (a.body) {
    var p = $n(a.body, e, !0);
    p.length === 1 && p[0] instanceof es ? (l = p[0], l.classes[0] = "mop") : l = Be.makeSpan(["mop"], p, e);
  } else {
    for (var g = [], m = 1; m < a.name.length; m++)
      g.push(Be.mathsym(a.name[m], a.mode, e));
    l = Be.makeSpan(["mop"], g, e);
  }
  var v = 0, y = 0;
  return (l instanceof es || a.name === "\\oiint" || a.name === "\\oiiint") && !a.suppressBaseShift && (v = (l.height - l.depth) / 2 - e.fontMetrics().axisHeight, y = l.italic), i ? nG(l, r, n, e, s, y, v) : (v && (l.style.position = "relative", l.style.top = pt(v)), l);
}, xg = (t, e) => {
  var r;
  if (t.symbol)
    r = new wa("mo", [ts(t.name, t.mode)]), iG.includes(t.name) && r.setAttribute("largeop", "false");
  else if (t.body)
    r = new wa("mo", da(t.body, e));
  else {
    r = new wa("mi", [new Xs(t.name.slice(1))]);
    var n = new wa("mo", [ts("", "text")]);
    t.parentIsSupSub ? r = new wa("mrow", [r, n]) : r = Nz([r, n]);
  }
  return r;
}, L0e = {
  "": "\\prod",
  "": "\\coprod",
  "": "\\sum",
  "": "\\bigwedge",
  "": "\\bigvee",
  "": "\\bigcap",
  "": "\\bigcup",
  "": "\\bigodot",
  "": "\\bigoplus",
  "": "\\bigotimes",
  "": "\\biguplus",
  "": "\\bigsqcup"
};
Tt({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "", "", "", "", "", "", "", "", "", "", "", ""],
  props: {
    numArgs: 0
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, i = n;
    return i.length === 1 && (i = L0e[i]), {
      type: "op",
      mode: r.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !0,
      name: i
    };
  },
  htmlBuilder: Jd,
  mathmlBuilder: xg
});
Tt({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = e[0];
    return {
      type: "op",
      mode: r.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      body: xn(n)
    };
  },
  htmlBuilder: Jd,
  mathmlBuilder: xg
});
var R0e = {
  "": "\\int",
  "": "\\iint",
  "": "\\iiint",
  "": "\\oint",
  "": "\\oiint",
  "": "\\oiiint"
};
Tt({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t;
    return {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      name: r
    };
  },
  htmlBuilder: Jd,
  mathmlBuilder: xg
});
Tt({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t;
    return {
      type: "op",
      mode: e.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !1,
      name: r
    };
  },
  htmlBuilder: Jd,
  mathmlBuilder: xg
});
Tt({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "", "", "", "", "", ""],
  props: {
    numArgs: 0,
    allowedInArgument: !0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t, n = r;
    return n.length === 1 && (n = R0e[n]), {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !0,
      name: n
    };
  },
  htmlBuilder: Jd,
  mathmlBuilder: xg
});
var aG = (t, e) => {
  var r, n, i = !1, a;
  t.type === "supsub" ? (r = t.sup, n = t.sub, a = Jt(t.base, "operatorname"), i = !0) : a = Jt(t, "operatorname");
  var s;
  if (a.body.length > 0) {
    for (var o = a.body.map((d) => {
      var f = d.text;
      return typeof f == "string" ? {
        type: "textord",
        mode: d.mode,
        text: f
      } : d;
    }), l = $n(o, e.withFont("mathrm"), !0), u = 0; u < l.length; u++) {
      var h = l[u];
      h instanceof es && (h.text = h.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
    }
    s = Be.makeSpan(["mop"], l, e);
  } else
    s = Be.makeSpan(["mop"], [], e);
  return i ? nG(s, r, n, e, e.style, 0, 0) : s;
}, M0e = (t, e) => {
  for (var r = da(t.body, e.withFont("mathrm")), n = !0, i = 0; i < r.length; i++) {
    var a = r[i];
    if (!(a instanceof it.SpaceNode)) if (a instanceof it.MathNode)
      switch (a.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        // Do nothing yet.
        case "mo": {
          var s = a.children[0];
          a.children.length === 1 && s instanceof it.TextNode ? s.text = s.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : n = !1;
          break;
        }
        default:
          n = !1;
      }
    else
      n = !1;
  }
  if (n) {
    var o = r.map((h) => h.toText()).join("");
    r = [new it.TextNode(o)];
  }
  var l = new it.MathNode("mi", r);
  l.setAttribute("mathvariant", "normal");
  var u = new it.MathNode("mo", [ts("", "text")]);
  return t.parentIsSupSub ? new it.MathNode("mrow", [l, u]) : it.newDocumentFragment([l, u]);
};
Tt({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0];
    return {
      type: "operatorname",
      mode: r.mode,
      body: xn(i),
      alwaysHandleSupSub: n === "\\operatornamewithlimits",
      limits: !1,
      parentIsSupSub: !1
    };
  },
  htmlBuilder: aG,
  mathmlBuilder: M0e
});
le("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
Zu({
  type: "ordgroup",
  htmlBuilder(t, e) {
    return t.semisimple ? Be.makeFragment($n(t.body, e, !1)) : Be.makeSpan(["mord"], $n(t.body, e, !0), e);
  },
  mathmlBuilder(t, e) {
    return Kl(t.body, e, !0);
  }
});
Tt({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var {
      parser: r
    } = t, n = e[0];
    return {
      type: "overline",
      mode: r.mode,
      body: n
    };
  },
  htmlBuilder(t, e) {
    var r = vr(t.body, e.havingCrampedStyle()), n = Be.makeLineSpan("overline-line", e), i = e.fontMetrics().defaultRuleThickness, a = Be.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: i
      }]
    }, e);
    return Be.makeSpan(["mord", "overline"], [a], e);
  },
  mathmlBuilder(t, e) {
    var r = new it.MathNode("mo", [new it.TextNode("")]);
    r.setAttribute("stretchy", "true");
    var n = new it.MathNode("mover", [Pr(t.body, e), r]);
    return n.setAttribute("accent", "true"), n;
  }
});
Tt({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = e[0];
    return {
      type: "phantom",
      mode: r.mode,
      body: xn(n)
    };
  },
  htmlBuilder: (t, e) => {
    var r = $n(t.body, e.withPhantom(), !1);
    return Be.makeFragment(r);
  },
  mathmlBuilder: (t, e) => {
    var r = da(t.body, e);
    return new it.MathNode("mphantom", r);
  }
});
Tt({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = e[0];
    return {
      type: "hphantom",
      mode: r.mode,
      body: n
    };
  },
  htmlBuilder: (t, e) => {
    var r = Be.makeSpan([], [vr(t.body, e.withPhantom())]);
    if (r.height = 0, r.depth = 0, r.children)
      for (var n = 0; n < r.children.length; n++)
        r.children[n].height = 0, r.children[n].depth = 0;
    return r = Be.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r
      }]
    }, e), Be.makeSpan(["mord"], [r], e);
  },
  mathmlBuilder: (t, e) => {
    var r = da(xn(t.body), e), n = new it.MathNode("mphantom", r), i = new it.MathNode("mpadded", [n]);
    return i.setAttribute("height", "0px"), i.setAttribute("depth", "0px"), i;
  }
});
Tt({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = e[0];
    return {
      type: "vphantom",
      mode: r.mode,
      body: n
    };
  },
  htmlBuilder: (t, e) => {
    var r = Be.makeSpan(["inner"], [vr(t.body, e.withPhantom())]), n = Be.makeSpan(["fix"], []);
    return Be.makeSpan(["mord", "rlap"], [r, n], e);
  },
  mathmlBuilder: (t, e) => {
    var r = da(xn(t.body), e), n = new it.MathNode("mphantom", r), i = new it.MathNode("mpadded", [n]);
    return i.setAttribute("width", "0px"), i;
  }
});
Tt({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: !0
  },
  handler(t, e) {
    var {
      parser: r
    } = t, n = Jt(e[0], "size").value, i = e[1];
    return {
      type: "raisebox",
      mode: r.mode,
      dy: n,
      body: i
    };
  },
  htmlBuilder(t, e) {
    var r = vr(t.body, e), n = tn(t.dy, e);
    return Be.makeVList({
      positionType: "shift",
      positionData: -n,
      children: [{
        type: "elem",
        elem: r
      }]
    }, e);
  },
  mathmlBuilder(t, e) {
    var r = new it.MathNode("mpadded", [Pr(t.body, e)]), n = t.dy.number + t.dy.unit;
    return r.setAttribute("voffset", n), r;
  }
});
Tt({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInArgument: !0
  },
  handler(t) {
    var {
      parser: e
    } = t;
    return {
      type: "internal",
      mode: e.mode
    };
  }
});
Tt({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    argTypes: ["size", "size", "size"]
  },
  handler(t, e, r) {
    var {
      parser: n
    } = t, i = r[0], a = Jt(e[0], "size"), s = Jt(e[1], "size");
    return {
      type: "rule",
      mode: n.mode,
      shift: i && Jt(i, "size").value,
      width: a.value,
      height: s.value
    };
  },
  htmlBuilder(t, e) {
    var r = Be.makeSpan(["mord", "rule"], [], e), n = tn(t.width, e), i = tn(t.height, e), a = t.shift ? tn(t.shift, e) : 0;
    return r.style.borderRightWidth = pt(n), r.style.borderTopWidth = pt(i), r.style.bottom = pt(a), r.width = n, r.height = i + a, r.depth = -a, r.maxFontSize = i * 1.125 * e.sizeMultiplier, r;
  },
  mathmlBuilder(t, e) {
    var r = tn(t.width, e), n = tn(t.height, e), i = t.shift ? tn(t.shift, e) : 0, a = e.color && e.getColor() || "black", s = new it.MathNode("mspace");
    s.setAttribute("mathbackground", a), s.setAttribute("width", pt(r)), s.setAttribute("height", pt(n));
    var o = new it.MathNode("mpadded", [s]);
    return i >= 0 ? o.setAttribute("height", pt(i)) : (o.setAttribute("height", pt(i)), o.setAttribute("depth", pt(-i))), o.setAttribute("voffset", pt(i)), o;
  }
});
function sG(t, e, r) {
  for (var n = $n(t, e, !1), i = e.sizeMultiplier / r.sizeMultiplier, a = 0; a < n.length; a++) {
    var s = n[a].classes.indexOf("sizing");
    s < 0 ? Array.prototype.push.apply(n[a].classes, e.sizingClasses(r)) : n[a].classes[s + 1] === "reset-size" + e.size && (n[a].classes[s + 1] = "reset-size" + r.size), n[a].height *= i, n[a].depth *= i;
  }
  return Be.makeFragment(n);
}
var vA = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"], N0e = (t, e) => {
  var r = e.havingSize(t.size);
  return sG(t.body, r, e);
};
Tt({
  type: "sizing",
  names: vA,
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      breakOnTokenText: r,
      funcName: n,
      parser: i
    } = t, a = i.parseExpression(!1, r);
    return {
      type: "sizing",
      mode: i.mode,
      // Figure out what size to use based on the list of functions above
      size: vA.indexOf(n) + 1,
      body: a
    };
  },
  htmlBuilder: N0e,
  mathmlBuilder: (t, e) => {
    var r = e.havingSize(t.size), n = da(t.body, r), i = new it.MathNode("mstyle", n);
    return i.setAttribute("mathsize", pt(r.sizeMultiplier)), i;
  }
});
Tt({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: !0
  },
  handler: (t, e, r) => {
    var {
      parser: n
    } = t, i = !1, a = !1, s = r[0] && Jt(r[0], "ordgroup");
    if (s)
      for (var o = "", l = 0; l < s.body.length; ++l) {
        var u = s.body[l];
        if (o = u.text, o === "t")
          i = !0;
        else if (o === "b")
          a = !0;
        else {
          i = !1, a = !1;
          break;
        }
      }
    else
      i = !0, a = !0;
    var h = e[0];
    return {
      type: "smash",
      mode: n.mode,
      body: h,
      smashHeight: i,
      smashDepth: a
    };
  },
  htmlBuilder: (t, e) => {
    var r = Be.makeSpan([], [vr(t.body, e)]);
    if (!t.smashHeight && !t.smashDepth)
      return r;
    if (t.smashHeight && (r.height = 0, r.children))
      for (var n = 0; n < r.children.length; n++)
        r.children[n].height = 0;
    if (t.smashDepth && (r.depth = 0, r.children))
      for (var i = 0; i < r.children.length; i++)
        r.children[i].depth = 0;
    var a = Be.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r
      }]
    }, e);
    return Be.makeSpan(["mord"], [a], e);
  },
  mathmlBuilder: (t, e) => {
    var r = new it.MathNode("mpadded", [Pr(t.body, e)]);
    return t.smashHeight && r.setAttribute("height", "0px"), t.smashDepth && r.setAttribute("depth", "0px"), r;
  }
});
Tt({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(t, e, r) {
    var {
      parser: n
    } = t, i = r[0], a = e[0];
    return {
      type: "sqrt",
      mode: n.mode,
      body: a,
      index: i
    };
  },
  htmlBuilder(t, e) {
    var r = vr(t.body, e.havingCrampedStyle());
    r.height === 0 && (r.height = e.fontMetrics().xHeight), r = Be.wrapFragment(r, e);
    var n = e.fontMetrics(), i = n.defaultRuleThickness, a = i;
    e.style.id < zt.TEXT.id && (a = e.fontMetrics().xHeight);
    var s = i + a / 4, o = r.height + r.depth + s + i, {
      span: l,
      ruleWidth: u,
      advanceWidth: h
    } = Yo.sqrtImage(o, e), d = l.height - u;
    d > r.height + r.depth + s && (s = (s + d - r.height - r.depth) / 2);
    var f = l.height - r.height - s - u;
    r.style.paddingLeft = pt(h);
    var p = Be.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(r.height + f)
      }, {
        type: "elem",
        elem: l
      }, {
        type: "kern",
        size: u
      }]
    }, e);
    if (t.index) {
      var g = e.havingStyle(zt.SCRIPTSCRIPT), m = vr(t.index, g, e), v = 0.6 * (p.height - p.depth), y = Be.makeVList({
        positionType: "shift",
        positionData: -v,
        children: [{
          type: "elem",
          elem: m
        }]
      }, e), b = Be.makeSpan(["root"], [y]);
      return Be.makeSpan(["mord", "sqrt"], [b, p], e);
    } else
      return Be.makeSpan(["mord", "sqrt"], [p], e);
  },
  mathmlBuilder(t, e) {
    var {
      body: r,
      index: n
    } = t;
    return n ? new it.MathNode("mroot", [Pr(r, e), Pr(n, e)]) : new it.MathNode("msqrt", [Pr(r, e)]);
  }
});
var yA = {
  display: zt.DISPLAY,
  text: zt.TEXT,
  script: zt.SCRIPT,
  scriptscript: zt.SCRIPTSCRIPT
};
Tt({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(t, e) {
    var {
      breakOnTokenText: r,
      funcName: n,
      parser: i
    } = t, a = i.parseExpression(!0, r), s = n.slice(1, n.length - 5);
    return {
      type: "styling",
      mode: i.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style: s,
      body: a
    };
  },
  htmlBuilder(t, e) {
    var r = yA[t.style], n = e.havingStyle(r).withFont("");
    return sG(t.body, n, e);
  },
  mathmlBuilder(t, e) {
    var r = yA[t.style], n = e.havingStyle(r), i = da(t.body, n), a = new it.MathNode("mstyle", i), s = {
      display: ["0", "true"],
      text: ["0", "false"],
      script: ["1", "false"],
      scriptscript: ["2", "false"]
    }, o = s[t.style];
    return a.setAttribute("scriptlevel", o[0]), a.setAttribute("displaystyle", o[1]), a;
  }
});
var I0e = function(e, r) {
  var n = e.base;
  if (n)
    if (n.type === "op") {
      var i = n.limits && (r.style.size === zt.DISPLAY.size || n.alwaysHandleSupSub);
      return i ? Jd : null;
    } else if (n.type === "operatorname") {
      var a = n.alwaysHandleSupSub && (r.style.size === zt.DISPLAY.size || n.limits);
      return a ? aG : null;
    } else {
      if (n.type === "accent")
        return Tr.isCharacterBox(n.base) ? bk : null;
      if (n.type === "horizBrace") {
        var s = !e.sub;
        return s === n.isOver ? rG : null;
      } else
        return null;
    }
  else return null;
};
Zu({
  type: "supsub",
  htmlBuilder(t, e) {
    var r = I0e(t, e);
    if (r)
      return r(t, e);
    var {
      base: n,
      sup: i,
      sub: a
    } = t, s = vr(n, e), o, l, u = e.fontMetrics(), h = 0, d = 0, f = n && Tr.isCharacterBox(n);
    if (i) {
      var p = e.havingStyle(e.style.sup());
      o = vr(i, p, e), f || (h = s.height - p.fontMetrics().supDrop * p.sizeMultiplier / e.sizeMultiplier);
    }
    if (a) {
      var g = e.havingStyle(e.style.sub());
      l = vr(a, g, e), f || (d = s.depth + g.fontMetrics().subDrop * g.sizeMultiplier / e.sizeMultiplier);
    }
    var m;
    e.style === zt.DISPLAY ? m = u.sup1 : e.style.cramped ? m = u.sup3 : m = u.sup2;
    var v = e.sizeMultiplier, y = pt(0.5 / u.ptPerEm / v), b = null;
    if (l) {
      var w = t.base && t.base.type === "op" && t.base.name && (t.base.name === "\\oiint" || t.base.name === "\\oiiint");
      (s instanceof es || w) && (b = pt(-s.italic));
    }
    var T;
    if (o && l) {
      h = Math.max(h, m, o.depth + 0.25 * u.xHeight), d = Math.max(d, u.sub2);
      var E = u.defaultRuleThickness, L = 4 * E;
      if (h - o.depth - (l.height - d) < L) {
        d = L - (h - o.depth) + l.height;
        var k = 0.8 * u.xHeight - (h - o.depth);
        k > 0 && (h += k, d -= k);
      }
      var C = [{
        type: "elem",
        elem: l,
        shift: d,
        marginRight: y,
        marginLeft: b
      }, {
        type: "elem",
        elem: o,
        shift: -h,
        marginRight: y
      }];
      T = Be.makeVList({
        positionType: "individualShift",
        children: C
      }, e);
    } else if (l) {
      d = Math.max(d, u.sub1, l.height - 0.8 * u.xHeight);
      var A = [{
        type: "elem",
        elem: l,
        marginLeft: b,
        marginRight: y
      }];
      T = Be.makeVList({
        positionType: "shift",
        positionData: d,
        children: A
      }, e);
    } else if (o)
      h = Math.max(h, m, o.depth + 0.25 * u.xHeight), T = Be.makeVList({
        positionType: "shift",
        positionData: -h,
        children: [{
          type: "elem",
          elem: o,
          marginRight: y
        }]
      }, e);
    else
      throw new Error("supsub must have either sup or sub.");
    var R = aT(s, "right") || "mord";
    return Be.makeSpan([R], [s, Be.makeSpan(["msupsub"], [T])], e);
  },
  mathmlBuilder(t, e) {
    var r = !1, n, i;
    t.base && t.base.type === "horizBrace" && (i = !!t.sup, i === t.base.isOver && (r = !0, n = t.base.isOver)), t.base && (t.base.type === "op" || t.base.type === "operatorname") && (t.base.parentIsSupSub = !0);
    var a = [Pr(t.base, e)];
    t.sub && a.push(Pr(t.sub, e)), t.sup && a.push(Pr(t.sup, e));
    var s;
    if (r)
      s = n ? "mover" : "munder";
    else if (t.sub)
      if (t.sup) {
        var u = t.base;
        u && u.type === "op" && u.limits && e.style === zt.DISPLAY || u && u.type === "operatorname" && u.alwaysHandleSupSub && (e.style === zt.DISPLAY || u.limits) ? s = "munderover" : s = "msubsup";
      } else {
        var l = t.base;
        l && l.type === "op" && l.limits && (e.style === zt.DISPLAY || l.alwaysHandleSupSub) || l && l.type === "operatorname" && l.alwaysHandleSupSub && (l.limits || e.style === zt.DISPLAY) ? s = "munder" : s = "msub";
      }
    else {
      var o = t.base;
      o && o.type === "op" && o.limits && (e.style === zt.DISPLAY || o.alwaysHandleSupSub) || o && o.type === "operatorname" && o.alwaysHandleSupSub && (o.limits || e.style === zt.DISPLAY) ? s = "mover" : s = "msup";
    }
    return new it.MathNode(s, a);
  }
});
Zu({
  type: "atom",
  htmlBuilder(t, e) {
    return Be.mathsym(t.text, t.mode, e, ["m" + t.family]);
  },
  mathmlBuilder(t, e) {
    var r = new it.MathNode("mo", [ts(t.text, t.mode)]);
    if (t.family === "bin") {
      var n = yk(t, e);
      n === "bold-italic" && r.setAttribute("mathvariant", n);
    } else t.family === "punct" ? r.setAttribute("separator", "true") : (t.family === "open" || t.family === "close") && r.setAttribute("stretchy", "false");
    return r;
  }
});
var oG = {
  mi: "italic",
  mn: "normal",
  mtext: "normal"
};
Zu({
  type: "mathord",
  htmlBuilder(t, e) {
    return Be.makeOrd(t, e, "mathord");
  },
  mathmlBuilder(t, e) {
    var r = new it.MathNode("mi", [ts(t.text, t.mode, e)]), n = yk(t, e) || "italic";
    return n !== oG[r.type] && r.setAttribute("mathvariant", n), r;
  }
});
Zu({
  type: "textord",
  htmlBuilder(t, e) {
    return Be.makeOrd(t, e, "textord");
  },
  mathmlBuilder(t, e) {
    var r = ts(t.text, t.mode, e), n = yk(t, e) || "normal", i;
    return t.mode === "text" ? i = new it.MathNode("mtext", [r]) : /[0-9]/.test(t.text) ? i = new it.MathNode("mn", [r]) : t.text === "\\prime" ? i = new it.MathNode("mo", [r]) : i = new it.MathNode("mi", [r]), n !== oG[i.type] && i.setAttribute("mathvariant", n), i;
  }
});
var E4 = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
}, k4 = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
Zu({
  type: "spacing",
  htmlBuilder(t, e) {
    if (k4.hasOwnProperty(t.text)) {
      var r = k4[t.text].className || "";
      if (t.mode === "text") {
        var n = Be.makeOrd(t, e, "textord");
        return n.classes.push(r), n;
      } else
        return Be.makeSpan(["mspace", r], [Be.mathsym(t.text, t.mode, e)], e);
    } else {
      if (E4.hasOwnProperty(t.text))
        return Be.makeSpan(["mspace", E4[t.text]], [], e);
      throw new ot('Unknown type of space "' + t.text + '"');
    }
  },
  mathmlBuilder(t, e) {
    var r;
    if (k4.hasOwnProperty(t.text))
      r = new it.MathNode("mtext", [new it.TextNode("")]);
    else {
      if (E4.hasOwnProperty(t.text))
        return new it.MathNode("mspace");
      throw new ot('Unknown type of space "' + t.text + '"');
    }
    return r;
  }
});
var xA = () => {
  var t = new it.MathNode("mtd", []);
  return t.setAttribute("width", "50%"), t;
};
Zu({
  type: "tag",
  mathmlBuilder(t, e) {
    var r = new it.MathNode("mtable", [new it.MathNode("mtr", [xA(), new it.MathNode("mtd", [Kl(t.body, e)]), xA(), new it.MathNode("mtd", [Kl(t.tag, e)])])]);
    return r.setAttribute("width", "100%"), r;
  }
});
var bA = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
}, wA = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
}, D0e = {
  "\\textit": "textit",
  "\\textup": "textup"
}, TA = (t, e) => {
  var r = t.font;
  if (r) {
    if (bA[r])
      return e.withTextFontFamily(bA[r]);
    if (wA[r])
      return e.withTextFontWeight(wA[r]);
    if (r === "\\emph")
      return e.fontShape === "textit" ? e.withTextFontShape("textup") : e.withTextFontShape("textit");
  } else return e;
  return e.withTextFontShape(D0e[r]);
};
Tt({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: !0,
    allowedInText: !0
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0];
    return {
      type: "text",
      mode: r.mode,
      body: xn(i),
      font: n
    };
  },
  htmlBuilder(t, e) {
    var r = TA(t, e), n = $n(t.body, r, !0);
    return Be.makeSpan(["mord", "text"], n, r);
  },
  mathmlBuilder(t, e) {
    var r = TA(t, e);
    return Kl(t.body, r);
  }
});
Tt({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "underline",
      mode: r.mode,
      body: e[0]
    };
  },
  htmlBuilder(t, e) {
    var r = vr(t.body, e), n = Be.makeLineSpan("underline-line", e), i = e.fontMetrics().defaultRuleThickness, a = Be.makeVList({
      positionType: "top",
      positionData: r.height,
      children: [{
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: r
      }]
    }, e);
    return Be.makeSpan(["mord", "underline"], [a], e);
  },
  mathmlBuilder(t, e) {
    var r = new it.MathNode("mo", [new it.TextNode("")]);
    r.setAttribute("stretchy", "true");
    var n = new it.MathNode("munder", [Pr(t.body, e), r]);
    return n.setAttribute("accentunder", "true"), n;
  }
});
Tt({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: !1
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "vcenter",
      mode: r.mode,
      body: e[0]
    };
  },
  htmlBuilder(t, e) {
    var r = vr(t.body, e), n = e.fontMetrics().axisHeight, i = 0.5 * (r.height - n - (r.depth + n));
    return Be.makeVList({
      positionType: "shift",
      positionData: i,
      children: [{
        type: "elem",
        elem: r
      }]
    }, e);
  },
  mathmlBuilder(t, e) {
    return new it.MathNode("mpadded", [Pr(t.body, e)], ["vcenter"]);
  }
});
Tt({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(t, e, r) {
    throw new ot("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(t, e) {
    for (var r = EA(t), n = [], i = e.havingStyle(e.style.text()), a = 0; a < r.length; a++) {
      var s = r[a];
      s === "~" && (s = "\\textasciitilde"), n.push(Be.makeSymbol(s, "Typewriter-Regular", t.mode, i, ["mord", "texttt"]));
    }
    return Be.makeSpan(["mord", "text"].concat(i.sizingClasses(e)), Be.tryCombineChars(n), i);
  },
  mathmlBuilder(t, e) {
    var r = new it.TextNode(EA(t)), n = new it.MathNode("mtext", [r]);
    return n.setAttribute("mathvariant", "monospace"), n;
  }
});
var EA = (t) => t.body.replace(/ /g, t.star ? "" : ""), Nl = Rz, lG = `[ \r
	]`, O0e = "\\\\[a-zA-Z@]+", P0e = "\\\\[^\uD800-\uDFFF]", B0e = "(" + O0e + ")" + lG + "*", F0e = `\\\\(
|[ \r	]+
?)[ \r	]*`, cT = "[-]", $0e = new RegExp(cT + "+$"), z0e = "(" + lG + "+)|" + // whitespace
(F0e + "|") + // \whitespace
"([!-\\[\\]---]" + // single codepoint
(cT + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
(cT + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
("|" + B0e) + // \macroName + spaces
("|" + P0e + ")");
let kA = class {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(e, r) {
    this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = e, this.settings = r, this.tokenRegex = new RegExp(z0e, "g"), this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(e, r) {
    this.catcodes[e] = r;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    var e = this.input, r = this.tokenRegex.lastIndex;
    if (r === e.length)
      return new Ea("EOF", new ta(this, r, r));
    var n = this.tokenRegex.exec(e);
    if (n === null || n.index !== r)
      throw new ot("Unexpected character: '" + e[r] + "'", new Ea(e[r], new ta(this, r, r + 1)));
    var i = n[6] || n[3] || (n[2] ? "\\ " : " ");
    if (this.catcodes[i] === 14) {
      var a = e.indexOf(`
`, this.tokenRegex.lastIndex);
      return a === -1 ? (this.tokenRegex.lastIndex = e.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = a + 1, this.lex();
    }
    return new Ea(i, new ta(this, r, this.tokenRegex.lastIndex));
  }
};
class G0e {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(e, r) {
    e === void 0 && (e = {}), r === void 0 && (r = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = r, this.builtins = e, this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0)
      throw new ot("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    var e = this.undefStack.pop();
    for (var r in e)
      e.hasOwnProperty(r) && (e[r] == null ? delete this.current[r] : this.current[r] = e[r]);
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    for (; this.undefStack.length > 0; )
      this.endGroup();
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(e) {
    return this.current.hasOwnProperty(e) || this.builtins.hasOwnProperty(e);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(e) {
    return this.current.hasOwnProperty(e) ? this.current[e] : this.builtins[e];
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */
  set(e, r, n) {
    if (n === void 0 && (n = !1), n) {
      for (var i = 0; i < this.undefStack.length; i++)
        delete this.undefStack[i][e];
      this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][e] = r);
    } else {
      var a = this.undefStack[this.undefStack.length - 1];
      a && !a.hasOwnProperty(e) && (a[e] = this.current[e]);
    }
    r == null ? delete this.current[e] : this.current[e] = r;
  }
}
var V0e = Zz;
le("\\noexpand", function(t) {
  var e = t.popToken();
  return t.isExpandable(e.text) && (e.noexpand = !0, e.treatAsRelax = !0), {
    tokens: [e],
    numArgs: 0
  };
});
le("\\expandafter", function(t) {
  var e = t.popToken();
  return t.expandOnce(!0), {
    tokens: [e],
    numArgs: 0
  };
});
le("\\@firstoftwo", function(t) {
  var e = t.consumeArgs(2);
  return {
    tokens: e[0],
    numArgs: 0
  };
});
le("\\@secondoftwo", function(t) {
  var e = t.consumeArgs(2);
  return {
    tokens: e[1],
    numArgs: 0
  };
});
le("\\@ifnextchar", function(t) {
  var e = t.consumeArgs(3);
  t.consumeSpaces();
  var r = t.future();
  return e[0].length === 1 && e[0][0].text === r.text ? {
    tokens: e[1],
    numArgs: 0
  } : {
    tokens: e[2],
    numArgs: 0
  };
});
le("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
le("\\TextOrMath", function(t) {
  var e = t.consumeArgs(2);
  return t.mode === "text" ? {
    tokens: e[0],
    numArgs: 0
  } : {
    tokens: e[1],
    numArgs: 0
  };
});
var SA = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
le("\\char", function(t) {
  var e = t.popToken(), r, n = "";
  if (e.text === "'")
    r = 8, e = t.popToken();
  else if (e.text === '"')
    r = 16, e = t.popToken();
  else if (e.text === "`")
    if (e = t.popToken(), e.text[0] === "\\")
      n = e.text.charCodeAt(1);
    else {
      if (e.text === "EOF")
        throw new ot("\\char` missing argument");
      n = e.text.charCodeAt(0);
    }
  else
    r = 10;
  if (r) {
    if (n = SA[e.text], n == null || n >= r)
      throw new ot("Invalid base-" + r + " digit " + e.text);
    for (var i; (i = SA[t.future().text]) != null && i < r; )
      n *= r, n += i, t.popToken();
  }
  return "\\@char{" + n + "}";
});
var _k = (t, e, r, n) => {
  var i = t.consumeArg().tokens;
  if (i.length !== 1)
    throw new ot("\\newcommand's first argument must be a macro name");
  var a = i[0].text, s = t.isDefined(a);
  if (s && !e)
    throw new ot("\\newcommand{" + a + "} attempting to redefine " + (a + "; use \\renewcommand"));
  if (!s && !r)
    throw new ot("\\renewcommand{" + a + "} when command " + a + " does not yet exist; use \\newcommand");
  var o = 0;
  if (i = t.consumeArg().tokens, i.length === 1 && i[0].text === "[") {
    for (var l = "", u = t.expandNextToken(); u.text !== "]" && u.text !== "EOF"; )
      l += u.text, u = t.expandNextToken();
    if (!l.match(/^\s*[0-9]+\s*$/))
      throw new ot("Invalid number of arguments: " + l);
    o = parseInt(l), i = t.consumeArg().tokens;
  }
  return s && n || t.macros.set(a, {
    tokens: i,
    numArgs: o
  }), "";
};
le("\\newcommand", (t) => _k(t, !1, !0, !1));
le("\\renewcommand", (t) => _k(t, !0, !1, !1));
le("\\providecommand", (t) => _k(t, !0, !0, !0));
le("\\message", (t) => {
  var e = t.consumeArgs(1)[0];
  return console.log(e.reverse().map((r) => r.text).join("")), "";
});
le("\\errmessage", (t) => {
  var e = t.consumeArgs(1)[0];
  return console.error(e.reverse().map((r) => r.text).join("")), "";
});
le("\\show", (t) => {
  var e = t.popToken(), r = e.text;
  return console.log(e, t.macros.get(r), Nl[r], Gr.math[r], Gr.text[r]), "";
});
le("\\bgroup", "{");
le("\\egroup", "}");
le("~", "\\nobreakspace");
le("\\lq", "`");
le("\\rq", "'");
le("\\aa", "\\r a");
le("\\AA", "\\r A");
le("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`}");
le("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
le("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`}");
le("", "\\mathscr{B}");
le("", "\\mathscr{E}");
le("", "\\mathscr{F}");
le("", "\\mathscr{H}");
le("", "\\mathscr{I}");
le("", "\\mathscr{L}");
le("", "\\mathscr{M}");
le("", "\\mathscr{R}");
le("", "\\mathfrak{C}");
le("", "\\mathfrak{H}");
le("", "\\mathfrak{Z}");
le("\\Bbbk", "\\Bbb{k}");
le("", "\\cdotp");
le("\\llap", "\\mathllap{\\textrm{#1}}");
le("\\rlap", "\\mathrlap{\\textrm{#1}}");
le("\\clap", "\\mathclap{\\textrm{#1}}");
le("\\mathstrut", "\\vphantom{(}");
le("\\underbar", "\\underline{\\text{#1}}");
le("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
le("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`}}");
le("\\ne", "\\neq");
le("", "\\neq");
le("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`}}");
le("", "\\notin");
le("", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`}}");
le("", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`}}");
le("", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`}}");
le("", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`}}");
le("", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`}}");
le("", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`}}");
le("", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`}}");
le("", "\\perp");
le("", "\\mathclose{!\\mkern-0.8mu!}");
le("", "\\notni");
le("", "\\ulcorner");
le("", "\\urcorner");
le("", "\\llcorner");
le("", "\\lrcorner");
le("", "\\copyright");
le("", "\\textregistered");
le("", "\\textregistered");
le("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
le("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
le("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
le("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
le("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
le("", "\\vdots");
le("\\varGamma", "\\mathit{\\Gamma}");
le("\\varDelta", "\\mathit{\\Delta}");
le("\\varTheta", "\\mathit{\\Theta}");
le("\\varLambda", "\\mathit{\\Lambda}");
le("\\varXi", "\\mathit{\\Xi}");
le("\\varPi", "\\mathit{\\Pi}");
le("\\varSigma", "\\mathit{\\Sigma}");
le("\\varUpsilon", "\\mathit{\\Upsilon}");
le("\\varPhi", "\\mathit{\\Phi}");
le("\\varPsi", "\\mathit{\\Psi}");
le("\\varOmega", "\\mathit{\\Omega}");
le("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
le("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
le("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
le("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
le("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
le("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
le("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
le("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
var CA = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
le("\\dots", function(t) {
  var e = "\\dotso", r = t.expandAfterFuture().text;
  return r in CA ? e = CA[r] : (r.slice(0, 4) === "\\not" || r in Gr.math && ["bin", "rel"].includes(Gr.math[r].group)) && (e = "\\dotsb"), e;
});
var Lk = {
  // \rightdelim@ checks for the following:
  ")": !0,
  "]": !0,
  "\\rbrack": !0,
  "\\}": !0,
  "\\rbrace": !0,
  "\\rangle": !0,
  "\\rceil": !0,
  "\\rfloor": !0,
  "\\rgroup": !0,
  "\\rmoustache": !0,
  "\\right": !0,
  "\\bigr": !0,
  "\\biggr": !0,
  "\\Bigr": !0,
  "\\Biggr": !0,
  // \extra@ also tests for the following:
  $: !0,
  // \extrap@ checks for the following:
  ";": !0,
  ".": !0,
  ",": !0
};
le("\\dotso", function(t) {
  var e = t.future().text;
  return e in Lk ? "\\ldots\\," : "\\ldots";
});
le("\\dotsc", function(t) {
  var e = t.future().text;
  return e in Lk && e !== "," ? "\\ldots\\," : "\\ldots";
});
le("\\cdots", function(t) {
  var e = t.future().text;
  return e in Lk ? "\\@cdots\\," : "\\@cdots";
});
le("\\dotsb", "\\cdots");
le("\\dotsm", "\\cdots");
le("\\dotsi", "\\!\\cdots");
le("\\dotsx", "\\ldots\\,");
le("\\DOTSI", "\\relax");
le("\\DOTSB", "\\relax");
le("\\DOTSX", "\\relax");
le("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
le("\\,", "\\tmspace+{3mu}{.1667em}");
le("\\thinspace", "\\,");
le("\\>", "\\mskip{4mu}");
le("\\:", "\\tmspace+{4mu}{.2222em}");
le("\\medspace", "\\:");
le("\\;", "\\tmspace+{5mu}{.2777em}");
le("\\thickspace", "\\;");
le("\\!", "\\tmspace-{3mu}{.1667em}");
le("\\negthinspace", "\\!");
le("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
le("\\negthickspace", "\\tmspace-{5mu}{.277em}");
le("\\enspace", "\\kern.5em ");
le("\\enskip", "\\hskip.5em\\relax");
le("\\quad", "\\hskip1em\\relax");
le("\\qquad", "\\hskip2em\\relax");
le("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
le("\\tag@paren", "\\tag@literal{({#1})}");
le("\\tag@literal", (t) => {
  if (t.macros.get("\\df@tag"))
    throw new ot("Multiple \\tag");
  return "\\gdef\\df@tag{\\text{#1}}";
});
le("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
le("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
le("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
le("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
le("\\newline", "\\\\\\relax");
le("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var cG = pt(Ys["Main-Regular"][84][1] - 0.7 * Ys["Main-Regular"][65][1]);
le("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + cG + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
le("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + cG + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
le("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
le("\\@hspace", "\\hskip #1\\relax");
le("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
le("\\ordinarycolon", ":");
le("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
le("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
le("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
le("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
le("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
le("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
le("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
le("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
le("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
le("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
le("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
le("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
le("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
le("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
le("", "\\dblcolon");
le("", "\\eqcolon");
le("", "\\coloneqq");
le("", "\\eqqcolon");
le("", "\\Coloneqq");
le("\\ratio", "\\vcentcolon");
le("\\coloncolon", "\\dblcolon");
le("\\colonequals", "\\coloneqq");
le("\\coloncolonequals", "\\Coloneqq");
le("\\equalscolon", "\\eqqcolon");
le("\\equalscoloncolon", "\\Eqqcolon");
le("\\colonminus", "\\coloneq");
le("\\coloncolonminus", "\\Coloneq");
le("\\minuscolon", "\\eqcolon");
le("\\minuscoloncolon", "\\Eqcolon");
le("\\coloncolonapprox", "\\Colonapprox");
le("\\coloncolonsim", "\\Colonsim");
le("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
le("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
le("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
le("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
le("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`}}");
le("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
le("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
le("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
le("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
le("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
le("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
le("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
le("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
le("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{}");
le("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{}");
le("\\ngeqq", "\\html@mathml{\\@ngeqq}{}");
le("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{}");
le("\\nleqq", "\\html@mathml{\\@nleqq}{}");
le("\\nleqslant", "\\html@mathml{\\@nleqslant}{}");
le("\\nshortmid", "\\html@mathml{\\@nshortmid}{}");
le("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{}");
le("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{}");
le("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{}");
le("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{}");
le("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{}");
le("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{}");
le("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{}");
le("\\imath", "\\html@mathml{\\@imath}{}");
le("\\jmath", "\\html@mathml{\\@jmath}{}");
le("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`}}");
le("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`}}");
le("", "\\llbracket");
le("", "\\rrbracket");
le("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`}}");
le("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`}}");
le("", "\\lBrace");
le("", "\\rBrace");
le("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`}}");
le("", "\\minuso");
le("\\darr", "\\downarrow");
le("\\dArr", "\\Downarrow");
le("\\Darr", "\\Downarrow");
le("\\lang", "\\langle");
le("\\rang", "\\rangle");
le("\\uarr", "\\uparrow");
le("\\uArr", "\\Uparrow");
le("\\Uarr", "\\Uparrow");
le("\\N", "\\mathbb{N}");
le("\\R", "\\mathbb{R}");
le("\\Z", "\\mathbb{Z}");
le("\\alef", "\\aleph");
le("\\alefsym", "\\aleph");
le("\\Alpha", "\\mathrm{A}");
le("\\Beta", "\\mathrm{B}");
le("\\bull", "\\bullet");
le("\\Chi", "\\mathrm{X}");
le("\\clubs", "\\clubsuit");
le("\\cnums", "\\mathbb{C}");
le("\\Complex", "\\mathbb{C}");
le("\\Dagger", "\\ddagger");
le("\\diamonds", "\\diamondsuit");
le("\\empty", "\\emptyset");
le("\\Epsilon", "\\mathrm{E}");
le("\\Eta", "\\mathrm{H}");
le("\\exist", "\\exists");
le("\\harr", "\\leftrightarrow");
le("\\hArr", "\\Leftrightarrow");
le("\\Harr", "\\Leftrightarrow");
le("\\hearts", "\\heartsuit");
le("\\image", "\\Im");
le("\\infin", "\\infty");
le("\\Iota", "\\mathrm{I}");
le("\\isin", "\\in");
le("\\Kappa", "\\mathrm{K}");
le("\\larr", "\\leftarrow");
le("\\lArr", "\\Leftarrow");
le("\\Larr", "\\Leftarrow");
le("\\lrarr", "\\leftrightarrow");
le("\\lrArr", "\\Leftrightarrow");
le("\\Lrarr", "\\Leftrightarrow");
le("\\Mu", "\\mathrm{M}");
le("\\natnums", "\\mathbb{N}");
le("\\Nu", "\\mathrm{N}");
le("\\Omicron", "\\mathrm{O}");
le("\\plusmn", "\\pm");
le("\\rarr", "\\rightarrow");
le("\\rArr", "\\Rightarrow");
le("\\Rarr", "\\Rightarrow");
le("\\real", "\\Re");
le("\\reals", "\\mathbb{R}");
le("\\Reals", "\\mathbb{R}");
le("\\Rho", "\\mathrm{P}");
le("\\sdot", "\\cdot");
le("\\sect", "\\S");
le("\\spades", "\\spadesuit");
le("\\sub", "\\subset");
le("\\sube", "\\subseteq");
le("\\supe", "\\supseteq");
le("\\Tau", "\\mathrm{T}");
le("\\thetasym", "\\vartheta");
le("\\weierp", "\\wp");
le("\\Zeta", "\\mathrm{Z}");
le("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
le("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
le("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
le("\\bra", "\\mathinner{\\langle{#1}|}");
le("\\ket", "\\mathinner{|{#1}\\rangle}");
le("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
le("\\Bra", "\\left\\langle#1\\right|");
le("\\Ket", "\\left|#1\\right\\rangle");
var uG = (t) => (e) => {
  var r = e.consumeArg().tokens, n = e.consumeArg().tokens, i = e.consumeArg().tokens, a = e.consumeArg().tokens, s = e.macros.get("|"), o = e.macros.get("\\|");
  e.macros.beginGroup();
  var l = (d) => (f) => {
    t && (f.macros.set("|", s), i.length && f.macros.set("\\|", o));
    var p = d;
    if (!d && i.length) {
      var g = f.future();
      g.text === "|" && (f.popToken(), p = !0);
    }
    return {
      tokens: p ? i : n,
      numArgs: 0
    };
  };
  e.macros.set("|", l(!1)), i.length && e.macros.set("\\|", l(!0));
  var u = e.consumeArg().tokens, h = e.expandTokens([
    ...a,
    ...u,
    ...r
    // reversed
  ]);
  return e.macros.endGroup(), {
    tokens: h.reverse(),
    numArgs: 0
  };
};
le("\\bra@ket", uG(!1));
le("\\bra@set", uG(!0));
le("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
le("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
le("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
le("\\angln", "{\\angl n}");
le("\\blue", "\\textcolor{##6495ed}{#1}");
le("\\orange", "\\textcolor{##ffa500}{#1}");
le("\\pink", "\\textcolor{##ff00af}{#1}");
le("\\red", "\\textcolor{##df0030}{#1}");
le("\\green", "\\textcolor{##28ae7b}{#1}");
le("\\gray", "\\textcolor{gray}{#1}");
le("\\purple", "\\textcolor{##9d38bd}{#1}");
le("\\blueA", "\\textcolor{##ccfaff}{#1}");
le("\\blueB", "\\textcolor{##80f6ff}{#1}");
le("\\blueC", "\\textcolor{##63d9ea}{#1}");
le("\\blueD", "\\textcolor{##11accd}{#1}");
le("\\blueE", "\\textcolor{##0c7f99}{#1}");
le("\\tealA", "\\textcolor{##94fff5}{#1}");
le("\\tealB", "\\textcolor{##26edd5}{#1}");
le("\\tealC", "\\textcolor{##01d1c1}{#1}");
le("\\tealD", "\\textcolor{##01a995}{#1}");
le("\\tealE", "\\textcolor{##208170}{#1}");
le("\\greenA", "\\textcolor{##b6ffb0}{#1}");
le("\\greenB", "\\textcolor{##8af281}{#1}");
le("\\greenC", "\\textcolor{##74cf70}{#1}");
le("\\greenD", "\\textcolor{##1fab54}{#1}");
le("\\greenE", "\\textcolor{##0d923f}{#1}");
le("\\goldA", "\\textcolor{##ffd0a9}{#1}");
le("\\goldB", "\\textcolor{##ffbb71}{#1}");
le("\\goldC", "\\textcolor{##ff9c39}{#1}");
le("\\goldD", "\\textcolor{##e07d10}{#1}");
le("\\goldE", "\\textcolor{##a75a05}{#1}");
le("\\redA", "\\textcolor{##fca9a9}{#1}");
le("\\redB", "\\textcolor{##ff8482}{#1}");
le("\\redC", "\\textcolor{##f9685d}{#1}");
le("\\redD", "\\textcolor{##e84d39}{#1}");
le("\\redE", "\\textcolor{##bc2612}{#1}");
le("\\maroonA", "\\textcolor{##ffbde0}{#1}");
le("\\maroonB", "\\textcolor{##ff92c6}{#1}");
le("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
le("\\maroonD", "\\textcolor{##ca337c}{#1}");
le("\\maroonE", "\\textcolor{##9e034e}{#1}");
le("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
le("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
le("\\purpleC", "\\textcolor{##aa87ff}{#1}");
le("\\purpleD", "\\textcolor{##7854ab}{#1}");
le("\\purpleE", "\\textcolor{##543b78}{#1}");
le("\\mintA", "\\textcolor{##f5f9e8}{#1}");
le("\\mintB", "\\textcolor{##edf2df}{#1}");
le("\\mintC", "\\textcolor{##e0e5cc}{#1}");
le("\\grayA", "\\textcolor{##f6f7f7}{#1}");
le("\\grayB", "\\textcolor{##f0f1f2}{#1}");
le("\\grayC", "\\textcolor{##e3e5e6}{#1}");
le("\\grayD", "\\textcolor{##d6d8da}{#1}");
le("\\grayE", "\\textcolor{##babec2}{#1}");
le("\\grayF", "\\textcolor{##888d93}{#1}");
le("\\grayG", "\\textcolor{##626569}{#1}");
le("\\grayH", "\\textcolor{##3b3e40}{#1}");
le("\\grayI", "\\textcolor{##21242c}{#1}");
le("\\kaBlue", "\\textcolor{##314453}{#1}");
le("\\kaGreen", "\\textcolor{##71B307}{#1}");
var hG = {
  "^": !0,
  // Parser.js
  _: !0,
  // Parser.js
  "\\limits": !0,
  // Parser.js
  "\\nolimits": !0
  // Parser.js
};
class U0e {
  constructor(e, r, n) {
    this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = r, this.expansionCount = 0, this.feed(e), this.macros = new G0e(V0e, r.macros), this.mode = n, this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(e) {
    this.lexer = new kA(e, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    return this.stack.length === 0 && this.pushToken(this.lexer.lex()), this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    return this.future(), this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(e) {
    this.stack.push(e);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(e) {
    this.stack.push(...e);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(e) {
    var r, n, i;
    if (e) {
      if (this.consumeSpaces(), this.future().text !== "[")
        return null;
      r = this.popToken(), {
        tokens: i,
        end: n
      } = this.consumeArg(["]"]);
    } else
      ({
        tokens: i,
        start: r,
        end: n
      } = this.consumeArg());
    return this.pushToken(new Ea("EOF", n.loc)), this.pushTokens(i), new Ea("", ta.range(r, n));
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; ; ) {
      var e = this.future();
      if (e.text === " ")
        this.stack.pop();
      else
        break;
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(e) {
    var r = [], n = e && e.length > 0;
    n || this.consumeSpaces();
    var i = this.future(), a, s = 0, o = 0;
    do {
      if (a = this.popToken(), r.push(a), a.text === "{")
        ++s;
      else if (a.text === "}") {
        if (--s, s === -1)
          throw new ot("Extra }", a);
      } else if (a.text === "EOF")
        throw new ot("Unexpected end of input in a macro argument, expected '" + (e && n ? e[o] : "}") + "'", a);
      if (e && n)
        if ((s === 0 || s === 1 && e[o] === "{") && a.text === e[o]) {
          if (++o, o === e.length) {
            r.splice(-o, o);
            break;
          }
        } else
          o = 0;
    } while (s !== 0 || n);
    return i.text === "{" && r[r.length - 1].text === "}" && (r.pop(), r.shift()), r.reverse(), {
      tokens: r,
      start: i,
      end: a
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(e, r) {
    if (r) {
      if (r.length !== e + 1)
        throw new ot("The length of delimiters doesn't match the number of args!");
      for (var n = r[0], i = 0; i < n.length; i++) {
        var a = this.popToken();
        if (n[i] !== a.text)
          throw new ot("Use of the macro doesn't match its definition", a);
      }
    }
    for (var s = [], o = 0; o < e; o++)
      s.push(this.consumeArg(r && r[o + 1]).tokens);
    return s;
  }
  /**
   * Increment `expansionCount` by the specified amount.
   * Throw an error if it exceeds `maxExpand`.
   */
  countExpansion(e) {
    if (this.expansionCount += e, this.expansionCount > this.settings.maxExpand)
      throw new ot("Too many expansions: infinite loop or need to increase maxExpand setting");
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(e) {
    var r = this.popToken(), n = r.text, i = r.noexpand ? null : this._getExpansion(n);
    if (i == null || e && i.unexpandable) {
      if (e && i == null && n[0] === "\\" && !this.isDefined(n))
        throw new ot("Undefined control sequence: " + n);
      return this.pushToken(r), !1;
    }
    this.countExpansion(1);
    var a = i.tokens, s = this.consumeArgs(i.numArgs, i.delimiters);
    if (i.numArgs) {
      a = a.slice();
      for (var o = a.length - 1; o >= 0; --o) {
        var l = a[o];
        if (l.text === "#") {
          if (o === 0)
            throw new ot("Incomplete placeholder at end of macro body", l);
          if (l = a[--o], l.text === "#")
            a.splice(o + 1, 1);
          else if (/^[1-9]$/.test(l.text))
            a.splice(o, 2, ...s[+l.text - 1]);
          else
            throw new ot("Not a valid argument number", l);
        }
      }
    }
    return this.pushTokens(a), a.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    return this.expandOnce(), this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; )
      if (this.expandOnce() === !1) {
        var e = this.stack.pop();
        return e.treatAsRelax && (e.text = "\\relax"), e;
      }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(e) {
    return this.macros.has(e) ? this.expandTokens([new Ea(e)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(e) {
    var r = [], n = this.stack.length;
    for (this.pushTokens(e); this.stack.length > n; )
      if (this.expandOnce(!0) === !1) {
        var i = this.stack.pop();
        i.treatAsRelax && (i.noexpand = !1, i.treatAsRelax = !1), r.push(i);
      }
    return this.countExpansion(r.length), r;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(e) {
    var r = this.expandMacro(e);
    return r && r.map((n) => n.text).join("");
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(e) {
    var r = this.macros.get(e);
    if (r == null)
      return r;
    if (e.length === 1) {
      var n = this.lexer.catcodes[e];
      if (n != null && n !== 13)
        return;
    }
    var i = typeof r == "function" ? r(this) : r;
    if (typeof i == "string") {
      var a = 0;
      if (i.indexOf("#") !== -1)
        for (var s = i.replace(/##/g, ""); s.indexOf("#" + (a + 1)) !== -1; )
          ++a;
      for (var o = new kA(i, this.settings), l = [], u = o.lex(); u.text !== "EOF"; )
        l.push(u), u = o.lex();
      l.reverse();
      var h = {
        tokens: l,
        numArgs: a
      };
      return h;
    }
    return i;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(e) {
    return this.macros.has(e) || Nl.hasOwnProperty(e) || Gr.math.hasOwnProperty(e) || Gr.text.hasOwnProperty(e) || hG.hasOwnProperty(e);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(e) {
    var r = this.macros.get(e);
    return r != null ? typeof r == "string" || typeof r == "function" || !r.unexpandable : Nl.hasOwnProperty(e) && !Nl[e].primitive;
  }
}
var AA = /^[]/, k1 = Object.freeze({
  "": "+",
  "": "-",
  "": "=",
  "": "(",
  "": ")",
  "": "0",
  "": "1",
  "": "2",
  "": "3",
  "": "4",
  "": "5",
  "": "6",
  "": "7",
  "": "8",
  "": "9",
  "": "a",
  "": "e",
  "": "h",
  "": "i",
  "": "j",
  "": "k",
  "": "l",
  "": "m",
  "": "n",
  "": "o",
  "": "p",
  "": "r",
  "": "s",
  "": "t",
  "": "u",
  "": "v",
  "": "x",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "+",
  "": "-",
  "": "=",
  "": "(",
  "": ")",
  "": "0",
  "": "1",
  "": "2",
  "": "3",
  "": "4",
  "": "5",
  "": "6",
  "": "7",
  "": "8",
  "": "9",
  "": "A",
  "": "B",
  "": "D",
  "": "E",
  "": "G",
  "": "H",
  "": "I",
  "": "J",
  "": "K",
  "": "L",
  "": "M",
  "": "N",
  "": "O",
  "": "P",
  "": "R",
  "": "T",
  "": "U",
  "": "V",
  "": "W",
  "": "a",
  "": "b",
  "": "c",
  "": "d",
  "": "e",
  "": "f",
  "": "g",
  : "h",
  "": "i",
  : "j",
  "": "k",
  : "l",
  "": "m",
  : "n",
  "": "o",
  "": "p",
  : "r",
  : "s",
  "": "t",
  "": "u",
  "": "v",
  : "w",
  : "x",
  : "y",
  "": "z",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": ""
}), S4 = {
  "": {
    text: "\\'",
    math: "\\acute"
  },
  "": {
    text: "\\`",
    math: "\\grave"
  },
  "": {
    text: '\\"',
    math: "\\ddot"
  },
  "": {
    text: "\\~",
    math: "\\tilde"
  },
  "": {
    text: "\\=",
    math: "\\bar"
  },
  "": {
    text: "\\u",
    math: "\\breve"
  },
  "": {
    text: "\\v",
    math: "\\check"
  },
  "": {
    text: "\\^",
    math: "\\hat"
  },
  "": {
    text: "\\.",
    math: "\\dot"
  },
  "": {
    text: "\\r",
    math: "\\mathring"
  },
  "": {
    text: "\\H"
  },
  "": {
    text: "\\c"
  }
}, _A = {
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "b",
  : "c",
  : "c",
  : "c",
  : "c",
  : "c",
  : "c",
  : "d",
  : "d",
  : "d",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "f",
  : "g",
  : "g",
  : "g",
  : "g",
  : "g",
  : "g",
  : "g",
  : "h",
  : "h",
  : "h",
  : "h",
  : "h",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "j",
  : "j",
  : "k",
  : "k",
  : "k",
  : "l",
  : "l",
  : "l",
  : "m",
  : "m",
  : "n",
  : "n",
  : "n",
  : "n",
  : "n",
  : "n",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "p",
  : "p",
  : "r",
  : "r",
  : "r",
  : "r",
  : "s",
  : "s",
  : "s",
  : "s",
  : "s",
  : "s",
  : "s",
  : "t",
  : "t",
  : "t",
  : "t",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "v",
  : "w",
  : "w",
  : "w",
  : "w",
  : "w",
  : "w",
  : "x",
  : "x",
  : "y",
  : "y",
  : "y",
  : "y",
  : "y",
  : "y",
  : "y",
  : "y",
  : "z",
  : "z",
  : "z",
  : "z",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "B",
  : "C",
  : "C",
  : "C",
  : "C",
  : "C",
  : "C",
  : "D",
  : "D",
  : "D",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "F",
  : "G",
  : "G",
  : "G",
  : "G",
  : "G",
  : "G",
  : "G",
  : "H",
  : "H",
  : "H",
  : "H",
  : "H",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "J",
  : "K",
  : "K",
  : "K",
  : "L",
  : "L",
  : "L",
  : "M",
  : "M",
  : "N",
  : "N",
  : "N",
  : "N",
  : "N",
  : "N",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "P",
  : "P",
  : "R",
  : "R",
  : "R",
  : "R",
  : "S",
  : "S",
  : "S",
  : "S",
  : "S",
  : "S",
  : "S",
  : "T",
  : "T",
  : "T",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "V",
  : "W",
  : "W",
  : "W",
  : "W",
  : "W",
  : "X",
  : "X",
  : "Y",
  : "Y",
  : "Y",
  : "Y",
  : "Y",
  : "Y",
  : "Y",
  : "Z",
  : "Z",
  : "Z",
  : "Z",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : ""
};
let dG = class fG {
  constructor(e, r) {
    this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new U0e(e, r, this.mode), this.settings = r, this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(e, r) {
    if (r === void 0 && (r = !0), this.fetch().text !== e)
      throw new ot("Expected '" + e + "', got '" + this.fetch().text + "'", this.fetch());
    r && this.consume();
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    return this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e, this.gullet.switchMode(e);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    this.settings.globalGroup || this.gullet.beginGroup(), this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
    try {
      var e = this.parseExpression(!1);
      return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), e;
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(e) {
    var r = this.nextToken;
    this.consume(), this.gullet.pushToken(new Ea("}")), this.gullet.pushTokens(e);
    var n = this.parseExpression(!1);
    return this.expect("}"), this.nextToken = r, n;
  }
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(e, r) {
    for (var n = []; ; ) {
      this.mode === "math" && this.consumeSpaces();
      var i = this.fetch();
      if (fG.endOfExpression.indexOf(i.text) !== -1 || r && i.text === r || e && Nl[i.text] && Nl[i.text].infix)
        break;
      var a = this.parseAtom(r);
      if (a) {
        if (a.type === "internal")
          continue;
      } else break;
      n.push(a);
    }
    return this.mode === "text" && this.formLigatures(n), this.handleInfixNodes(n);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(e) {
    for (var r = -1, n, i = 0; i < e.length; i++)
      if (e[i].type === "infix") {
        if (r !== -1)
          throw new ot("only one infix operator per group", e[i].token);
        r = i, n = e[i].replaceWith;
      }
    if (r !== -1 && n) {
      var a, s, o = e.slice(0, r), l = e.slice(r + 1);
      o.length === 1 && o[0].type === "ordgroup" ? a = o[0] : a = {
        type: "ordgroup",
        mode: this.mode,
        body: o
      }, l.length === 1 && l[0].type === "ordgroup" ? s = l[0] : s = {
        type: "ordgroup",
        mode: this.mode,
        body: l
      };
      var u;
      return n === "\\\\abovefrac" ? u = this.callFunction(n, [a, e[r], s], []) : u = this.callFunction(n, [a, s], []), [u];
    } else
      return e;
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(e) {
    var r = this.fetch(), n = r.text;
    this.consume(), this.consumeSpaces();
    var i;
    do {
      var a;
      i = this.parseGroup(e);
    } while (((a = i) == null ? void 0 : a.type) === "internal");
    if (!i)
      throw new ot("Expected group after '" + n + "'", r);
    return i;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(e) {
    for (var r = [], n = 0; n < e.length; n++)
      r.push({
        type: "textord",
        mode: "text",
        text: e[n]
      });
    var i = {
      type: "text",
      mode: this.mode,
      body: r
    }, a = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [i]
    };
    return a;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(e) {
    var r = this.parseGroup("atom", e);
    if (r?.type === "internal" || this.mode === "text")
      return r;
    for (var n, i; ; ) {
      this.consumeSpaces();
      var a = this.fetch();
      if (a.text === "\\limits" || a.text === "\\nolimits") {
        if (r && r.type === "op") {
          var s = a.text === "\\limits";
          r.limits = s, r.alwaysHandleSupSub = !0;
        } else if (r && r.type === "operatorname")
          r.alwaysHandleSupSub && (r.limits = a.text === "\\limits");
        else
          throw new ot("Limit controls must follow a math operator", a);
        this.consume();
      } else if (a.text === "^") {
        if (n)
          throw new ot("Double superscript", a);
        n = this.handleSupSubscript("superscript");
      } else if (a.text === "_") {
        if (i)
          throw new ot("Double subscript", a);
        i = this.handleSupSubscript("subscript");
      } else if (a.text === "'") {
        if (n)
          throw new ot("Double superscript", a);
        var o = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        }, l = [o];
        for (this.consume(); this.fetch().text === "'"; )
          l.push(o), this.consume();
        this.fetch().text === "^" && l.push(this.handleSupSubscript("superscript")), n = {
          type: "ordgroup",
          mode: this.mode,
          body: l
        };
      } else if (k1[a.text]) {
        var u = AA.test(a.text), h = [];
        for (h.push(new Ea(k1[a.text])), this.consume(); ; ) {
          var d = this.fetch().text;
          if (!k1[d] || AA.test(d) !== u)
            break;
          h.unshift(new Ea(k1[d])), this.consume();
        }
        var f = this.subparse(h);
        u ? i = {
          type: "ordgroup",
          mode: "math",
          body: f
        } : n = {
          type: "ordgroup",
          mode: "math",
          body: f
        };
      } else
        break;
    }
    return n || i ? {
      type: "supsub",
      mode: this.mode,
      base: r,
      sup: n,
      sub: i
    } : r;
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(e, r) {
    var n = this.fetch(), i = n.text, a = Nl[i];
    if (!a)
      return null;
    if (this.consume(), r && r !== "atom" && !a.allowedInArgument)
      throw new ot("Got function '" + i + "' with no arguments" + (r ? " as " + r : ""), n);
    if (this.mode === "text" && !a.allowedInText)
      throw new ot("Can't use function '" + i + "' in text mode", n);
    if (this.mode === "math" && a.allowedInMath === !1)
      throw new ot("Can't use function '" + i + "' in math mode", n);
    var {
      args: s,
      optArgs: o
    } = this.parseArguments(i, a);
    return this.callFunction(i, s, o, n, e);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(e, r, n, i, a) {
    var s = {
      funcName: e,
      parser: this,
      token: i,
      breakOnTokenText: a
    }, o = Nl[e];
    if (o && o.handler)
      return o.handler(s, r, n);
    throw new ot("No function handler for " + e);
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(e, r) {
    var n = r.numArgs + r.numOptionalArgs;
    if (n === 0)
      return {
        args: [],
        optArgs: []
      };
    for (var i = [], a = [], s = 0; s < n; s++) {
      var o = r.argTypes && r.argTypes[s], l = s < r.numOptionalArgs;
      (r.primitive && o == null || // \sqrt expands into primitive if optional argument doesn't exist
      r.type === "sqrt" && s === 1 && a[0] == null) && (o = "primitive");
      var u = this.parseGroupOfType("argument to '" + e + "'", o, l);
      if (l)
        a.push(u);
      else if (u != null)
        i.push(u);
      else
        throw new ot("Null argument, please report this as a bug");
    }
    return {
      args: i,
      optArgs: a
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(e, r, n) {
    switch (r) {
      case "color":
        return this.parseColorGroup(n);
      case "size":
        return this.parseSizeGroup(n);
      case "url":
        return this.parseUrlGroup(n);
      case "math":
      case "text":
        return this.parseArgumentGroup(n, r);
      case "hbox": {
        var i = this.parseArgumentGroup(n, "text");
        return i != null ? {
          type: "styling",
          mode: i.mode,
          body: [i],
          style: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        var a = this.parseStringGroup("raw", n);
        return a != null ? {
          type: "raw",
          mode: "text",
          string: a.text
        } : null;
      }
      case "primitive": {
        if (n)
          throw new ot("A primitive argument cannot be optional");
        var s = this.parseGroup(e);
        if (s == null)
          throw new ot("Expected group as " + e, this.fetch());
        return s;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(n);
      default:
        throw new ot("Unknown group type as " + e, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    for (; this.fetch().text === " "; )
      this.consume();
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(e, r) {
    var n = this.gullet.scanArgument(r);
    if (n == null)
      return null;
    for (var i = "", a; (a = this.fetch()).text !== "EOF"; )
      i += a.text, this.consume();
    return this.consume(), n.text = i, n;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(e, r) {
    for (var n = this.fetch(), i = n, a = "", s; (s = this.fetch()).text !== "EOF" && e.test(a + s.text); )
      i = s, a += i.text, this.consume();
    if (a === "")
      throw new ot("Invalid " + r + ": '" + n.text + "'", n);
    return n.range(i, a);
  }
  /**
   * Parses a color description.
   */
  parseColorGroup(e) {
    var r = this.parseStringGroup("color", e);
    if (r == null)
      return null;
    var n = /^(#[a-f0-9]{3,4}|#[a-f0-9]{6}|#[a-f0-9]{8}|[a-f0-9]{6}|[a-z]+)$/i.exec(r.text);
    if (!n)
      throw new ot("Invalid color: '" + r.text + "'", r);
    var i = n[0];
    return /^[0-9a-f]{6}$/i.test(i) && (i = "#" + i), {
      type: "color-token",
      mode: this.mode,
      color: i
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(e) {
    var r, n = !1;
    if (this.gullet.consumeSpaces(), !e && this.gullet.future().text !== "{" ? r = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : r = this.parseStringGroup("size", e), !r)
      return null;
    !e && r.text.length === 0 && (r.text = "0pt", n = !0);
    var i = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(r.text);
    if (!i)
      throw new ot("Invalid size: '" + r.text + "'", r);
    var a = {
      number: +(i[1] + i[2]),
      // sign + magnitude, cast to number
      unit: i[3]
    };
    if (!wz(a))
      throw new ot("Invalid unit: '" + a.unit + "'", r);
    return {
      type: "size",
      mode: this.mode,
      value: a,
      isBlank: n
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(e) {
    this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
    var r = this.parseStringGroup("url", e);
    if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), r == null)
      return null;
    var n = r.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url: n
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(e, r) {
    var n = this.gullet.scanArgument(e);
    if (n == null)
      return null;
    var i = this.mode;
    r && this.switchMode(r), this.gullet.beginGroup();
    var a = this.parseExpression(!1, "EOF");
    this.expect("EOF"), this.gullet.endGroup();
    var s = {
      type: "ordgroup",
      mode: this.mode,
      loc: n.loc,
      body: a
    };
    return r && this.switchMode(i), s;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(e, r) {
    var n = this.fetch(), i = n.text, a;
    if (i === "{" || i === "\\begingroup") {
      this.consume();
      var s = i === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var o = this.parseExpression(!1, s), l = this.fetch();
      this.expect(s), this.gullet.endGroup(), a = {
        type: "ordgroup",
        mode: this.mode,
        loc: ta.range(n, l),
        body: o,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: i === "\\begingroup" || void 0
      };
    } else if (a = this.parseFunction(r, e) || this.parseSymbol(), a == null && i[0] === "\\" && !hG.hasOwnProperty(i)) {
      if (this.settings.throwOnError)
        throw new ot("Undefined control sequence: " + i, n);
      a = this.formatUnsupportedCmd(i), this.consume();
    }
    return a;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(e) {
    for (var r = e.length - 1, n = 0; n < r; ++n) {
      var i = e[n], a = i.text;
      a === "-" && e[n + 1].text === "-" && (n + 1 < r && e[n + 2].text === "-" ? (e.splice(n, 3, {
        type: "textord",
        mode: "text",
        loc: ta.range(i, e[n + 2]),
        text: "---"
      }), r -= 2) : (e.splice(n, 2, {
        type: "textord",
        mode: "text",
        loc: ta.range(i, e[n + 1]),
        text: "--"
      }), r -= 1)), (a === "'" || a === "`") && e[n + 1].text === a && (e.splice(n, 2, {
        type: "textord",
        mode: "text",
        loc: ta.range(i, e[n + 1]),
        text: a + a
      }), r -= 1);
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    var e = this.fetch(), r = e.text;
    if (/^\\verb[^a-zA-Z]/.test(r)) {
      this.consume();
      var n = r.slice(5), i = n.charAt(0) === "*";
      if (i && (n = n.slice(1)), n.length < 2 || n.charAt(0) !== n.slice(-1))
        throw new ot(`\\verb assertion failed --
                    please report what input caused this bug`);
      return n = n.slice(1, -1), {
        type: "verb",
        mode: "text",
        body: n,
        star: i
      };
    }
    _A.hasOwnProperty(r[0]) && !Gr[this.mode][r[0]] && (this.settings.strict && this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + r[0] + '" used in math mode', e), r = _A[r[0]] + r.slice(1));
    var a = $0e.exec(r);
    a && (r = r.substring(0, a.index), r === "i" ? r = "" : r === "j" && (r = ""));
    var s;
    if (Gr[this.mode][r]) {
      this.settings.strict && this.mode === "math" && iT.indexOf(r) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + r[0] + '" used in math mode', e);
      var o = Gr[this.mode][r].group, l = ta.range(e), u;
      if (Mfe.hasOwnProperty(o)) {
        var h = o;
        u = {
          type: "atom",
          mode: this.mode,
          family: h,
          loc: l,
          text: r
        };
      } else
        u = {
          type: o,
          mode: this.mode,
          loc: l,
          text: r
        };
      s = u;
    } else if (r.charCodeAt(0) >= 128)
      this.settings.strict && (xz(r.charCodeAt(0)) ? this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + r[0] + '" used in math mode', e) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + r[0] + '"' + (" (" + r.charCodeAt(0) + ")"), e)), s = {
        type: "textord",
        mode: "text",
        loc: ta.range(e),
        text: r
      };
    else
      return null;
    if (this.consume(), a)
      for (var d = 0; d < a[0].length; d++) {
        var f = a[0][d];
        if (!S4[f])
          throw new ot("Unknown accent ' " + f + "'", e);
        var p = S4[f][this.mode] || S4[f].text;
        if (!p)
          throw new ot("Accent " + f + " unsupported in " + this.mode + " mode", e);
        s = {
          type: "accent",
          mode: this.mode,
          loc: ta.range(e),
          label: p,
          isStretchy: !1,
          isShifty: !0,
          // $FlowFixMe
          base: s
        };
      }
    return s;
  }
};
dG.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var Rk = function(e, r) {
  if (!(typeof e == "string" || e instanceof String))
    throw new TypeError("KaTeX can only parse string typed expression");
  var n = new dG(e, r);
  delete n.gullet.macros.current["\\df@tag"];
  var i = n.parse();
  if (delete n.gullet.macros.current["\\current@color"], delete n.gullet.macros.current["\\color"], n.gullet.macros.get("\\df@tag")) {
    if (!r.displayMode)
      throw new ot("\\tag works only in display equations");
    i = [{
      type: "tag",
      mode: "text",
      body: i,
      tag: n.subparse([new Ea("\\df@tag")])
    }];
  }
  return i;
}, Mk = function(e, r, n) {
  r.textContent = "";
  var i = yx(e, n).toNode();
  r.appendChild(i);
};
typeof document < "u" && document.compatMode !== "CSS1Compat" && (typeof console < "u" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), Mk = function() {
  throw new ot("KaTeX doesn't work in quirks mode.");
});
var pG = function(e, r) {
  var n = yx(e, r).toMarkup();
  return n;
}, gG = function(e, r) {
  var n = new dk(r);
  return Rk(e, n);
}, mG = function(e, r, n) {
  if (n.throwOnError || !(e instanceof ot))
    throw e;
  var i = Be.makeSpan(["katex-error"], [new es(r)]);
  return i.setAttribute("title", e.toString()), i.setAttribute("style", "color:" + n.errorColor), i;
}, yx = function(e, r) {
  var n = new dk(r);
  try {
    var i = Rk(e, n);
    return e0e(i, e, n);
  } catch (a) {
    return mG(a, e, n);
  }
}, vG = function(e, r) {
  var n = new dk(r);
  try {
    var i = Rk(e, n);
    return t0e(i, e, n);
  } catch (a) {
    return mG(a, e, n);
  }
}, yG = "0.16.27", xG = {
  Span: yg,
  Anchor: gk,
  SymbolNode: es,
  SvgNode: el,
  PathNode: jl,
  LineNode: nT
}, H0e = {
  /**
   * Current KaTeX version
   */
  version: yG,
  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render: Mk,
  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString: pG,
  /**
   * KaTeX error, usually during parsing.
   */
  ParseError: ot,
  /**
   * The schema of Settings
   */
  SETTINGS_SCHEMA: Z0,
  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: gG,
  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: yx,
  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: vG,
  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: bz,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: G,
  /**
   * adds a new function to builtin function list,
   * which directly produce parse tree elements
   * and have their own html/mathml builders
   */
  __defineFunction: Tt,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: le,
  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: These methods are not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree: xG
};
const q0e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ParseError: ot,
  SETTINGS_SCHEMA: Z0,
  __defineFunction: Tt,
  __defineMacro: le,
  __defineSymbol: G,
  __domTree: xG,
  __parse: gG,
  __renderToDomTree: yx,
  __renderToHTMLTree: vG,
  __setFontMetrics: bz,
  default: H0e,
  get render() {
    return Mk;
  },
  renderToString: pG,
  version: yG
}, Symbol.toStringTag, { value: "Module" }));
var W0e = "[object Symbol]";
function Eu(t) {
  return typeof t == "symbol" || io(t) && Hu(t) == W0e;
}
function ed(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length, i = Array(n); ++r < n; )
    i[r] = e(t[r], r, t);
  return i;
}
var LA = Qa ? Qa.prototype : void 0, RA = LA ? LA.toString : void 0;
function bG(t) {
  if (typeof t == "string")
    return t;
  if (An(t))
    return ed(t, bG) + "";
  if (Eu(t))
    return RA ? RA.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -1 / 0 ? "-0" : e;
}
var Y0e = /\s/;
function X0e(t) {
  for (var e = t.length; e-- && Y0e.test(t.charAt(e)); )
    ;
  return e;
}
var j0e = /^\s+/;
function K0e(t) {
  return t && t.slice(0, X0e(t) + 1).replace(j0e, "");
}
var MA = NaN, Z0e = /^[-+]0x[0-9a-f]+$/i, Q0e = /^0b[01]+$/i, J0e = /^0o[0-7]+$/i, epe = parseInt;
function tpe(t) {
  if (typeof t == "number")
    return t;
  if (Eu(t))
    return MA;
  if (Ca(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Ca(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = K0e(t);
  var r = Q0e.test(t);
  return r || J0e.test(t) ? epe(t.slice(2), r ? 2 : 8) : Z0e.test(t) ? MA : +t;
}
var NA = 1 / 0, rpe = 17976931348623157e292;
function Im(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = tpe(t), t === NA || t === -NA) {
    var e = t < 0 ? -1 : 1;
    return e * rpe;
  }
  return t === t ? t : 0;
}
function npe(t) {
  var e = Im(t), r = e % 1;
  return e === e ? r ? e - r : e : 0;
}
function ipe() {
}
function wG(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n && e(t[r], r, t) !== !1; )
    ;
  return t;
}
function TG(t, e, r, n) {
  for (var i = t.length, a = r + -1; ++a < i; )
    if (e(t[a], a, t))
      return a;
  return -1;
}
function ape(t) {
  return t !== t;
}
function spe(t, e, r) {
  for (var n = r - 1, i = t.length; ++n < i; )
    if (t[n] === e)
      return n;
  return -1;
}
function ope(t, e, r) {
  return e === e ? spe(t, e, r) : TG(t, ape, r);
}
function lpe(t, e) {
  var r = t == null ? 0 : t.length;
  return !!r && ope(t, e, 0) > -1;
}
function ba(t) {
  return dc(t) ? JP(t) : L$(t);
}
var cpe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, upe = /^\w*$/;
function Nk(t, e) {
  if (An(t))
    return !1;
  var r = typeof t;
  return r == "number" || r == "symbol" || r == "boolean" || t == null || Eu(t) ? !0 : upe.test(t) || !cpe.test(t) || e != null && t in Object(e);
}
var hpe = 500;
function dpe(t) {
  var e = Xd(t, function(n) {
    return r.size === hpe && r.clear(), n;
  }), r = e.cache;
  return e;
}
var fpe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, ppe = /\\(\\)?/g, gpe = dpe(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace(fpe, function(r, n, i, a) {
    e.push(i ? a.replace(ppe, "$1") : n || r);
  }), e;
});
function EG(t) {
  return t == null ? "" : bG(t);
}
function xx(t, e) {
  return An(t) ? t : Nk(t, e) ? [t] : gpe(EG(t));
}
function bg(t) {
  if (typeof t == "string" || Eu(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -1 / 0 ? "-0" : e;
}
function bx(t, e) {
  e = xx(e, t);
  for (var r = 0, n = e.length; t != null && r < n; )
    t = t[bg(e[r++])];
  return r && r == n ? t : void 0;
}
function mpe(t, e, r) {
  var n = t == null ? void 0 : bx(t, e);
  return n === void 0 ? r : n;
}
function Ik(t, e) {
  for (var r = -1, n = e.length, i = t.length; ++r < n; )
    t[i + r] = e[r];
  return t;
}
var IA = Qa ? Qa.isConcatSpreadable : void 0;
function vpe(t) {
  return An(t) || wd(t) || !!(IA && t && t[IA]);
}
function wx(t, e, r, n, i) {
  var a = -1, s = t.length;
  for (r || (r = vpe), i || (i = []); ++a < s; ) {
    var o = t[a];
    r(o) ? Ik(i, o) : n || (i[i.length] = o);
  }
  return i;
}
function Qu(t) {
  var e = t == null ? 0 : t.length;
  return e ? wx(t) : [];
}
function ype(t) {
  return rB(tB(t, void 0, Qu), t + "");
}
function xpe(t, e, r, n) {
  var i = -1, a = t == null ? 0 : t.length;
  for (n && a && (r = t[++i]); ++i < a; )
    r = e(r, t[i], i, t);
  return r;
}
function bpe(t, e) {
  return t && fg(e, ba(e), t);
}
function wpe(t, e) {
  return t && fg(e, Yu(e), t);
}
function kG(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length, i = 0, a = []; ++r < n; ) {
    var s = t[r];
    e(s, r, t) && (a[i++] = s);
  }
  return a;
}
function SG() {
  return [];
}
var Tpe = Object.prototype, Epe = Tpe.propertyIsEnumerable, DA = Object.getOwnPropertySymbols, Dk = DA ? function(t) {
  return t == null ? [] : (t = Object(t), kG(DA(t), function(e) {
    return Epe.call(t, e);
  }));
} : SG;
function kpe(t, e) {
  return fg(t, Dk(t), e);
}
var Spe = Object.getOwnPropertySymbols, CG = Spe ? function(t) {
  for (var e = []; t; )
    Ik(e, Dk(t)), t = BE(t);
  return e;
} : SG;
function Cpe(t, e) {
  return fg(t, CG(t), e);
}
function AG(t, e, r) {
  var n = e(t);
  return An(t) ? n : Ik(n, r(t));
}
function uT(t) {
  return AG(t, ba, Dk);
}
function Ape(t) {
  return AG(t, Yu, CG);
}
var _pe = Object.prototype, Lpe = _pe.hasOwnProperty;
function Rpe(t) {
  var e = t.length, r = new t.constructor(e);
  return e && typeof t[0] == "string" && Lpe.call(t, "index") && (r.index = t.index, r.input = t.input), r;
}
function Mpe(t, e) {
  var r = e ? PE(t.buffer) : t.buffer;
  return new t.constructor(r, t.byteOffset, t.byteLength);
}
var Npe = /\w*$/;
function Ipe(t) {
  var e = new t.constructor(t.source, Npe.exec(t));
  return e.lastIndex = t.lastIndex, e;
}
var OA = Qa ? Qa.prototype : void 0, PA = OA ? OA.valueOf : void 0;
function Dpe(t) {
  return PA ? Object(PA.call(t)) : {};
}
var Ope = "[object Boolean]", Ppe = "[object Date]", Bpe = "[object Map]", Fpe = "[object Number]", $pe = "[object RegExp]", zpe = "[object Set]", Gpe = "[object String]", Vpe = "[object Symbol]", Upe = "[object ArrayBuffer]", Hpe = "[object DataView]", qpe = "[object Float32Array]", Wpe = "[object Float64Array]", Ype = "[object Int8Array]", Xpe = "[object Int16Array]", jpe = "[object Int32Array]", Kpe = "[object Uint8Array]", Zpe = "[object Uint8ClampedArray]", Qpe = "[object Uint16Array]", Jpe = "[object Uint32Array]";
function ege(t, e, r) {
  var n = t.constructor;
  switch (e) {
    case Upe:
      return PE(t);
    case Ope:
    case Ppe:
      return new n(+t);
    case Hpe:
      return Mpe(t, r);
    case qpe:
    case Wpe:
    case Ype:
    case Xpe:
    case jpe:
    case Kpe:
    case Zpe:
    case Qpe:
    case Jpe:
      return HP(t, r);
    case Bpe:
      return new n();
    case Fpe:
    case Gpe:
      return new n(t);
    case $pe:
      return Ipe(t);
    case zpe:
      return new n();
    case Vpe:
      return Dpe(t);
  }
}
var tge = "[object Map]";
function rge(t) {
  return io(t) && Ga(t) == tge;
}
var BA = Ed && Ed.isMap, nge = BA ? K2(BA) : rge, ige = "[object Set]";
function age(t) {
  return io(t) && Ga(t) == ige;
}
var FA = Ed && Ed.isSet, sge = FA ? K2(FA) : age, oge = 1, lge = 2, cge = 4, _G = "[object Arguments]", uge = "[object Array]", hge = "[object Boolean]", dge = "[object Date]", fge = "[object Error]", LG = "[object Function]", pge = "[object GeneratorFunction]", gge = "[object Map]", mge = "[object Number]", RG = "[object Object]", vge = "[object RegExp]", yge = "[object Set]", xge = "[object String]", bge = "[object Symbol]", wge = "[object WeakMap]", Tge = "[object ArrayBuffer]", Ege = "[object DataView]", kge = "[object Float32Array]", Sge = "[object Float64Array]", Cge = "[object Int8Array]", Age = "[object Int16Array]", _ge = "[object Int32Array]", Lge = "[object Uint8Array]", Rge = "[object Uint8ClampedArray]", Mge = "[object Uint16Array]", Nge = "[object Uint32Array]", Fr = {};
Fr[_G] = Fr[uge] = Fr[Tge] = Fr[Ege] = Fr[hge] = Fr[dge] = Fr[kge] = Fr[Sge] = Fr[Cge] = Fr[Age] = Fr[_ge] = Fr[gge] = Fr[mge] = Fr[RG] = Fr[vge] = Fr[yge] = Fr[xge] = Fr[bge] = Fr[Lge] = Fr[Rge] = Fr[Mge] = Fr[Nge] = !0;
Fr[fge] = Fr[LG] = Fr[wge] = !1;
function J0(t, e, r, n, i, a) {
  var s, o = e & oge, l = e & lge, u = e & cge;
  if (s !== void 0)
    return s;
  if (!Ca(t))
    return t;
  var h = An(t);
  if (h) {
    if (s = Rpe(t), !o)
      return qP(t, s);
  } else {
    var d = Ga(t), f = d == LG || d == pge;
    if (Td(t))
      return UP(t, o);
    if (d == RG || d == _G || f && !i) {
      if (s = l || f ? {} : YP(t), !o)
        return l ? Cpe(t, wpe(s, t)) : kpe(t, bpe(s, t));
    } else {
      if (!Fr[d])
        return i ? t : {};
      s = ege(t, d, o);
    }
  }
  a || (a = new ys());
  var p = a.get(t);
  if (p)
    return p;
  a.set(t, s), sge(t) ? t.forEach(function(v) {
    s.add(J0(v, e, r, v, t, a));
  }) : nge(t) && t.forEach(function(v, y) {
    s.set(y, J0(v, e, r, y, t, a));
  });
  var g = u ? l ? Ape : uT : l ? Yu : ba, m = h ? void 0 : g(t);
  return wG(m || t, function(v, y) {
    m && (y = v, v = t[y]), Q2(s, y, J0(v, e, r, y, t, a));
  }), s;
}
var Ige = 4;
function MG(t) {
  return J0(t, Ige);
}
var Dge = 1, Oge = 4;
function Pge(t) {
  return J0(t, Dge | Oge);
}
var Bge = "__lodash_hash_undefined__";
function Fge(t) {
  return this.__data__.set(t, Bge), this;
}
function $ge(t) {
  return this.__data__.has(t);
}
function Rp(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.__data__ = new ul(); ++e < r; )
    this.add(t[e]);
}
Rp.prototype.add = Rp.prototype.push = Fge;
Rp.prototype.has = $ge;
function zge(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n; )
    if (e(t[r], r, t))
      return !0;
  return !1;
}
function NG(t, e) {
  return t.has(e);
}
var Gge = 1, Vge = 2;
function IG(t, e, r, n, i, a) {
  var s = r & Gge, o = t.length, l = e.length;
  if (o != l && !(s && l > o))
    return !1;
  var u = a.get(t), h = a.get(e);
  if (u && h)
    return u == e && h == t;
  var d = -1, f = !0, p = r & Vge ? new Rp() : void 0;
  for (a.set(t, e), a.set(e, t); ++d < o; ) {
    var g = t[d], m = e[d];
    if (n)
      var v = s ? n(m, g, d, e, t, a) : n(g, m, d, t, e, a);
    if (v !== void 0) {
      if (v)
        continue;
      f = !1;
      break;
    }
    if (p) {
      if (!zge(e, function(y, b) {
        if (!NG(p, b) && (g === y || i(g, y, r, n, a)))
          return p.push(b);
      })) {
        f = !1;
        break;
      }
    } else if (!(g === m || i(g, m, r, n, a))) {
      f = !1;
      break;
    }
  }
  return a.delete(t), a.delete(e), f;
}
function Uge(t) {
  var e = -1, r = Array(t.size);
  return t.forEach(function(n, i) {
    r[++e] = [i, n];
  }), r;
}
function Ok(t) {
  var e = -1, r = Array(t.size);
  return t.forEach(function(n) {
    r[++e] = n;
  }), r;
}
var Hge = 1, qge = 2, Wge = "[object Boolean]", Yge = "[object Date]", Xge = "[object Error]", jge = "[object Map]", Kge = "[object Number]", Zge = "[object RegExp]", Qge = "[object Set]", Jge = "[object String]", e1e = "[object Symbol]", t1e = "[object ArrayBuffer]", r1e = "[object DataView]", $A = Qa ? Qa.prototype : void 0, C4 = $A ? $A.valueOf : void 0;
function n1e(t, e, r, n, i, a, s) {
  switch (r) {
    case r1e:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case t1e:
      return !(t.byteLength != e.byteLength || !a(new ty(t), new ty(e)));
    case Wge:
    case Yge:
    case Kge:
      return Yd(+t, +e);
    case Xge:
      return t.name == e.name && t.message == e.message;
    case Zge:
    case Jge:
      return t == e + "";
    case jge:
      var o = Uge;
    case Qge:
      var l = n & Hge;
      if (o || (o = Ok), t.size != e.size && !l)
        return !1;
      var u = s.get(t);
      if (u)
        return u == e;
      n |= qge, s.set(t, e);
      var h = IG(o(t), o(e), n, i, a, s);
      return s.delete(t), h;
    case e1e:
      if (C4)
        return C4.call(t) == C4.call(e);
  }
  return !1;
}
var i1e = 1, a1e = Object.prototype, s1e = a1e.hasOwnProperty;
function o1e(t, e, r, n, i, a) {
  var s = r & i1e, o = uT(t), l = o.length, u = uT(e), h = u.length;
  if (l != h && !s)
    return !1;
  for (var d = l; d--; ) {
    var f = o[d];
    if (!(s ? f in e : s1e.call(e, f)))
      return !1;
  }
  var p = a.get(t), g = a.get(e);
  if (p && g)
    return p == e && g == t;
  var m = !0;
  a.set(t, e), a.set(e, t);
  for (var v = s; ++d < l; ) {
    f = o[d];
    var y = t[f], b = e[f];
    if (n)
      var w = s ? n(b, y, f, e, t, a) : n(y, b, f, t, e, a);
    if (!(w === void 0 ? y === b || i(y, b, r, n, a) : w)) {
      m = !1;
      break;
    }
    v || (v = f == "constructor");
  }
  if (m && !v) {
    var T = t.constructor, E = e.constructor;
    T != E && "constructor" in t && "constructor" in e && !(typeof T == "function" && T instanceof T && typeof E == "function" && E instanceof E) && (m = !1);
  }
  return a.delete(t), a.delete(e), m;
}
var l1e = 1, zA = "[object Arguments]", GA = "[object Array]", S1 = "[object Object]", c1e = Object.prototype, VA = c1e.hasOwnProperty;
function u1e(t, e, r, n, i, a) {
  var s = An(t), o = An(e), l = s ? GA : Ga(t), u = o ? GA : Ga(e);
  l = l == zA ? S1 : l, u = u == zA ? S1 : u;
  var h = l == S1, d = u == S1, f = l == u;
  if (f && Td(t)) {
    if (!Td(e))
      return !1;
    s = !0, h = !1;
  }
  if (f && !h)
    return a || (a = new ys()), s || Z2(t) ? IG(t, e, r, n, i, a) : n1e(t, e, l, r, n, i, a);
  if (!(r & l1e)) {
    var p = h && VA.call(t, "__wrapped__"), g = d && VA.call(e, "__wrapped__");
    if (p || g) {
      var m = p ? t.value() : t, v = g ? e.value() : e;
      return a || (a = new ys()), i(m, v, r, n, a);
    }
  }
  return f ? (a || (a = new ys()), o1e(t, e, r, n, i, a)) : !1;
}
function Pk(t, e, r, n, i) {
  return t === e ? !0 : t == null || e == null || !io(t) && !io(e) ? t !== t && e !== e : u1e(t, e, r, n, Pk, i);
}
var h1e = 1, d1e = 2;
function f1e(t, e, r, n) {
  var i = r.length, a = i;
  if (t == null)
    return !a;
  for (t = Object(t); i--; ) {
    var s = r[i];
    if (s[2] ? s[1] !== t[s[0]] : !(s[0] in t))
      return !1;
  }
  for (; ++i < a; ) {
    s = r[i];
    var o = s[0], l = t[o], u = s[1];
    if (s[2]) {
      if (l === void 0 && !(o in t))
        return !1;
    } else {
      var h = new ys(), d;
      if (!(d === void 0 ? Pk(u, l, h1e | d1e, n, h) : d))
        return !1;
    }
  }
  return !0;
}
function DG(t) {
  return t === t && !Ca(t);
}
function p1e(t) {
  for (var e = ba(t), r = e.length; r--; ) {
    var n = e[r], i = t[n];
    e[r] = [n, i, DG(i)];
  }
  return e;
}
function OG(t, e) {
  return function(r) {
    return r == null ? !1 : r[t] === e && (e !== void 0 || t in Object(r));
  };
}
function g1e(t) {
  var e = p1e(t);
  return e.length == 1 && e[0][2] ? OG(e[0][0], e[0][1]) : function(r) {
    return r === t || f1e(r, t, e);
  };
}
function m1e(t, e) {
  return t != null && e in Object(t);
}
function PG(t, e, r) {
  e = xx(e, t);
  for (var n = -1, i = e.length, a = !1; ++n < i; ) {
    var s = bg(e[n]);
    if (!(a = t != null && r(t, s)))
      break;
    t = t[s];
  }
  return a || ++n != i ? a : (i = t == null ? 0 : t.length, !!i && FE(i) && J2(s, i) && (An(t) || wd(t)));
}
function BG(t, e) {
  return t != null && PG(t, e, m1e);
}
var v1e = 1, y1e = 2;
function x1e(t, e) {
  return Nk(t) && DG(e) ? OG(bg(t), e) : function(r) {
    var n = mpe(r, t);
    return n === void 0 && n === e ? BG(r, t) : Pk(e, n, v1e | y1e);
  };
}
function b1e(t) {
  return function(e) {
    return e?.[t];
  };
}
function w1e(t) {
  return function(e) {
    return bx(e, t);
  };
}
function T1e(t) {
  return Nk(t) ? b1e(bg(t)) : w1e(t);
}
function dl(t) {
  return typeof t == "function" ? t : t == null ? Xu : typeof t == "object" ? An(t) ? x1e(t[0], t[1]) : g1e(t) : T1e(t);
}
function Bk(t, e) {
  return t && OE(t, e, ba);
}
function E1e(t, e) {
  return function(r, n) {
    if (r == null)
      return r;
    if (!dc(r))
      return t(r, n);
    for (var i = r.length, a = -1, s = Object(r); ++a < i && n(s[a], a, s) !== !1; )
      ;
    return r;
  };
}
var Tx = E1e(Bk), FG = Object.prototype, k1e = FG.hasOwnProperty, S1e = ex(function(t, e) {
  t = Object(t);
  var r = -1, n = e.length, i = n > 2 ? e[2] : void 0;
  for (i && Ep(e[0], e[1], i) && (n = 1); ++r < n; )
    for (var a = e[r], s = Yu(a), o = -1, l = s.length; ++o < l; ) {
      var u = s[o], h = t[u];
      (h === void 0 || Yd(h, FG[u]) && !k1e.call(t, u)) && (t[u] = a[u]);
    }
  return t;
});
function by(t) {
  var e = t == null ? 0 : t.length;
  return e ? t[e - 1] : void 0;
}
function Fk(t) {
  return typeof t == "function" ? t : Xu;
}
function Ye(t, e) {
  var r = An(t) ? wG : Tx;
  return r(t, Fk(e));
}
function C1e(t, e) {
  var r = [];
  return Tx(t, function(n, i, a) {
    e(n, i, a) && r.push(n);
  }), r;
}
function js(t, e) {
  var r = An(t) ? kG : C1e;
  return r(t, dl(e));
}
function A1e(t) {
  return function(e, r, n) {
    var i = Object(e);
    if (!dc(e)) {
      var a = dl(r);
      e = ba(e), r = function(o) {
        return a(i[o], o, i);
      };
    }
    var s = t(e, r, n);
    return s > -1 ? i[a ? e[s] : s] : void 0;
  };
}
var _1e = Math.max;
function L1e(t, e, r) {
  var n = t == null ? 0 : t.length;
  if (!n)
    return -1;
  var i = r == null ? 0 : npe(r);
  return i < 0 && (i = _1e(n + i, 0)), TG(t, dl(e), i);
}
var $k = A1e(L1e);
function $G(t, e) {
  var r = -1, n = dc(t) ? Array(t.length) : [];
  return Tx(t, function(i, a, s) {
    n[++r] = e(i, a, s);
  }), n;
}
function Ir(t, e) {
  var r = An(t) ? ed : $G;
  return r(t, dl(e));
}
function R1e(t, e) {
  return wx(Ir(t, e));
}
function M1e(t, e) {
  return t == null ? t : OE(t, Fk(e), Yu);
}
function N1e(t, e) {
  return t && Bk(t, Fk(e));
}
function I1e(t, e) {
  return t > e;
}
var D1e = Object.prototype, O1e = D1e.hasOwnProperty;
function P1e(t, e) {
  return t != null && O1e.call(t, e);
}
function zG(t, e) {
  return t != null && PG(t, e, P1e);
}
function B1e(t, e) {
  return ed(e, function(r) {
    return t[r];
  });
}
function Xo(t) {
  return t == null ? [] : B1e(t, ba(t));
}
function yn(t) {
  return t === void 0;
}
function GG(t, e) {
  return t < e;
}
function Ex(t, e) {
  var r = {};
  return e = dl(e), Bk(t, function(n, i, a) {
    X2(r, i, e(n, i, a));
  }), r;
}
function zk(t, e, r) {
  for (var n = -1, i = t.length; ++n < i; ) {
    var a = t[n], s = e(a);
    if (s != null && (o === void 0 ? s === s && !Eu(s) : r(s, o)))
      var o = s, l = a;
  }
  return l;
}
function ku(t) {
  return t && t.length ? zk(t, Xu, I1e) : void 0;
}
function Ad(t) {
  return t && t.length ? zk(t, Xu, GG) : void 0;
}
function Gk(t, e) {
  return t && t.length ? zk(t, dl(e), GG) : void 0;
}
function F1e(t, e, r, n) {
  if (!Ca(t))
    return t;
  e = xx(e, t);
  for (var i = -1, a = e.length, s = a - 1, o = t; o != null && ++i < a; ) {
    var l = bg(e[i]), u = r;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return t;
    if (i != s) {
      var h = o[l];
      u = void 0, u === void 0 && (u = Ca(h) ? h : J2(e[i + 1]) ? [] : {});
    }
    Q2(o, l, u), o = o[l];
  }
  return t;
}
function $1e(t, e, r) {
  for (var n = -1, i = e.length, a = {}; ++n < i; ) {
    var s = e[n], o = bx(t, s);
    r(o, s) && F1e(a, xx(s, t), o);
  }
  return a;
}
function z1e(t, e) {
  var r = t.length;
  for (t.sort(e); r--; )
    t[r] = t[r].value;
  return t;
}
function G1e(t, e) {
  if (t !== e) {
    var r = t !== void 0, n = t === null, i = t === t, a = Eu(t), s = e !== void 0, o = e === null, l = e === e, u = Eu(e);
    if (!o && !u && !a && t > e || a && s && l && !o && !u || n && s && l || !r && l || !i)
      return 1;
    if (!n && !a && !u && t < e || u && r && i && !n && !a || o && r && i || !s && i || !l)
      return -1;
  }
  return 0;
}
function V1e(t, e, r) {
  for (var n = -1, i = t.criteria, a = e.criteria, s = i.length, o = r.length; ++n < s; ) {
    var l = G1e(i[n], a[n]);
    if (l) {
      if (n >= o)
        return l;
      var u = r[n];
      return l * (u == "desc" ? -1 : 1);
    }
  }
  return t.index - e.index;
}
function U1e(t, e, r) {
  e.length ? e = ed(e, function(a) {
    return An(a) ? function(s) {
      return bx(s, a.length === 1 ? a[0] : a);
    } : a;
  }) : e = [Xu];
  var n = -1;
  e = ed(e, K2(dl));
  var i = $G(t, function(a, s, o) {
    var l = ed(e, function(u) {
      return u(a);
    });
    return { criteria: l, index: ++n, value: a };
  });
  return z1e(i, function(a, s) {
    return V1e(a, s, r);
  });
}
function H1e(t, e) {
  return $1e(t, e, function(r, n) {
    return BG(t, n);
  });
}
var wy = ype(function(t, e) {
  return t == null ? {} : H1e(t, e);
}), q1e = Math.ceil, W1e = Math.max;
function Y1e(t, e, r, n) {
  for (var i = -1, a = W1e(q1e((e - t) / (r || 1)), 0), s = Array(a); a--; )
    s[++i] = t, t += r;
  return s;
}
function X1e(t) {
  return function(e, r, n) {
    return n && typeof n != "number" && Ep(e, r, n) && (r = n = void 0), e = Im(e), r === void 0 ? (r = e, e = 0) : r = Im(r), n = n === void 0 ? e < r ? 1 : -1 : Im(n), Y1e(e, r, n);
  };
}
var _d = X1e();
function j1e(t, e, r, n, i) {
  return i(t, function(a, s, o) {
    r = n ? (n = !1, a) : e(r, a, s, o);
  }), r;
}
function Su(t, e, r) {
  var n = An(t) ? xpe : j1e, i = arguments.length < 3;
  return n(t, dl(e), r, i, Tx);
}
var wg = ex(function(t, e) {
  if (t == null)
    return [];
  var r = e.length;
  return r > 1 && Ep(t, e[0], e[1]) ? e = [] : r > 2 && Ep(e[0], e[1], e[2]) && (e = [e[0]]), U1e(t, wx(e), []);
}), K1e = 1 / 0, Z1e = Qh && 1 / Ok(new Qh([, -0]))[1] == K1e ? function(t) {
  return new Qh(t);
} : ipe, Q1e = 200;
function VG(t, e, r) {
  var n = -1, i = lpe, a = t.length, s = !0, o = [], l = o;
  if (a >= Q1e) {
    var u = e ? null : Z1e(t);
    if (u)
      return Ok(u);
    s = !1, i = NG, l = new Rp();
  } else
    l = e ? [] : o;
  e:
    for (; ++n < a; ) {
      var h = t[n], d = e ? e(h) : h;
      if (h = h !== 0 ? h : 0, s && d === d) {
        for (var f = l.length; f--; )
          if (l[f] === d)
            continue e;
        e && l.push(d), o.push(h);
      } else i(l, d, r) || (l !== o && l.push(d), o.push(h));
    }
  return o;
}
var J1e = ex(function(t) {
  return VG(wx(t, 1, jP, !0));
});
function eme(t, e) {
  return t && t.length ? VG(t, dl(e)) : [];
}
var tme = 0;
function Vk(t) {
  var e = ++tme;
  return EG(t) + e;
}
function rme(t, e, r) {
  for (var n = -1, i = t.length, a = e.length, s = {}; ++n < i; ) {
    var o = n < a ? e[n] : void 0;
    r(s, t[n], o);
  }
  return s;
}
function nme(t, e) {
  return rme(t || [], e || [], Q2);
}
var ime = "\0", Fc = "\0", UA = "";
class fa {
  constructor(e = {}) {
    this._isDirected = Object.prototype.hasOwnProperty.call(e, "directed") ? e.directed : !0, this._isMultigraph = Object.prototype.hasOwnProperty.call(e, "multigraph") ? e.multigraph : !1, this._isCompound = Object.prototype.hasOwnProperty.call(e, "compound") ? e.compound : !1, this._label = void 0, this._defaultNodeLabelFn = zh(void 0), this._defaultEdgeLabelFn = zh(void 0), this._nodes = {}, this._isCompound && (this._parent = {}, this._children = {}, this._children[Fc] = {}), this._in = {}, this._preds = {}, this._out = {}, this._sucs = {}, this._edgeObjs = {}, this._edgeLabels = {};
  }
  /* === Graph functions ========= */
  isDirected() {
    return this._isDirected;
  }
  isMultigraph() {
    return this._isMultigraph;
  }
  isCompound() {
    return this._isCompound;
  }
  setGraph(e) {
    return this._label = e, this;
  }
  graph() {
    return this._label;
  }
  /* === Node functions ========== */
  setDefaultNodeLabel(e) {
    return bp(e) || (e = zh(e)), this._defaultNodeLabelFn = e, this;
  }
  nodeCount() {
    return this._nodeCount;
  }
  nodes() {
    return ba(this._nodes);
  }
  sources() {
    var e = this;
    return js(this.nodes(), function(r) {
      return Ap(e._in[r]);
    });
  }
  sinks() {
    var e = this;
    return js(this.nodes(), function(r) {
      return Ap(e._out[r]);
    });
  }
  setNodes(e, r) {
    var n = arguments, i = this;
    return Ye(e, function(a) {
      n.length > 1 ? i.setNode(a, r) : i.setNode(a);
    }), this;
  }
  setNode(e, r) {
    return Object.prototype.hasOwnProperty.call(this._nodes, e) ? (arguments.length > 1 && (this._nodes[e] = r), this) : (this._nodes[e] = arguments.length > 1 ? r : this._defaultNodeLabelFn(e), this._isCompound && (this._parent[e] = Fc, this._children[e] = {}, this._children[Fc][e] = !0), this._in[e] = {}, this._preds[e] = {}, this._out[e] = {}, this._sucs[e] = {}, ++this._nodeCount, this);
  }
  node(e) {
    return this._nodes[e];
  }
  hasNode(e) {
    return Object.prototype.hasOwnProperty.call(this._nodes, e);
  }
  removeNode(e) {
    if (Object.prototype.hasOwnProperty.call(this._nodes, e)) {
      var r = (n) => this.removeEdge(this._edgeObjs[n]);
      delete this._nodes[e], this._isCompound && (this._removeFromParentsChildList(e), delete this._parent[e], Ye(this.children(e), (n) => {
        this.setParent(n);
      }), delete this._children[e]), Ye(ba(this._in[e]), r), delete this._in[e], delete this._preds[e], Ye(ba(this._out[e]), r), delete this._out[e], delete this._sucs[e], --this._nodeCount;
    }
    return this;
  }
  setParent(e, r) {
    if (!this._isCompound)
      throw new Error("Cannot set parent in a non-compound graph");
    if (yn(r))
      r = Fc;
    else {
      r += "";
      for (var n = r; !yn(n); n = this.parent(n))
        if (n === e)
          throw new Error("Setting " + r + " as parent of " + e + " would create a cycle");
      this.setNode(r);
    }
    return this.setNode(e), this._removeFromParentsChildList(e), this._parent[e] = r, this._children[r][e] = !0, this;
  }
  _removeFromParentsChildList(e) {
    delete this._children[this._parent[e]][e];
  }
  parent(e) {
    if (this._isCompound) {
      var r = this._parent[e];
      if (r !== Fc)
        return r;
    }
  }
  children(e) {
    if (yn(e) && (e = Fc), this._isCompound) {
      var r = this._children[e];
      if (r)
        return ba(r);
    } else {
      if (e === Fc)
        return this.nodes();
      if (this.hasNode(e))
        return [];
    }
  }
  predecessors(e) {
    var r = this._preds[e];
    if (r)
      return ba(r);
  }
  successors(e) {
    var r = this._sucs[e];
    if (r)
      return ba(r);
  }
  neighbors(e) {
    var r = this.predecessors(e);
    if (r)
      return J1e(r, this.successors(e));
  }
  isLeaf(e) {
    var r;
    return this.isDirected() ? r = this.successors(e) : r = this.neighbors(e), r.length === 0;
  }
  filterNodes(e) {
    var r = new this.constructor({
      directed: this._isDirected,
      multigraph: this._isMultigraph,
      compound: this._isCompound
    });
    r.setGraph(this.graph());
    var n = this;
    Ye(this._nodes, function(s, o) {
      e(o) && r.setNode(o, s);
    }), Ye(this._edgeObjs, function(s) {
      r.hasNode(s.v) && r.hasNode(s.w) && r.setEdge(s, n.edge(s));
    });
    var i = {};
    function a(s) {
      var o = n.parent(s);
      return o === void 0 || r.hasNode(o) ? (i[s] = o, o) : o in i ? i[o] : a(o);
    }
    return this._isCompound && Ye(r.nodes(), function(s) {
      r.setParent(s, a(s));
    }), r;
  }
  /* === Edge functions ========== */
  setDefaultEdgeLabel(e) {
    return bp(e) || (e = zh(e)), this._defaultEdgeLabelFn = e, this;
  }
  edgeCount() {
    return this._edgeCount;
  }
  edges() {
    return Xo(this._edgeObjs);
  }
  setPath(e, r) {
    var n = this, i = arguments;
    return Su(e, function(a, s) {
      return i.length > 1 ? n.setEdge(a, s, r) : n.setEdge(a, s), s;
    }), this;
  }
  /*
   * setEdge(v, w, [value, [name]])
   * setEdge({ v, w, [name] }, [value])
   */
  setEdge() {
    var e, r, n, i, a = !1, s = arguments[0];
    typeof s == "object" && s !== null && "v" in s ? (e = s.v, r = s.w, n = s.name, arguments.length === 2 && (i = arguments[1], a = !0)) : (e = s, r = arguments[1], n = arguments[3], arguments.length > 2 && (i = arguments[2], a = !0)), e = "" + e, r = "" + r, yn(n) || (n = "" + n);
    var o = Jf(this._isDirected, e, r, n);
    if (Object.prototype.hasOwnProperty.call(this._edgeLabels, o))
      return a && (this._edgeLabels[o] = i), this;
    if (!yn(n) && !this._isMultigraph)
      throw new Error("Cannot set a named edge when isMultigraph = false");
    this.setNode(e), this.setNode(r), this._edgeLabels[o] = a ? i : this._defaultEdgeLabelFn(e, r, n);
    var l = ame(this._isDirected, e, r, n);
    return e = l.v, r = l.w, Object.freeze(l), this._edgeObjs[o] = l, HA(this._preds[r], e), HA(this._sucs[e], r), this._in[r][o] = l, this._out[e][o] = l, this._edgeCount++, this;
  }
  edge(e, r, n) {
    var i = arguments.length === 1 ? A4(this._isDirected, arguments[0]) : Jf(this._isDirected, e, r, n);
    return this._edgeLabels[i];
  }
  hasEdge(e, r, n) {
    var i = arguments.length === 1 ? A4(this._isDirected, arguments[0]) : Jf(this._isDirected, e, r, n);
    return Object.prototype.hasOwnProperty.call(this._edgeLabels, i);
  }
  removeEdge(e, r, n) {
    var i = arguments.length === 1 ? A4(this._isDirected, arguments[0]) : Jf(this._isDirected, e, r, n), a = this._edgeObjs[i];
    return a && (e = a.v, r = a.w, delete this._edgeLabels[i], delete this._edgeObjs[i], qA(this._preds[r], e), qA(this._sucs[e], r), delete this._in[r][i], delete this._out[e][i], this._edgeCount--), this;
  }
  inEdges(e, r) {
    var n = this._in[e];
    if (n) {
      var i = Xo(n);
      return r ? js(i, function(a) {
        return a.v === r;
      }) : i;
    }
  }
  outEdges(e, r) {
    var n = this._out[e];
    if (n) {
      var i = Xo(n);
      return r ? js(i, function(a) {
        return a.w === r;
      }) : i;
    }
  }
  nodeEdges(e, r) {
    var n = this.inEdges(e, r);
    if (n)
      return n.concat(this.outEdges(e, r));
  }
}
fa.prototype._nodeCount = 0;
fa.prototype._edgeCount = 0;
function HA(t, e) {
  t[e] ? t[e]++ : t[e] = 1;
}
function qA(t, e) {
  --t[e] || delete t[e];
}
function Jf(t, e, r, n) {
  var i = "" + e, a = "" + r;
  if (!t && i > a) {
    var s = i;
    i = a, a = s;
  }
  return i + UA + a + UA + (yn(n) ? ime : n);
}
function ame(t, e, r, n) {
  var i = "" + e, a = "" + r;
  if (!t && i > a) {
    var s = i;
    i = a, a = s;
  }
  var o = { v: i, w: a };
  return n && (o.name = n), o;
}
function A4(t, e) {
  return Jf(t, e.v, e.w, e.name);
}
class sme {
  constructor() {
    var e = {};
    e._next = e._prev = e, this._sentinel = e;
  }
  dequeue() {
    var e = this._sentinel, r = e._prev;
    if (r !== e)
      return WA(r), r;
  }
  enqueue(e) {
    var r = this._sentinel;
    e._prev && e._next && WA(e), e._next = r._next, r._next._prev = e, r._next = e, e._prev = r;
  }
  toString() {
    for (var e = [], r = this._sentinel, n = r._prev; n !== r; )
      e.push(JSON.stringify(n, ome)), n = n._prev;
    return "[" + e.join(", ") + "]";
  }
}
function WA(t) {
  t._prev._next = t._next, t._next._prev = t._prev, delete t._next, delete t._prev;
}
function ome(t, e) {
  if (t !== "_next" && t !== "_prev")
    return e;
}
var lme = zh(1);
function cme(t, e) {
  if (t.nodeCount() <= 1)
    return [];
  var r = hme(t, e || lme), n = ume(r.graph, r.buckets, r.zeroIdx);
  return Qu(
    Ir(n, function(i) {
      return t.outEdges(i.v, i.w);
    })
  );
}
function ume(t, e, r) {
  for (var n = [], i = e[e.length - 1], a = e[0], s; t.nodeCount(); ) {
    for (; s = a.dequeue(); )
      _4(t, e, r, s);
    for (; s = i.dequeue(); )
      _4(t, e, r, s);
    if (t.nodeCount()) {
      for (var o = e.length - 2; o > 0; --o)
        if (s = e[o].dequeue(), s) {
          n = n.concat(_4(t, e, r, s, !0));
          break;
        }
    }
  }
  return n;
}
function _4(t, e, r, n, i) {
  var a = i ? [] : void 0;
  return Ye(t.inEdges(n.v), function(s) {
    var o = t.edge(s), l = t.node(s.v);
    i && a.push({ v: s.v, w: s.w }), l.out -= o, hT(e, r, l);
  }), Ye(t.outEdges(n.v), function(s) {
    var o = t.edge(s), l = s.w, u = t.node(l);
    u.in -= o, hT(e, r, u);
  }), t.removeNode(n.v), a;
}
function hme(t, e) {
  var r = new fa(), n = 0, i = 0;
  Ye(t.nodes(), function(o) {
    r.setNode(o, { v: o, in: 0, out: 0 });
  }), Ye(t.edges(), function(o) {
    var l = r.edge(o.v, o.w) || 0, u = e(o), h = l + u;
    r.setEdge(o.v, o.w, h), i = Math.max(i, r.node(o.v).out += u), n = Math.max(n, r.node(o.w).in += u);
  });
  var a = _d(i + n + 3).map(function() {
    return new sme();
  }), s = n + 1;
  return Ye(r.nodes(), function(o) {
    hT(a, s, r.node(o));
  }), { graph: r, buckets: a, zeroIdx: s };
}
function hT(t, e, r) {
  r.out ? r.in ? t[r.out - r.in + e].enqueue(r) : t[t.length - 1].enqueue(r) : t[0].enqueue(r);
}
function dme(t) {
  var e = t.graph().acyclicer === "greedy" ? cme(t, r(t)) : fme(t);
  Ye(e, function(n) {
    var i = t.edge(n);
    t.removeEdge(n), i.forwardName = n.name, i.reversed = !0, t.setEdge(n.w, n.v, i, Vk("rev"));
  });
  function r(n) {
    return function(i) {
      return n.edge(i).weight;
    };
  }
}
function fme(t) {
  var e = [], r = {}, n = {};
  function i(a) {
    Object.prototype.hasOwnProperty.call(n, a) || (n[a] = !0, r[a] = !0, Ye(t.outEdges(a), function(s) {
      Object.prototype.hasOwnProperty.call(r, s.w) ? e.push(s) : i(s.w);
    }), delete r[a]);
  }
  return Ye(t.nodes(), i), e;
}
function pme(t) {
  Ye(t.edges(), function(e) {
    var r = t.edge(e);
    if (r.reversed) {
      t.removeEdge(e);
      var n = r.forwardName;
      delete r.reversed, delete r.forwardName, t.setEdge(e.w, e.v, r, n);
    }
  });
}
function ef(t, e, r, n) {
  var i;
  do
    i = Vk(n);
  while (t.hasNode(i));
  return r.dummy = e, t.setNode(i, r), i;
}
function gme(t) {
  var e = new fa().setGraph(t.graph());
  return Ye(t.nodes(), function(r) {
    e.setNode(r, t.node(r));
  }), Ye(t.edges(), function(r) {
    var n = e.edge(r.v, r.w) || { weight: 0, minlen: 1 }, i = t.edge(r);
    e.setEdge(r.v, r.w, {
      weight: n.weight + i.weight,
      minlen: Math.max(n.minlen, i.minlen)
    });
  }), e;
}
function UG(t) {
  var e = new fa({ multigraph: t.isMultigraph() }).setGraph(t.graph());
  return Ye(t.nodes(), function(r) {
    t.children(r).length || e.setNode(r, t.node(r));
  }), Ye(t.edges(), function(r) {
    e.setEdge(r, t.edge(r));
  }), e;
}
function YA(t, e) {
  var r = t.x, n = t.y, i = e.x - r, a = e.y - n, s = t.width / 2, o = t.height / 2;
  if (!i && !a)
    throw new Error("Not possible to find intersection inside of the rectangle");
  var l, u;
  return Math.abs(a) * s > Math.abs(i) * o ? (a < 0 && (o = -o), l = o * i / a, u = o) : (i < 0 && (s = -s), l = s, u = s * a / i), { x: r + l, y: n + u };
}
function kx(t) {
  var e = Ir(_d(HG(t) + 1), function() {
    return [];
  });
  return Ye(t.nodes(), function(r) {
    var n = t.node(r), i = n.rank;
    yn(i) || (e[i][n.order] = r);
  }), e;
}
function mme(t) {
  var e = Ad(
    Ir(t.nodes(), function(r) {
      return t.node(r).rank;
    })
  );
  Ye(t.nodes(), function(r) {
    var n = t.node(r);
    zG(n, "rank") && (n.rank -= e);
  });
}
function vme(t) {
  var e = Ad(
    Ir(t.nodes(), function(a) {
      return t.node(a).rank;
    })
  ), r = [];
  Ye(t.nodes(), function(a) {
    var s = t.node(a).rank - e;
    r[s] || (r[s] = []), r[s].push(a);
  });
  var n = 0, i = t.graph().nodeRankFactor;
  Ye(r, function(a, s) {
    yn(a) && s % i !== 0 ? --n : n && Ye(a, function(o) {
      t.node(o).rank += n;
    });
  });
}
function XA(t, e, r, n) {
  var i = {
    width: 0,
    height: 0
  };
  return arguments.length >= 4 && (i.rank = r, i.order = n), ef(t, "border", i, e);
}
function HG(t) {
  return ku(
    Ir(t.nodes(), function(e) {
      var r = t.node(e).rank;
      if (!yn(r))
        return r;
    })
  );
}
function yme(t, e) {
  var r = { lhs: [], rhs: [] };
  return Ye(t, function(n) {
    e(n) ? r.lhs.push(n) : r.rhs.push(n);
  }), r;
}
function xme(t, e) {
  return e();
}
function bme(t) {
  function e(r) {
    var n = t.children(r), i = t.node(r);
    if (n.length && Ye(n, e), Object.prototype.hasOwnProperty.call(i, "minRank")) {
      i.borderLeft = [], i.borderRight = [];
      for (var a = i.minRank, s = i.maxRank + 1; a < s; ++a)
        jA(t, "borderLeft", "_bl", r, i, a), jA(t, "borderRight", "_br", r, i, a);
    }
  }
  Ye(t.children(), e);
}
function jA(t, e, r, n, i, a) {
  var s = { width: 0, height: 0, rank: a, borderType: e }, o = i[e][a - 1], l = ef(t, "border", s, r);
  i[e][a] = l, t.setParent(l, n), o && t.setEdge(o, l, { weight: 1 });
}
function wme(t) {
  var e = t.graph().rankdir.toLowerCase();
  (e === "lr" || e === "rl") && qG(t);
}
function Tme(t) {
  var e = t.graph().rankdir.toLowerCase();
  (e === "bt" || e === "rl") && Eme(t), (e === "lr" || e === "rl") && (kme(t), qG(t));
}
function qG(t) {
  Ye(t.nodes(), function(e) {
    KA(t.node(e));
  }), Ye(t.edges(), function(e) {
    KA(t.edge(e));
  });
}
function KA(t) {
  var e = t.width;
  t.width = t.height, t.height = e;
}
function Eme(t) {
  Ye(t.nodes(), function(e) {
    L4(t.node(e));
  }), Ye(t.edges(), function(e) {
    var r = t.edge(e);
    Ye(r.points, L4), Object.prototype.hasOwnProperty.call(r, "y") && L4(r);
  });
}
function L4(t) {
  t.y = -t.y;
}
function kme(t) {
  Ye(t.nodes(), function(e) {
    R4(t.node(e));
  }), Ye(t.edges(), function(e) {
    var r = t.edge(e);
    Ye(r.points, R4), Object.prototype.hasOwnProperty.call(r, "x") && R4(r);
  });
}
function R4(t) {
  var e = t.x;
  t.x = t.y, t.y = e;
}
function Sme(t) {
  t.graph().dummyChains = [], Ye(t.edges(), function(e) {
    Cme(t, e);
  });
}
function Cme(t, e) {
  var r = e.v, n = t.node(r).rank, i = e.w, a = t.node(i).rank, s = e.name, o = t.edge(e), l = o.labelRank;
  if (a !== n + 1) {
    t.removeEdge(e);
    var u = void 0, h, d;
    for (d = 0, ++n; n < a; ++d, ++n)
      o.points = [], u = {
        width: 0,
        height: 0,
        edgeLabel: o,
        edgeObj: e,
        rank: n
      }, h = ef(t, "edge", u, "_d"), n === l && (u.width = o.width, u.height = o.height, u.dummy = "edge-label", u.labelpos = o.labelpos), t.setEdge(r, h, { weight: o.weight }, s), d === 0 && t.graph().dummyChains.push(h), r = h;
    t.setEdge(r, i, { weight: o.weight }, s);
  }
}
function Ame(t) {
  Ye(t.graph().dummyChains, function(e) {
    var r = t.node(e), n = r.edgeLabel, i;
    for (t.setEdge(r.edgeObj, n); r.dummy; )
      i = t.successors(e)[0], t.removeNode(e), n.points.push({ x: r.x, y: r.y }), r.dummy === "edge-label" && (n.x = r.x, n.y = r.y, n.width = r.width, n.height = r.height), e = i, r = t.node(e);
  });
}
function Uk(t) {
  var e = {};
  function r(n) {
    var i = t.node(n);
    if (Object.prototype.hasOwnProperty.call(e, n))
      return i.rank;
    e[n] = !0;
    var a = Ad(
      Ir(t.outEdges(n), function(s) {
        return r(s.w) - t.edge(s).minlen;
      })
    );
    return (a === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3
    a === void 0 || // return value of _.map([]) for Lodash 4
    a === null) && (a = 0), i.rank = a;
  }
  Ye(t.sources(), r);
}
function Mp(t, e) {
  return t.node(e.w).rank - t.node(e.v).rank - t.edge(e).minlen;
}
function WG(t) {
  var e = new fa({ directed: !1 }), r = t.nodes()[0], n = t.nodeCount();
  e.setNode(r, {});
  for (var i, a; _me(e, t) < n; )
    i = Lme(e, t), a = e.hasNode(i.v) ? Mp(t, i) : -Mp(t, i), Rme(e, t, a);
  return e;
}
function _me(t, e) {
  function r(n) {
    Ye(e.nodeEdges(n), function(i) {
      var a = i.v, s = n === a ? i.w : a;
      !t.hasNode(s) && !Mp(e, i) && (t.setNode(s, {}), t.setEdge(n, s, {}), r(s));
    });
  }
  return Ye(t.nodes(), r), t.nodeCount();
}
function Lme(t, e) {
  return Gk(e.edges(), function(r) {
    if (t.hasNode(r.v) !== t.hasNode(r.w))
      return Mp(e, r);
  });
}
function Rme(t, e, r) {
  Ye(t.nodes(), function(n) {
    e.node(n).rank += r;
  });
}
function Mme() {
}
Mme.prototype = new Error();
function YG(t, e, r) {
  An(e) || (e = [e]);
  var n = (t.isDirected() ? t.successors : t.neighbors).bind(t), i = [], a = {};
  return Ye(e, function(s) {
    if (!t.hasNode(s))
      throw new Error("Graph does not have node: " + s);
    XG(t, s, r === "post", a, n, i);
  }), i;
}
function XG(t, e, r, n, i, a) {
  Object.prototype.hasOwnProperty.call(n, e) || (n[e] = !0, r || a.push(e), Ye(i(e), function(s) {
    XG(t, s, r, n, i, a);
  }), r && a.push(e));
}
function Nme(t, e) {
  return YG(t, e, "post");
}
function Ime(t, e) {
  return YG(t, e, "pre");
}
Ju.initLowLimValues = qk;
Ju.initCutValues = Hk;
Ju.calcCutValue = jG;
Ju.leaveEdge = ZG;
Ju.enterEdge = QG;
Ju.exchangeEdges = JG;
function Ju(t) {
  t = gme(t), Uk(t);
  var e = WG(t);
  qk(e), Hk(e, t);
  for (var r, n; r = ZG(e); )
    n = QG(e, t, r), JG(e, t, r, n);
}
function Hk(t, e) {
  var r = Nme(t, t.nodes());
  r = r.slice(0, r.length - 1), Ye(r, function(n) {
    Dme(t, e, n);
  });
}
function Dme(t, e, r) {
  var n = t.node(r), i = n.parent;
  t.edge(r, i).cutvalue = jG(t, e, r);
}
function jG(t, e, r) {
  var n = t.node(r), i = n.parent, a = !0, s = e.edge(r, i), o = 0;
  return s || (a = !1, s = e.edge(i, r)), o = s.weight, Ye(e.nodeEdges(r), function(l) {
    var u = l.v === r, h = u ? l.w : l.v;
    if (h !== i) {
      var d = u === a, f = e.edge(l).weight;
      if (o += d ? f : -f, Pme(t, r, h)) {
        var p = t.edge(r, h).cutvalue;
        o += d ? -p : p;
      }
    }
  }), o;
}
function qk(t, e) {
  arguments.length < 2 && (e = t.nodes()[0]), KG(t, {}, 1, e);
}
function KG(t, e, r, n, i) {
  var a = r, s = t.node(n);
  return e[n] = !0, Ye(t.neighbors(n), function(o) {
    Object.prototype.hasOwnProperty.call(e, o) || (r = KG(t, e, r, o, n));
  }), s.low = a, s.lim = r++, i ? s.parent = i : delete s.parent, r;
}
function ZG(t) {
  return $k(t.edges(), function(e) {
    return t.edge(e).cutvalue < 0;
  });
}
function QG(t, e, r) {
  var n = r.v, i = r.w;
  e.hasEdge(n, i) || (n = r.w, i = r.v);
  var a = t.node(n), s = t.node(i), o = a, l = !1;
  a.lim > s.lim && (o = s, l = !0);
  var u = js(e.edges(), function(h) {
    return l === ZA(t, t.node(h.v), o) && l !== ZA(t, t.node(h.w), o);
  });
  return Gk(u, function(h) {
    return Mp(e, h);
  });
}
function JG(t, e, r, n) {
  var i = r.v, a = r.w;
  t.removeEdge(i, a), t.setEdge(n.v, n.w, {}), qk(t), Hk(t, e), Ome(t, e);
}
function Ome(t, e) {
  var r = $k(t.nodes(), function(i) {
    return !e.node(i).parent;
  }), n = Ime(t, r);
  n = n.slice(1), Ye(n, function(i) {
    var a = t.node(i).parent, s = e.edge(i, a), o = !1;
    s || (s = e.edge(a, i), o = !0), e.node(i).rank = e.node(a).rank + (o ? s.minlen : -s.minlen);
  });
}
function Pme(t, e, r) {
  return t.hasEdge(e, r);
}
function ZA(t, e, r) {
  return r.low <= e.lim && e.lim <= r.lim;
}
function Bme(t) {
  switch (t.graph().ranker) {
    case "network-simplex":
      QA(t);
      break;
    case "tight-tree":
      $me(t);
      break;
    case "longest-path":
      Fme(t);
      break;
    default:
      QA(t);
  }
}
var Fme = Uk;
function $me(t) {
  Uk(t), WG(t);
}
function QA(t) {
  Ju(t);
}
function zme(t) {
  var e = ef(t, "root", {}, "_root"), r = Gme(t), n = ku(Xo(r)) - 1, i = 2 * n + 1;
  t.graph().nestingRoot = e, Ye(t.edges(), function(s) {
    t.edge(s).minlen *= i;
  });
  var a = Vme(t) + 1;
  Ye(t.children(), function(s) {
    eV(t, e, i, a, n, r, s);
  }), t.graph().nodeRankFactor = i;
}
function eV(t, e, r, n, i, a, s) {
  var o = t.children(s);
  if (!o.length) {
    s !== e && t.setEdge(e, s, { weight: 0, minlen: r });
    return;
  }
  var l = XA(t, "_bt"), u = XA(t, "_bb"), h = t.node(s);
  t.setParent(l, s), h.borderTop = l, t.setParent(u, s), h.borderBottom = u, Ye(o, function(d) {
    eV(t, e, r, n, i, a, d);
    var f = t.node(d), p = f.borderTop ? f.borderTop : d, g = f.borderBottom ? f.borderBottom : d, m = f.borderTop ? n : 2 * n, v = p !== g ? 1 : i - a[s] + 1;
    t.setEdge(l, p, {
      weight: m,
      minlen: v,
      nestingEdge: !0
    }), t.setEdge(g, u, {
      weight: m,
      minlen: v,
      nestingEdge: !0
    });
  }), t.parent(s) || t.setEdge(e, l, { weight: 0, minlen: i + a[s] });
}
function Gme(t) {
  var e = {};
  function r(n, i) {
    var a = t.children(n);
    a && a.length && Ye(a, function(s) {
      r(s, i + 1);
    }), e[n] = i;
  }
  return Ye(t.children(), function(n) {
    r(n, 1);
  }), e;
}
function Vme(t) {
  return Su(
    t.edges(),
    function(e, r) {
      return e + t.edge(r).weight;
    },
    0
  );
}
function Ume(t) {
  var e = t.graph();
  t.removeNode(e.nestingRoot), delete e.nestingRoot, Ye(t.edges(), function(r) {
    var n = t.edge(r);
    n.nestingEdge && t.removeEdge(r);
  });
}
function Hme(t, e, r) {
  var n = {}, i;
  Ye(r, function(a) {
    for (var s = t.parent(a), o, l; s; ) {
      if (o = t.parent(s), o ? (l = n[o], n[o] = s) : (l = i, i = s), l && l !== s) {
        e.setEdge(l, s);
        return;
      }
      s = o;
    }
  });
}
function qme(t, e, r) {
  var n = Wme(t), i = new fa({ compound: !0 }).setGraph({ root: n }).setDefaultNodeLabel(function(a) {
    return t.node(a);
  });
  return Ye(t.nodes(), function(a) {
    var s = t.node(a), o = t.parent(a);
    (s.rank === e || s.minRank <= e && e <= s.maxRank) && (i.setNode(a), i.setParent(a, o || n), Ye(t[r](a), function(l) {
      var u = l.v === a ? l.w : l.v, h = i.edge(u, a), d = yn(h) ? 0 : h.weight;
      i.setEdge(u, a, { weight: t.edge(l).weight + d });
    }), Object.prototype.hasOwnProperty.call(s, "minRank") && i.setNode(a, {
      borderLeft: s.borderLeft[e],
      borderRight: s.borderRight[e]
    }));
  }), i;
}
function Wme(t) {
  for (var e; t.hasNode(e = Vk("_root")); ) ;
  return e;
}
function Yme(t, e) {
  for (var r = 0, n = 1; n < e.length; ++n)
    r += Xme(t, e[n - 1], e[n]);
  return r;
}
function Xme(t, e, r) {
  for (var n = nme(
    r,
    Ir(r, function(u, h) {
      return h;
    })
  ), i = Qu(
    Ir(e, function(u) {
      return wg(
        Ir(t.outEdges(u), function(h) {
          return { pos: n[h.w], weight: t.edge(h).weight };
        }),
        "pos"
      );
    })
  ), a = 1; a < r.length; ) a <<= 1;
  var s = 2 * a - 1;
  a -= 1;
  var o = Ir(new Array(s), function() {
    return 0;
  }), l = 0;
  return Ye(
    // @ts-expect-error
    i.forEach(function(u) {
      var h = u.pos + a;
      o[h] += u.weight;
      for (var d = 0; h > 0; )
        h % 2 && (d += o[h + 1]), h = h - 1 >> 1, o[h] += u.weight;
      l += u.weight * d;
    })
  ), l;
}
function jme(t) {
  var e = {}, r = js(t.nodes(), function(o) {
    return !t.children(o).length;
  }), n = ku(
    Ir(r, function(o) {
      return t.node(o).rank;
    })
  ), i = Ir(_d(n + 1), function() {
    return [];
  });
  function a(o) {
    if (!zG(e, o)) {
      e[o] = !0;
      var l = t.node(o);
      i[l.rank].push(o), Ye(t.successors(o), a);
    }
  }
  var s = wg(r, function(o) {
    return t.node(o).rank;
  });
  return Ye(s, a), i;
}
function Kme(t, e) {
  return Ir(e, function(r) {
    var n = t.inEdges(r);
    if (n.length) {
      var i = Su(
        n,
        function(a, s) {
          var o = t.edge(s), l = t.node(s.v);
          return {
            sum: a.sum + o.weight * l.order,
            weight: a.weight + o.weight
          };
        },
        { sum: 0, weight: 0 }
      );
      return {
        v: r,
        barycenter: i.sum / i.weight,
        weight: i.weight
      };
    } else
      return { v: r };
  });
}
function Zme(t, e) {
  var r = {};
  Ye(t, function(i, a) {
    var s = r[i.v] = {
      indegree: 0,
      in: [],
      out: [],
      vs: [i.v],
      i: a
    };
    yn(i.barycenter) || (s.barycenter = i.barycenter, s.weight = i.weight);
  }), Ye(e.edges(), function(i) {
    var a = r[i.v], s = r[i.w];
    !yn(a) && !yn(s) && (s.indegree++, a.out.push(r[i.w]));
  });
  var n = js(r, function(i) {
    return !i.indegree;
  });
  return Qme(n);
}
function Qme(t) {
  var e = [];
  function r(a) {
    return function(s) {
      s.merged || (yn(s.barycenter) || yn(a.barycenter) || s.barycenter >= a.barycenter) && Jme(a, s);
    };
  }
  function n(a) {
    return function(s) {
      s.in.push(a), --s.indegree === 0 && t.push(s);
    };
  }
  for (; t.length; ) {
    var i = t.pop();
    e.push(i), Ye(i.in.reverse(), r(i)), Ye(i.out, n(i));
  }
  return Ir(
    js(e, function(a) {
      return !a.merged;
    }),
    function(a) {
      return wy(a, ["vs", "i", "barycenter", "weight"]);
    }
  );
}
function Jme(t, e) {
  var r = 0, n = 0;
  t.weight && (r += t.barycenter * t.weight, n += t.weight), e.weight && (r += e.barycenter * e.weight, n += e.weight), t.vs = e.vs.concat(t.vs), t.barycenter = r / n, t.weight = n, t.i = Math.min(e.i, t.i), e.merged = !0;
}
function eve(t, e) {
  var r = yme(t, function(h) {
    return Object.prototype.hasOwnProperty.call(h, "barycenter");
  }), n = r.lhs, i = wg(r.rhs, function(h) {
    return -h.i;
  }), a = [], s = 0, o = 0, l = 0;
  n.sort(tve(!!e)), l = JA(a, i, l), Ye(n, function(h) {
    l += h.vs.length, a.push(h.vs), s += h.barycenter * h.weight, o += h.weight, l = JA(a, i, l);
  });
  var u = { vs: Qu(a) };
  return o && (u.barycenter = s / o, u.weight = o), u;
}
function JA(t, e, r) {
  for (var n; e.length && (n = by(e)).i <= r; )
    e.pop(), t.push(n.vs), r++;
  return r;
}
function tve(t) {
  return function(e, r) {
    return e.barycenter < r.barycenter ? -1 : e.barycenter > r.barycenter ? 1 : t ? r.i - e.i : e.i - r.i;
  };
}
function tV(t, e, r, n) {
  var i = t.children(e), a = t.node(e), s = a ? a.borderLeft : void 0, o = a ? a.borderRight : void 0, l = {};
  s && (i = js(i, function(g) {
    return g !== s && g !== o;
  }));
  var u = Kme(t, i);
  Ye(u, function(g) {
    if (t.children(g.v).length) {
      var m = tV(t, g.v, r, n);
      l[g.v] = m, Object.prototype.hasOwnProperty.call(m, "barycenter") && nve(g, m);
    }
  });
  var h = Zme(u, r);
  rve(h, l);
  var d = eve(h, n);
  if (s && (d.vs = Qu([s, d.vs, o]), t.predecessors(s).length)) {
    var f = t.node(t.predecessors(s)[0]), p = t.node(t.predecessors(o)[0]);
    Object.prototype.hasOwnProperty.call(d, "barycenter") || (d.barycenter = 0, d.weight = 0), d.barycenter = (d.barycenter * d.weight + f.order + p.order) / (d.weight + 2), d.weight += 2;
  }
  return d;
}
function rve(t, e) {
  Ye(t, function(r) {
    r.vs = Qu(
      r.vs.map(function(n) {
        return e[n] ? e[n].vs : n;
      })
    );
  });
}
function nve(t, e) {
  yn(t.barycenter) ? (t.barycenter = e.barycenter, t.weight = e.weight) : (t.barycenter = (t.barycenter * t.weight + e.barycenter * e.weight) / (t.weight + e.weight), t.weight += e.weight);
}
function ive(t) {
  var e = HG(t), r = e_(t, _d(1, e + 1), "inEdges"), n = e_(t, _d(e - 1, -1, -1), "outEdges"), i = jme(t);
  t_(t, i);
  for (var a = Number.POSITIVE_INFINITY, s, o = 0, l = 0; l < 4; ++o, ++l) {
    ave(o % 2 ? r : n, o % 4 >= 2), i = kx(t);
    var u = Yme(t, i);
    u < a && (l = 0, s = Pge(i), a = u);
  }
  t_(t, s);
}
function e_(t, e, r) {
  return Ir(e, function(n) {
    return qme(t, n, r);
  });
}
function ave(t, e) {
  var r = new fa();
  Ye(t, function(n) {
    var i = n.graph().root, a = tV(n, i, r, e);
    Ye(a.vs, function(s, o) {
      n.node(s).order = o;
    }), Hme(n, r, a.vs);
  });
}
function t_(t, e) {
  Ye(e, function(r) {
    Ye(r, function(n, i) {
      t.node(n).order = i;
    });
  });
}
function sve(t) {
  var e = lve(t);
  Ye(t.graph().dummyChains, function(r) {
    for (var n = t.node(r), i = n.edgeObj, a = ove(t, e, i.v, i.w), s = a.path, o = a.lca, l = 0, u = s[l], h = !0; r !== i.w; ) {
      if (n = t.node(r), h) {
        for (; (u = s[l]) !== o && t.node(u).maxRank < n.rank; )
          l++;
        u === o && (h = !1);
      }
      if (!h) {
        for (; l < s.length - 1 && t.node(u = s[l + 1]).minRank <= n.rank; )
          l++;
        u = s[l];
      }
      t.setParent(r, u), r = t.successors(r)[0];
    }
  });
}
function ove(t, e, r, n) {
  var i = [], a = [], s = Math.min(e[r].low, e[n].low), o = Math.max(e[r].lim, e[n].lim), l, u;
  l = r;
  do
    l = t.parent(l), i.push(l);
  while (l && (e[l].low > s || o > e[l].lim));
  for (u = l, l = n; (l = t.parent(l)) !== u; )
    a.push(l);
  return { path: i.concat(a.reverse()), lca: u };
}
function lve(t) {
  var e = {}, r = 0;
  function n(i) {
    var a = r;
    Ye(t.children(i), n), e[i] = { low: a, lim: r++ };
  }
  return Ye(t.children(), n), e;
}
function cve(t, e) {
  var r = {};
  function n(i, a) {
    var s = 0, o = 0, l = i.length, u = by(a);
    return Ye(a, function(h, d) {
      var f = hve(t, h), p = f ? t.node(f).order : l;
      (f || h === u) && (Ye(a.slice(o, d + 1), function(g) {
        Ye(t.predecessors(g), function(m) {
          var v = t.node(m), y = v.order;
          (y < s || p < y) && !(v.dummy && t.node(g).dummy) && rV(r, m, g);
        });
      }), o = d + 1, s = p);
    }), a;
  }
  return Su(e, n), r;
}
function uve(t, e) {
  var r = {};
  function n(a, s, o, l, u) {
    var h;
    Ye(_d(s, o), function(d) {
      h = a[d], t.node(h).dummy && Ye(t.predecessors(h), function(f) {
        var p = t.node(f);
        p.dummy && (p.order < l || p.order > u) && rV(r, f, h);
      });
    });
  }
  function i(a, s) {
    var o = -1, l, u = 0;
    return Ye(s, function(h, d) {
      if (t.node(h).dummy === "border") {
        var f = t.predecessors(h);
        f.length && (l = t.node(f[0]).order, n(s, u, d, o, l), u = d, o = l);
      }
      n(s, u, s.length, l, a.length);
    }), s;
  }
  return Su(e, i), r;
}
function hve(t, e) {
  if (t.node(e).dummy)
    return $k(t.predecessors(e), function(r) {
      return t.node(r).dummy;
    });
}
function rV(t, e, r) {
  if (e > r) {
    var n = e;
    e = r, r = n;
  }
  Object.prototype.hasOwnProperty.call(t, e) || Object.defineProperty(t, e, {
    enumerable: !0,
    configurable: !0,
    value: {},
    writable: !0
  });
  var i = t[e];
  Object.defineProperty(i, r, {
    enumerable: !0,
    configurable: !0,
    value: !0,
    writable: !0
  });
}
function dve(t, e, r) {
  if (e > r) {
    var n = e;
    e = r, r = n;
  }
  return !!t[e] && Object.prototype.hasOwnProperty.call(t[e], r);
}
function fve(t, e, r, n) {
  var i = {}, a = {}, s = {};
  return Ye(e, function(o) {
    Ye(o, function(l, u) {
      i[l] = l, a[l] = l, s[l] = u;
    });
  }), Ye(e, function(o) {
    var l = -1;
    Ye(o, function(u) {
      var h = n(u);
      if (h.length) {
        h = wg(h, function(m) {
          return s[m];
        });
        for (var d = (h.length - 1) / 2, f = Math.floor(d), p = Math.ceil(d); f <= p; ++f) {
          var g = h[f];
          a[u] === u && l < s[g] && !dve(r, u, g) && (a[g] = u, a[u] = i[u] = i[g], l = s[g]);
        }
      }
    });
  }), { root: i, align: a };
}
function pve(t, e, r, n, i) {
  var a = {}, s = gve(t, e, r, i), o = i ? "borderLeft" : "borderRight";
  function l(d, f) {
    for (var p = s.nodes(), g = p.pop(), m = {}; g; )
      m[g] ? d(g) : (m[g] = !0, p.push(g), p = p.concat(f(g))), g = p.pop();
  }
  function u(d) {
    a[d] = s.inEdges(d).reduce(function(f, p) {
      return Math.max(f, a[p.v] + s.edge(p));
    }, 0);
  }
  function h(d) {
    var f = s.outEdges(d).reduce(function(g, m) {
      return Math.min(g, a[m.w] - s.edge(m));
    }, Number.POSITIVE_INFINITY), p = t.node(d);
    f !== Number.POSITIVE_INFINITY && p.borderType !== o && (a[d] = Math.max(a[d], f));
  }
  return l(u, s.predecessors.bind(s)), l(h, s.successors.bind(s)), Ye(n, function(d) {
    a[d] = a[r[d]];
  }), a;
}
function gve(t, e, r, n) {
  var i = new fa(), a = t.graph(), s = bve(a.nodesep, a.edgesep, n);
  return Ye(e, function(o) {
    var l;
    Ye(o, function(u) {
      var h = r[u];
      if (i.setNode(h), l) {
        var d = r[l], f = i.edge(d, h);
        i.setEdge(d, h, Math.max(s(t, u, l), f || 0));
      }
      l = u;
    });
  }), i;
}
function mve(t, e) {
  return Gk(Xo(e), function(r) {
    var n = Number.NEGATIVE_INFINITY, i = Number.POSITIVE_INFINITY;
    return M1e(r, function(a, s) {
      var o = wve(t, s) / 2;
      n = Math.max(a + o, n), i = Math.min(a - o, i);
    }), n - i;
  });
}
function vve(t, e) {
  var r = Xo(e), n = Ad(r), i = ku(r);
  Ye(["u", "d"], function(a) {
    Ye(["l", "r"], function(s) {
      var o = a + s, l = t[o], u;
      if (l !== e) {
        var h = Xo(l);
        u = s === "l" ? n - Ad(h) : i - ku(h), u && (t[o] = Ex(l, function(d) {
          return d + u;
        }));
      }
    });
  });
}
function yve(t, e) {
  return Ex(t.ul, function(r, n) {
    if (e)
      return t[e.toLowerCase()][n];
    var i = wg(Ir(t, n));
    return (i[1] + i[2]) / 2;
  });
}
function xve(t) {
  var e = kx(t), r = ry(cve(t, e), uve(t, e)), n = {}, i;
  Ye(["u", "d"], function(s) {
    i = s === "u" ? e : Xo(e).reverse(), Ye(["l", "r"], function(o) {
      o === "r" && (i = Ir(i, function(d) {
        return Xo(d).reverse();
      }));
      var l = (s === "u" ? t.predecessors : t.successors).bind(t), u = fve(t, i, r, l), h = pve(t, i, u.root, u.align, o === "r");
      o === "r" && (h = Ex(h, function(d) {
        return -d;
      })), n[s + o] = h;
    });
  });
  var a = mve(t, n);
  return vve(n, a), yve(n, t.graph().align);
}
function bve(t, e, r) {
  return function(n, i, a) {
    var s = n.node(i), o = n.node(a), l = 0, u;
    if (l += s.width / 2, Object.prototype.hasOwnProperty.call(s, "labelpos"))
      switch (s.labelpos.toLowerCase()) {
        case "l":
          u = -s.width / 2;
          break;
        case "r":
          u = s.width / 2;
          break;
      }
    if (u && (l += r ? u : -u), u = 0, l += (s.dummy ? e : t) / 2, l += (o.dummy ? e : t) / 2, l += o.width / 2, Object.prototype.hasOwnProperty.call(o, "labelpos"))
      switch (o.labelpos.toLowerCase()) {
        case "l":
          u = o.width / 2;
          break;
        case "r":
          u = -o.width / 2;
          break;
      }
    return u && (l += r ? u : -u), u = 0, l;
  };
}
function wve(t, e) {
  return t.node(e).width;
}
function Tve(t) {
  t = UG(t), Eve(t), N1e(xve(t), function(e, r) {
    t.node(r).x = e;
  });
}
function Eve(t) {
  var e = kx(t), r = t.graph().ranksep, n = 0;
  Ye(e, function(i) {
    var a = ku(
      Ir(i, function(s) {
        return t.node(s).height;
      })
    );
    Ye(i, function(s) {
      t.node(s).y = n + a / 2;
    }), n += a + r;
  });
}
function nV(t, e) {
  var r = xme;
  r("layout", () => {
    var n = r("  buildLayoutGraph", () => Dve(t));
    r("  runLayout", () => kve(n, r)), r("  updateInputGraph", () => Sve(t, n));
  });
}
function kve(t, e) {
  e("    makeSpaceForEdgeLabels", () => Ove(t)), e("    removeSelfEdges", () => Hve(t)), e("    acyclic", () => dme(t)), e("    nestingGraph.run", () => zme(t)), e("    rank", () => Bme(UG(t))), e("    injectEdgeLabelProxies", () => Pve(t)), e("    removeEmptyRanks", () => vme(t)), e("    nestingGraph.cleanup", () => Ume(t)), e("    normalizeRanks", () => mme(t)), e("    assignRankMinMax", () => Bve(t)), e("    removeEdgeLabelProxies", () => Fve(t)), e("    normalize.run", () => Sme(t)), e("    parentDummyChains", () => sve(t)), e("    addBorderSegments", () => bme(t)), e("    order", () => ive(t)), e("    insertSelfEdges", () => qve(t)), e("    adjustCoordinateSystem", () => wme(t)), e("    position", () => Tve(t)), e("    positionSelfEdges", () => Wve(t)), e("    removeBorderNodes", () => Uve(t)), e("    normalize.undo", () => Ame(t)), e("    fixupEdgeLabelCoords", () => Gve(t)), e("    undoCoordinateSystem", () => Tme(t)), e("    translateGraph", () => $ve(t)), e("    assignNodeIntersects", () => zve(t)), e("    reversePoints", () => Vve(t)), e("    acyclic.undo", () => pme(t));
}
function Sve(t, e) {
  Ye(t.nodes(), function(r) {
    var n = t.node(r), i = e.node(r);
    n && (n.x = i.x, n.y = i.y, e.children(r).length && (n.width = i.width, n.height = i.height));
  }), Ye(t.edges(), function(r) {
    var n = t.edge(r), i = e.edge(r);
    n.points = i.points, Object.prototype.hasOwnProperty.call(i, "x") && (n.x = i.x, n.y = i.y);
  }), t.graph().width = e.graph().width, t.graph().height = e.graph().height;
}
var Cve = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"], Ave = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" }, _ve = ["acyclicer", "ranker", "rankdir", "align"], Lve = ["width", "height"], Rve = { width: 0, height: 0 }, Mve = ["minlen", "weight", "width", "height", "labeloffset"], Nve = {
  minlen: 1,
  weight: 1,
  width: 0,
  height: 0,
  labeloffset: 10,
  labelpos: "r"
}, Ive = ["labelpos"];
function Dve(t) {
  var e = new fa({ multigraph: !0, compound: !0 }), r = N4(t.graph());
  return e.setGraph(
    ry({}, Ave, M4(r, Cve), wy(r, _ve))
  ), Ye(t.nodes(), function(n) {
    var i = N4(t.node(n));
    e.setNode(n, S1e(M4(i, Lve), Rve)), e.setParent(n, t.parent(n));
  }), Ye(t.edges(), function(n) {
    var i = N4(t.edge(n));
    e.setEdge(
      n,
      ry({}, Nve, M4(i, Mve), wy(i, Ive))
    );
  }), e;
}
function Ove(t) {
  var e = t.graph();
  e.ranksep /= 2, Ye(t.edges(), function(r) {
    var n = t.edge(r);
    n.minlen *= 2, n.labelpos.toLowerCase() !== "c" && (e.rankdir === "TB" || e.rankdir === "BT" ? n.width += n.labeloffset : n.height += n.labeloffset);
  });
}
function Pve(t) {
  Ye(t.edges(), function(e) {
    var r = t.edge(e);
    if (r.width && r.height) {
      var n = t.node(e.v), i = t.node(e.w), a = { rank: (i.rank - n.rank) / 2 + n.rank, e };
      ef(t, "edge-proxy", a, "_ep");
    }
  });
}
function Bve(t) {
  var e = 0;
  Ye(t.nodes(), function(r) {
    var n = t.node(r);
    n.borderTop && (n.minRank = t.node(n.borderTop).rank, n.maxRank = t.node(n.borderBottom).rank, e = ku(e, n.maxRank));
  }), t.graph().maxRank = e;
}
function Fve(t) {
  Ye(t.nodes(), function(e) {
    var r = t.node(e);
    r.dummy === "edge-proxy" && (t.edge(r.e).labelRank = r.rank, t.removeNode(e));
  });
}
function $ve(t) {
  var e = Number.POSITIVE_INFINITY, r = 0, n = Number.POSITIVE_INFINITY, i = 0, a = t.graph(), s = a.marginx || 0, o = a.marginy || 0;
  function l(u) {
    var h = u.x, d = u.y, f = u.width, p = u.height;
    e = Math.min(e, h - f / 2), r = Math.max(r, h + f / 2), n = Math.min(n, d - p / 2), i = Math.max(i, d + p / 2);
  }
  Ye(t.nodes(), function(u) {
    l(t.node(u));
  }), Ye(t.edges(), function(u) {
    var h = t.edge(u);
    Object.prototype.hasOwnProperty.call(h, "x") && l(h);
  }), e -= s, n -= o, Ye(t.nodes(), function(u) {
    var h = t.node(u);
    h.x -= e, h.y -= n;
  }), Ye(t.edges(), function(u) {
    var h = t.edge(u);
    Ye(h.points, function(d) {
      d.x -= e, d.y -= n;
    }), Object.prototype.hasOwnProperty.call(h, "x") && (h.x -= e), Object.prototype.hasOwnProperty.call(h, "y") && (h.y -= n);
  }), a.width = r - e + s, a.height = i - n + o;
}
function zve(t) {
  Ye(t.edges(), function(e) {
    var r = t.edge(e), n = t.node(e.v), i = t.node(e.w), a, s;
    r.points ? (a = r.points[0], s = r.points[r.points.length - 1]) : (r.points = [], a = i, s = n), r.points.unshift(YA(n, a)), r.points.push(YA(i, s));
  });
}
function Gve(t) {
  Ye(t.edges(), function(e) {
    var r = t.edge(e);
    if (Object.prototype.hasOwnProperty.call(r, "x"))
      switch ((r.labelpos === "l" || r.labelpos === "r") && (r.width -= r.labeloffset), r.labelpos) {
        case "l":
          r.x -= r.width / 2 + r.labeloffset;
          break;
        case "r":
          r.x += r.width / 2 + r.labeloffset;
          break;
      }
  });
}
function Vve(t) {
  Ye(t.edges(), function(e) {
    var r = t.edge(e);
    r.reversed && r.points.reverse();
  });
}
function Uve(t) {
  Ye(t.nodes(), function(e) {
    if (t.children(e).length) {
      var r = t.node(e), n = t.node(r.borderTop), i = t.node(r.borderBottom), a = t.node(by(r.borderLeft)), s = t.node(by(r.borderRight));
      r.width = Math.abs(s.x - a.x), r.height = Math.abs(i.y - n.y), r.x = a.x + r.width / 2, r.y = n.y + r.height / 2;
    }
  }), Ye(t.nodes(), function(e) {
    t.node(e).dummy === "border" && t.removeNode(e);
  });
}
function Hve(t) {
  Ye(t.edges(), function(e) {
    if (e.v === e.w) {
      var r = t.node(e.v);
      r.selfEdges || (r.selfEdges = []), r.selfEdges.push({ e, label: t.edge(e) }), t.removeEdge(e);
    }
  });
}
function qve(t) {
  var e = kx(t);
  Ye(e, function(r) {
    var n = 0;
    Ye(r, function(i, a) {
      var s = t.node(i);
      s.order = a + n, Ye(s.selfEdges, function(o) {
        ef(
          t,
          "selfedge",
          {
            width: o.label.width,
            height: o.label.height,
            rank: s.rank,
            order: a + ++n,
            e: o.e,
            label: o.label
          },
          "_se"
        );
      }), delete s.selfEdges;
    });
  });
}
function Wve(t) {
  Ye(t.nodes(), function(e) {
    var r = t.node(e);
    if (r.dummy === "selfedge") {
      var n = t.node(r.e.v), i = n.x + n.width / 2, a = n.y, s = r.x - i, o = n.height / 2;
      t.setEdge(r.e, r.label), t.removeNode(e), r.label.points = [
        { x: i + 2 * s / 3, y: a - o },
        { x: i + 5 * s / 6, y: a - o },
        { x: i + s, y: a },
        { x: i + 5 * s / 6, y: a + o },
        { x: i + 2 * s / 3, y: a + o }
      ], r.label.x = r.x, r.label.y = r.y;
    }
  });
}
function M4(t, e) {
  return Ex(wy(t, e), Number);
}
function N4(t) {
  var e = {};
  return Ye(t, function(r, n) {
    e[n.toLowerCase()] = r;
  }), e;
}
function Ks(t) {
  var e = {
    options: {
      directed: t.isDirected(),
      multigraph: t.isMultigraph(),
      compound: t.isCompound()
    },
    nodes: Yve(t),
    edges: Xve(t)
  };
  return yn(t.graph()) || (e.value = MG(t.graph())), e;
}
function Yve(t) {
  return Ir(t.nodes(), function(e) {
    var r = t.node(e), n = t.parent(e), i = { v: e };
    return yn(r) || (i.value = r), yn(n) || (i.parent = n), i;
  });
}
function Xve(t) {
  return Ir(t.edges(), function(e) {
    var r = t.edge(e), n = { v: e.v, w: e.w };
    return yn(e.name) || (n.name = e.name), yn(r) || (n.value = r), n;
  });
}
var tr = /* @__PURE__ */ new Map(), su = /* @__PURE__ */ new Map(), iV = /* @__PURE__ */ new Map(), jve = /* @__PURE__ */ x(() => {
  su.clear(), iV.clear(), tr.clear();
}, "clear"), Ty = /* @__PURE__ */ x((t, e) => {
  const r = su.get(e) || [];
  return ie.trace("In isDescendant", e, " ", t, " = ", r.includes(t)), r.includes(t);
}, "isDescendant"), Kve = /* @__PURE__ */ x((t, e) => {
  const r = su.get(e) || [];
  return ie.info("Descendants of ", e, " is ", r), ie.info("Edge is ", t), t.v === e || t.w === e ? !1 : r ? r.includes(t.v) || Ty(t.v, e) || Ty(t.w, e) || r.includes(t.w) : (ie.debug("Tilt, ", e, ",not in descendants"), !1);
}, "edgeInCluster"), aV = /* @__PURE__ */ x((t, e, r, n) => {
  ie.warn(
    "Copying children of ",
    t,
    "root",
    n,
    "data",
    e.node(t),
    n
  );
  const i = e.children(t) || [];
  t !== n && i.push(t), ie.warn("Copying (nodes) clusterId", t, "nodes", i), i.forEach((a) => {
    if (e.children(a).length > 0)
      aV(a, e, r, n);
    else {
      const s = e.node(a);
      ie.info("cp ", a, " to ", n, " with parent ", t), r.setNode(a, s), n !== e.parent(a) && (ie.warn("Setting parent", a, e.parent(a)), r.setParent(a, e.parent(a))), t !== n && a !== t ? (ie.debug("Setting parent", a, t), r.setParent(a, t)) : (ie.info("In copy ", t, "root", n, "data", e.node(t), n), ie.debug(
        "Not Setting parent for node=",
        a,
        "cluster!==rootId",
        t !== n,
        "node!==clusterId",
        a !== t
      ));
      const o = e.edges(a);
      ie.debug("Copying Edges", o), o.forEach((l) => {
        ie.info("Edge", l);
        const u = e.edge(l.v, l.w, l.name);
        ie.info("Edge data", u, n);
        try {
          Kve(l, n) ? (ie.info("Copying as ", l.v, l.w, u, l.name), r.setEdge(l.v, l.w, u, l.name), ie.info("newGraph edges ", r.edges(), r.edge(r.edges()[0]))) : ie.info(
            "Skipping copy of edge ",
            l.v,
            "-->",
            l.w,
            " rootId: ",
            n,
            " clusterId:",
            t
          );
        } catch (h) {
          ie.error(h);
        }
      });
    }
    ie.debug("Removing node", a), e.removeNode(a);
  });
}, "copy"), sV = /* @__PURE__ */ x((t, e) => {
  const r = e.children(t);
  let n = [...r];
  for (const i of r)
    iV.set(i, t), n = [...n, ...sV(i, e)];
  return n;
}, "extractDescendants"), Zve = /* @__PURE__ */ x((t, e, r) => {
  const n = t.edges().filter((l) => l.v === e || l.w === e), i = t.edges().filter((l) => l.v === r || l.w === r), a = n.map((l) => ({ v: l.v === e ? r : l.v, w: l.w === e ? e : l.w })), s = i.map((l) => ({ v: l.v, w: l.w }));
  return a.filter((l) => s.some((u) => l.v === u.v && l.w === u.w));
}, "findCommonEdges"), Np = /* @__PURE__ */ x((t, e, r) => {
  const n = e.children(t);
  if (ie.trace("Searching children of id ", t, n), n.length < 1)
    return t;
  let i;
  for (const a of n) {
    const s = Np(a, e, r), o = Zve(e, r, s);
    if (s)
      if (o.length > 0)
        i = s;
      else
        return s;
  }
  return i;
}, "findNonClusterChild"), r_ = /* @__PURE__ */ x((t) => !tr.has(t) || !tr.get(t).externalConnections ? t : tr.has(t) ? tr.get(t).id : t, "getAnchorId"), Qve = /* @__PURE__ */ x((t, e) => {
  if (!t || e > 10) {
    ie.debug("Opting out, no graph ");
    return;
  } else
    ie.debug("Opting in, graph ");
  t.nodes().forEach(function(r) {
    t.children(r).length > 0 && (ie.warn(
      "Cluster identified",
      r,
      " Replacement id in edges: ",
      Np(r, t, r)
    ), su.set(r, sV(r, t)), tr.set(r, { id: Np(r, t, r), clusterData: t.node(r) }));
  }), t.nodes().forEach(function(r) {
    const n = t.children(r), i = t.edges();
    n.length > 0 ? (ie.debug("Cluster identified", r, su), i.forEach((a) => {
      const s = Ty(a.v, r), o = Ty(a.w, r);
      s ^ o && (ie.warn("Edge: ", a, " leaves cluster ", r), ie.warn("Descendants of XXX ", r, ": ", su.get(r)), tr.get(r).externalConnections = !0);
    })) : ie.debug("Not a cluster ", r, su);
  });
  for (let r of tr.keys()) {
    const n = tr.get(r).id, i = t.parent(n);
    i !== r && tr.has(i) && !tr.get(i).externalConnections && (tr.get(r).id = i);
  }
  t.edges().forEach(function(r) {
    const n = t.edge(r);
    ie.warn("Edge " + r.v + " -> " + r.w + ": " + JSON.stringify(r)), ie.warn("Edge " + r.v + " -> " + r.w + ": " + JSON.stringify(t.edge(r)));
    let i = r.v, a = r.w;
    if (ie.warn(
      "Fix XXX",
      tr,
      "ids:",
      r.v,
      r.w,
      "Translating: ",
      tr.get(r.v),
      " --- ",
      tr.get(r.w)
    ), tr.get(r.v) || tr.get(r.w)) {
      if (ie.warn("Fixing and trying - removing XXX", r.v, r.w, r.name), i = r_(r.v), a = r_(r.w), t.removeEdge(r.v, r.w, r.name), i !== r.v) {
        const s = t.parent(i);
        tr.get(s).externalConnections = !0, n.fromCluster = r.v;
      }
      if (a !== r.w) {
        const s = t.parent(a);
        tr.get(s).externalConnections = !0, n.toCluster = r.w;
      }
      ie.warn("Fix Replacing with XXX", i, a, r.name), t.setEdge(i, a, n, r.name);
    }
  }), ie.warn("Adjusted Graph", Ks(t)), oV(t, 0), ie.trace(tr);
}, "adjustClustersAndEdges"), oV = /* @__PURE__ */ x((t, e) => {
  if (ie.warn("extractor - ", e, Ks(t), t.children("D")), e > 10) {
    ie.error("Bailing out");
    return;
  }
  let r = t.nodes(), n = !1;
  for (const i of r) {
    const a = t.children(i);
    n = n || a.length > 0;
  }
  if (!n) {
    ie.debug("Done, no node has children", t.nodes());
    return;
  }
  ie.debug("Nodes = ", r, e);
  for (const i of r)
    if (ie.debug(
      "Extracting node",
      i,
      tr,
      tr.has(i) && !tr.get(i).externalConnections,
      !t.parent(i),
      t.node(i),
      t.children("D"),
      " Depth ",
      e
    ), !tr.has(i))
      ie.debug("Not a cluster", i, e);
    else if (!tr.get(i).externalConnections && t.children(i) && t.children(i).length > 0) {
      ie.warn(
        "Cluster without external connections, without a parent and with children",
        i,
        e
      );
      let s = t.graph().rankdir === "TB" ? "LR" : "TB";
      tr.get(i)?.clusterData?.dir && (s = tr.get(i).clusterData.dir, ie.warn("Fixing dir", tr.get(i).clusterData.dir, s));
      const o = new fa({
        multigraph: !0,
        compound: !0
      }).setGraph({
        rankdir: s,
        nodesep: 50,
        ranksep: 50,
        marginx: 8,
        marginy: 8
      }).setDefaultEdgeLabel(function() {
        return {};
      });
      ie.warn("Old graph before copy", Ks(t)), aV(i, t, o, i), t.setNode(i, {
        clusterNode: !0,
        id: i,
        clusterData: tr.get(i).clusterData,
        label: tr.get(i).label,
        graph: o
      }), ie.warn("New graph after copy node: (", i, ")", Ks(o)), ie.debug("Old graph after copy", Ks(t));
    } else
      ie.warn(
        "Cluster ** ",
        i,
        " **not meeting the criteria !externalConnections:",
        !tr.get(i).externalConnections,
        " no parent: ",
        !t.parent(i),
        " children ",
        t.children(i) && t.children(i).length > 0,
        t.children("D"),
        e
      ), ie.debug(tr);
  r = t.nodes(), ie.warn("New list of nodes", r);
  for (const i of r) {
    const a = t.node(i);
    ie.warn(" Now next level", i, a), a?.clusterNode && oV(a.graph, e + 1);
  }
}, "extractor"), lV = /* @__PURE__ */ x((t, e) => {
  if (e.length === 0)
    return [];
  let r = Object.assign([], e);
  return e.forEach((n) => {
    const i = t.children(n), a = lV(t, i);
    r = [...r, ...a];
  }), r;
}, "sorter"), Jve = /* @__PURE__ */ x((t) => lV(t, t.children()), "sortNodesByHierarchy"), cV = /* @__PURE__ */ x(async (t, e, r, n, i, a) => {
  ie.warn("Graph in recursive render:XAX", Ks(e), i);
  const s = e.graph().rankdir;
  ie.trace("Dir in recursive render - dir:", s);
  const o = t.insert("g").attr("class", "root");
  e.nodes() ? ie.info("Recursive render XXX", e.nodes()) : ie.info("No nodes found for", e), e.edges().length > 0 && ie.info("Recursive edges", e.edge(e.edges()[0]));
  const l = o.insert("g").attr("class", "clusters"), u = o.insert("g").attr("class", "edgePaths"), h = o.insert("g").attr("class", "edgeLabels"), d = o.insert("g").attr("class", "nodes");
  await Promise.all(
    e.nodes().map(async function(m) {
      const v = e.node(m);
      if (i !== void 0) {
        const y = JSON.parse(JSON.stringify(i.clusterData));
        ie.trace(
          `Setting data for parent cluster XXX
 Node.id = `,
          m,
          `
 data=`,
          y.height,
          `
Parent cluster`,
          i.height
        ), e.setNode(i.id, y), e.parent(m) || (ie.trace("Setting parent", m, i.id), e.setParent(m, i.id, y));
      }
      if (ie.info("(Insert) Node XXX" + m + ": " + JSON.stringify(e.node(m))), v?.clusterNode) {
        ie.info("Cluster identified XBX", m, v.width, e.node(m));
        const { ranksep: y, nodesep: b } = e.graph();
        v.graph.setGraph({
          ...v.graph.graph(),
          ranksep: y + 25,
          nodesep: b
        });
        const w = await cV(
          d,
          v.graph,
          r,
          n,
          e.node(m),
          a
        ), T = w.elem;
        Mt(v, T), v.diff = w.diff || 0, ie.info(
          "New compound node after recursive render XAX",
          m,
          "width",
          // node,
          v.width,
          "height",
          v.height
          // node.x,
          // node.y
        ), Kle(T, v);
      } else
        e.children(m).length > 0 ? (ie.trace(
          "Cluster - the non recursive path XBX",
          m,
          v.id,
          v,
          v.width,
          "Graph:",
          e
        ), ie.trace(Np(v.id, e)), tr.set(v.id, { id: Np(v.id, e), node: v })) : (ie.trace("Node - the non recursive path XAX", m, d, e.node(m), s), await lx(d, e.node(m), { config: a, dir: s }));
    })
  ), await (/* @__PURE__ */ x(async () => {
    const m = e.edges().map(async function(v) {
      const y = e.edge(v.v, v.w, v.name);
      ie.info("Edge " + v.v + " -> " + v.w + ": " + JSON.stringify(v)), ie.info("Edge " + v.v + " -> " + v.w + ": ", v, " ", JSON.stringify(e.edge(v))), ie.info(
        "Fix",
        tr,
        "ids:",
        v.v,
        v.w,
        "Translating: ",
        tr.get(v.v),
        tr.get(v.w)
      ), await g$(h, y);
    });
    await Promise.all(m);
  }, "processEdges"))(), ie.info("Graph before layout:", JSON.stringify(Ks(e))), ie.info("############################################# XXX"), ie.info("###                Layout                 ### XXX"), ie.info("############################################# XXX"), nV(e), ie.info("Graph after layout:", JSON.stringify(Ks(e)));
  let p = 0, { subGraphTitleTotalMargin: g } = dg(a);
  return await Promise.all(
    Jve(e).map(async function(m) {
      const v = e.node(m);
      if (ie.info(
        "Position XBX => " + m + ": (" + v.x,
        "," + v.y,
        ") width: ",
        v.width,
        " height: ",
        v.height
      ), v?.clusterNode)
        v.y += g, ie.info(
          "A tainted cluster node XBX1",
          m,
          v.id,
          v.width,
          v.height,
          v.x,
          v.y,
          e.parent(m)
        ), tr.get(v.id).node = v, Ww(v);
      else if (e.children(m).length > 0) {
        ie.info(
          "A pure cluster node XBX1",
          m,
          v.id,
          v.x,
          v.y,
          v.width,
          v.height,
          e.parent(m)
        ), v.height += g, e.node(v.parentId);
        const y = v?.padding / 2 || 0, b = v?.labelBBox?.height || 0, w = b - y || 0;
        ie.debug("OffsetY", w, "labelHeight", b, "halfPadding", y), await ik(l, v), tr.get(v.id).node = v;
      } else {
        const y = e.node(v.parentId);
        v.y += g / 2, ie.info(
          "A regular node XBX1 - using the padding",
          v.id,
          "parent",
          v.parentId,
          v.width,
          v.height,
          v.x,
          v.y,
          "offsetY",
          v.offsetY,
          "parent",
          y,
          y?.offsetY,
          v
        ), Ww(v);
      }
    })
  ), e.edges().forEach(function(m) {
    const v = e.edge(m);
    ie.info("Edge " + m.v + " -> " + m.w + ": " + JSON.stringify(v), v), v.points.forEach((T) => T.y += g / 2);
    const y = e.node(m.v);
    var b = e.node(m.w);
    const w = y$(u, v, tr, r, y, b, n);
    m$(v, w);
  }), e.nodes().forEach(function(m) {
    const v = e.node(m);
    ie.info(m, v.type, v.diff), v.isGroup && (p = v.diff);
  }), ie.warn("Returning from recursive render XAX", o, p), { elem: o, diff: p };
}, "recursiveRender"), eye = /* @__PURE__ */ x(async (t, e) => {
  const r = new fa({
    multigraph: !0,
    compound: !0
  }).setGraph({
    rankdir: t.direction,
    nodesep: t.config?.nodeSpacing || t.config?.flowchart?.nodeSpacing || t.nodeSpacing,
    ranksep: t.config?.rankSpacing || t.config?.flowchart?.rankSpacing || t.rankSpacing,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function() {
    return {};
  }), n = e.select("g");
  w$(n, t.markers, t.type, t.diagramId), Zle(), ece(), Nle(), jve(), t.nodes.forEach((a) => {
    r.setNode(a.id, { ...a }), a.parentId && r.setParent(a.id, a.parentId);
  }), ie.debug("Edges:", t.edges), t.edges.forEach((a) => {
    if (a.start === a.end) {
      const s = a.start, o = s + "---" + s + "---1", l = s + "---" + s + "---2", u = r.node(s);
      r.setNode(o, {
        domId: o,
        id: o,
        parentId: u.parentId,
        labelStyle: "",
        label: "",
        padding: 0,
        shape: "labelRect",
        // shape: 'rect',
        style: "",
        width: 10,
        height: 10
      }), r.setParent(o, u.parentId), r.setNode(l, {
        domId: l,
        id: l,
        parentId: u.parentId,
        labelStyle: "",
        padding: 0,
        // shape: 'rect',
        shape: "labelRect",
        label: "",
        style: "",
        width: 10,
        height: 10
      }), r.setParent(l, u.parentId);
      const h = structuredClone(a), d = structuredClone(a), f = structuredClone(a);
      h.label = "", h.arrowTypeEnd = "none", h.id = s + "-cyclic-special-1", d.arrowTypeStart = "none", d.arrowTypeEnd = "none", d.id = s + "-cyclic-special-mid", f.label = "", u.isGroup && (h.fromCluster = s, f.toCluster = s), f.id = s + "-cyclic-special-2", f.arrowTypeStart = "none", r.setEdge(s, o, h, s + "-cyclic-special-0"), r.setEdge(o, l, d, s + "-cyclic-special-1"), r.setEdge(l, s, f, s + "-cyc<lic-special-2");
    } else
      r.setEdge(a.start, a.end, { ...a }, a.id);
  }), ie.warn("Graph at first:", JSON.stringify(Ks(r))), Qve(r), ie.warn("Graph after XAX:", JSON.stringify(Ks(r)));
  const i = we();
  await cV(
    n,
    r,
    t.type,
    t.diagramId,
    void 0,
    i
  );
}, "render");
const tye = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  render: eye
}, Symbol.toStringTag, { value: "Module" }));
function dT(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
  return n;
}
function rye(t) {
  if (Array.isArray(t)) return t;
}
function nye(t) {
  if (Array.isArray(t)) return dT(t);
}
function mc(t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function iye(t, e) {
  for (var r = 0; r < e.length; r++) {
    var n = e[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, hV(n.key), n);
  }
}
function vc(t, e, r) {
  return e && iye(t.prototype, e), Object.defineProperty(t, "prototype", {
    writable: !1
  }), t;
}
function oa(t, e) {
  var r = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (!r) {
    if (Array.isArray(t) || (r = Wk(t)) || e) {
      r && (t = r);
      var n = 0, i = function() {
      };
      return {
        s: i,
        n: function() {
          return n >= t.length ? {
            done: !0
          } : {
            done: !1,
            value: t[n++]
          };
        },
        e: function(l) {
          throw l;
        },
        f: i
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var a, s = !0, o = !1;
  return {
    s: function() {
      r = r.call(t);
    },
    n: function() {
      var l = r.next();
      return s = l.done, l;
    },
    e: function(l) {
      o = !0, a = l;
    },
    f: function() {
      try {
        s || r.return == null || r.return();
      } finally {
        if (o) throw a;
      }
    }
  };
}
function uV(t, e, r) {
  return (e = hV(e)) in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t;
}
function aye(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
}
function sye(t, e) {
  var r = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (r != null) {
    var n, i, a, s, o = [], l = !0, u = !1;
    try {
      if (a = (r = r.call(t)).next, e === 0) {
        if (Object(r) !== r) return;
        l = !1;
      } else for (; !(l = (n = a.call(r)).done) && (o.push(n.value), o.length !== e); l = !0) ;
    } catch (h) {
      u = !0, i = h;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw i;
      }
    }
    return o;
  }
}
function oye() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function lye() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function En(t, e) {
  return rye(t) || sye(t, e) || Wk(t, e) || oye();
}
function Ey(t) {
  return nye(t) || aye(t) || Wk(t) || lye();
}
function cye(t, e) {
  if (typeof t != "object" || !t) return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
function hV(t) {
  var e = cye(t, "string");
  return typeof e == "symbol" ? e : e + "";
}
function zn(t) {
  "@babel/helpers - typeof";
  return zn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, zn(t);
}
function Wk(t, e) {
  if (t) {
    if (typeof t == "string") return dT(t, e);
    var r = {}.toString.call(t).slice(8, -1);
    return r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set" ? Array.from(t) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? dT(t, e) : void 0;
  }
}
var Dn = typeof window > "u" ? null : window, n_ = Dn ? Dn.navigator : null;
Dn && Dn.document;
var uye = zn(""), dV = zn({}), hye = zn(function() {
}), dye = typeof HTMLElement > "u" ? "undefined" : zn(HTMLElement), Tg = function(e) {
  return e && e.instanceString && an(e.instanceString) ? e.instanceString() : null;
}, Bt = function(e) {
  return e != null && zn(e) == uye;
}, an = function(e) {
  return e != null && zn(e) === hye;
}, Or = function(e) {
  return !ka(e) && (Array.isArray ? Array.isArray(e) : e != null && e instanceof Array);
}, mr = function(e) {
  return e != null && zn(e) === dV && !Or(e) && e.constructor === Object;
}, fye = function(e) {
  return e != null && zn(e) === dV;
}, mt = function(e) {
  return e != null && zn(e) === zn(1) && !isNaN(e);
}, pye = function(e) {
  return mt(e) && Math.floor(e) === e;
}, ky = function(e) {
  if (dye !== "undefined")
    return e != null && e instanceof HTMLElement;
}, ka = function(e) {
  return Eg(e) || fV(e);
}, Eg = function(e) {
  return Tg(e) === "collection" && e._private.single;
}, fV = function(e) {
  return Tg(e) === "collection" && !e._private.single;
}, Yk = function(e) {
  return Tg(e) === "core";
}, pV = function(e) {
  return Tg(e) === "stylesheet";
}, gye = function(e) {
  return Tg(e) === "event";
}, Zl = function(e) {
  return e == null ? !0 : !!(e === "" || e.match(/^\s+$/));
}, mye = function(e) {
  return typeof HTMLElement > "u" ? !1 : e instanceof HTMLElement;
}, vye = function(e) {
  return mr(e) && mt(e.x1) && mt(e.x2) && mt(e.y1) && mt(e.y2);
}, yye = function(e) {
  return fye(e) && an(e.then);
}, xye = function() {
  return n_ && n_.userAgent.match(/msie|trident|edge/i);
}, Ld = function(e, r) {
  r || (r = function() {
    if (arguments.length === 1)
      return arguments[0];
    if (arguments.length === 0)
      return "undefined";
    for (var a = [], s = 0; s < arguments.length; s++)
      a.push(arguments[s]);
    return a.join("$");
  });
  var n = function() {
    var a = this, s = arguments, o, l = r.apply(a, s), u = n.cache;
    return (o = u[l]) || (o = u[l] = e.apply(a, s)), o;
  };
  return n.cache = {}, n;
}, Xk = Ld(function(t) {
  return t.replace(/([A-Z])/g, function(e) {
    return "-" + e.toLowerCase();
  });
}), Sx = Ld(function(t) {
  return t.replace(/(-\w)/g, function(e) {
    return e[1].toUpperCase();
  });
}), gV = Ld(function(t, e) {
  return t + e[0].toUpperCase() + e.substring(1);
}, function(t, e) {
  return t + "$" + e;
}), i_ = function(e) {
  return Zl(e) ? e : e.charAt(0).toUpperCase() + e.substring(1);
}, Il = function(e, r) {
  return e.slice(-1 * r.length) === r;
}, Fn = "(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))", bye = "rgb[a]?\\((" + Fn + "[%]?)\\s*,\\s*(" + Fn + "[%]?)\\s*,\\s*(" + Fn + "[%]?)(?:\\s*,\\s*(" + Fn + "))?\\)", wye = "rgb[a]?\\((?:" + Fn + "[%]?)\\s*,\\s*(?:" + Fn + "[%]?)\\s*,\\s*(?:" + Fn + "[%]?)(?:\\s*,\\s*(?:" + Fn + "))?\\)", Tye = "hsl[a]?\\((" + Fn + ")\\s*,\\s*(" + Fn + "[%])\\s*,\\s*(" + Fn + "[%])(?:\\s*,\\s*(" + Fn + "))?\\)", Eye = "hsl[a]?\\((?:" + Fn + ")\\s*,\\s*(?:" + Fn + "[%])\\s*,\\s*(?:" + Fn + "[%])(?:\\s*,\\s*(?:" + Fn + "))?\\)", kye = "\\#[0-9a-fA-F]{3}", Sye = "\\#[0-9a-fA-F]{6}", mV = function(e, r) {
  return e < r ? -1 : e > r ? 1 : 0;
}, Cye = function(e, r) {
  return -1 * mV(e, r);
}, Gt = Object.assign != null ? Object.assign.bind(Object) : function(t) {
  for (var e = arguments, r = 1; r < e.length; r++) {
    var n = e[r];
    if (n != null)
      for (var i = Object.keys(n), a = 0; a < i.length; a++) {
        var s = i[a];
        t[s] = n[s];
      }
  }
  return t;
}, Aye = function(e) {
  if (!(!(e.length === 4 || e.length === 7) || e[0] !== "#")) {
    var r = e.length === 4, n, i, a, s = 16;
    return r ? (n = parseInt(e[1] + e[1], s), i = parseInt(e[2] + e[2], s), a = parseInt(e[3] + e[3], s)) : (n = parseInt(e[1] + e[2], s), i = parseInt(e[3] + e[4], s), a = parseInt(e[5] + e[6], s)), [n, i, a];
  }
}, _ye = function(e) {
  var r, n, i, a, s, o, l, u;
  function h(g, m, v) {
    return v < 0 && (v += 1), v > 1 && (v -= 1), v < 1 / 6 ? g + (m - g) * 6 * v : v < 1 / 2 ? m : v < 2 / 3 ? g + (m - g) * (2 / 3 - v) * 6 : g;
  }
  var d = new RegExp("^" + Tye + "$").exec(e);
  if (d) {
    if (n = parseInt(d[1]), n < 0 ? n = (360 - -1 * n % 360) % 360 : n > 360 && (n = n % 360), n /= 360, i = parseFloat(d[2]), i < 0 || i > 100 || (i = i / 100, a = parseFloat(d[3]), a < 0 || a > 100) || (a = a / 100, s = d[4], s !== void 0 && (s = parseFloat(s), s < 0 || s > 1)))
      return;
    if (i === 0)
      o = l = u = Math.round(a * 255);
    else {
      var f = a < 0.5 ? a * (1 + i) : a + i - a * i, p = 2 * a - f;
      o = Math.round(255 * h(p, f, n + 1 / 3)), l = Math.round(255 * h(p, f, n)), u = Math.round(255 * h(p, f, n - 1 / 3));
    }
    r = [o, l, u, s];
  }
  return r;
}, Lye = function(e) {
  var r, n = new RegExp("^" + bye + "$").exec(e);
  if (n) {
    r = [];
    for (var i = [], a = 1; a <= 3; a++) {
      var s = n[a];
      if (s[s.length - 1] === "%" && (i[a] = !0), s = parseFloat(s), i[a] && (s = s / 100 * 255), s < 0 || s > 255)
        return;
      r.push(Math.floor(s));
    }
    var o = i[1] || i[2] || i[3], l = i[1] && i[2] && i[3];
    if (o && !l)
      return;
    var u = n[4];
    if (u !== void 0) {
      if (u = parseFloat(u), u < 0 || u > 1)
        return;
      r.push(u);
    }
  }
  return r;
}, Rye = function(e) {
  return Mye[e.toLowerCase()];
}, vV = function(e) {
  return (Or(e) ? e : null) || Rye(e) || Aye(e) || Lye(e) || _ye(e);
}, Mye = {
  // special colour names
  transparent: [0, 0, 0, 0],
  // NB alpha === 0
  // regular colours
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  grey: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
}, yV = function(e) {
  for (var r = e.map, n = e.keys, i = n.length, a = 0; a < i; a++) {
    var s = n[a];
    if (mr(s))
      throw Error("Tried to set map with object key");
    a < n.length - 1 ? (r[s] == null && (r[s] = {}), r = r[s]) : r[s] = e.value;
  }
}, xV = function(e) {
  for (var r = e.map, n = e.keys, i = n.length, a = 0; a < i; a++) {
    var s = n[a];
    if (mr(s))
      throw Error("Tried to get map with object key");
    if (r = r[s], r == null)
      return r;
  }
  return r;
}, C1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function kg(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var I4, a_;
function Sg() {
  if (a_) return I4;
  a_ = 1;
  function t(e) {
    var r = typeof e;
    return e != null && (r == "object" || r == "function");
  }
  return I4 = t, I4;
}
var D4, s_;
function Nye() {
  if (s_) return D4;
  s_ = 1;
  var t = typeof C1 == "object" && C1 && C1.Object === Object && C1;
  return D4 = t, D4;
}
var O4, o_;
function Cx() {
  if (o_) return O4;
  o_ = 1;
  var t = Nye(), e = typeof self == "object" && self && self.Object === Object && self, r = t || e || Function("return this")();
  return O4 = r, O4;
}
var P4, l_;
function Iye() {
  if (l_) return P4;
  l_ = 1;
  var t = Cx(), e = function() {
    return t.Date.now();
  };
  return P4 = e, P4;
}
var B4, c_;
function Dye() {
  if (c_) return B4;
  c_ = 1;
  var t = /\s/;
  function e(r) {
    for (var n = r.length; n-- && t.test(r.charAt(n)); )
      ;
    return n;
  }
  return B4 = e, B4;
}
var F4, u_;
function Oye() {
  if (u_) return F4;
  u_ = 1;
  var t = Dye(), e = /^\s+/;
  function r(n) {
    return n && n.slice(0, t(n) + 1).replace(e, "");
  }
  return F4 = r, F4;
}
var $4, h_;
function jk() {
  if (h_) return $4;
  h_ = 1;
  var t = Cx(), e = t.Symbol;
  return $4 = e, $4;
}
var z4, d_;
function Pye() {
  if (d_) return z4;
  d_ = 1;
  var t = jk(), e = Object.prototype, r = e.hasOwnProperty, n = e.toString, i = t ? t.toStringTag : void 0;
  function a(s) {
    var o = r.call(s, i), l = s[i];
    try {
      s[i] = void 0;
      var u = !0;
    } catch {
    }
    var h = n.call(s);
    return u && (o ? s[i] = l : delete s[i]), h;
  }
  return z4 = a, z4;
}
var G4, f_;
function Bye() {
  if (f_) return G4;
  f_ = 1;
  var t = Object.prototype, e = t.toString;
  function r(n) {
    return e.call(n);
  }
  return G4 = r, G4;
}
var V4, p_;
function bV() {
  if (p_) return V4;
  p_ = 1;
  var t = jk(), e = Pye(), r = Bye(), n = "[object Null]", i = "[object Undefined]", a = t ? t.toStringTag : void 0;
  function s(o) {
    return o == null ? o === void 0 ? i : n : a && a in Object(o) ? e(o) : r(o);
  }
  return V4 = s, V4;
}
var U4, g_;
function Fye() {
  if (g_) return U4;
  g_ = 1;
  function t(e) {
    return e != null && typeof e == "object";
  }
  return U4 = t, U4;
}
var H4, m_;
function Cg() {
  if (m_) return H4;
  m_ = 1;
  var t = bV(), e = Fye(), r = "[object Symbol]";
  function n(i) {
    return typeof i == "symbol" || e(i) && t(i) == r;
  }
  return H4 = n, H4;
}
var q4, v_;
function $ye() {
  if (v_) return q4;
  v_ = 1;
  var t = Oye(), e = Sg(), r = Cg(), n = NaN, i = /^[-+]0x[0-9a-f]+$/i, a = /^0b[01]+$/i, s = /^0o[0-7]+$/i, o = parseInt;
  function l(u) {
    if (typeof u == "number")
      return u;
    if (r(u))
      return n;
    if (e(u)) {
      var h = typeof u.valueOf == "function" ? u.valueOf() : u;
      u = e(h) ? h + "" : h;
    }
    if (typeof u != "string")
      return u === 0 ? u : +u;
    u = t(u);
    var d = a.test(u);
    return d || s.test(u) ? o(u.slice(2), d ? 2 : 8) : i.test(u) ? n : +u;
  }
  return q4 = l, q4;
}
var W4, y_;
function zye() {
  if (y_) return W4;
  y_ = 1;
  var t = Sg(), e = Iye(), r = $ye(), n = "Expected a function", i = Math.max, a = Math.min;
  function s(o, l, u) {
    var h, d, f, p, g, m, v = 0, y = !1, b = !1, w = !0;
    if (typeof o != "function")
      throw new TypeError(n);
    l = r(l) || 0, t(u) && (y = !!u.leading, b = "maxWait" in u, f = b ? i(r(u.maxWait) || 0, l) : f, w = "trailing" in u ? !!u.trailing : w);
    function T(P) {
      var S = h, M = d;
      return h = d = void 0, v = P, p = o.apply(M, S), p;
    }
    function E(P) {
      return v = P, g = setTimeout(C, l), y ? T(P) : p;
    }
    function L(P) {
      var S = P - m, M = P - v, N = l - S;
      return b ? a(N, f - M) : N;
    }
    function k(P) {
      var S = P - m, M = P - v;
      return m === void 0 || S >= l || S < 0 || b && M >= f;
    }
    function C() {
      var P = e();
      if (k(P))
        return A(P);
      g = setTimeout(C, L(P));
    }
    function A(P) {
      return g = void 0, w && h ? T(P) : (h = d = void 0, p);
    }
    function R() {
      g !== void 0 && clearTimeout(g), v = 0, h = m = d = g = void 0;
    }
    function _() {
      return g === void 0 ? p : A(e());
    }
    function O() {
      var P = e(), S = k(P);
      if (h = arguments, d = this, m = P, S) {
        if (g === void 0)
          return E(m);
        if (b)
          return clearTimeout(g), g = setTimeout(C, l), T(m);
      }
      return g === void 0 && (g = setTimeout(C, l)), p;
    }
    return O.cancel = R, O.flush = _, O;
  }
  return W4 = s, W4;
}
var Gye = zye(), Ag = /* @__PURE__ */ kg(Gye), Y4 = Dn ? Dn.performance : null, wV = Y4 && Y4.now ? function() {
  return Y4.now();
} : function() {
  return Date.now();
}, Vye = (function() {
  if (Dn) {
    if (Dn.requestAnimationFrame)
      return function(t) {
        Dn.requestAnimationFrame(t);
      };
    if (Dn.mozRequestAnimationFrame)
      return function(t) {
        Dn.mozRequestAnimationFrame(t);
      };
    if (Dn.webkitRequestAnimationFrame)
      return function(t) {
        Dn.webkitRequestAnimationFrame(t);
      };
    if (Dn.msRequestAnimationFrame)
      return function(t) {
        Dn.msRequestAnimationFrame(t);
      };
  }
  return function(t) {
    t && setTimeout(function() {
      t(wV());
    }, 1e3 / 60);
  };
})(), Sy = function(e) {
  return Vye(e);
}, nl = wV, Kc = 9261, TV = 65599, Nh = 5381, EV = function(e) {
  for (var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Kc, n = r, i; i = e.next(), !i.done; )
    n = n * TV + i.value | 0;
  return n;
}, Ip = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Kc;
  return r * TV + e | 0;
}, Dp = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Nh;
  return (r << 5) + r + e | 0;
}, Uye = function(e, r) {
  return e * 2097152 + r;
}, Tl = function(e) {
  return e[0] * 2097152 + e[1];
}, A1 = function(e, r) {
  return [Ip(e[0], r[0]), Dp(e[1], r[1])];
}, x_ = function(e, r) {
  var n = {
    value: 0,
    done: !1
  }, i = 0, a = e.length, s = {
    next: function() {
      return i < a ? n.value = e[i++] : n.done = !0, n;
    }
  };
  return EV(s, r);
}, Cu = function(e, r) {
  var n = {
    value: 0,
    done: !1
  }, i = 0, a = e.length, s = {
    next: function() {
      return i < a ? n.value = e.charCodeAt(i++) : n.done = !0, n;
    }
  };
  return EV(s, r);
}, kV = function() {
  return Hye(arguments);
}, Hye = function(e) {
  for (var r, n = 0; n < e.length; n++) {
    var i = e[n];
    n === 0 ? r = Cu(i) : r = Cu(i, r);
  }
  return r;
};
function qye(t, e, r, n, i) {
  var a = i * Math.PI / 180, s = Math.cos(a) * (t - r) - Math.sin(a) * (e - n) + r, o = Math.sin(a) * (t - r) + Math.cos(a) * (e - n) + n;
  return {
    x: s,
    y: o
  };
}
var Wye = function(e, r, n, i, a, s) {
  return {
    x: (e - n) * a + n,
    y: (r - i) * s + i
  };
};
function Yye(t, e, r) {
  if (r === 0) return t;
  var n = (e.x1 + e.x2) / 2, i = (e.y1 + e.y2) / 2, a = e.w / e.h, s = 1 / a, o = qye(t.x, t.y, n, i, r), l = Wye(o.x, o.y, n, i, a, s);
  return {
    x: l.x,
    y: l.y
  };
}
var b_ = !0, Xye = console.warn != null, jye = console.trace != null, Kk = Number.MAX_SAFE_INTEGER || 9007199254740991, SV = function() {
  return !0;
}, Cy = function() {
  return !1;
}, w_ = function() {
  return 0;
}, Zk = function() {
}, Zr = function(e) {
  throw new Error(e);
}, CV = function(e) {
  if (e !== void 0)
    b_ = !!e;
  else
    return b_;
}, Lr = function(e) {
  CV() && (Xye ? console.warn(e) : (console.log(e), jye && console.trace()));
}, Kye = function(e) {
  return Gt({}, e);
}, Zs = function(e) {
  return e == null ? e : Or(e) ? e.slice() : mr(e) ? Kye(e) : e;
}, Zye = function(e) {
  return e.slice();
}, AV = function(e, r) {
  for (
    // loop :)
    r = e = "";
    // b - result , a - numeric letiable
    e++ < 36;
    //
    r += e * 51 & 52 ? (
      //  return a random number or 4
      (e ^ 15 ? (
        // generate a random number from 0 to 15
        8 ^ Math.random() * (e ^ 20 ? 16 : 4)
      ) : 4).toString(16)
    ) : "-"
  ) ;
  return r;
}, Qye = {}, _V = function() {
  return Qye;
}, fi = function(e) {
  var r = Object.keys(e);
  return function(n) {
    for (var i = {}, a = 0; a < r.length; a++) {
      var s = r[a], o = n?.[s];
      i[s] = o === void 0 ? e[s] : o;
    }
    return i;
  };
}, Ql = function(e, r, n) {
  for (var i = e.length - 1; i >= 0; i--)
    e[i] === r && e.splice(i, 1);
}, Qk = function(e) {
  e.splice(0, e.length);
}, Jye = function(e, r) {
  for (var n = 0; n < r.length; n++) {
    var i = r[n];
    e.push(i);
  }
}, na = function(e, r, n) {
  return n && (r = gV(n, r)), e[r];
}, Do = function(e, r, n, i) {
  n && (r = gV(n, r)), e[r] = i;
}, e2e = /* @__PURE__ */ (function() {
  function t() {
    mc(this, t), this._obj = {};
  }
  return vc(t, [{
    key: "set",
    value: function(r, n) {
      return this._obj[r] = n, this;
    }
  }, {
    key: "delete",
    value: function(r) {
      return this._obj[r] = void 0, this;
    }
  }, {
    key: "clear",
    value: function() {
      this._obj = {};
    }
  }, {
    key: "has",
    value: function(r) {
      return this._obj[r] !== void 0;
    }
  }, {
    key: "get",
    value: function(r) {
      return this._obj[r];
    }
  }]);
})(), Go = typeof Map < "u" ? Map : e2e, t2e = "undefined", r2e = /* @__PURE__ */ (function() {
  function t(e) {
    if (mc(this, t), this._obj = /* @__PURE__ */ Object.create(null), this.size = 0, e != null) {
      var r;
      e.instanceString != null && e.instanceString() === this.instanceString() ? r = e.toArray() : r = e;
      for (var n = 0; n < r.length; n++)
        this.add(r[n]);
    }
  }
  return vc(t, [{
    key: "instanceString",
    value: function() {
      return "set";
    }
  }, {
    key: "add",
    value: function(r) {
      var n = this._obj;
      n[r] !== 1 && (n[r] = 1, this.size++);
    }
  }, {
    key: "delete",
    value: function(r) {
      var n = this._obj;
      n[r] === 1 && (n[r] = 0, this.size--);
    }
  }, {
    key: "clear",
    value: function() {
      this._obj = /* @__PURE__ */ Object.create(null);
    }
  }, {
    key: "has",
    value: function(r) {
      return this._obj[r] === 1;
    }
  }, {
    key: "toArray",
    value: function() {
      var r = this;
      return Object.keys(this._obj).filter(function(n) {
        return r.has(n);
      });
    }
  }, {
    key: "forEach",
    value: function(r, n) {
      return this.toArray().forEach(r, n);
    }
  }]);
})(), tf = (typeof Set > "u" ? "undefined" : zn(Set)) !== t2e ? Set : r2e, Ax = function(e, r) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  if (e === void 0 || r === void 0 || !Yk(e)) {
    Zr("An element must have a core reference and parameters set");
    return;
  }
  var i = r.group;
  if (i == null && (r.data && r.data.source != null && r.data.target != null ? i = "edges" : i = "nodes"), i !== "nodes" && i !== "edges") {
    Zr("An element must be of type `nodes` or `edges`; you specified `" + i + "`");
    return;
  }
  this.length = 1, this[0] = this;
  var a = this._private = {
    cy: e,
    single: !0,
    // indicates this is an element
    data: r.data || {},
    // data object
    position: r.position || {
      x: 0,
      y: 0
    },
    // (x, y) position pair
    autoWidth: void 0,
    // width and height of nodes calculated by the renderer when set to special 'auto' value
    autoHeight: void 0,
    autoPadding: void 0,
    compoundBoundsClean: !1,
    // whether the compound dimensions need to be recalculated the next time dimensions are read
    listeners: [],
    // array of bound listeners
    group: i,
    // string; 'nodes' or 'edges'
    style: {},
    // properties as set by the style
    rstyle: {},
    // properties for style sent from the renderer to the core
    styleCxts: [],
    // applied style contexts from the styler
    styleKeys: {},
    // per-group keys of style property values
    removed: !0,
    // whether it's inside the vis; true if removed (set true here since we call restore)
    selected: !!r.selected,
    // whether it's selected
    selectable: r.selectable === void 0 ? !0 : !!r.selectable,
    // whether it's selectable
    locked: !!r.locked,
    // whether the element is locked (cannot be moved)
    grabbed: !1,
    // whether the element is grabbed by the mouse; renderer sets this privately
    grabbable: r.grabbable === void 0 ? !0 : !!r.grabbable,
    // whether the element can be grabbed
    pannable: r.pannable === void 0 ? i === "edges" : !!r.pannable,
    // whether the element has passthrough panning enabled
    active: !1,
    // whether the element is active from user interaction
    classes: new tf(),
    // map ( className => true )
    animation: {
      // object for currently-running animations
      current: [],
      queue: []
    },
    rscratch: {},
    // object in which the renderer can store information
    scratch: r.scratch || {},
    // scratch objects
    edges: [],
    // array of connected edges
    children: [],
    // array of children
    parent: r.parent && r.parent.isNode() ? r.parent : null,
    // parent ref
    traversalCache: {},
    // cache of output of traversal functions
    backgrounding: !1,
    // whether background images are loading
    bbCache: null,
    // cache of the current bounding box
    bbCacheShift: {
      x: 0,
      y: 0
    },
    // shift applied to cached bb to be applied on next get
    bodyBounds: null,
    // bounds cache of element body, w/o overlay
    overlayBounds: null,
    // bounds cache of element body, including overlay
    labelBounds: {
      // bounds cache of labels
      all: null,
      source: null,
      target: null,
      main: null
    },
    arrowBounds: {
      // bounds cache of edge arrows
      source: null,
      target: null,
      "mid-source": null,
      "mid-target": null
    }
  };
  if (a.position.x == null && (a.position.x = 0), a.position.y == null && (a.position.y = 0), r.renderedPosition) {
    var s = r.renderedPosition, o = e.pan(), l = e.zoom();
    a.position = {
      x: (s.x - o.x) / l,
      y: (s.y - o.y) / l
    };
  }
  var u = [];
  Or(r.classes) ? u = r.classes : Bt(r.classes) && (u = r.classes.split(/\s+/));
  for (var h = 0, d = u.length; h < d; h++) {
    var f = u[h];
    !f || f === "" || a.classes.add(f);
  }
  this.createEmitter(), (n === void 0 || n) && this.restore();
  var p = r.style || r.css;
  p && (Lr("Setting a `style` bypass at element creation should be done only when absolutely necessary.  Try to use the stylesheet instead."), this.style(p));
}, T_ = function(e) {
  return e = {
    bfs: e.bfs || !e.dfs,
    dfs: e.dfs || !e.bfs
  }, function(n, i, a) {
    var s;
    mr(n) && !ka(n) && (s = n, n = s.roots || s.root, i = s.visit, a = s.directed), a = arguments.length === 2 && !an(i) ? i : a, i = an(i) ? i : function() {
    };
    for (var o = this._private.cy, l = n = Bt(n) ? this.filter(n) : n, u = [], h = [], d = {}, f = {}, p = {}, g = 0, m, v = this.byGroup(), y = v.nodes, b = v.edges, w = 0; w < l.length; w++) {
      var T = l[w], E = T.id();
      T.isNode() && (u.unshift(T), e.bfs && (p[E] = !0, h.push(T)), f[E] = 0);
    }
    for (var L = function() {
      var P = e.bfs ? u.shift() : u.pop(), S = P.id();
      if (e.dfs) {
        if (p[S])
          return 0;
        p[S] = !0, h.push(P);
      }
      var M = f[S], N = d[S], D = N != null ? N.source() : null, I = N != null ? N.target() : null, B = N == null ? void 0 : P.same(D) ? I[0] : D[0], z;
      if (z = i(P, N, B, g++, M), z === !0)
        return m = P, 1;
      if (z === !1)
        return 1;
      for (var F = P.connectedEdges().filter(function(ae) {
        return (!a || ae.source().same(P)) && b.has(ae);
      }), V = 0; V < F.length; V++) {
        var H = F[V], J = H.connectedNodes().filter(function(ae) {
          return !ae.same(P) && y.has(ae);
        }), q = J.id();
        J.length !== 0 && !p[q] && (J = J[0], u.push(J), e.bfs && (p[q] = !0, h.push(J)), d[q] = H, f[q] = f[S] + 1);
      }
    }, k; u.length !== 0 && (k = L(), !(k !== 0 && k === 1)); )
      ;
    for (var C = o.collection(), A = 0; A < h.length; A++) {
      var R = h[A], _ = d[R.id()];
      _ != null && C.push(_), C.push(R);
    }
    return {
      path: o.collection(C),
      found: o.collection(m)
    };
  };
}, Op = {
  breadthFirstSearch: T_({
    bfs: !0
  }),
  depthFirstSearch: T_({
    dfs: !0
  })
};
Op.bfs = Op.breadthFirstSearch;
Op.dfs = Op.depthFirstSearch;
var Dm = { exports: {} }, n2e = Dm.exports, E_;
function i2e() {
  return E_ || (E_ = 1, (function(t, e) {
    (function() {
      var r, n, i, a, s, o, l, u, h, d, f, p, g, m, v;
      i = Math.floor, d = Math.min, n = function(y, b) {
        return y < b ? -1 : y > b ? 1 : 0;
      }, h = function(y, b, w, T, E) {
        var L;
        if (w == null && (w = 0), E == null && (E = n), w < 0)
          throw new Error("lo must be non-negative");
        for (T == null && (T = y.length); w < T; )
          L = i((w + T) / 2), E(b, y[L]) < 0 ? T = L : w = L + 1;
        return [].splice.apply(y, [w, w - w].concat(b)), b;
      }, o = function(y, b, w) {
        return w == null && (w = n), y.push(b), m(y, 0, y.length - 1, w);
      }, s = function(y, b) {
        var w, T;
        return b == null && (b = n), w = y.pop(), y.length ? (T = y[0], y[0] = w, v(y, 0, b)) : T = w, T;
      }, u = function(y, b, w) {
        var T;
        return w == null && (w = n), T = y[0], y[0] = b, v(y, 0, w), T;
      }, l = function(y, b, w) {
        var T;
        return w == null && (w = n), y.length && w(y[0], b) < 0 && (T = [y[0], b], b = T[0], y[0] = T[1], v(y, 0, w)), b;
      }, a = function(y, b) {
        var w, T, E, L, k, C;
        for (b == null && (b = n), L = (function() {
          C = [];
          for (var A = 0, R = i(y.length / 2); 0 <= R ? A < R : A > R; 0 <= R ? A++ : A--)
            C.push(A);
          return C;
        }).apply(this).reverse(), k = [], T = 0, E = L.length; T < E; T++)
          w = L[T], k.push(v(y, w, b));
        return k;
      }, g = function(y, b, w) {
        var T;
        if (w == null && (w = n), T = y.indexOf(b), T !== -1)
          return m(y, 0, T, w), v(y, T, w);
      }, f = function(y, b, w) {
        var T, E, L, k, C;
        if (w == null && (w = n), E = y.slice(0, b), !E.length)
          return E;
        for (a(E, w), C = y.slice(b), L = 0, k = C.length; L < k; L++)
          T = C[L], l(E, T, w);
        return E.sort(w).reverse();
      }, p = function(y, b, w) {
        var T, E, L, k, C, A, R, _, O;
        if (w == null && (w = n), b * 10 <= y.length) {
          if (L = y.slice(0, b).sort(w), !L.length)
            return L;
          for (E = L[L.length - 1], R = y.slice(b), k = 0, A = R.length; k < A; k++)
            T = R[k], w(T, E) < 0 && (h(L, T, 0, null, w), L.pop(), E = L[L.length - 1]);
          return L;
        }
        for (a(y, w), O = [], C = 0, _ = d(b, y.length); 0 <= _ ? C < _ : C > _; 0 <= _ ? ++C : --C)
          O.push(s(y, w));
        return O;
      }, m = function(y, b, w, T) {
        var E, L, k;
        for (T == null && (T = n), E = y[w]; w > b; ) {
          if (k = w - 1 >> 1, L = y[k], T(E, L) < 0) {
            y[w] = L, w = k;
            continue;
          }
          break;
        }
        return y[w] = E;
      }, v = function(y, b, w) {
        var T, E, L, k, C;
        for (w == null && (w = n), E = y.length, C = b, L = y[b], T = 2 * b + 1; T < E; )
          k = T + 1, k < E && !(w(y[T], y[k]) < 0) && (T = k), y[b] = y[T], b = T, T = 2 * b + 1;
        return y[b] = L, m(y, C, b, w);
      }, r = (function() {
        y.push = o, y.pop = s, y.replace = u, y.pushpop = l, y.heapify = a, y.updateItem = g, y.nlargest = f, y.nsmallest = p;
        function y(b) {
          this.cmp = b ?? n, this.nodes = [];
        }
        return y.prototype.push = function(b) {
          return o(this.nodes, b, this.cmp);
        }, y.prototype.pop = function() {
          return s(this.nodes, this.cmp);
        }, y.prototype.peek = function() {
          return this.nodes[0];
        }, y.prototype.contains = function(b) {
          return this.nodes.indexOf(b) !== -1;
        }, y.prototype.replace = function(b) {
          return u(this.nodes, b, this.cmp);
        }, y.prototype.pushpop = function(b) {
          return l(this.nodes, b, this.cmp);
        }, y.prototype.heapify = function() {
          return a(this.nodes, this.cmp);
        }, y.prototype.updateItem = function(b) {
          return g(this.nodes, b, this.cmp);
        }, y.prototype.clear = function() {
          return this.nodes = [];
        }, y.prototype.empty = function() {
          return this.nodes.length === 0;
        }, y.prototype.size = function() {
          return this.nodes.length;
        }, y.prototype.clone = function() {
          var b;
          return b = new y(), b.nodes = this.nodes.slice(0), b;
        }, y.prototype.toArray = function() {
          return this.nodes.slice(0);
        }, y.prototype.insert = y.prototype.push, y.prototype.top = y.prototype.peek, y.prototype.front = y.prototype.peek, y.prototype.has = y.prototype.contains, y.prototype.copy = y.prototype.clone, y;
      })(), (function(y, b) {
        return t.exports = b();
      })(this, function() {
        return r;
      });
    }).call(n2e);
  })(Dm)), Dm.exports;
}
var X4, k_;
function a2e() {
  return k_ || (k_ = 1, X4 = i2e()), X4;
}
var s2e = a2e(), _g = /* @__PURE__ */ kg(s2e), o2e = fi({
  root: null,
  weight: function(e) {
    return 1;
  },
  directed: !1
}), l2e = {
  dijkstra: function(e) {
    if (!mr(e)) {
      var r = arguments;
      e = {
        root: r[0],
        weight: r[1],
        directed: r[2]
      };
    }
    var n = o2e(e), i = n.root, a = n.weight, s = n.directed, o = this, l = a, u = Bt(i) ? this.filter(i)[0] : i[0], h = {}, d = {}, f = {}, p = this.byGroup(), g = p.nodes, m = p.edges;
    m.unmergeBy(function(M) {
      return M.isLoop();
    });
    for (var v = function(N) {
      return h[N.id()];
    }, y = function(N, D) {
      h[N.id()] = D, b.updateItem(N);
    }, b = new _g(function(M, N) {
      return v(M) - v(N);
    }), w = 0; w < g.length; w++) {
      var T = g[w];
      h[T.id()] = T.same(u) ? 0 : 1 / 0, b.push(T);
    }
    for (var E = function(N, D) {
      for (var I = (s ? N.edgesTo(D) : N.edgesWith(D)).intersect(m), B = 1 / 0, z, F = 0; F < I.length; F++) {
        var V = I[F], H = l(V);
        (H < B || !z) && (B = H, z = V);
      }
      return {
        edge: z,
        dist: B
      };
    }; b.size() > 0; ) {
      var L = b.pop(), k = v(L), C = L.id();
      if (f[C] = k, k !== 1 / 0)
        for (var A = L.neighborhood().intersect(g), R = 0; R < A.length; R++) {
          var _ = A[R], O = _.id(), P = E(L, _), S = k + P.dist;
          S < v(_) && (y(_, S), d[O] = {
            node: L,
            edge: P.edge
          });
        }
    }
    return {
      distanceTo: function(N) {
        var D = Bt(N) ? g.filter(N)[0] : N[0];
        return f[D.id()];
      },
      pathTo: function(N) {
        var D = Bt(N) ? g.filter(N)[0] : N[0], I = [], B = D, z = B.id();
        if (D.length > 0)
          for (I.unshift(D); d[z]; ) {
            var F = d[z];
            I.unshift(F.edge), I.unshift(F.node), B = F.node, z = B.id();
          }
        return o.spawn(I);
      }
    };
  }
}, c2e = {
  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
  // implemented from pseudocode from wikipedia
  kruskal: function(e) {
    e = e || function(w) {
      return 1;
    };
    for (var r = this.byGroup(), n = r.nodes, i = r.edges, a = n.length, s = new Array(a), o = n, l = function(T) {
      for (var E = 0; E < s.length; E++) {
        var L = s[E];
        if (L.has(T))
          return E;
      }
    }, u = 0; u < a; u++)
      s[u] = this.spawn(n[u]);
    for (var h = i.sort(function(w, T) {
      return e(w) - e(T);
    }), d = 0; d < h.length; d++) {
      var f = h[d], p = f.source()[0], g = f.target()[0], m = l(p), v = l(g), y = s[m], b = s[v];
      m !== v && (o.merge(f), y.merge(b), s.splice(v, 1));
    }
    return o;
  }
}, u2e = fi({
  root: null,
  goal: null,
  weight: function(e) {
    return 1;
  },
  heuristic: function(e) {
    return 0;
  },
  directed: !1
}), h2e = {
  // Implemented from pseudocode from wikipedia
  aStar: function(e) {
    var r = this.cy(), n = u2e(e), i = n.root, a = n.goal, s = n.heuristic, o = n.directed, l = n.weight;
    i = r.collection(i)[0], a = r.collection(a)[0];
    var u = i.id(), h = a.id(), d = {}, f = {}, p = {}, g = new _g(function(z, F) {
      return f[z.id()] - f[F.id()];
    }), m = new tf(), v = {}, y = {}, b = function(F, V) {
      g.push(F), m.add(V);
    }, w, T, E = function() {
      w = g.pop(), T = w.id(), m.delete(T);
    }, L = function(F) {
      return m.has(F);
    };
    b(i, u), d[u] = 0, f[u] = s(i);
    for (var k = 0; g.size() > 0; ) {
      if (E(), k++, T === h) {
        for (var C = [], A = a, R = h, _ = y[R]; C.unshift(A), _ != null && C.unshift(_), A = v[R], A != null; )
          R = A.id(), _ = y[R];
        return {
          found: !0,
          distance: d[T],
          path: this.spawn(C),
          steps: k
        };
      }
      p[T] = !0;
      for (var O = w._private.edges, P = 0; P < O.length; P++) {
        var S = O[P];
        if (this.hasElementWithId(S.id()) && !(o && S.data("source") !== T)) {
          var M = S.source(), N = S.target(), D = M.id() !== T ? M : N, I = D.id();
          if (this.hasElementWithId(I) && !p[I]) {
            var B = d[T] + l(S);
            if (!L(I)) {
              d[I] = B, f[I] = B + s(D), b(D, I), v[I] = w, y[I] = S;
              continue;
            }
            B < d[I] && (d[I] = B, f[I] = B + s(D), v[I] = w, y[I] = S);
          }
        }
      }
    }
    return {
      found: !1,
      distance: void 0,
      path: void 0,
      steps: k
    };
  }
}, d2e = fi({
  weight: function(e) {
    return 1;
  },
  directed: !1
}), f2e = {
  // Implemented from pseudocode from wikipedia
  floydWarshall: function(e) {
    for (var r = this.cy(), n = d2e(e), i = n.weight, a = n.directed, s = i, o = this.byGroup(), l = o.nodes, u = o.edges, h = l.length, d = h * h, f = function(H) {
      return l.indexOf(H);
    }, p = function(H) {
      return l[H];
    }, g = new Array(d), m = 0; m < d; m++) {
      var v = m % h, y = (m - v) / h;
      y === v ? g[m] = 0 : g[m] = 1 / 0;
    }
    for (var b = new Array(d), w = new Array(d), T = 0; T < u.length; T++) {
      var E = u[T], L = E.source()[0], k = E.target()[0];
      if (L !== k) {
        var C = f(L), A = f(k), R = C * h + A, _ = s(E);
        if (g[R] > _ && (g[R] = _, b[R] = A, w[R] = E), !a) {
          var O = A * h + C;
          !a && g[O] > _ && (g[O] = _, b[O] = C, w[O] = E);
        }
      }
    }
    for (var P = 0; P < h; P++)
      for (var S = 0; S < h; S++)
        for (var M = S * h + P, N = 0; N < h; N++) {
          var D = S * h + N, I = P * h + N;
          g[M] + g[I] < g[D] && (g[D] = g[M] + g[I], b[D] = b[M]);
        }
    var B = function(H) {
      return (Bt(H) ? r.filter(H) : H)[0];
    }, z = function(H) {
      return f(B(H));
    }, F = {
      distance: function(H, J) {
        var q = z(H), ae = z(J);
        return g[q * h + ae];
      },
      path: function(H, J) {
        var q = z(H), ae = z(J), re = p(q);
        if (q === ae)
          return re.collection();
        if (b[q * h + ae] == null)
          return r.collection();
        var pe = r.collection(), K = q, Z;
        for (pe.merge(re); q !== ae; )
          K = q, q = b[q * h + ae], Z = w[K * h + q], pe.merge(Z), pe.merge(p(q));
        return pe;
      }
    };
    return F;
  }
  // floydWarshall
}, p2e = fi({
  weight: function(e) {
    return 1;
  },
  directed: !1,
  root: null
}), g2e = {
  // Implemented from pseudocode from wikipedia
  bellmanFord: function(e) {
    var r = this, n = p2e(e), i = n.weight, a = n.directed, s = n.root, o = i, l = this, u = this.cy(), h = this.byGroup(), d = h.edges, f = h.nodes, p = f.length, g = new Go(), m = !1, v = [];
    s = u.collection(s)[0], d.unmergeBy(function(Ae) {
      return Ae.isLoop();
    });
    for (var y = d.length, b = function(W) {
      var De = g.get(W.id());
      return De || (De = {}, g.set(W.id(), De)), De;
    }, w = function(W) {
      return (Bt(W) ? u.$(W) : W)[0];
    }, T = function(W) {
      return b(w(W)).dist;
    }, E = function(W) {
      for (var De = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s, ue = w(W), ze = [], Ge = ue; ; ) {
        if (Ge == null)
          return r.spawn();
        var Ve = b(Ge), ke = Ve.edge, Oe = Ve.pred;
        if (ze.unshift(Ge[0]), Ge.same(De) && ze.length > 0)
          break;
        ke != null && ze.unshift(ke), Ge = Oe;
      }
      return l.spawn(ze);
    }, L = 0; L < p; L++) {
      var k = f[L], C = b(k);
      k.same(s) ? C.dist = 0 : C.dist = 1 / 0, C.pred = null, C.edge = null;
    }
    for (var A = !1, R = function(W, De, ue, ze, Ge, Ve) {
      var ke = ze.dist + Ve;
      ke < Ge.dist && !ue.same(ze.edge) && (Ge.dist = ke, Ge.pred = W, Ge.edge = ue, A = !0);
    }, _ = 1; _ < p; _++) {
      A = !1;
      for (var O = 0; O < y; O++) {
        var P = d[O], S = P.source(), M = P.target(), N = o(P), D = b(S), I = b(M);
        R(S, M, P, D, I, N), a || R(M, S, P, I, D, N);
      }
      if (!A)
        break;
    }
    if (A)
      for (var B = [], z = 0; z < y; z++) {
        var F = d[z], V = F.source(), H = F.target(), J = o(F), q = b(V).dist, ae = b(H).dist;
        if (q + J < ae || !a && ae + J < q)
          if (m || (Lr("Graph contains a negative weight cycle for Bellman-Ford"), m = !0), e.findNegativeWeightCycles !== !1) {
            var re = [];
            q + J < ae && re.push(V), !a && ae + J < q && re.push(H);
            for (var pe = re.length, K = 0; K < pe; K++) {
              var Z = re[K], X = [Z];
              X.push(b(Z).edge);
              for (var Y = b(Z).pred; X.indexOf(Y) === -1; )
                X.push(Y), X.push(b(Y).edge), Y = b(Y).pred;
              X = X.slice(X.indexOf(Y));
              for (var ee = X[0].id(), j = 0, fe = 2; fe < X.length; fe += 2)
                X[fe].id() < ee && (ee = X[fe].id(), j = fe);
              X = X.slice(j).concat(X.slice(0, j)), X.push(X[0]);
              var te = X.map(function(Ae) {
                return Ae.id();
              }).join(",");
              B.indexOf(te) === -1 && (v.push(l.spawn(X)), B.push(te));
            }
          } else
            break;
      }
    return {
      distanceTo: T,
      pathTo: E,
      hasNegativeWeightCycle: m,
      negativeWeightCycles: v
    };
  }
  // bellmanFord
}, m2e = Math.sqrt(2), v2e = function(e, r, n) {
  n.length === 0 && Zr("Karger-Stein must be run on a connected (sub)graph");
  for (var i = n[e], a = i[1], s = i[2], o = r[a], l = r[s], u = n, h = u.length - 1; h >= 0; h--) {
    var d = u[h], f = d[1], p = d[2];
    (r[f] === o && r[p] === l || r[f] === l && r[p] === o) && u.splice(h, 1);
  }
  for (var g = 0; g < u.length; g++) {
    var m = u[g];
    m[1] === l ? (u[g] = m.slice(), u[g][1] = o) : m[2] === l && (u[g] = m.slice(), u[g][2] = o);
  }
  for (var v = 0; v < r.length; v++)
    r[v] === l && (r[v] = o);
  return u;
}, j4 = function(e, r, n, i) {
  for (; n > i; ) {
    var a = Math.floor(Math.random() * r.length);
    r = v2e(a, e, r), n--;
  }
  return r;
}, y2e = {
  // Computes the minimum cut of an undirected graph
  // Returns the correct answer with high probability
  kargerStein: function() {
    var e = this, r = this.byGroup(), n = r.nodes, i = r.edges;
    i.unmergeBy(function(I) {
      return I.isLoop();
    });
    var a = n.length, s = i.length, o = Math.ceil(Math.pow(Math.log(a) / Math.LN2, 2)), l = Math.floor(a / m2e);
    if (a < 2) {
      Zr("At least 2 nodes are required for Karger-Stein algorithm");
      return;
    }
    for (var u = [], h = 0; h < s; h++) {
      var d = i[h];
      u.push([h, n.indexOf(d.source()), n.indexOf(d.target())]);
    }
    for (var f = 1 / 0, p = [], g = new Array(a), m = new Array(a), v = new Array(a), y = function(B, z) {
      for (var F = 0; F < a; F++)
        z[F] = B[F];
    }, b = 0; b <= o; b++) {
      for (var w = 0; w < a; w++)
        m[w] = w;
      var T = j4(m, u.slice(), a, l), E = T.slice();
      y(m, v);
      var L = j4(m, T, l, 2), k = j4(v, E, l, 2);
      L.length <= k.length && L.length < f ? (f = L.length, p = L, y(m, g)) : k.length <= L.length && k.length < f && (f = k.length, p = k, y(v, g));
    }
    for (var C = this.spawn(p.map(function(I) {
      return i[I[0]];
    })), A = this.spawn(), R = this.spawn(), _ = g[0], O = 0; O < g.length; O++) {
      var P = g[O], S = n[O];
      P === _ ? A.merge(S) : R.merge(S);
    }
    var M = function(B) {
      var z = e.spawn();
      return B.forEach(function(F) {
        z.merge(F), F.connectedEdges().forEach(function(V) {
          e.contains(V) && !C.contains(V) && z.merge(V);
        });
      }), z;
    }, N = [M(A), M(R)], D = {
      cut: C,
      components: N,
      // n.b. partitions are included to be compatible with the old api spec
      // (could be removed in a future major version)
      partition1: A,
      partition2: R
    };
    return D;
  }
}, K4, x2e = function(e) {
  return {
    x: e.x,
    y: e.y
  };
}, _x = function(e, r, n) {
  return {
    x: e.x * r + n.x,
    y: e.y * r + n.y
  };
}, LV = function(e, r, n) {
  return {
    x: (e.x - n.x) / r,
    y: (e.y - n.y) / r
  };
}, Gh = function(e) {
  return {
    x: e[0],
    y: e[1]
  };
}, b2e = function(e) {
  for (var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.length, i = 1 / 0, a = r; a < n; a++) {
    var s = e[a];
    isFinite(s) && (i = Math.min(s, i));
  }
  return i;
}, w2e = function(e) {
  for (var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.length, i = -1 / 0, a = r; a < n; a++) {
    var s = e[a];
    isFinite(s) && (i = Math.max(s, i));
  }
  return i;
}, T2e = function(e) {
  for (var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.length, i = 0, a = 0, s = r; s < n; s++) {
    var o = e[s];
    isFinite(o) && (i += o, a++);
  }
  return i / a;
}, E2e = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.length, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !0;
  i ? e = e.slice(r, n) : (n < e.length && e.splice(n, e.length - n), r > 0 && e.splice(0, r));
  for (var o = 0, l = e.length - 1; l >= 0; l--) {
    var u = e[l];
    s ? isFinite(u) || (e[l] = -1 / 0, o++) : e.splice(l, 1);
  }
  a && e.sort(function(f, p) {
    return f - p;
  });
  var h = e.length, d = Math.floor(h / 2);
  return h % 2 !== 0 ? e[d + 1 + o] : (e[d - 1 + o] + e[d + o]) / 2;
}, k2e = function(e) {
  return Math.PI * e / 180;
}, _1 = function(e, r) {
  return Math.atan2(r, e) - Math.PI / 2;
}, Jk = Math.log2 || function(t) {
  return Math.log(t) / Math.log(2);
}, eS = function(e) {
  return e > 0 ? 1 : e < 0 ? -1 : 0;
}, Au = function(e, r) {
  return Math.sqrt(Wc(e, r));
}, Wc = function(e, r) {
  var n = r.x - e.x, i = r.y - e.y;
  return n * n + i * i;
}, S2e = function(e) {
  for (var r = e.length, n = 0, i = 0; i < r; i++)
    n += e[i];
  for (var a = 0; a < r; a++)
    e[a] = e[a] / n;
  return e;
}, Yn = function(e, r, n, i) {
  return (1 - i) * (1 - i) * e + 2 * (1 - i) * i * r + i * i * n;
}, td = function(e, r, n, i) {
  return {
    x: Yn(e.x, r.x, n.x, i),
    y: Yn(e.y, r.y, n.y, i)
  };
}, C2e = function(e, r, n, i) {
  var a = {
    x: r.x - e.x,
    y: r.y - e.y
  }, s = Au(e, r), o = {
    x: a.x / s,
    y: a.y / s
  };
  return n = n ?? 0, i = i ?? n * s, {
    x: e.x + o.x * i,
    y: e.y + o.y * i
  };
}, Pp = function(e, r, n) {
  return Math.max(e, Math.min(n, r));
}, qi = function(e) {
  if (e == null)
    return {
      x1: 1 / 0,
      y1: 1 / 0,
      x2: -1 / 0,
      y2: -1 / 0,
      w: 0,
      h: 0
    };
  if (e.x1 != null && e.y1 != null) {
    if (e.x2 != null && e.y2 != null && e.x2 >= e.x1 && e.y2 >= e.y1)
      return {
        x1: e.x1,
        y1: e.y1,
        x2: e.x2,
        y2: e.y2,
        w: e.x2 - e.x1,
        h: e.y2 - e.y1
      };
    if (e.w != null && e.h != null && e.w >= 0 && e.h >= 0)
      return {
        x1: e.x1,
        y1: e.y1,
        x2: e.x1 + e.w,
        y2: e.y1 + e.h,
        w: e.w,
        h: e.h
      };
  }
}, A2e = function(e) {
  return {
    x1: e.x1,
    x2: e.x2,
    w: e.w,
    y1: e.y1,
    y2: e.y2,
    h: e.h
  };
}, _2e = function(e) {
  e.x1 = 1 / 0, e.y1 = 1 / 0, e.x2 = -1 / 0, e.y2 = -1 / 0, e.w = 0, e.h = 0;
}, L2e = function(e, r) {
  e.x1 = Math.min(e.x1, r.x1), e.x2 = Math.max(e.x2, r.x2), e.w = e.x2 - e.x1, e.y1 = Math.min(e.y1, r.y1), e.y2 = Math.max(e.y2, r.y2), e.h = e.y2 - e.y1;
}, RV = function(e, r, n) {
  e.x1 = Math.min(e.x1, r), e.x2 = Math.max(e.x2, r), e.w = e.x2 - e.x1, e.y1 = Math.min(e.y1, n), e.y2 = Math.max(e.y2, n), e.h = e.y2 - e.y1;
}, Om = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return e.x1 -= r, e.x2 += r, e.y1 -= r, e.y2 += r, e.w = e.x2 - e.x1, e.h = e.y2 - e.y1, e;
}, Pm = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0], n, i, a, s;
  if (r.length === 1)
    n = i = a = s = r[0];
  else if (r.length === 2)
    n = a = r[0], s = i = r[1];
  else if (r.length === 4) {
    var o = En(r, 4);
    n = o[0], i = o[1], a = o[2], s = o[3];
  }
  return e.x1 -= s, e.x2 += i, e.y1 -= n, e.y2 += a, e.w = e.x2 - e.x1, e.h = e.y2 - e.y1, e;
}, S_ = function(e, r) {
  e.x1 = r.x1, e.y1 = r.y1, e.x2 = r.x2, e.y2 = r.y2, e.w = e.x2 - e.x1, e.h = e.y2 - e.y1;
}, tS = function(e, r) {
  return !(e.x1 > r.x2 || r.x1 > e.x2 || e.x2 < r.x1 || r.x2 < e.x1 || e.y2 < r.y1 || r.y2 < e.y1 || e.y1 > r.y2 || r.y1 > e.y2);
}, Dl = function(e, r, n) {
  return e.x1 <= r && r <= e.x2 && e.y1 <= n && n <= e.y2;
}, C_ = function(e, r) {
  return Dl(e, r.x, r.y);
}, MV = function(e, r) {
  return Dl(e, r.x1, r.y1) && Dl(e, r.x2, r.y2);
}, R2e = (K4 = Math.hypot) !== null && K4 !== void 0 ? K4 : function(t, e) {
  return Math.sqrt(t * t + e * e);
};
function M2e(t, e) {
  if (t.length < 3)
    throw new Error("Need at least 3 vertices");
  var r = function(C, A) {
    return {
      x: C.x + A.x,
      y: C.y + A.y
    };
  }, n = function(C, A) {
    return {
      x: C.x - A.x,
      y: C.y - A.y
    };
  }, i = function(C, A) {
    return {
      x: C.x * A,
      y: C.y * A
    };
  }, a = function(C, A) {
    return C.x * A.y - C.y * A.x;
  }, s = function(C) {
    var A = R2e(C.x, C.y);
    return A === 0 ? {
      x: 0,
      y: 0
    } : {
      x: C.x / A,
      y: C.y / A
    };
  }, o = function(C) {
    for (var A = 0, R = 0; R < C.length; R++) {
      var _ = C[R], O = C[(R + 1) % C.length];
      A += _.x * O.y - O.x * _.y;
    }
    return A / 2;
  }, l = function(C, A, R, _) {
    var O = n(A, C), P = n(_, R), S = a(O, P);
    if (Math.abs(S) < 1e-9)
      return r(C, i(O, 0.5));
    var M = a(n(R, C), P) / S;
    return r(C, i(O, M));
  }, u = t.map(function(k) {
    return {
      x: k.x,
      y: k.y
    };
  });
  o(u) < 0 && u.reverse();
  for (var h = u.length, d = [], f = 0; f < h; f++) {
    var p = u[f], g = u[(f + 1) % h], m = n(g, p), v = s({
      x: m.y,
      y: -m.x
    });
    d.push(v);
  }
  for (var y = d.map(function(k, C) {
    var A = r(u[C], i(k, e)), R = r(u[(C + 1) % h], i(k, e));
    return {
      p1: A,
      p2: R
    };
  }), b = [], w = 0; w < h; w++) {
    var T = y[(w - 1 + h) % h], E = y[w], L = l(T.p1, T.p2, E.p1, E.p2);
    b.push(L);
  }
  return b;
}
function N2e(t, e, r, n, i, a) {
  var s = G2e(t, e, r, n, i), o = M2e(s, a), l = qi();
  return o.forEach(function(u) {
    return RV(l, u.x, u.y);
  }), l;
}
var NV = function(e, r, n, i, a, s, o) {
  var l = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : "auto", u = l === "auto" ? Jl(a, s) : l, h = a / 2, d = s / 2;
  u = Math.min(u, h, d);
  var f = u !== h, p = u !== d, g;
  if (f) {
    var m = n - h + u - o, v = i - d - o, y = n + h - u + o, b = v;
    if (g = Ol(e, r, n, i, m, v, y, b, !1), g.length > 0)
      return g;
  }
  if (p) {
    var w = n + h + o, T = i - d + u - o, E = w, L = i + d - u + o;
    if (g = Ol(e, r, n, i, w, T, E, L, !1), g.length > 0)
      return g;
  }
  if (f) {
    var k = n - h + u - o, C = i + d + o, A = n + h - u + o, R = C;
    if (g = Ol(e, r, n, i, k, C, A, R, !1), g.length > 0)
      return g;
  }
  if (p) {
    var _ = n - h - o, O = i - d + u - o, P = _, S = i + d - u + o;
    if (g = Ol(e, r, n, i, _, O, P, S, !1), g.length > 0)
      return g;
  }
  var M;
  {
    var N = n - h + u, D = i - d + u;
    if (M = e0(e, r, n, i, N, D, u + o), M.length > 0 && M[0] <= N && M[1] <= D)
      return [M[0], M[1]];
  }
  {
    var I = n + h - u, B = i - d + u;
    if (M = e0(e, r, n, i, I, B, u + o), M.length > 0 && M[0] >= I && M[1] <= B)
      return [M[0], M[1]];
  }
  {
    var z = n + h - u, F = i + d - u;
    if (M = e0(e, r, n, i, z, F, u + o), M.length > 0 && M[0] >= z && M[1] >= F)
      return [M[0], M[1]];
  }
  {
    var V = n - h + u, H = i + d - u;
    if (M = e0(e, r, n, i, V, H, u + o), M.length > 0 && M[0] <= V && M[1] >= H)
      return [M[0], M[1]];
  }
  return [];
}, I2e = function(e, r, n, i, a, s, o) {
  var l = o, u = Math.min(n, a), h = Math.max(n, a), d = Math.min(i, s), f = Math.max(i, s);
  return u - l <= e && e <= h + l && d - l <= r && r <= f + l;
}, D2e = function(e, r, n, i, a, s, o, l, u) {
  var h = {
    x1: Math.min(n, o, a) - u,
    x2: Math.max(n, o, a) + u,
    y1: Math.min(i, l, s) - u,
    y2: Math.max(i, l, s) + u
  };
  return !(e < h.x1 || e > h.x2 || r < h.y1 || r > h.y2);
}, O2e = function(e, r, n, i) {
  n -= i;
  var a = r * r - 4 * e * n;
  if (a < 0)
    return [];
  var s = Math.sqrt(a), o = 2 * e, l = (-r + s) / o, u = (-r - s) / o;
  return [l, u];
}, P2e = function(e, r, n, i, a) {
  var s = 1e-5;
  e === 0 && (e = s), r /= e, n /= e, i /= e;
  var o, l, u, h, d, f, p, g;
  if (l = (3 * n - r * r) / 9, u = -(27 * i) + r * (9 * n - 2 * (r * r)), u /= 54, o = l * l * l + u * u, a[1] = 0, p = r / 3, o > 0) {
    d = u + Math.sqrt(o), d = d < 0 ? -Math.pow(-d, 1 / 3) : Math.pow(d, 1 / 3), f = u - Math.sqrt(o), f = f < 0 ? -Math.pow(-f, 1 / 3) : Math.pow(f, 1 / 3), a[0] = -p + d + f, p += (d + f) / 2, a[4] = a[2] = -p, p = Math.sqrt(3) * (-f + d) / 2, a[3] = p, a[5] = -p;
    return;
  }
  if (a[5] = a[3] = 0, o === 0) {
    g = u < 0 ? -Math.pow(-u, 1 / 3) : Math.pow(u, 1 / 3), a[0] = -p + 2 * g, a[4] = a[2] = -(g + p);
    return;
  }
  l = -l, h = l * l * l, h = Math.acos(u / Math.sqrt(h)), g = 2 * Math.sqrt(l), a[0] = -p + g * Math.cos(h / 3), a[2] = -p + g * Math.cos((h + 2 * Math.PI) / 3), a[4] = -p + g * Math.cos((h + 4 * Math.PI) / 3);
}, B2e = function(e, r, n, i, a, s, o, l) {
  var u = 1 * n * n - 4 * n * a + 2 * n * o + 4 * a * a - 4 * a * o + o * o + i * i - 4 * i * s + 2 * i * l + 4 * s * s - 4 * s * l + l * l, h = 9 * n * a - 3 * n * n - 3 * n * o - 6 * a * a + 3 * a * o + 9 * i * s - 3 * i * i - 3 * i * l - 6 * s * s + 3 * s * l, d = 3 * n * n - 6 * n * a + n * o - n * e + 2 * a * a + 2 * a * e - o * e + 3 * i * i - 6 * i * s + i * l - i * r + 2 * s * s + 2 * s * r - l * r, f = 1 * n * a - n * n + n * e - a * e + i * s - i * i + i * r - s * r, p = [];
  P2e(u, h, d, f, p);
  for (var g = 1e-7, m = [], v = 0; v < 6; v += 2)
    Math.abs(p[v + 1]) < g && p[v] >= 0 && p[v] <= 1 && m.push(p[v]);
  m.push(1), m.push(0);
  for (var y = -1, b, w, T, E = 0; E < m.length; E++)
    b = Math.pow(1 - m[E], 2) * n + 2 * (1 - m[E]) * m[E] * a + m[E] * m[E] * o, w = Math.pow(1 - m[E], 2) * i + 2 * (1 - m[E]) * m[E] * s + m[E] * m[E] * l, T = Math.pow(b - e, 2) + Math.pow(w - r, 2), y >= 0 ? T < y && (y = T) : y = T;
  return y;
}, F2e = function(e, r, n, i, a, s) {
  var o = [e - n, r - i], l = [a - n, s - i], u = l[0] * l[0] + l[1] * l[1], h = o[0] * o[0] + o[1] * o[1], d = o[0] * l[0] + o[1] * l[1], f = d * d / u;
  return d < 0 ? h : f > u ? (e - a) * (e - a) + (r - s) * (r - s) : h - f;
}, ia = function(e, r, n) {
  for (var i, a, s, o, l, u = 0, h = 0; h < n.length / 2; h++)
    if (i = n[h * 2], a = n[h * 2 + 1], h + 1 < n.length / 2 ? (s = n[(h + 1) * 2], o = n[(h + 1) * 2 + 1]) : (s = n[(h + 1 - n.length / 2) * 2], o = n[(h + 1 - n.length / 2) * 2 + 1]), !(i == e && s == e)) if (i >= e && e >= s || i <= e && e <= s)
      l = (e - i) / (s - i) * (o - a) + a, l > r && u++;
    else
      continue;
  return u % 2 !== 0;
}, il = function(e, r, n, i, a, s, o, l, u) {
  var h = new Array(n.length), d;
  l[0] != null ? (d = Math.atan(l[1] / l[0]), l[0] < 0 ? d = d + Math.PI / 2 : d = -d - Math.PI / 2) : d = l;
  for (var f = Math.cos(-d), p = Math.sin(-d), g = 0; g < h.length / 2; g++)
    h[g * 2] = s / 2 * (n[g * 2] * f - n[g * 2 + 1] * p), h[g * 2 + 1] = o / 2 * (n[g * 2 + 1] * f + n[g * 2] * p), h[g * 2] += i, h[g * 2 + 1] += a;
  var m;
  if (u > 0) {
    var v = _y(h, -u);
    m = Ay(v);
  } else
    m = h;
  return ia(e, r, m);
}, $2e = function(e, r, n, i, a, s, o, l) {
  for (var u = new Array(n.length * 2), h = 0; h < l.length; h++) {
    var d = l[h];
    u[h * 4 + 0] = d.startX, u[h * 4 + 1] = d.startY, u[h * 4 + 2] = d.stopX, u[h * 4 + 3] = d.stopY;
    var f = Math.pow(d.cx - e, 2) + Math.pow(d.cy - r, 2);
    if (f <= Math.pow(d.radius, 2))
      return !0;
  }
  return ia(e, r, u);
}, Ay = function(e) {
  for (var r = new Array(e.length / 2), n, i, a, s, o, l, u, h, d = 0; d < e.length / 4; d++) {
    n = e[d * 4], i = e[d * 4 + 1], a = e[d * 4 + 2], s = e[d * 4 + 3], d < e.length / 4 - 1 ? (o = e[(d + 1) * 4], l = e[(d + 1) * 4 + 1], u = e[(d + 1) * 4 + 2], h = e[(d + 1) * 4 + 3]) : (o = e[0], l = e[1], u = e[2], h = e[3]);
    var f = Ol(n, i, a, s, o, l, u, h, !0);
    r[d * 2] = f[0], r[d * 2 + 1] = f[1];
  }
  return r;
}, _y = function(e, r) {
  for (var n = new Array(e.length * 2), i, a, s, o, l = 0; l < e.length / 2; l++) {
    i = e[l * 2], a = e[l * 2 + 1], l < e.length / 2 - 1 ? (s = e[(l + 1) * 2], o = e[(l + 1) * 2 + 1]) : (s = e[0], o = e[1]);
    var u = o - a, h = -(s - i), d = Math.sqrt(u * u + h * h), f = u / d, p = h / d;
    n[l * 4] = i + f * r, n[l * 4 + 1] = a + p * r, n[l * 4 + 2] = s + f * r, n[l * 4 + 3] = o + p * r;
  }
  return n;
}, z2e = function(e, r, n, i, a, s) {
  var o = n - e, l = i - r;
  o /= a, l /= s;
  var u = Math.sqrt(o * o + l * l), h = u - 1;
  if (h < 0)
    return [];
  var d = h / u;
  return [(n - e) * d + e, (i - r) * d + r];
}, ou = function(e, r, n, i, a, s, o) {
  return e -= a, r -= s, e /= n / 2 + o, r /= i / 2 + o, e * e + r * r <= 1;
}, e0 = function(e, r, n, i, a, s, o) {
  var l = [n - e, i - r], u = [e - a, r - s], h = l[0] * l[0] + l[1] * l[1], d = 2 * (u[0] * l[0] + u[1] * l[1]), f = u[0] * u[0] + u[1] * u[1] - o * o, p = d * d - 4 * h * f;
  if (p < 0)
    return [];
  var g = (-d + Math.sqrt(p)) / (2 * h), m = (-d - Math.sqrt(p)) / (2 * h), v = Math.min(g, m), y = Math.max(g, m), b = [];
  if (v >= 0 && v <= 1 && b.push(v), y >= 0 && y <= 1 && b.push(y), b.length === 0)
    return [];
  var w = b[0] * l[0] + e, T = b[0] * l[1] + r;
  if (b.length > 1) {
    if (b[0] == b[1])
      return [w, T];
    var E = b[1] * l[0] + e, L = b[1] * l[1] + r;
    return [w, T, E, L];
  } else
    return [w, T];
}, Z4 = function(e, r, n) {
  return r <= e && e <= n || n <= e && e <= r ? e : e <= r && r <= n || n <= r && r <= e ? r : n;
}, Ol = function(e, r, n, i, a, s, o, l, u) {
  var h = e - a, d = n - e, f = o - a, p = r - s, g = i - r, m = l - s, v = f * p - m * h, y = d * p - g * h, b = m * d - f * g;
  if (b !== 0) {
    var w = v / b, T = y / b, E = 1e-3, L = 0 - E, k = 1 + E;
    return L <= w && w <= k && L <= T && T <= k ? [e + w * d, r + w * g] : u ? [e + w * d, r + w * g] : [];
  } else
    return v === 0 || y === 0 ? Z4(e, n, o) === o ? [o, l] : Z4(e, n, a) === a ? [a, s] : Z4(a, o, n) === n ? [n, i] : [] : [];
}, G2e = function(e, r, n, i, a) {
  var s = [], o = i / 2, l = a / 2, u = r, h = n;
  s.push({
    x: u + o * e[0],
    y: h + l * e[1]
  });
  for (var d = 1; d < e.length / 2; d++)
    s.push({
      x: u + o * e[d * 2],
      y: h + l * e[d * 2 + 1]
    });
  return s;
}, Bp = function(e, r, n, i, a, s, o, l) {
  var u = [], h, d = new Array(n.length), f = !0;
  s == null && (f = !1);
  var p;
  if (f) {
    for (var g = 0; g < d.length / 2; g++)
      d[g * 2] = n[g * 2] * s + i, d[g * 2 + 1] = n[g * 2 + 1] * o + a;
    if (l > 0) {
      var m = _y(d, -l);
      p = Ay(m);
    } else
      p = d;
  } else
    p = n;
  for (var v, y, b, w, T = 0; T < p.length / 2; T++)
    v = p[T * 2], y = p[T * 2 + 1], T < p.length / 2 - 1 ? (b = p[(T + 1) * 2], w = p[(T + 1) * 2 + 1]) : (b = p[0], w = p[1]), h = Ol(e, r, i, a, v, y, b, w), h.length !== 0 && u.push(h[0], h[1]);
  return u;
}, V2e = function(e, r, n, i, a, s, o, l, u) {
  var h = [], d, f = new Array(n.length * 2);
  u.forEach(function(b, w) {
    w === 0 ? (f[f.length - 2] = b.startX, f[f.length - 1] = b.startY) : (f[w * 4 - 2] = b.startX, f[w * 4 - 1] = b.startY), f[w * 4] = b.stopX, f[w * 4 + 1] = b.stopY, d = e0(e, r, i, a, b.cx, b.cy, b.radius), d.length !== 0 && h.push(d[0], d[1]);
  });
  for (var p = 0; p < f.length / 4; p++)
    d = Ol(e, r, i, a, f[p * 4], f[p * 4 + 1], f[p * 4 + 2], f[p * 4 + 3], !1), d.length !== 0 && h.push(d[0], d[1]);
  if (h.length > 2) {
    for (var g = [h[0], h[1]], m = Math.pow(g[0] - e, 2) + Math.pow(g[1] - r, 2), v = 1; v < h.length / 2; v++) {
      var y = Math.pow(h[v * 2] - e, 2) + Math.pow(h[v * 2 + 1] - r, 2);
      y <= m && (g[0] = h[v * 2], g[1] = h[v * 2 + 1], m = y);
    }
    return g;
  }
  return h;
}, L1 = function(e, r, n) {
  var i = [e[0] - r[0], e[1] - r[1]], a = Math.sqrt(i[0] * i[0] + i[1] * i[1]), s = (a - n) / a;
  return s < 0 && (s = 1e-5), [r[0] + s * i[0], r[1] + s * i[1]];
}, Di = function(e, r) {
  var n = fT(e, r);
  return n = IV(n), n;
}, IV = function(e) {
  for (var r, n, i = e.length / 2, a = 1 / 0, s = 1 / 0, o = -1 / 0, l = -1 / 0, u = 0; u < i; u++)
    r = e[2 * u], n = e[2 * u + 1], a = Math.min(a, r), o = Math.max(o, r), s = Math.min(s, n), l = Math.max(l, n);
  for (var h = 2 / (o - a), d = 2 / (l - s), f = 0; f < i; f++)
    r = e[2 * f] = e[2 * f] * h, n = e[2 * f + 1] = e[2 * f + 1] * d, a = Math.min(a, r), o = Math.max(o, r), s = Math.min(s, n), l = Math.max(l, n);
  if (s < -1)
    for (var p = 0; p < i; p++)
      n = e[2 * p + 1] = e[2 * p + 1] + (-1 - s);
  return e;
}, fT = function(e, r) {
  var n = 1 / e * 2 * Math.PI, i = e % 2 === 0 ? Math.PI / 2 + n / 2 : Math.PI / 2;
  i += r;
  for (var a = new Array(e * 2), s, o = 0; o < e; o++)
    s = o * n + i, a[2 * o] = Math.cos(s), a[2 * o + 1] = Math.sin(-s);
  return a;
}, Jl = function(e, r) {
  return Math.min(e / 4, r / 4, 8);
}, DV = function(e, r) {
  return Math.min(e / 10, r / 10, 8);
}, rS = function() {
  return 8;
}, U2e = function(e, r, n) {
  return [e - 2 * r + n, 2 * (r - e), e];
}, pT = function(e, r) {
  return {
    heightOffset: Math.min(15, 0.05 * r),
    widthOffset: Math.min(100, 0.25 * e),
    ctrlPtOffsetPct: 0.05
  };
};
function Q4(t, e) {
  function r(d) {
    for (var f = [], p = 0; p < d.length; p++) {
      var g = d[p], m = d[(p + 1) % d.length], v = {
        x: m.x - g.x,
        y: m.y - g.y
      }, y = {
        x: -v.y,
        y: v.x
      }, b = Math.sqrt(y.x * y.x + y.y * y.y);
      f.push({
        x: y.x / b,
        y: y.y / b
      });
    }
    return f;
  }
  function n(d, f) {
    var p = 1 / 0, g = -1 / 0, m = oa(d), v;
    try {
      for (m.s(); !(v = m.n()).done; ) {
        var y = v.value, b = y.x * f.x + y.y * f.y;
        p = Math.min(p, b), g = Math.max(g, b);
      }
    } catch (w) {
      m.e(w);
    } finally {
      m.f();
    }
    return {
      min: p,
      max: g
    };
  }
  function i(d, f) {
    return !(d.max < f.min || f.max < d.min);
  }
  var a = [].concat(Ey(r(t)), Ey(r(e))), s = oa(a), o;
  try {
    for (s.s(); !(o = s.n()).done; ) {
      var l = o.value, u = n(t, l), h = n(e, l);
      if (!i(u, h))
        return !1;
    }
  } catch (d) {
    s.e(d);
  } finally {
    s.f();
  }
  return !0;
}
var H2e = fi({
  dampingFactor: 0.8,
  precision: 1e-6,
  iterations: 200,
  weight: function(e) {
    return 1;
  }
}), q2e = {
  pageRank: function(e) {
    for (var r = H2e(e), n = r.dampingFactor, i = r.precision, a = r.iterations, s = r.weight, o = this._private.cy, l = this.byGroup(), u = l.nodes, h = l.edges, d = u.length, f = d * d, p = h.length, g = new Array(f), m = new Array(d), v = (1 - n) / d, y = 0; y < d; y++) {
      for (var b = 0; b < d; b++) {
        var w = y * d + b;
        g[w] = 0;
      }
      m[y] = 0;
    }
    for (var T = 0; T < p; T++) {
      var E = h[T], L = E.data("source"), k = E.data("target");
      if (L !== k) {
        var C = u.indexOfId(L), A = u.indexOfId(k), R = s(E), _ = A * d + C;
        g[_] += R, m[C] += R;
      }
    }
    for (var O = 1 / d + v, P = 0; P < d; P++)
      if (m[P] === 0)
        for (var S = 0; S < d; S++) {
          var M = S * d + P;
          g[M] = O;
        }
      else
        for (var N = 0; N < d; N++) {
          var D = N * d + P;
          g[D] = g[D] / m[P] + v;
        }
    for (var I = new Array(d), B = new Array(d), z, F = 0; F < d; F++)
      I[F] = 1;
    for (var V = 0; V < a; V++) {
      for (var H = 0; H < d; H++)
        B[H] = 0;
      for (var J = 0; J < d; J++)
        for (var q = 0; q < d; q++) {
          var ae = J * d + q;
          B[J] += g[ae] * I[q];
        }
      S2e(B), z = I, I = B, B = z;
      for (var re = 0, pe = 0; pe < d; pe++) {
        var K = z[pe] - I[pe];
        re += K * K;
      }
      if (re < i)
        break;
    }
    var Z = {
      rank: function(Y) {
        return Y = o.collection(Y)[0], I[u.indexOf(Y)];
      }
    };
    return Z;
  }
  // pageRank
}, A_ = fi({
  root: null,
  weight: function(e) {
    return 1;
  },
  directed: !1,
  alpha: 0
}), rd = {
  degreeCentralityNormalized: function(e) {
    e = A_(e);
    var r = this.cy(), n = this.nodes(), i = n.length;
    if (e.directed) {
      for (var h = {}, d = {}, f = 0, p = 0, g = 0; g < i; g++) {
        var m = n[g], v = m.id();
        e.root = m;
        var y = this.degreeCentrality(e);
        f < y.indegree && (f = y.indegree), p < y.outdegree && (p = y.outdegree), h[v] = y.indegree, d[v] = y.outdegree;
      }
      return {
        indegree: function(w) {
          return f == 0 ? 0 : (Bt(w) && (w = r.filter(w)), h[w.id()] / f);
        },
        outdegree: function(w) {
          return p === 0 ? 0 : (Bt(w) && (w = r.filter(w)), d[w.id()] / p);
        }
      };
    } else {
      for (var a = {}, s = 0, o = 0; o < i; o++) {
        var l = n[o];
        e.root = l;
        var u = this.degreeCentrality(e);
        s < u.degree && (s = u.degree), a[l.id()] = u.degree;
      }
      return {
        degree: function(w) {
          return s === 0 ? 0 : (Bt(w) && (w = r.filter(w)), a[w.id()] / s);
        }
      };
    }
  },
  // degreeCentralityNormalized
  // Implemented from the algorithm in Opsahl's paper
  // "Node centrality in weighted networks: Generalizing degree and shortest paths"
  // check the heading 2 "Degree"
  degreeCentrality: function(e) {
    e = A_(e);
    var r = this.cy(), n = this, i = e, a = i.root, s = i.weight, o = i.directed, l = i.alpha;
    if (a = r.collection(a)[0], o) {
      for (var p = a.connectedEdges(), g = p.filter(function(L) {
        return L.target().same(a) && n.has(L);
      }), m = p.filter(function(L) {
        return L.source().same(a) && n.has(L);
      }), v = g.length, y = m.length, b = 0, w = 0, T = 0; T < g.length; T++)
        b += s(g[T]);
      for (var E = 0; E < m.length; E++)
        w += s(m[E]);
      return {
        indegree: Math.pow(v, 1 - l) * Math.pow(b, l),
        outdegree: Math.pow(y, 1 - l) * Math.pow(w, l)
      };
    } else {
      for (var u = a.connectedEdges().intersection(n), h = u.length, d = 0, f = 0; f < u.length; f++)
        d += s(u[f]);
      return {
        degree: Math.pow(h, 1 - l) * Math.pow(d, l)
      };
    }
  }
  // degreeCentrality
};
rd.dc = rd.degreeCentrality;
rd.dcn = rd.degreeCentralityNormalised = rd.degreeCentralityNormalized;
var __ = fi({
  harmonic: !0,
  weight: function() {
    return 1;
  },
  directed: !1,
  root: null
}), nd = {
  closenessCentralityNormalized: function(e) {
    for (var r = __(e), n = r.harmonic, i = r.weight, a = r.directed, s = this.cy(), o = {}, l = 0, u = this.nodes(), h = this.floydWarshall({
      weight: i,
      directed: a
    }), d = 0; d < u.length; d++) {
      for (var f = 0, p = u[d], g = 0; g < u.length; g++)
        if (d !== g) {
          var m = h.distance(p, u[g]);
          n ? f += 1 / m : f += m;
        }
      n || (f = 1 / f), l < f && (l = f), o[p.id()] = f;
    }
    return {
      closeness: function(y) {
        return l == 0 ? 0 : (Bt(y) ? y = s.filter(y)[0].id() : y = y.id(), o[y] / l);
      }
    };
  },
  // Implemented from pseudocode from wikipedia
  closenessCentrality: function(e) {
    var r = __(e), n = r.root, i = r.weight, a = r.directed, s = r.harmonic;
    n = this.filter(n)[0];
    for (var o = this.dijkstra({
      root: n,
      weight: i,
      directed: a
    }), l = 0, u = this.nodes(), h = 0; h < u.length; h++) {
      var d = u[h];
      if (!d.same(n)) {
        var f = o.distanceTo(d);
        s ? l += 1 / f : l += f;
      }
    }
    return s ? l : 1 / l;
  }
  // closenessCentrality
};
nd.cc = nd.closenessCentrality;
nd.ccn = nd.closenessCentralityNormalised = nd.closenessCentralityNormalized;
var W2e = fi({
  weight: null,
  directed: !1
}), gT = {
  // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
  betweennessCentrality: function(e) {
    for (var r = W2e(e), n = r.directed, i = r.weight, a = i != null, s = this.cy(), o = this.nodes(), l = {}, u = {}, h = 0, d = {
      set: function(w, T) {
        u[w] = T, T > h && (h = T);
      },
      get: function(w) {
        return u[w];
      }
    }, f = 0; f < o.length; f++) {
      var p = o[f], g = p.id();
      n ? l[g] = p.outgoers().nodes() : l[g] = p.openNeighborhood().nodes(), d.set(g, 0);
    }
    for (var m = function() {
      for (var w = o[v].id(), T = [], E = {}, L = {}, k = {}, C = new _g(function(J, q) {
        return k[J] - k[q];
      }), A = 0; A < o.length; A++) {
        var R = o[A].id();
        E[R] = [], L[R] = 0, k[R] = 1 / 0;
      }
      for (L[w] = 1, k[w] = 0, C.push(w); !C.empty(); ) {
        var _ = C.pop();
        if (T.push(_), a)
          for (var O = 0; O < l[_].length; O++) {
            var P = l[_][O], S = s.getElementById(_), M = void 0;
            S.edgesTo(P).length > 0 ? M = S.edgesTo(P)[0] : M = P.edgesTo(S)[0];
            var N = i(M);
            P = P.id(), k[P] > k[_] + N && (k[P] = k[_] + N, C.nodes.indexOf(P) < 0 ? C.push(P) : C.updateItem(P), L[P] = 0, E[P] = []), k[P] == k[_] + N && (L[P] = L[P] + L[_], E[P].push(_));
          }
        else
          for (var D = 0; D < l[_].length; D++) {
            var I = l[_][D].id();
            k[I] == 1 / 0 && (C.push(I), k[I] = k[_] + 1), k[I] == k[_] + 1 && (L[I] = L[I] + L[_], E[I].push(_));
          }
      }
      for (var B = {}, z = 0; z < o.length; z++)
        B[o[z].id()] = 0;
      for (; T.length > 0; ) {
        for (var F = T.pop(), V = 0; V < E[F].length; V++) {
          var H = E[F][V];
          B[H] = B[H] + L[H] / L[F] * (1 + B[F]);
        }
        F != o[v].id() && d.set(F, d.get(F) + B[F]);
      }
    }, v = 0; v < o.length; v++)
      m();
    var y = {
      betweenness: function(w) {
        var T = s.collection(w).id();
        return d.get(T);
      },
      betweennessNormalized: function(w) {
        if (h == 0)
          return 0;
        var T = s.collection(w).id();
        return d.get(T) / h;
      }
    };
    return y.betweennessNormalised = y.betweennessNormalized, y;
  }
  // betweennessCentrality
};
gT.bc = gT.betweennessCentrality;
var Y2e = fi({
  expandFactor: 2,
  // affects time of computation and cluster granularity to some extent: M * M
  inflateFactor: 2,
  // affects cluster granularity (the greater the value, the more clusters): M(i,j) / E(j)
  multFactor: 1,
  // optional self loops for each node. Use a neutral value to improve cluster computations.
  maxIterations: 20,
  // maximum number of iterations of the MCL algorithm in a single run
  attributes: [
    // attributes/features used to group nodes, ie. similarity values between nodes
    function(t) {
      return 1;
    }
  ]
}), X2e = function(e) {
  return Y2e(e);
}, j2e = function(e, r) {
  for (var n = 0, i = 0; i < r.length; i++)
    n += r[i](e);
  return n;
}, K2e = function(e, r, n) {
  for (var i = 0; i < r; i++)
    e[i * r + i] = n;
}, OV = function(e, r) {
  for (var n, i = 0; i < r; i++) {
    n = 0;
    for (var a = 0; a < r; a++)
      n += e[a * r + i];
    for (var s = 0; s < r; s++)
      e[s * r + i] = e[s * r + i] / n;
  }
}, Z2e = function(e, r, n) {
  for (var i = new Array(n * n), a = 0; a < n; a++) {
    for (var s = 0; s < n; s++)
      i[a * n + s] = 0;
    for (var o = 0; o < n; o++)
      for (var l = 0; l < n; l++)
        i[a * n + l] += e[a * n + o] * r[o * n + l];
  }
  return i;
}, Q2e = function(e, r, n) {
  for (var i = e.slice(0), a = 1; a < n; a++)
    e = Z2e(e, i, r);
  return e;
}, J2e = function(e, r, n) {
  for (var i = new Array(r * r), a = 0; a < r * r; a++)
    i[a] = Math.pow(e[a], n);
  return OV(i, r), i;
}, exe = function(e, r, n, i) {
  for (var a = 0; a < n; a++) {
    var s = Math.round(e[a] * Math.pow(10, i)) / Math.pow(10, i), o = Math.round(r[a] * Math.pow(10, i)) / Math.pow(10, i);
    if (s !== o)
      return !1;
  }
  return !0;
}, txe = function(e, r, n, i) {
  for (var a = [], s = 0; s < r; s++) {
    for (var o = [], l = 0; l < r; l++)
      Math.round(e[s * r + l] * 1e3) / 1e3 > 0 && o.push(n[l]);
    o.length !== 0 && a.push(i.collection(o));
  }
  return a;
}, rxe = function(e, r) {
  for (var n = 0; n < e.length; n++)
    if (!r[n] || e[n].id() !== r[n].id())
      return !1;
  return !0;
}, nxe = function(e) {
  for (var r = 0; r < e.length; r++)
    for (var n = 0; n < e.length; n++)
      r != n && rxe(e[r], e[n]) && e.splice(n, 1);
  return e;
}, L_ = function(e) {
  for (var r = this.nodes(), n = this.edges(), i = this.cy(), a = X2e(e), s = {}, o = 0; o < r.length; o++)
    s[r[o].id()] = o;
  for (var l = r.length, u = l * l, h = new Array(u), d, f = 0; f < u; f++)
    h[f] = 0;
  for (var p = 0; p < n.length; p++) {
    var g = n[p], m = s[g.source().id()], v = s[g.target().id()], y = j2e(g, a.attributes);
    h[m * l + v] += y, h[v * l + m] += y;
  }
  K2e(h, l, a.multFactor), OV(h, l);
  for (var b = !0, w = 0; b && w < a.maxIterations; )
    b = !1, d = Q2e(h, l, a.expandFactor), h = J2e(d, l, a.inflateFactor), exe(h, d, u, 4) || (b = !0), w++;
  var T = txe(h, l, r, i);
  return T = nxe(T), T;
}, ixe = {
  markovClustering: L_,
  mcl: L_
}, axe = function(e) {
  return e;
}, PV = function(e, r) {
  return Math.abs(r - e);
}, R_ = function(e, r, n) {
  return e + PV(r, n);
}, M_ = function(e, r, n) {
  return e + Math.pow(n - r, 2);
}, sxe = function(e) {
  return Math.sqrt(e);
}, oxe = function(e, r, n) {
  return Math.max(e, PV(r, n));
}, Rf = function(e, r, n, i, a) {
  for (var s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : axe, o = i, l, u, h = 0; h < e; h++)
    l = r(h), u = n(h), o = a(o, l, u);
  return s(o);
}, Rd = {
  euclidean: function(e, r, n) {
    return e >= 2 ? Rf(e, r, n, 0, M_, sxe) : Rf(e, r, n, 0, R_);
  },
  squaredEuclidean: function(e, r, n) {
    return Rf(e, r, n, 0, M_);
  },
  manhattan: function(e, r, n) {
    return Rf(e, r, n, 0, R_);
  },
  max: function(e, r, n) {
    return Rf(e, r, n, -1 / 0, oxe);
  }
};
Rd["squared-euclidean"] = Rd.squaredEuclidean;
Rd.squaredeuclidean = Rd.squaredEuclidean;
function Lx(t, e, r, n, i, a) {
  var s;
  return an(t) ? s = t : s = Rd[t] || Rd.euclidean, e === 0 && an(t) ? s(i, a) : s(e, r, n, i, a);
}
var lxe = fi({
  k: 2,
  m: 2,
  sensitivityThreshold: 1e-4,
  distance: "euclidean",
  maxIterations: 10,
  attributes: [],
  testMode: !1,
  testCentroids: null
}), nS = function(e) {
  return lxe(e);
}, Ly = function(e, r, n, i, a) {
  var s = a !== "kMedoids", o = s ? function(d) {
    return n[d];
  } : function(d) {
    return i[d](n);
  }, l = function(f) {
    return i[f](r);
  }, u = n, h = r;
  return Lx(e, i.length, o, l, u, h);
}, J4 = function(e, r, n) {
  for (var i = n.length, a = new Array(i), s = new Array(i), o = new Array(r), l = null, u = 0; u < i; u++)
    a[u] = e.min(n[u]).value, s[u] = e.max(n[u]).value;
  for (var h = 0; h < r; h++) {
    l = [];
    for (var d = 0; d < i; d++)
      l[d] = Math.random() * (s[d] - a[d]) + a[d];
    o[h] = l;
  }
  return o;
}, BV = function(e, r, n, i, a) {
  for (var s = 1 / 0, o = 0, l = 0; l < r.length; l++) {
    var u = Ly(n, e, r[l], i, a);
    u < s && (s = u, o = l);
  }
  return o;
}, FV = function(e, r, n) {
  for (var i = [], a = null, s = 0; s < r.length; s++)
    a = r[s], n[a.id()] === e && i.push(a);
  return i;
}, cxe = function(e, r, n) {
  return Math.abs(r - e) <= n;
}, uxe = function(e, r, n) {
  for (var i = 0; i < e.length; i++)
    for (var a = 0; a < e[i].length; a++) {
      var s = Math.abs(e[i][a] - r[i][a]);
      if (s > n)
        return !1;
    }
  return !0;
}, hxe = function(e, r, n) {
  for (var i = 0; i < n; i++)
    if (e === r[i]) return !0;
  return !1;
}, N_ = function(e, r) {
  var n = new Array(r);
  if (e.length < 50)
    for (var i = 0; i < r; i++) {
      for (var a = e[Math.floor(Math.random() * e.length)]; hxe(a, n, i); )
        a = e[Math.floor(Math.random() * e.length)];
      n[i] = a;
    }
  else
    for (var s = 0; s < r; s++)
      n[s] = e[Math.floor(Math.random() * e.length)];
  return n;
}, I_ = function(e, r, n) {
  for (var i = 0, a = 0; a < r.length; a++)
    i += Ly("manhattan", r[a], e, n, "kMedoids");
  return i;
}, dxe = function(e) {
  var r = this.cy(), n = this.nodes(), i = null, a = nS(e), s = new Array(a.k), o = {}, l;
  a.testMode ? typeof a.testCentroids == "number" ? (a.testCentroids, l = J4(n, a.k, a.attributes)) : zn(a.testCentroids) === "object" ? l = a.testCentroids : l = J4(n, a.k, a.attributes) : l = J4(n, a.k, a.attributes);
  for (var u = !0, h = 0; u && h < a.maxIterations; ) {
    for (var d = 0; d < n.length; d++)
      i = n[d], o[i.id()] = BV(i, l, a.distance, a.attributes, "kMeans");
    u = !1;
    for (var f = 0; f < a.k; f++) {
      var p = FV(f, n, o);
      if (p.length !== 0) {
        for (var g = a.attributes.length, m = l[f], v = new Array(g), y = new Array(g), b = 0; b < g; b++) {
          y[b] = 0;
          for (var w = 0; w < p.length; w++)
            i = p[w], y[b] += a.attributes[b](i);
          v[b] = y[b] / p.length, cxe(v[b], m[b], a.sensitivityThreshold) || (u = !0);
        }
        l[f] = v, s[f] = r.collection(p);
      }
    }
    h++;
  }
  return s;
}, fxe = function(e) {
  var r = this.cy(), n = this.nodes(), i = null, a = nS(e), s = new Array(a.k), o, l = {}, u, h = new Array(a.k);
  a.testMode ? typeof a.testCentroids == "number" || (zn(a.testCentroids) === "object" ? o = a.testCentroids : o = N_(n, a.k)) : o = N_(n, a.k);
  for (var d = !0, f = 0; d && f < a.maxIterations; ) {
    for (var p = 0; p < n.length; p++)
      i = n[p], l[i.id()] = BV(i, o, a.distance, a.attributes, "kMedoids");
    d = !1;
    for (var g = 0; g < o.length; g++) {
      var m = FV(g, n, l);
      if (m.length !== 0) {
        h[g] = I_(o[g], m, a.attributes);
        for (var v = 0; v < m.length; v++)
          u = I_(m[v], m, a.attributes), u < h[g] && (h[g] = u, o[g] = m[v], d = !0);
        s[g] = r.collection(m);
      }
    }
    f++;
  }
  return s;
}, pxe = function(e, r, n, i, a) {
  for (var s, o, l = 0; l < r.length; l++)
    for (var u = 0; u < e.length; u++)
      i[l][u] = Math.pow(n[l][u], a.m);
  for (var h = 0; h < e.length; h++)
    for (var d = 0; d < a.attributes.length; d++) {
      s = 0, o = 0;
      for (var f = 0; f < r.length; f++)
        s += i[f][h] * a.attributes[d](r[f]), o += i[f][h];
      e[h][d] = s / o;
    }
}, gxe = function(e, r, n, i, a) {
  for (var s = 0; s < e.length; s++)
    r[s] = e[s].slice();
  for (var o, l, u, h = 2 / (a.m - 1), d = 0; d < n.length; d++)
    for (var f = 0; f < i.length; f++) {
      o = 0;
      for (var p = 0; p < n.length; p++)
        l = Ly(a.distance, i[f], n[d], a.attributes, "cmeans"), u = Ly(a.distance, i[f], n[p], a.attributes, "cmeans"), o += Math.pow(l / u, h);
      e[f][d] = 1 / o;
    }
}, mxe = function(e, r, n, i) {
  for (var a = new Array(n.k), s = 0; s < a.length; s++)
    a[s] = [];
  for (var o, l, u = 0; u < r.length; u++) {
    o = -1 / 0, l = -1;
    for (var h = 0; h < r[0].length; h++)
      r[u][h] > o && (o = r[u][h], l = h);
    a[l].push(e[u]);
  }
  for (var d = 0; d < a.length; d++)
    a[d] = i.collection(a[d]);
  return a;
}, D_ = function(e) {
  var r = this.cy(), n = this.nodes(), i = nS(e), a, s, o, l, u;
  l = new Array(n.length);
  for (var h = 0; h < n.length; h++)
    l[h] = new Array(i.k);
  o = new Array(n.length);
  for (var d = 0; d < n.length; d++)
    o[d] = new Array(i.k);
  for (var f = 0; f < n.length; f++) {
    for (var p = 0, g = 0; g < i.k; g++)
      o[f][g] = Math.random(), p += o[f][g];
    for (var m = 0; m < i.k; m++)
      o[f][m] = o[f][m] / p;
  }
  s = new Array(i.k);
  for (var v = 0; v < i.k; v++)
    s[v] = new Array(i.attributes.length);
  u = new Array(n.length);
  for (var y = 0; y < n.length; y++)
    u[y] = new Array(i.k);
  for (var b = !0, w = 0; b && w < i.maxIterations; )
    b = !1, pxe(s, n, o, u, i), gxe(o, l, s, n, i), uxe(o, l, i.sensitivityThreshold) || (b = !0), w++;
  return a = mxe(n, o, i, r), {
    clusters: a,
    degreeOfMembership: o
  };
}, vxe = {
  kMeans: dxe,
  kMedoids: fxe,
  fuzzyCMeans: D_,
  fcm: D_
}, yxe = fi({
  distance: "euclidean",
  // distance metric to compare nodes
  linkage: "min",
  // linkage criterion : how to determine the distance between clusters of nodes
  mode: "threshold",
  // mode:'threshold' => clusters must be threshold distance apart
  threshold: 1 / 0,
  // the distance threshold
  // mode:'dendrogram' => the nodes are organised as leaves in a tree (siblings are close), merging makes clusters
  addDendrogram: !1,
  // whether to add the dendrogram to the graph for viz
  dendrogramDepth: 0,
  // depth at which dendrogram branches are merged into the returned clusters
  attributes: []
  // array of attr functions
}), xxe = {
  single: "min",
  complete: "max"
}, bxe = function(e) {
  var r = yxe(e), n = xxe[r.linkage];
  return n != null && (r.linkage = n), r;
}, O_ = function(e, r, n, i, a) {
  for (var s = 0, o = 1 / 0, l, u = a.attributes, h = function(A, R) {
    return Lx(a.distance, u.length, function(_) {
      return u[_](A);
    }, function(_) {
      return u[_](R);
    }, A, R);
  }, d = 0; d < e.length; d++) {
    var f = e[d].key, p = n[f][i[f]];
    p < o && (s = f, o = p);
  }
  if (a.mode === "threshold" && o >= a.threshold || a.mode === "dendrogram" && e.length === 1)
    return !1;
  var g = r[s], m = r[i[s]], v;
  a.mode === "dendrogram" ? v = {
    left: g,
    right: m,
    key: g.key
  } : v = {
    value: g.value.concat(m.value),
    key: g.key
  }, e[g.index] = v, e.splice(m.index, 1), r[g.key] = v;
  for (var y = 0; y < e.length; y++) {
    var b = e[y];
    g.key === b.key ? l = 1 / 0 : a.linkage === "min" ? (l = n[g.key][b.key], n[g.key][b.key] > n[m.key][b.key] && (l = n[m.key][b.key])) : a.linkage === "max" ? (l = n[g.key][b.key], n[g.key][b.key] < n[m.key][b.key] && (l = n[m.key][b.key])) : a.linkage === "mean" ? l = (n[g.key][b.key] * g.size + n[m.key][b.key] * m.size) / (g.size + m.size) : a.mode === "dendrogram" ? l = h(b.value, g.value) : l = h(b.value[0], g.value[0]), n[g.key][b.key] = n[b.key][g.key] = l;
  }
  for (var w = 0; w < e.length; w++) {
    var T = e[w].key;
    if (i[T] === g.key || i[T] === m.key) {
      for (var E = T, L = 0; L < e.length; L++) {
        var k = e[L].key;
        n[T][k] < n[T][E] && (E = k);
      }
      i[T] = E;
    }
    e[w].index = w;
  }
  return g.key = m.key = g.index = m.index = null, !0;
}, Vh = function(e, r, n) {
  e && (e.value ? r.push(e.value) : (e.left && Vh(e.left, r), e.right && Vh(e.right, r)));
}, mT = function(e, r) {
  if (!e) return "";
  if (e.left && e.right) {
    var n = mT(e.left, r), i = mT(e.right, r), a = r.add({
      group: "nodes",
      data: {
        id: n + "," + i
      }
    });
    return r.add({
      group: "edges",
      data: {
        source: n,
        target: a.id()
      }
    }), r.add({
      group: "edges",
      data: {
        source: i,
        target: a.id()
      }
    }), a.id();
  } else if (e.value)
    return e.value.id();
}, vT = function(e, r, n) {
  if (!e) return [];
  var i = [], a = [], s = [];
  return r === 0 ? (e.left && Vh(e.left, i), e.right && Vh(e.right, a), s = i.concat(a), [n.collection(s)]) : r === 1 ? e.value ? [n.collection(e.value)] : (e.left && Vh(e.left, i), e.right && Vh(e.right, a), [n.collection(i), n.collection(a)]) : e.value ? [n.collection(e.value)] : (e.left && (i = vT(e.left, r - 1, n)), e.right && (a = vT(e.right, r - 1, n)), i.concat(a));
}, P_ = function(e) {
  for (var r = this.cy(), n = this.nodes(), i = bxe(e), a = i.attributes, s = function(w, T) {
    return Lx(i.distance, a.length, function(E) {
      return a[E](w);
    }, function(E) {
      return a[E](T);
    }, w, T);
  }, o = [], l = [], u = [], h = [], d = 0; d < n.length; d++) {
    var f = {
      value: i.mode === "dendrogram" ? n[d] : [n[d]],
      key: d,
      index: d
    };
    o[d] = f, h[d] = f, l[d] = [], u[d] = 0;
  }
  for (var p = 0; p < o.length; p++)
    for (var g = 0; g <= p; g++) {
      var m = void 0;
      i.mode === "dendrogram" ? m = p === g ? 1 / 0 : s(o[p].value, o[g].value) : m = p === g ? 1 / 0 : s(o[p].value[0], o[g].value[0]), l[p][g] = m, l[g][p] = m, m < l[p][u[p]] && (u[p] = g);
    }
  for (var v = O_(o, h, l, u, i); v; )
    v = O_(o, h, l, u, i);
  var y;
  return i.mode === "dendrogram" ? (y = vT(o[0], i.dendrogramDepth, r), i.addDendrogram && mT(o[0], r)) : (y = new Array(o.length), o.forEach(function(b, w) {
    b.key = b.index = null, y[w] = r.collection(b.value);
  })), y;
}, wxe = {
  hierarchicalClustering: P_,
  hca: P_
}, Txe = fi({
  distance: "euclidean",
  // distance metric to compare attributes between two nodes
  preference: "median",
  // suitability of a data point to serve as an exemplar
  damping: 0.8,
  // damping factor between [0.5, 1)
  maxIterations: 1e3,
  // max number of iterations to run
  minIterations: 100,
  // min number of iterations to run in order for clustering to stop
  attributes: [
    // functions to quantify the similarity between any two points
    // e.g. node => node.data('weight')
  ]
}), Exe = function(e) {
  var r = e.damping, n = e.preference;
  0.5 <= r && r < 1 || Zr("Damping must range on [0.5, 1).  Got: ".concat(r));
  var i = ["median", "mean", "min", "max"];
  return i.some(function(a) {
    return a === n;
  }) || mt(n) || Zr("Preference must be one of [".concat(i.map(function(a) {
    return "'".concat(a, "'");
  }).join(", "), "] or a number.  Got: ").concat(n)), Txe(e);
}, kxe = function(e, r, n, i) {
  var a = function(o, l) {
    return i[l](o);
  };
  return -Lx(e, i.length, function(s) {
    return a(r, s);
  }, function(s) {
    return a(n, s);
  }, r, n);
}, Sxe = function(e, r) {
  var n = null;
  return r === "median" ? n = E2e(e) : r === "mean" ? n = T2e(e) : r === "min" ? n = b2e(e) : r === "max" ? n = w2e(e) : n = r, n;
}, Cxe = function(e, r, n) {
  for (var i = [], a = 0; a < e; a++)
    r[a * e + a] + n[a * e + a] > 0 && i.push(a);
  return i;
}, B_ = function(e, r, n) {
  for (var i = [], a = 0; a < e; a++) {
    for (var s = -1, o = -1 / 0, l = 0; l < n.length; l++) {
      var u = n[l];
      r[a * e + u] > o && (s = u, o = r[a * e + u]);
    }
    s > 0 && i.push(s);
  }
  for (var h = 0; h < n.length; h++)
    i[n[h]] = n[h];
  return i;
}, Axe = function(e, r, n) {
  for (var i = B_(e, r, n), a = 0; a < n.length; a++) {
    for (var s = [], o = 0; o < i.length; o++)
      i[o] === n[a] && s.push(o);
    for (var l = -1, u = -1 / 0, h = 0; h < s.length; h++) {
      for (var d = 0, f = 0; f < s.length; f++)
        d += r[s[f] * e + s[h]];
      d > u && (l = h, u = d);
    }
    n[a] = s[l];
  }
  return i = B_(e, r, n), i;
}, F_ = function(e) {
  for (var r = this.cy(), n = this.nodes(), i = Exe(e), a = {}, s = 0; s < n.length; s++)
    a[n[s].id()] = s;
  var o, l, u, h, d, f;
  o = n.length, l = o * o, u = new Array(l);
  for (var p = 0; p < l; p++)
    u[p] = -1 / 0;
  for (var g = 0; g < o; g++)
    for (var m = 0; m < o; m++)
      g !== m && (u[g * o + m] = kxe(i.distance, n[g], n[m], i.attributes));
  h = Sxe(u, i.preference);
  for (var v = 0; v < o; v++)
    u[v * o + v] = h;
  d = new Array(l);
  for (var y = 0; y < l; y++)
    d[y] = 0;
  f = new Array(l);
  for (var b = 0; b < l; b++)
    f[b] = 0;
  for (var w = new Array(o), T = new Array(o), E = new Array(o), L = 0; L < o; L++)
    w[L] = 0, T[L] = 0, E[L] = 0;
  for (var k = new Array(o * i.minIterations), C = 0; C < k.length; C++)
    k[C] = 0;
  var A;
  for (A = 0; A < i.maxIterations; A++) {
    for (var R = 0; R < o; R++) {
      for (var _ = -1 / 0, O = -1 / 0, P = -1, S = 0, M = 0; M < o; M++)
        w[M] = d[R * o + M], S = f[R * o + M] + u[R * o + M], S >= _ ? (O = _, _ = S, P = M) : S > O && (O = S);
      for (var N = 0; N < o; N++)
        d[R * o + N] = (1 - i.damping) * (u[R * o + N] - _) + i.damping * w[N];
      d[R * o + P] = (1 - i.damping) * (u[R * o + P] - O) + i.damping * w[P];
    }
    for (var D = 0; D < o; D++) {
      for (var I = 0, B = 0; B < o; B++)
        w[B] = f[B * o + D], T[B] = Math.max(0, d[B * o + D]), I += T[B];
      I -= T[D], T[D] = d[D * o + D], I += T[D];
      for (var z = 0; z < o; z++)
        f[z * o + D] = (1 - i.damping) * Math.min(0, I - T[z]) + i.damping * w[z];
      f[D * o + D] = (1 - i.damping) * (I - T[D]) + i.damping * w[D];
    }
    for (var F = 0, V = 0; V < o; V++) {
      var H = f[V * o + V] + d[V * o + V] > 0 ? 1 : 0;
      k[A % i.minIterations * o + V] = H, F += H;
    }
    if (F > 0 && (A >= i.minIterations - 1 || A == i.maxIterations - 1)) {
      for (var J = 0, q = 0; q < o; q++) {
        E[q] = 0;
        for (var ae = 0; ae < i.minIterations; ae++)
          E[q] += k[ae * o + q];
        (E[q] === 0 || E[q] === i.minIterations) && J++;
      }
      if (J === o)
        break;
    }
  }
  for (var re = Cxe(o, d, f), pe = Axe(o, u, re), K = {}, Z = 0; Z < re.length; Z++)
    K[re[Z]] = [];
  for (var X = 0; X < n.length; X++) {
    var Y = a[n[X].id()], ee = pe[Y];
    ee != null && K[ee].push(n[X]);
  }
  for (var j = new Array(re.length), fe = 0; fe < re.length; fe++)
    j[fe] = r.collection(K[re[fe]]);
  return j;
}, _xe = {
  affinityPropagation: F_,
  ap: F_
}, Lxe = fi({
  root: void 0,
  directed: !1
}), Rxe = {
  hierholzer: function(e) {
    if (!mr(e)) {
      var r = arguments;
      e = {
        root: r[0],
        directed: r[1]
      };
    }
    var n = Lxe(e), i = n.root, a = n.directed, s = this, o = !1, l, u, h;
    i && (h = Bt(i) ? this.filter(i)[0].id() : i[0].id());
    var d = {}, f = {};
    a ? s.forEach(function(b) {
      var w = b.id();
      if (b.isNode()) {
        var T = b.indegree(!0), E = b.outdegree(!0), L = T - E, k = E - T;
        L == 1 ? l ? o = !0 : l = w : k == 1 ? u ? o = !0 : u = w : (k > 1 || L > 1) && (o = !0), d[w] = [], b.outgoers().forEach(function(C) {
          C.isEdge() && d[w].push(C.id());
        });
      } else
        f[w] = [void 0, b.target().id()];
    }) : s.forEach(function(b) {
      var w = b.id();
      if (b.isNode()) {
        var T = b.degree(!0);
        T % 2 && (l ? u ? o = !0 : u = w : l = w), d[w] = [], b.connectedEdges().forEach(function(E) {
          return d[w].push(E.id());
        });
      } else
        f[w] = [b.source().id(), b.target().id()];
    });
    var p = {
      found: !1,
      trail: void 0
    };
    if (o) return p;
    if (u && l)
      if (a) {
        if (h && u != h)
          return p;
        h = u;
      } else {
        if (h && u != h && l != h)
          return p;
        h || (h = u);
      }
    else
      h || (h = s[0].id());
    var g = function(w) {
      for (var T = w, E = [w], L, k, C; d[T].length; )
        L = d[T].shift(), k = f[L][0], C = f[L][1], T != C ? (d[C] = d[C].filter(function(A) {
          return A != L;
        }), T = C) : !a && T != k && (d[k] = d[k].filter(function(A) {
          return A != L;
        }), T = k), E.unshift(L), E.unshift(T);
      return E;
    }, m = [], v = [];
    for (v = g(h); v.length != 1; )
      d[v[0]].length == 0 ? (m.unshift(s.getElementById(v.shift())), m.unshift(s.getElementById(v.shift()))) : v = g(v.shift()).concat(v);
    m.unshift(s.getElementById(v.shift()));
    for (var y in d)
      if (d[y].length)
        return p;
    return p.found = !0, p.trail = this.spawn(m, !0), p;
  }
}, R1 = function() {
  var e = this, r = {}, n = 0, i = 0, a = [], s = [], o = {}, l = function(f, p) {
    for (var g = s.length - 1, m = [], v = e.spawn(); s[g].x != f || s[g].y != p; )
      m.push(s.pop().edge), g--;
    m.push(s.pop().edge), m.forEach(function(y) {
      var b = y.connectedNodes().intersection(e);
      v.merge(y), b.forEach(function(w) {
        var T = w.id(), E = w.connectedEdges().intersection(e);
        v.merge(w), r[T].cutVertex ? v.merge(E.filter(function(L) {
          return L.isLoop();
        })) : v.merge(E);
      });
    }), a.push(v);
  }, u = function(f, p, g) {
    f === g && (i += 1), r[p] = {
      id: n,
      low: n++,
      cutVertex: !1
    };
    var m = e.getElementById(p).connectedEdges().intersection(e);
    if (m.size() === 0)
      a.push(e.spawn(e.getElementById(p)));
    else {
      var v, y, b, w;
      m.forEach(function(T) {
        v = T.source().id(), y = T.target().id(), b = v === p ? y : v, b !== g && (w = T.id(), o[w] || (o[w] = !0, s.push({
          x: p,
          y: b,
          edge: T
        })), b in r ? r[p].low = Math.min(r[p].low, r[b].id) : (u(f, b, p), r[p].low = Math.min(r[p].low, r[b].low), r[p].id <= r[b].low && (r[p].cutVertex = !0, l(p, b))));
      });
    }
  };
  e.forEach(function(d) {
    if (d.isNode()) {
      var f = d.id();
      f in r || (i = 0, u(f, f), r[f].cutVertex = i > 1);
    }
  });
  var h = Object.keys(r).filter(function(d) {
    return r[d].cutVertex;
  }).map(function(d) {
    return e.getElementById(d);
  });
  return {
    cut: e.spawn(h),
    components: a
  };
}, Mxe = {
  hopcroftTarjanBiconnected: R1,
  htbc: R1,
  htb: R1,
  hopcroftTarjanBiconnectedComponents: R1
}, M1 = function() {
  var e = this, r = {}, n = 0, i = [], a = [], s = e.spawn(e), o = function(u) {
    a.push(u), r[u] = {
      index: n,
      low: n++,
      explored: !1
    };
    var h = e.getElementById(u).connectedEdges().intersection(e);
    if (h.forEach(function(m) {
      var v = m.target().id();
      v !== u && (v in r || o(v), r[v].explored || (r[u].low = Math.min(r[u].low, r[v].low)));
    }), r[u].index === r[u].low) {
      for (var d = e.spawn(); ; ) {
        var f = a.pop();
        if (d.merge(e.getElementById(f)), r[f].low = r[u].index, r[f].explored = !0, f === u)
          break;
      }
      var p = d.edgesWith(d), g = d.merge(p);
      i.push(g), s = s.difference(g);
    }
  };
  return e.forEach(function(l) {
    if (l.isNode()) {
      var u = l.id();
      u in r || o(u);
    }
  }), {
    cut: s,
    components: i
  };
}, Nxe = {
  tarjanStronglyConnected: M1,
  tsc: M1,
  tscc: M1,
  tarjanStronglyConnectedComponents: M1
}, $V = {};
[Op, l2e, c2e, h2e, f2e, g2e, y2e, q2e, rd, nd, gT, ixe, vxe, wxe, _xe, Rxe, Mxe, Nxe].forEach(function(t) {
  Gt($V, t);
});
var zV = 0, GV = 1, VV = 2, Cs = function(e) {
  if (!(this instanceof Cs)) return new Cs(e);
  this.id = "Thenable/1.0.7", this.state = zV, this.fulfillValue = void 0, this.rejectReason = void 0, this.onFulfilled = [], this.onRejected = [], this.proxy = {
    then: this.then.bind(this)
  }, typeof e == "function" && e.call(this, this.fulfill.bind(this), this.reject.bind(this));
};
Cs.prototype = {
  /*  promise resolving methods  */
  fulfill: function(e) {
    return $_(this, GV, "fulfillValue", e);
  },
  reject: function(e) {
    return $_(this, VV, "rejectReason", e);
  },
  /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
  then: function(e, r) {
    var n = this, i = new Cs();
    return n.onFulfilled.push(G_(e, i, "fulfill")), n.onRejected.push(G_(r, i, "reject")), UV(n), i.proxy;
  }
};
var $_ = function(e, r, n, i) {
  return e.state === zV && (e.state = r, e[n] = i, UV(e)), e;
}, UV = function(e) {
  e.state === GV ? z_(e, "onFulfilled", e.fulfillValue) : e.state === VV && z_(e, "onRejected", e.rejectReason);
}, z_ = function(e, r, n) {
  if (e[r].length !== 0) {
    var i = e[r];
    e[r] = [];
    var a = function() {
      for (var o = 0; o < i.length; o++) i[o](n);
    };
    typeof setImmediate == "function" ? setImmediate(a) : setTimeout(a, 0);
  }
}, G_ = function(e, r, n) {
  return function(i) {
    if (typeof e != "function")
      r[n].call(r, i);
    else {
      var a;
      try {
        a = e(i);
      } catch (s) {
        r.reject(s);
        return;
      }
      HV(r, a);
    }
  };
}, HV = function(e, r) {
  if (e === r || e.proxy === r) {
    e.reject(new TypeError("cannot resolve promise with itself"));
    return;
  }
  var n;
  if (zn(r) === "object" && r !== null || typeof r == "function")
    try {
      n = r.then;
    } catch (a) {
      e.reject(a);
      return;
    }
  if (typeof n == "function") {
    var i = !1;
    try {
      n.call(
        r,
        /*  resolvePromise  */
        /*  [Promises/A+ 2.3.3.3.1]  */
        function(a) {
          i || (i = !0, a === r ? e.reject(new TypeError("circular thenable chain")) : HV(e, a));
        },
        /*  rejectPromise  */
        /*  [Promises/A+ 2.3.3.3.2]  */
        function(a) {
          i || (i = !0, e.reject(a));
        }
      );
    } catch (a) {
      i || e.reject(a);
    }
    return;
  }
  e.fulfill(r);
};
Cs.all = function(t) {
  return new Cs(function(e, r) {
    for (var n = new Array(t.length), i = 0, a = function(l, u) {
      n[l] = u, i++, i === t.length && e(n);
    }, s = 0; s < t.length; s++)
      (function(o) {
        var l = t[o], u = l != null && l.then != null;
        if (u)
          l.then(function(d) {
            a(o, d);
          }, function(d) {
            r(d);
          });
        else {
          var h = l;
          a(o, h);
        }
      })(s);
  });
};
Cs.resolve = function(t) {
  return new Cs(function(e, r) {
    e(t);
  });
};
Cs.reject = function(t) {
  return new Cs(function(e, r) {
    r(t);
  });
};
var rf = typeof Promise < "u" ? Promise : Cs, yT = function(e, r, n) {
  var i = Yk(e), a = !i, s = this._private = Gt({
    duration: 1e3
  }, r, n);
  if (s.target = e, s.style = s.style || s.css, s.started = !1, s.playing = !1, s.hooked = !1, s.applying = !1, s.progress = 0, s.completes = [], s.frames = [], s.complete && an(s.complete) && s.completes.push(s.complete), a) {
    var o = e.position();
    s.startPosition = s.startPosition || {
      x: o.x,
      y: o.y
    }, s.startStyle = s.startStyle || e.cy().style().getAnimationStartStyle(e, s.style);
  }
  if (i) {
    var l = e.pan();
    s.startPan = {
      x: l.x,
      y: l.y
    }, s.startZoom = e.zoom();
  }
  this.length = 1, this[0] = this;
}, _u = yT.prototype;
Gt(_u, {
  instanceString: function() {
    return "animation";
  },
  hook: function() {
    var e = this._private;
    if (!e.hooked) {
      var r, n = e.target._private.animation;
      e.queue ? r = n.queue : r = n.current, r.push(this), ka(e.target) && e.target.cy().addToAnimationPool(e.target), e.hooked = !0;
    }
    return this;
  },
  play: function() {
    var e = this._private;
    return e.progress === 1 && (e.progress = 0), e.playing = !0, e.started = !1, e.stopped = !1, this.hook(), this;
  },
  playing: function() {
    return this._private.playing;
  },
  apply: function() {
    var e = this._private;
    return e.applying = !0, e.started = !1, e.stopped = !1, this.hook(), this;
  },
  applying: function() {
    return this._private.applying;
  },
  pause: function() {
    var e = this._private;
    return e.playing = !1, e.started = !1, this;
  },
  stop: function() {
    var e = this._private;
    return e.playing = !1, e.started = !1, e.stopped = !0, this;
  },
  rewind: function() {
    return this.progress(0);
  },
  fastforward: function() {
    return this.progress(1);
  },
  time: function(e) {
    var r = this._private;
    return e === void 0 ? r.progress * r.duration : this.progress(e / r.duration);
  },
  progress: function(e) {
    var r = this._private, n = r.playing;
    return e === void 0 ? r.progress : (n && this.pause(), r.progress = e, r.started = !1, n && this.play(), this);
  },
  completed: function() {
    return this._private.progress === 1;
  },
  reverse: function() {
    var e = this._private, r = e.playing;
    r && this.pause(), e.progress = 1 - e.progress, e.started = !1;
    var n = function(u, h) {
      var d = e[u];
      d != null && (e[u] = e[h], e[h] = d);
    };
    if (n("zoom", "startZoom"), n("pan", "startPan"), n("position", "startPosition"), e.style)
      for (var i = 0; i < e.style.length; i++) {
        var a = e.style[i], s = a.name, o = e.startStyle[s];
        e.startStyle[s] = a, e.style[i] = o;
      }
    return r && this.play(), this;
  },
  promise: function(e) {
    var r = this._private, n;
    switch (e) {
      case "frame":
        n = r.frames;
        break;
      default:
      case "complete":
      case "completed":
        n = r.completes;
    }
    return new rf(function(i, a) {
      n.push(function() {
        i();
      });
    });
  }
});
_u.complete = _u.completed;
_u.run = _u.play;
_u.running = _u.playing;
var Ixe = {
  animated: function() {
    return function() {
      var r = this, n = r.length !== void 0, i = n ? r : [r], a = this._private.cy || this;
      if (!a.styleEnabled())
        return !1;
      var s = i[0];
      if (s)
        return s._private.animation.current.length > 0;
    };
  },
  // animated
  clearQueue: function() {
    return function() {
      var r = this, n = r.length !== void 0, i = n ? r : [r], a = this._private.cy || this;
      if (!a.styleEnabled())
        return this;
      for (var s = 0; s < i.length; s++) {
        var o = i[s];
        o._private.animation.queue = [];
      }
      return this;
    };
  },
  // clearQueue
  delay: function() {
    return function(r, n) {
      var i = this._private.cy || this;
      return i.styleEnabled() ? this.animate({
        delay: r,
        duration: r,
        complete: n
      }) : this;
    };
  },
  // delay
  delayAnimation: function() {
    return function(r, n) {
      var i = this._private.cy || this;
      return i.styleEnabled() ? this.animation({
        delay: r,
        duration: r,
        complete: n
      }) : this;
    };
  },
  // delay
  animation: function() {
    return function(r, n) {
      var i = this, a = i.length !== void 0, s = a ? i : [i], o = this._private.cy || this, l = !a, u = !l;
      if (!o.styleEnabled())
        return this;
      var h = o.style();
      r = Gt({}, r, n);
      var d = Object.keys(r).length === 0;
      if (d)
        return new yT(s[0], r);
      switch (r.duration === void 0 && (r.duration = 400), r.duration) {
        case "slow":
          r.duration = 600;
          break;
        case "fast":
          r.duration = 200;
          break;
      }
      if (u && (r.style = h.getPropsList(r.style || r.css), r.css = void 0), u && r.renderedPosition != null) {
        var f = r.renderedPosition, p = o.pan(), g = o.zoom();
        r.position = LV(f, g, p);
      }
      if (l && r.panBy != null) {
        var m = r.panBy, v = o.pan();
        r.pan = {
          x: v.x + m.x,
          y: v.y + m.y
        };
      }
      var y = r.center || r.centre;
      if (l && y != null) {
        var b = o.getCenterPan(y.eles, r.zoom);
        b != null && (r.pan = b);
      }
      if (l && r.fit != null) {
        var w = r.fit, T = o.getFitViewport(w.eles || w.boundingBox, w.padding);
        T != null && (r.pan = T.pan, r.zoom = T.zoom);
      }
      if (l && mr(r.zoom)) {
        var E = o.getZoomedViewport(r.zoom);
        E != null ? (E.zoomed && (r.zoom = E.zoom), E.panned && (r.pan = E.pan)) : r.zoom = null;
      }
      return new yT(s[0], r);
    };
  },
  // animate
  animate: function() {
    return function(r, n) {
      var i = this, a = i.length !== void 0, s = a ? i : [i], o = this._private.cy || this;
      if (!o.styleEnabled())
        return this;
      n && (r = Gt({}, r, n));
      for (var l = 0; l < s.length; l++) {
        var u = s[l], h = u.animated() && (r.queue === void 0 || r.queue), d = u.animation(r, h ? {
          queue: !0
        } : void 0);
        d.play();
      }
      return this;
    };
  },
  // animate
  stop: function() {
    return function(r, n) {
      var i = this, a = i.length !== void 0, s = a ? i : [i], o = this._private.cy || this;
      if (!o.styleEnabled())
        return this;
      for (var l = 0; l < s.length; l++) {
        for (var u = s[l], h = u._private, d = h.animation.current, f = 0; f < d.length; f++) {
          var p = d[f], g = p._private;
          n && (g.duration = 0);
        }
        r && (h.animation.queue = []), n || (h.animation.current = []);
      }
      return o.notify("draw"), this;
    };
  }
  // stop
}, e3, V_;
function Rx() {
  if (V_) return e3;
  V_ = 1;
  var t = Array.isArray;
  return e3 = t, e3;
}
var t3, U_;
function Dxe() {
  if (U_) return t3;
  U_ = 1;
  var t = Rx(), e = Cg(), r = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, n = /^\w*$/;
  function i(a, s) {
    if (t(a))
      return !1;
    var o = typeof a;
    return o == "number" || o == "symbol" || o == "boolean" || a == null || e(a) ? !0 : n.test(a) || !r.test(a) || s != null && a in Object(s);
  }
  return t3 = i, t3;
}
var r3, H_;
function Oxe() {
  if (H_) return r3;
  H_ = 1;
  var t = bV(), e = Sg(), r = "[object AsyncFunction]", n = "[object Function]", i = "[object GeneratorFunction]", a = "[object Proxy]";
  function s(o) {
    if (!e(o))
      return !1;
    var l = t(o);
    return l == n || l == i || l == r || l == a;
  }
  return r3 = s, r3;
}
var n3, q_;
function Pxe() {
  if (q_) return n3;
  q_ = 1;
  var t = Cx(), e = t["__core-js_shared__"];
  return n3 = e, n3;
}
var i3, W_;
function Bxe() {
  if (W_) return i3;
  W_ = 1;
  var t = Pxe(), e = (function() {
    var n = /[^.]+$/.exec(t && t.keys && t.keys.IE_PROTO || "");
    return n ? "Symbol(src)_1." + n : "";
  })();
  function r(n) {
    return !!e && e in n;
  }
  return i3 = r, i3;
}
var a3, Y_;
function Fxe() {
  if (Y_) return a3;
  Y_ = 1;
  var t = Function.prototype, e = t.toString;
  function r(n) {
    if (n != null) {
      try {
        return e.call(n);
      } catch {
      }
      try {
        return n + "";
      } catch {
      }
    }
    return "";
  }
  return a3 = r, a3;
}
var s3, X_;
function $xe() {
  if (X_) return s3;
  X_ = 1;
  var t = Oxe(), e = Bxe(), r = Sg(), n = Fxe(), i = /[\\^$.*+?()[\]{}|]/g, a = /^\[object .+?Constructor\]$/, s = Function.prototype, o = Object.prototype, l = s.toString, u = o.hasOwnProperty, h = RegExp(
    "^" + l.call(u).replace(i, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function d(f) {
    if (!r(f) || e(f))
      return !1;
    var p = t(f) ? h : a;
    return p.test(n(f));
  }
  return s3 = d, s3;
}
var o3, j_;
function zxe() {
  if (j_) return o3;
  j_ = 1;
  function t(e, r) {
    return e?.[r];
  }
  return o3 = t, o3;
}
var l3, K_;
function iS() {
  if (K_) return l3;
  K_ = 1;
  var t = $xe(), e = zxe();
  function r(n, i) {
    var a = e(n, i);
    return t(a) ? a : void 0;
  }
  return l3 = r, l3;
}
var c3, Z_;
function Mx() {
  if (Z_) return c3;
  Z_ = 1;
  var t = iS(), e = t(Object, "create");
  return c3 = e, c3;
}
var u3, Q_;
function Gxe() {
  if (Q_) return u3;
  Q_ = 1;
  var t = Mx();
  function e() {
    this.__data__ = t ? t(null) : {}, this.size = 0;
  }
  return u3 = e, u3;
}
var h3, J_;
function Vxe() {
  if (J_) return h3;
  J_ = 1;
  function t(e) {
    var r = this.has(e) && delete this.__data__[e];
    return this.size -= r ? 1 : 0, r;
  }
  return h3 = t, h3;
}
var d3, e9;
function Uxe() {
  if (e9) return d3;
  e9 = 1;
  var t = Mx(), e = "__lodash_hash_undefined__", r = Object.prototype, n = r.hasOwnProperty;
  function i(a) {
    var s = this.__data__;
    if (t) {
      var o = s[a];
      return o === e ? void 0 : o;
    }
    return n.call(s, a) ? s[a] : void 0;
  }
  return d3 = i, d3;
}
var f3, t9;
function Hxe() {
  if (t9) return f3;
  t9 = 1;
  var t = Mx(), e = Object.prototype, r = e.hasOwnProperty;
  function n(i) {
    var a = this.__data__;
    return t ? a[i] !== void 0 : r.call(a, i);
  }
  return f3 = n, f3;
}
var p3, r9;
function qxe() {
  if (r9) return p3;
  r9 = 1;
  var t = Mx(), e = "__lodash_hash_undefined__";
  function r(n, i) {
    var a = this.__data__;
    return this.size += this.has(n) ? 0 : 1, a[n] = t && i === void 0 ? e : i, this;
  }
  return p3 = r, p3;
}
var g3, n9;
function Wxe() {
  if (n9) return g3;
  n9 = 1;
  var t = Gxe(), e = Vxe(), r = Uxe(), n = Hxe(), i = qxe();
  function a(s) {
    var o = -1, l = s == null ? 0 : s.length;
    for (this.clear(); ++o < l; ) {
      var u = s[o];
      this.set(u[0], u[1]);
    }
  }
  return a.prototype.clear = t, a.prototype.delete = e, a.prototype.get = r, a.prototype.has = n, a.prototype.set = i, g3 = a, g3;
}
var m3, i9;
function Yxe() {
  if (i9) return m3;
  i9 = 1;
  function t() {
    this.__data__ = [], this.size = 0;
  }
  return m3 = t, m3;
}
var v3, a9;
function qV() {
  if (a9) return v3;
  a9 = 1;
  function t(e, r) {
    return e === r || e !== e && r !== r;
  }
  return v3 = t, v3;
}
var y3, s9;
function Nx() {
  if (s9) return y3;
  s9 = 1;
  var t = qV();
  function e(r, n) {
    for (var i = r.length; i--; )
      if (t(r[i][0], n))
        return i;
    return -1;
  }
  return y3 = e, y3;
}
var x3, o9;
function Xxe() {
  if (o9) return x3;
  o9 = 1;
  var t = Nx(), e = Array.prototype, r = e.splice;
  function n(i) {
    var a = this.__data__, s = t(a, i);
    if (s < 0)
      return !1;
    var o = a.length - 1;
    return s == o ? a.pop() : r.call(a, s, 1), --this.size, !0;
  }
  return x3 = n, x3;
}
var b3, l9;
function jxe() {
  if (l9) return b3;
  l9 = 1;
  var t = Nx();
  function e(r) {
    var n = this.__data__, i = t(n, r);
    return i < 0 ? void 0 : n[i][1];
  }
  return b3 = e, b3;
}
var w3, c9;
function Kxe() {
  if (c9) return w3;
  c9 = 1;
  var t = Nx();
  function e(r) {
    return t(this.__data__, r) > -1;
  }
  return w3 = e, w3;
}
var T3, u9;
function Zxe() {
  if (u9) return T3;
  u9 = 1;
  var t = Nx();
  function e(r, n) {
    var i = this.__data__, a = t(i, r);
    return a < 0 ? (++this.size, i.push([r, n])) : i[a][1] = n, this;
  }
  return T3 = e, T3;
}
var E3, h9;
function Qxe() {
  if (h9) return E3;
  h9 = 1;
  var t = Yxe(), e = Xxe(), r = jxe(), n = Kxe(), i = Zxe();
  function a(s) {
    var o = -1, l = s == null ? 0 : s.length;
    for (this.clear(); ++o < l; ) {
      var u = s[o];
      this.set(u[0], u[1]);
    }
  }
  return a.prototype.clear = t, a.prototype.delete = e, a.prototype.get = r, a.prototype.has = n, a.prototype.set = i, E3 = a, E3;
}
var k3, d9;
function Jxe() {
  if (d9) return k3;
  d9 = 1;
  var t = iS(), e = Cx(), r = t(e, "Map");
  return k3 = r, k3;
}
var S3, f9;
function ebe() {
  if (f9) return S3;
  f9 = 1;
  var t = Wxe(), e = Qxe(), r = Jxe();
  function n() {
    this.size = 0, this.__data__ = {
      hash: new t(),
      map: new (r || e)(),
      string: new t()
    };
  }
  return S3 = n, S3;
}
var C3, p9;
function tbe() {
  if (p9) return C3;
  p9 = 1;
  function t(e) {
    var r = typeof e;
    return r == "string" || r == "number" || r == "symbol" || r == "boolean" ? e !== "__proto__" : e === null;
  }
  return C3 = t, C3;
}
var A3, g9;
function Ix() {
  if (g9) return A3;
  g9 = 1;
  var t = tbe();
  function e(r, n) {
    var i = r.__data__;
    return t(n) ? i[typeof n == "string" ? "string" : "hash"] : i.map;
  }
  return A3 = e, A3;
}
var _3, m9;
function rbe() {
  if (m9) return _3;
  m9 = 1;
  var t = Ix();
  function e(r) {
    var n = t(this, r).delete(r);
    return this.size -= n ? 1 : 0, n;
  }
  return _3 = e, _3;
}
var L3, v9;
function nbe() {
  if (v9) return L3;
  v9 = 1;
  var t = Ix();
  function e(r) {
    return t(this, r).get(r);
  }
  return L3 = e, L3;
}
var R3, y9;
function ibe() {
  if (y9) return R3;
  y9 = 1;
  var t = Ix();
  function e(r) {
    return t(this, r).has(r);
  }
  return R3 = e, R3;
}
var M3, x9;
function abe() {
  if (x9) return M3;
  x9 = 1;
  var t = Ix();
  function e(r, n) {
    var i = t(this, r), a = i.size;
    return i.set(r, n), this.size += i.size == a ? 0 : 1, this;
  }
  return M3 = e, M3;
}
var N3, b9;
function sbe() {
  if (b9) return N3;
  b9 = 1;
  var t = ebe(), e = rbe(), r = nbe(), n = ibe(), i = abe();
  function a(s) {
    var o = -1, l = s == null ? 0 : s.length;
    for (this.clear(); ++o < l; ) {
      var u = s[o];
      this.set(u[0], u[1]);
    }
  }
  return a.prototype.clear = t, a.prototype.delete = e, a.prototype.get = r, a.prototype.has = n, a.prototype.set = i, N3 = a, N3;
}
var I3, w9;
function obe() {
  if (w9) return I3;
  w9 = 1;
  var t = sbe(), e = "Expected a function";
  function r(n, i) {
    if (typeof n != "function" || i != null && typeof i != "function")
      throw new TypeError(e);
    var a = function() {
      var s = arguments, o = i ? i.apply(this, s) : s[0], l = a.cache;
      if (l.has(o))
        return l.get(o);
      var u = n.apply(this, s);
      return a.cache = l.set(o, u) || l, u;
    };
    return a.cache = new (r.Cache || t)(), a;
  }
  return r.Cache = t, I3 = r, I3;
}
var D3, T9;
function lbe() {
  if (T9) return D3;
  T9 = 1;
  var t = obe(), e = 500;
  function r(n) {
    var i = t(n, function(s) {
      return a.size === e && a.clear(), s;
    }), a = i.cache;
    return i;
  }
  return D3 = r, D3;
}
var O3, E9;
function WV() {
  if (E9) return O3;
  E9 = 1;
  var t = lbe(), e = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, r = /\\(\\)?/g, n = t(function(i) {
    var a = [];
    return i.charCodeAt(0) === 46 && a.push(""), i.replace(e, function(s, o, l, u) {
      a.push(l ? u.replace(r, "$1") : o || s);
    }), a;
  });
  return O3 = n, O3;
}
var P3, k9;
function YV() {
  if (k9) return P3;
  k9 = 1;
  function t(e, r) {
    for (var n = -1, i = e == null ? 0 : e.length, a = Array(i); ++n < i; )
      a[n] = r(e[n], n, e);
    return a;
  }
  return P3 = t, P3;
}
var B3, S9;
function cbe() {
  if (S9) return B3;
  S9 = 1;
  var t = jk(), e = YV(), r = Rx(), n = Cg(), i = t ? t.prototype : void 0, a = i ? i.toString : void 0;
  function s(o) {
    if (typeof o == "string")
      return o;
    if (r(o))
      return e(o, s) + "";
    if (n(o))
      return a ? a.call(o) : "";
    var l = o + "";
    return l == "0" && 1 / o == -1 / 0 ? "-0" : l;
  }
  return B3 = s, B3;
}
var F3, C9;
function XV() {
  if (C9) return F3;
  C9 = 1;
  var t = cbe();
  function e(r) {
    return r == null ? "" : t(r);
  }
  return F3 = e, F3;
}
var $3, A9;
function jV() {
  if (A9) return $3;
  A9 = 1;
  var t = Rx(), e = Dxe(), r = WV(), n = XV();
  function i(a, s) {
    return t(a) ? a : e(a, s) ? [a] : r(n(a));
  }
  return $3 = i, $3;
}
var z3, _9;
function aS() {
  if (_9) return z3;
  _9 = 1;
  var t = Cg();
  function e(r) {
    if (typeof r == "string" || t(r))
      return r;
    var n = r + "";
    return n == "0" && 1 / r == -1 / 0 ? "-0" : n;
  }
  return z3 = e, z3;
}
var G3, L9;
function ube() {
  if (L9) return G3;
  L9 = 1;
  var t = jV(), e = aS();
  function r(n, i) {
    i = t(i, n);
    for (var a = 0, s = i.length; n != null && a < s; )
      n = n[e(i[a++])];
    return a && a == s ? n : void 0;
  }
  return G3 = r, G3;
}
var V3, R9;
function hbe() {
  if (R9) return V3;
  R9 = 1;
  var t = ube();
  function e(r, n, i) {
    var a = r == null ? void 0 : t(r, n);
    return a === void 0 ? i : a;
  }
  return V3 = e, V3;
}
var dbe = hbe(), fbe = /* @__PURE__ */ kg(dbe), U3, M9;
function pbe() {
  if (M9) return U3;
  M9 = 1;
  var t = iS(), e = (function() {
    try {
      var r = t(Object, "defineProperty");
      return r({}, "", {}), r;
    } catch {
    }
  })();
  return U3 = e, U3;
}
var H3, N9;
function gbe() {
  if (N9) return H3;
  N9 = 1;
  var t = pbe();
  function e(r, n, i) {
    n == "__proto__" && t ? t(r, n, {
      configurable: !0,
      enumerable: !0,
      value: i,
      writable: !0
    }) : r[n] = i;
  }
  return H3 = e, H3;
}
var q3, I9;
function mbe() {
  if (I9) return q3;
  I9 = 1;
  var t = gbe(), e = qV(), r = Object.prototype, n = r.hasOwnProperty;
  function i(a, s, o) {
    var l = a[s];
    (!(n.call(a, s) && e(l, o)) || o === void 0 && !(s in a)) && t(a, s, o);
  }
  return q3 = i, q3;
}
var W3, D9;
function vbe() {
  if (D9) return W3;
  D9 = 1;
  var t = 9007199254740991, e = /^(?:0|[1-9]\d*)$/;
  function r(n, i) {
    var a = typeof n;
    return i = i ?? t, !!i && (a == "number" || a != "symbol" && e.test(n)) && n > -1 && n % 1 == 0 && n < i;
  }
  return W3 = r, W3;
}
var Y3, O9;
function ybe() {
  if (O9) return Y3;
  O9 = 1;
  var t = mbe(), e = jV(), r = vbe(), n = Sg(), i = aS();
  function a(s, o, l, u) {
    if (!n(s))
      return s;
    o = e(o, s);
    for (var h = -1, d = o.length, f = d - 1, p = s; p != null && ++h < d; ) {
      var g = i(o[h]), m = l;
      if (g === "__proto__" || g === "constructor" || g === "prototype")
        return s;
      if (h != f) {
        var v = p[g];
        m = u ? u(v, g, p) : void 0, m === void 0 && (m = n(v) ? v : r(o[h + 1]) ? [] : {});
      }
      t(p, g, m), p = p[g];
    }
    return s;
  }
  return Y3 = a, Y3;
}
var X3, P9;
function xbe() {
  if (P9) return X3;
  P9 = 1;
  var t = ybe();
  function e(r, n, i) {
    return r == null ? r : t(r, n, i);
  }
  return X3 = e, X3;
}
var bbe = xbe(), wbe = /* @__PURE__ */ kg(bbe), j3, B9;
function Tbe() {
  if (B9) return j3;
  B9 = 1;
  function t(e, r) {
    var n = -1, i = e.length;
    for (r || (r = Array(i)); ++n < i; )
      r[n] = e[n];
    return r;
  }
  return j3 = t, j3;
}
var K3, F9;
function Ebe() {
  if (F9) return K3;
  F9 = 1;
  var t = YV(), e = Tbe(), r = Rx(), n = Cg(), i = WV(), a = aS(), s = XV();
  function o(l) {
    return r(l) ? t(l, a) : n(l) ? [l] : e(i(s(l)));
  }
  return K3 = o, K3;
}
var kbe = Ebe(), Sbe = /* @__PURE__ */ kg(kbe), Cbe = {
  // access data field
  data: function(e) {
    var r = {
      field: "data",
      bindingEvent: "data",
      allowBinding: !1,
      allowSetting: !1,
      allowGetting: !1,
      settingEvent: "data",
      settingTriggersEvent: !1,
      triggerFnName: "trigger",
      immutableKeys: {},
      // key => true if immutable
      updateStyle: !1,
      beforeGet: function(i) {
      },
      beforeSet: function(i, a) {
      },
      onSet: function(i) {
      },
      canSet: function(i) {
        return !0;
      }
    };
    return e = Gt({}, r, e), function(i, a) {
      var s = e, o = this, l = o.length !== void 0, u = l ? o : [o], h = l ? o[0] : o;
      if (Bt(i)) {
        var d = i.indexOf(".") !== -1, f = d && Sbe(i);
        if (s.allowGetting && a === void 0) {
          var p;
          return h && (s.beforeGet(h), f && h._private[s.field][i] === void 0 ? p = fbe(h._private[s.field], f) : p = h._private[s.field][i]), p;
        } else if (s.allowSetting && a !== void 0) {
          var g = !s.immutableKeys[i];
          if (g) {
            var m = uV({}, i, a);
            s.beforeSet(o, m);
            for (var v = 0, y = u.length; v < y; v++) {
              var b = u[v];
              s.canSet(b) && (f && h._private[s.field][i] === void 0 ? wbe(b._private[s.field], f, a) : b._private[s.field][i] = a);
            }
            s.updateStyle && o.updateStyle(), s.onSet(o), s.settingTriggersEvent && o[s.triggerFnName](s.settingEvent);
          }
        }
      } else if (s.allowSetting && mr(i)) {
        var w = i, T, E, L = Object.keys(w);
        s.beforeSet(o, w);
        for (var k = 0; k < L.length; k++) {
          T = L[k], E = w[T];
          var C = !s.immutableKeys[T];
          if (C)
            for (var A = 0; A < u.length; A++) {
              var R = u[A];
              s.canSet(R) && (R._private[s.field][T] = E);
            }
        }
        s.updateStyle && o.updateStyle(), s.onSet(o), s.settingTriggersEvent && o[s.triggerFnName](s.settingEvent);
      } else if (s.allowBinding && an(i)) {
        var _ = i;
        o.on(s.bindingEvent, _);
      } else if (s.allowGetting && i === void 0) {
        var O;
        return h && (s.beforeGet(h), O = h._private[s.field]), O;
      }
      return o;
    };
  },
  // data
  // remove data field
  removeData: function(e) {
    var r = {
      field: "data",
      event: "data",
      triggerFnName: "trigger",
      triggerEvent: !1,
      immutableKeys: {}
      // key => true if immutable
    };
    return e = Gt({}, r, e), function(i) {
      var a = e, s = this, o = s.length !== void 0, l = o ? s : [s];
      if (Bt(i)) {
        for (var u = i.split(/\s+/), h = u.length, d = 0; d < h; d++) {
          var f = u[d];
          if (!Zl(f)) {
            var p = !a.immutableKeys[f];
            if (p)
              for (var g = 0, m = l.length; g < m; g++)
                l[g]._private[a.field][f] = void 0;
          }
        }
        a.triggerEvent && s[a.triggerFnName](a.event);
      } else if (i === void 0) {
        for (var v = 0, y = l.length; v < y; v++)
          for (var b = l[v]._private[a.field], w = Object.keys(b), T = 0; T < w.length; T++) {
            var E = w[T], L = !a.immutableKeys[E];
            L && (b[E] = void 0);
          }
        a.triggerEvent && s[a.triggerFnName](a.event);
      }
      return s;
    };
  }
  // removeData
}, Abe = {
  eventAliasesOn: function(e) {
    var r = e;
    r.addListener = r.listen = r.bind = r.on, r.unlisten = r.unbind = r.off = r.removeListener, r.trigger = r.emit, r.pon = r.promiseOn = function(n, i) {
      var a = this, s = Array.prototype.slice.call(arguments, 0);
      return new rf(function(o, l) {
        var u = function(p) {
          a.off.apply(a, d), o(p);
        }, h = s.concat([u]), d = h.concat([]);
        a.on.apply(a, h);
      });
    };
  }
}, Ar = {};
[Ixe, Cbe, Abe].forEach(function(t) {
  Gt(Ar, t);
});
var _be = {
  animate: Ar.animate(),
  animation: Ar.animation(),
  animated: Ar.animated(),
  clearQueue: Ar.clearQueue(),
  delay: Ar.delay(),
  delayAnimation: Ar.delayAnimation(),
  stop: Ar.stop()
}, Bm = {
  classes: function(e) {
    var r = this;
    if (e === void 0) {
      var n = [];
      return r[0]._private.classes.forEach(function(g) {
        return n.push(g);
      }), n;
    } else Or(e) || (e = (e || "").match(/\S+/g) || []);
    for (var i = [], a = new tf(e), s = 0; s < r.length; s++) {
      for (var o = r[s], l = o._private, u = l.classes, h = !1, d = 0; d < e.length; d++) {
        var f = e[d], p = u.has(f);
        if (!p) {
          h = !0;
          break;
        }
      }
      h || (h = u.size !== e.length), h && (l.classes = a, i.push(o));
    }
    return i.length > 0 && this.spawn(i).updateStyle().emit("class"), r;
  },
  addClass: function(e) {
    return this.toggleClass(e, !0);
  },
  hasClass: function(e) {
    var r = this[0];
    return r != null && r._private.classes.has(e);
  },
  toggleClass: function(e, r) {
    Or(e) || (e = e.match(/\S+/g) || []);
    for (var n = this, i = r === void 0, a = [], s = 0, o = n.length; s < o; s++)
      for (var l = n[s], u = l._private.classes, h = !1, d = 0; d < e.length; d++) {
        var f = e[d], p = u.has(f), g = !1;
        r || i && !p ? (u.add(f), g = !0) : (!r || i && p) && (u.delete(f), g = !0), !h && g && (a.push(l), h = !0);
      }
    return a.length > 0 && this.spawn(a).updateStyle().emit("class"), n;
  },
  removeClass: function(e) {
    return this.toggleClass(e, !1);
  },
  flashClass: function(e, r) {
    var n = this;
    if (r == null)
      r = 250;
    else if (r === 0)
      return n;
    return n.addClass(e), setTimeout(function() {
      n.removeClass(e);
    }, r), n;
  }
};
Bm.className = Bm.classNames = Bm.classes;
var gr = {
  metaChar: "[\\!\\\"\\#\\$\\%\\&\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]",
  // chars we need to escape in let names, etc
  comparatorOp: "=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=",
  // binary comparison op (used in data selectors)
  boolOp: "\\?|\\!|\\^",
  // boolean (unary) operators (used in data selectors)
  string: `"(?:\\\\"|[^"])*"|'(?:\\\\'|[^'])*'`,
  // string literals (used in data selectors) -- doublequotes | singlequotes
  number: Fn,
  // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
  meta: "degree|indegree|outdegree",
  // allowed metadata fields (i.e. allowed functions to use from Collection)
  separator: "\\s*,\\s*",
  // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
  descendant: "\\s+",
  child: "\\s+>\\s+",
  subject: "\\$",
  group: "node|edge|\\*",
  directedEdge: "\\s+->\\s+",
  undirectedEdge: "\\s+<->\\s+"
};
gr.variable = "(?:[\\w-.]|(?:\\\\" + gr.metaChar + "))+";
gr.className = "(?:[\\w-]|(?:\\\\" + gr.metaChar + "))+";
gr.value = gr.string + "|" + gr.number;
gr.id = gr.variable;
(function() {
  var t, e, r;
  for (t = gr.comparatorOp.split("|"), r = 0; r < t.length; r++)
    e = t[r], gr.comparatorOp += "|@" + e;
  for (t = gr.comparatorOp.split("|"), r = 0; r < t.length; r++)
    e = t[r], !(e.indexOf("!") >= 0) && e !== "=" && (gr.comparatorOp += "|\\!" + e);
})();
var Dr = function() {
  return {
    checks: []
  };
}, _t = {
  /** E.g. node */
  GROUP: 0,
  /** A collection of elements */
  COLLECTION: 1,
  /** A filter(ele) function */
  FILTER: 2,
  /** E.g. [foo > 1] */
  DATA_COMPARE: 3,
  /** E.g. [foo] */
  DATA_EXIST: 4,
  /** E.g. [?foo] */
  DATA_BOOL: 5,
  /** E.g. [[degree > 2]] */
  META_COMPARE: 6,
  /** E.g. :selected */
  STATE: 7,
  /** E.g. #foo */
  ID: 8,
  /** E.g. .foo */
  CLASS: 9,
  /** E.g. #foo <-> #bar */
  UNDIRECTED_EDGE: 10,
  /** E.g. #foo -> #bar */
  DIRECTED_EDGE: 11,
  /** E.g. $#foo -> #bar */
  NODE_SOURCE: 12,
  /** E.g. #foo -> $#bar */
  NODE_TARGET: 13,
  /** E.g. $#foo <-> #bar */
  NODE_NEIGHBOR: 14,
  /** E.g. #foo > #bar */
  CHILD: 15,
  /** E.g. #foo #bar */
  DESCENDANT: 16,
  /** E.g. $#foo > #bar */
  PARENT: 17,
  /** E.g. $#foo #bar */
  ANCESTOR: 18,
  /** E.g. #foo > $bar > #baz */
  COMPOUND_SPLIT: 19,
  /** Always matches, useful placeholder for subject in `COMPOUND_SPLIT` */
  TRUE: 20
}, xT = [{
  selector: ":selected",
  matches: function(e) {
    return e.selected();
  }
}, {
  selector: ":unselected",
  matches: function(e) {
    return !e.selected();
  }
}, {
  selector: ":selectable",
  matches: function(e) {
    return e.selectable();
  }
}, {
  selector: ":unselectable",
  matches: function(e) {
    return !e.selectable();
  }
}, {
  selector: ":locked",
  matches: function(e) {
    return e.locked();
  }
}, {
  selector: ":unlocked",
  matches: function(e) {
    return !e.locked();
  }
}, {
  selector: ":visible",
  matches: function(e) {
    return e.visible();
  }
}, {
  selector: ":hidden",
  matches: function(e) {
    return !e.visible();
  }
}, {
  selector: ":transparent",
  matches: function(e) {
    return e.transparent();
  }
}, {
  selector: ":grabbed",
  matches: function(e) {
    return e.grabbed();
  }
}, {
  selector: ":free",
  matches: function(e) {
    return !e.grabbed();
  }
}, {
  selector: ":removed",
  matches: function(e) {
    return e.removed();
  }
}, {
  selector: ":inside",
  matches: function(e) {
    return !e.removed();
  }
}, {
  selector: ":grabbable",
  matches: function(e) {
    return e.grabbable();
  }
}, {
  selector: ":ungrabbable",
  matches: function(e) {
    return !e.grabbable();
  }
}, {
  selector: ":animated",
  matches: function(e) {
    return e.animated();
  }
}, {
  selector: ":unanimated",
  matches: function(e) {
    return !e.animated();
  }
}, {
  selector: ":parent",
  matches: function(e) {
    return e.isParent();
  }
}, {
  selector: ":childless",
  matches: function(e) {
    return e.isChildless();
  }
}, {
  selector: ":child",
  matches: function(e) {
    return e.isChild();
  }
}, {
  selector: ":orphan",
  matches: function(e) {
    return e.isOrphan();
  }
}, {
  selector: ":nonorphan",
  matches: function(e) {
    return e.isChild();
  }
}, {
  selector: ":compound",
  matches: function(e) {
    return e.isNode() ? e.isParent() : e.source().isParent() || e.target().isParent();
  }
}, {
  selector: ":loop",
  matches: function(e) {
    return e.isLoop();
  }
}, {
  selector: ":simple",
  matches: function(e) {
    return e.isSimple();
  }
}, {
  selector: ":active",
  matches: function(e) {
    return e.active();
  }
}, {
  selector: ":inactive",
  matches: function(e) {
    return !e.active();
  }
}, {
  selector: ":backgrounding",
  matches: function(e) {
    return e.backgrounding();
  }
}, {
  selector: ":nonbackgrounding",
  matches: function(e) {
    return !e.backgrounding();
  }
}].sort(function(t, e) {
  return Cye(t.selector, e.selector);
}), Lbe = (function() {
  for (var t = {}, e, r = 0; r < xT.length; r++)
    e = xT[r], t[e.selector] = e.matches;
  return t;
})(), Rbe = function(e, r) {
  return Lbe[e](r);
}, Mbe = "(" + xT.map(function(t) {
  return t.selector;
}).join("|") + ")", yh = function(e) {
  return e.replace(new RegExp("\\\\(" + gr.metaChar + ")", "g"), function(r, n) {
    return n;
  });
}, El = function(e, r, n) {
  e[e.length - 1] = n;
}, bT = [{
  name: "group",
  // just used for identifying when debugging
  query: !0,
  regex: "(" + gr.group + ")",
  populate: function(e, r, n) {
    var i = En(n, 1), a = i[0];
    r.checks.push({
      type: _t.GROUP,
      value: a === "*" ? a : a + "s"
    });
  }
}, {
  name: "state",
  query: !0,
  regex: Mbe,
  populate: function(e, r, n) {
    var i = En(n, 1), a = i[0];
    r.checks.push({
      type: _t.STATE,
      value: a
    });
  }
}, {
  name: "id",
  query: !0,
  regex: "\\#(" + gr.id + ")",
  populate: function(e, r, n) {
    var i = En(n, 1), a = i[0];
    r.checks.push({
      type: _t.ID,
      value: yh(a)
    });
  }
}, {
  name: "className",
  query: !0,
  regex: "\\.(" + gr.className + ")",
  populate: function(e, r, n) {
    var i = En(n, 1), a = i[0];
    r.checks.push({
      type: _t.CLASS,
      value: yh(a)
    });
  }
}, {
  name: "dataExists",
  query: !0,
  regex: "\\[\\s*(" + gr.variable + ")\\s*\\]",
  populate: function(e, r, n) {
    var i = En(n, 1), a = i[0];
    r.checks.push({
      type: _t.DATA_EXIST,
      field: yh(a)
    });
  }
}, {
  name: "dataCompare",
  query: !0,
  regex: "\\[\\s*(" + gr.variable + ")\\s*(" + gr.comparatorOp + ")\\s*(" + gr.value + ")\\s*\\]",
  populate: function(e, r, n) {
    var i = En(n, 3), a = i[0], s = i[1], o = i[2], l = new RegExp("^" + gr.string + "$").exec(o) != null;
    l ? o = o.substring(1, o.length - 1) : o = parseFloat(o), r.checks.push({
      type: _t.DATA_COMPARE,
      field: yh(a),
      operator: s,
      value: o
    });
  }
}, {
  name: "dataBool",
  query: !0,
  regex: "\\[\\s*(" + gr.boolOp + ")\\s*(" + gr.variable + ")\\s*\\]",
  populate: function(e, r, n) {
    var i = En(n, 2), a = i[0], s = i[1];
    r.checks.push({
      type: _t.DATA_BOOL,
      field: yh(s),
      operator: a
    });
  }
}, {
  name: "metaCompare",
  query: !0,
  regex: "\\[\\[\\s*(" + gr.meta + ")\\s*(" + gr.comparatorOp + ")\\s*(" + gr.number + ")\\s*\\]\\]",
  populate: function(e, r, n) {
    var i = En(n, 3), a = i[0], s = i[1], o = i[2];
    r.checks.push({
      type: _t.META_COMPARE,
      field: yh(a),
      operator: s,
      value: parseFloat(o)
    });
  }
}, {
  name: "nextQuery",
  separator: !0,
  regex: gr.separator,
  populate: function(e, r) {
    var n = e.currentSubject, i = e.edgeCount, a = e.compoundCount, s = e[e.length - 1];
    n != null && (s.subject = n, e.currentSubject = null), s.edgeCount = i, s.compoundCount = a, e.edgeCount = 0, e.compoundCount = 0;
    var o = e[e.length++] = Dr();
    return o;
  }
}, {
  name: "directedEdge",
  separator: !0,
  regex: gr.directedEdge,
  populate: function(e, r) {
    if (e.currentSubject == null) {
      var n = Dr(), i = r, a = Dr();
      return n.checks.push({
        type: _t.DIRECTED_EDGE,
        source: i,
        target: a
      }), El(e, r, n), e.edgeCount++, a;
    } else {
      var s = Dr(), o = r, l = Dr();
      return s.checks.push({
        type: _t.NODE_SOURCE,
        source: o,
        target: l
      }), El(e, r, s), e.edgeCount++, l;
    }
  }
}, {
  name: "undirectedEdge",
  separator: !0,
  regex: gr.undirectedEdge,
  populate: function(e, r) {
    if (e.currentSubject == null) {
      var n = Dr(), i = r, a = Dr();
      return n.checks.push({
        type: _t.UNDIRECTED_EDGE,
        nodes: [i, a]
      }), El(e, r, n), e.edgeCount++, a;
    } else {
      var s = Dr(), o = r, l = Dr();
      return s.checks.push({
        type: _t.NODE_NEIGHBOR,
        node: o,
        neighbor: l
      }), El(e, r, s), l;
    }
  }
}, {
  name: "child",
  separator: !0,
  regex: gr.child,
  populate: function(e, r) {
    if (e.currentSubject == null) {
      var n = Dr(), i = Dr(), a = e[e.length - 1];
      return n.checks.push({
        type: _t.CHILD,
        parent: a,
        child: i
      }), El(e, r, n), e.compoundCount++, i;
    } else if (e.currentSubject === r) {
      var s = Dr(), o = e[e.length - 1], l = Dr(), u = Dr(), h = Dr(), d = Dr();
      return s.checks.push({
        type: _t.COMPOUND_SPLIT,
        left: o,
        right: l,
        subject: u
      }), u.checks = r.checks, r.checks = [{
        type: _t.TRUE
      }], d.checks.push({
        type: _t.TRUE
      }), l.checks.push({
        type: _t.PARENT,
        // type is swapped on right side queries
        parent: d,
        child: h
        // empty for now
      }), El(e, o, s), e.currentSubject = u, e.compoundCount++, h;
    } else {
      var f = Dr(), p = Dr(), g = [{
        type: _t.PARENT,
        parent: f,
        child: p
      }];
      return f.checks = r.checks, r.checks = g, e.compoundCount++, p;
    }
  }
}, {
  name: "descendant",
  separator: !0,
  regex: gr.descendant,
  populate: function(e, r) {
    if (e.currentSubject == null) {
      var n = Dr(), i = Dr(), a = e[e.length - 1];
      return n.checks.push({
        type: _t.DESCENDANT,
        ancestor: a,
        descendant: i
      }), El(e, r, n), e.compoundCount++, i;
    } else if (e.currentSubject === r) {
      var s = Dr(), o = e[e.length - 1], l = Dr(), u = Dr(), h = Dr(), d = Dr();
      return s.checks.push({
        type: _t.COMPOUND_SPLIT,
        left: o,
        right: l,
        subject: u
      }), u.checks = r.checks, r.checks = [{
        type: _t.TRUE
      }], d.checks.push({
        type: _t.TRUE
      }), l.checks.push({
        type: _t.ANCESTOR,
        // type is swapped on right side queries
        ancestor: d,
        descendant: h
        // empty for now
      }), El(e, o, s), e.currentSubject = u, e.compoundCount++, h;
    } else {
      var f = Dr(), p = Dr(), g = [{
        type: _t.ANCESTOR,
        ancestor: f,
        descendant: p
      }];
      return f.checks = r.checks, r.checks = g, e.compoundCount++, p;
    }
  }
}, {
  name: "subject",
  modifier: !0,
  regex: gr.subject,
  populate: function(e, r) {
    if (e.currentSubject != null && e.currentSubject !== r)
      return Lr("Redefinition of subject in selector `" + e.toString() + "`"), !1;
    e.currentSubject = r;
    var n = e[e.length - 1], i = n.checks[0], a = i == null ? null : i.type;
    a === _t.DIRECTED_EDGE ? i.type = _t.NODE_TARGET : a === _t.UNDIRECTED_EDGE && (i.type = _t.NODE_NEIGHBOR, i.node = i.nodes[1], i.neighbor = i.nodes[0], i.nodes = null);
  }
}];
bT.forEach(function(t) {
  return t.regexObj = new RegExp("^" + t.regex);
});
var Nbe = function(e) {
  for (var r, n, i, a = 0; a < bT.length; a++) {
    var s = bT[a], o = s.name, l = e.match(s.regexObj);
    if (l != null) {
      n = l, r = s, i = o;
      var u = l[0];
      e = e.substring(u.length);
      break;
    }
  }
  return {
    expr: r,
    match: n,
    name: i,
    remaining: e
  };
}, Ibe = function(e) {
  var r = e.match(/^\s+/);
  if (r) {
    var n = r[0];
    e = e.substring(n.length);
  }
  return e;
}, Dbe = function(e) {
  var r = this, n = r.inputText = e, i = r[0] = Dr();
  for (r.length = 1, n = Ibe(n); ; ) {
    var a = Nbe(n);
    if (a.expr == null)
      return Lr("The selector `" + e + "`is invalid"), !1;
    var s = a.match.slice(1), o = a.expr.populate(r, i, s);
    if (o === !1)
      return !1;
    if (o != null && (i = o), n = a.remaining, n.match(/^\s*$/))
      break;
  }
  var l = r[r.length - 1];
  r.currentSubject != null && (l.subject = r.currentSubject), l.edgeCount = r.edgeCount, l.compoundCount = r.compoundCount;
  for (var u = 0; u < r.length; u++) {
    var h = r[u];
    if (h.compoundCount > 0 && h.edgeCount > 0)
      return Lr("The selector `" + e + "` is invalid because it uses both a compound selector and an edge selector"), !1;
    if (h.edgeCount > 1)
      return Lr("The selector `" + e + "` is invalid because it uses multiple edge selectors"), !1;
    h.edgeCount === 1 && Lr("The selector `" + e + "` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.");
  }
  return !0;
}, Obe = function() {
  if (this.toStringCache != null)
    return this.toStringCache;
  for (var e = function(h) {
    return h ?? "";
  }, r = function(h) {
    return Bt(h) ? '"' + h + '"' : e(h);
  }, n = function(h) {
    return " " + h + " ";
  }, i = function(h, d) {
    var f = h.type, p = h.value;
    switch (f) {
      case _t.GROUP: {
        var g = e(p);
        return g.substring(0, g.length - 1);
      }
      case _t.DATA_COMPARE: {
        var m = h.field, v = h.operator;
        return "[" + m + n(e(v)) + r(p) + "]";
      }
      case _t.DATA_BOOL: {
        var y = h.operator, b = h.field;
        return "[" + e(y) + b + "]";
      }
      case _t.DATA_EXIST: {
        var w = h.field;
        return "[" + w + "]";
      }
      case _t.META_COMPARE: {
        var T = h.operator, E = h.field;
        return "[[" + E + n(e(T)) + r(p) + "]]";
      }
      case _t.STATE:
        return p;
      case _t.ID:
        return "#" + p;
      case _t.CLASS:
        return "." + p;
      case _t.PARENT:
      case _t.CHILD:
        return a(h.parent, d) + n(">") + a(h.child, d);
      case _t.ANCESTOR:
      case _t.DESCENDANT:
        return a(h.ancestor, d) + " " + a(h.descendant, d);
      case _t.COMPOUND_SPLIT: {
        var L = a(h.left, d), k = a(h.subject, d), C = a(h.right, d);
        return L + (L.length > 0 ? " " : "") + k + C;
      }
      case _t.TRUE:
        return "";
    }
  }, a = function(h, d) {
    return h.checks.reduce(function(f, p, g) {
      return f + (d === h && g === 0 ? "$" : "") + i(p, d);
    }, "");
  }, s = "", o = 0; o < this.length; o++) {
    var l = this[o];
    s += a(l, l.subject), this.length > 1 && o < this.length - 1 && (s += ", ");
  }
  return this.toStringCache = s, s;
}, Pbe = {
  parse: Dbe,
  toString: Obe
}, KV = function(e, r, n) {
  var i, a = Bt(e), s = mt(e), o = Bt(n), l, u, h = !1, d = !1, f = !1;
  switch (r.indexOf("!") >= 0 && (r = r.replace("!", ""), d = !0), r.indexOf("@") >= 0 && (r = r.replace("@", ""), h = !0), (a || o || h) && (l = !a && !s ? "" : "" + e, u = "" + n), h && (e = l = l.toLowerCase(), n = u = u.toLowerCase()), r) {
    case "*=":
      i = l.indexOf(u) >= 0;
      break;
    case "$=":
      i = l.indexOf(u, l.length - u.length) >= 0;
      break;
    case "^=":
      i = l.indexOf(u) === 0;
      break;
    case "=":
      i = e === n;
      break;
    case ">":
      f = !0, i = e > n;
      break;
    case ">=":
      f = !0, i = e >= n;
      break;
    case "<":
      f = !0, i = e < n;
      break;
    case "<=":
      f = !0, i = e <= n;
      break;
    default:
      i = !1;
      break;
  }
  return d && (e != null || !f) && (i = !i), i;
}, Bbe = function(e, r) {
  switch (r) {
    case "?":
      return !!e;
    case "!":
      return !e;
    case "^":
      return e === void 0;
  }
}, Fbe = function(e) {
  return e !== void 0;
}, sS = function(e, r) {
  return e.data(r);
}, $be = function(e, r) {
  return e[r]();
}, hn = [], Wr = function(e, r) {
  return e.checks.every(function(n) {
    return hn[n.type](n, r);
  });
};
hn[_t.GROUP] = function(t, e) {
  var r = t.value;
  return r === "*" || r === e.group();
};
hn[_t.STATE] = function(t, e) {
  var r = t.value;
  return Rbe(r, e);
};
hn[_t.ID] = function(t, e) {
  var r = t.value;
  return e.id() === r;
};
hn[_t.CLASS] = function(t, e) {
  var r = t.value;
  return e.hasClass(r);
};
hn[_t.META_COMPARE] = function(t, e) {
  var r = t.field, n = t.operator, i = t.value;
  return KV($be(e, r), n, i);
};
hn[_t.DATA_COMPARE] = function(t, e) {
  var r = t.field, n = t.operator, i = t.value;
  return KV(sS(e, r), n, i);
};
hn[_t.DATA_BOOL] = function(t, e) {
  var r = t.field, n = t.operator;
  return Bbe(sS(e, r), n);
};
hn[_t.DATA_EXIST] = function(t, e) {
  var r = t.field;
  return t.operator, Fbe(sS(e, r));
};
hn[_t.UNDIRECTED_EDGE] = function(t, e) {
  var r = t.nodes[0], n = t.nodes[1], i = e.source(), a = e.target();
  return Wr(r, i) && Wr(n, a) || Wr(n, i) && Wr(r, a);
};
hn[_t.NODE_NEIGHBOR] = function(t, e) {
  return Wr(t.node, e) && e.neighborhood().some(function(r) {
    return r.isNode() && Wr(t.neighbor, r);
  });
};
hn[_t.DIRECTED_EDGE] = function(t, e) {
  return Wr(t.source, e.source()) && Wr(t.target, e.target());
};
hn[_t.NODE_SOURCE] = function(t, e) {
  return Wr(t.source, e) && e.outgoers().some(function(r) {
    return r.isNode() && Wr(t.target, r);
  });
};
hn[_t.NODE_TARGET] = function(t, e) {
  return Wr(t.target, e) && e.incomers().some(function(r) {
    return r.isNode() && Wr(t.source, r);
  });
};
hn[_t.CHILD] = function(t, e) {
  return Wr(t.child, e) && Wr(t.parent, e.parent());
};
hn[_t.PARENT] = function(t, e) {
  return Wr(t.parent, e) && e.children().some(function(r) {
    return Wr(t.child, r);
  });
};
hn[_t.DESCENDANT] = function(t, e) {
  return Wr(t.descendant, e) && e.ancestors().some(function(r) {
    return Wr(t.ancestor, r);
  });
};
hn[_t.ANCESTOR] = function(t, e) {
  return Wr(t.ancestor, e) && e.descendants().some(function(r) {
    return Wr(t.descendant, r);
  });
};
hn[_t.COMPOUND_SPLIT] = function(t, e) {
  return Wr(t.subject, e) && Wr(t.left, e) && Wr(t.right, e);
};
hn[_t.TRUE] = function() {
  return !0;
};
hn[_t.COLLECTION] = function(t, e) {
  var r = t.value;
  return r.has(e);
};
hn[_t.FILTER] = function(t, e) {
  var r = t.value;
  return r(e);
};
var zbe = function(e) {
  var r = this;
  if (r.length === 1 && r[0].checks.length === 1 && r[0].checks[0].type === _t.ID)
    return e.getElementById(r[0].checks[0].value).collection();
  var n = function(a) {
    for (var s = 0; s < r.length; s++) {
      var o = r[s];
      if (Wr(o, a))
        return !0;
    }
    return !1;
  };
  return r.text() == null && (n = function() {
    return !0;
  }), e.filter(n);
}, Gbe = function(e) {
  for (var r = this, n = 0; n < r.length; n++) {
    var i = r[n];
    if (Wr(i, e))
      return !0;
  }
  return !1;
}, Vbe = {
  matches: Gbe,
  filter: zbe
}, ec = function(e) {
  this.inputText = e, this.currentSubject = null, this.compoundCount = 0, this.edgeCount = 0, this.length = 0, e == null || Bt(e) && e.match(/^\s*$/) || (ka(e) ? this.addQuery({
    checks: [{
      type: _t.COLLECTION,
      value: e.collection()
    }]
  }) : an(e) ? this.addQuery({
    checks: [{
      type: _t.FILTER,
      value: e
    }]
  }) : Bt(e) ? this.parse(e) || (this.invalid = !0) : Zr("A selector must be created from a string; found "));
}, tc = ec.prototype;
[Pbe, Vbe].forEach(function(t) {
  return Gt(tc, t);
});
tc.text = function() {
  return this.inputText;
};
tc.size = function() {
  return this.length;
};
tc.eq = function(t) {
  return this[t];
};
tc.sameText = function(t) {
  return !this.invalid && !t.invalid && this.text() === t.text();
};
tc.addQuery = function(t) {
  this[this.length++] = t;
};
tc.selector = tc.toString;
var zl = {
  allAre: function(e) {
    var r = new ec(e);
    return this.every(function(n) {
      return r.matches(n);
    });
  },
  is: function(e) {
    var r = new ec(e);
    return this.some(function(n) {
      return r.matches(n);
    });
  },
  some: function(e, r) {
    for (var n = 0; n < this.length; n++) {
      var i = r ? e.apply(r, [this[n], n, this]) : e(this[n], n, this);
      if (i)
        return !0;
    }
    return !1;
  },
  every: function(e, r) {
    for (var n = 0; n < this.length; n++) {
      var i = r ? e.apply(r, [this[n], n, this]) : e(this[n], n, this);
      if (!i)
        return !1;
    }
    return !0;
  },
  same: function(e) {
    if (this === e)
      return !0;
    e = this.cy().collection(e);
    var r = this.length, n = e.length;
    return r !== n ? !1 : r === 1 ? this[0] === e[0] : this.every(function(i) {
      return e.hasElementWithId(i.id());
    });
  },
  anySame: function(e) {
    return e = this.cy().collection(e), this.some(function(r) {
      return e.hasElementWithId(r.id());
    });
  },
  allAreNeighbors: function(e) {
    e = this.cy().collection(e);
    var r = this.neighborhood();
    return e.every(function(n) {
      return r.hasElementWithId(n.id());
    });
  },
  contains: function(e) {
    e = this.cy().collection(e);
    var r = this;
    return e.every(function(n) {
      return r.hasElementWithId(n.id());
    });
  }
};
zl.allAreNeighbours = zl.allAreNeighbors;
zl.has = zl.contains;
zl.equal = zl.equals = zl.same;
var Xa = function(e, r) {
  return function(i, a, s, o) {
    var l = i, u = this, h;
    if (l == null ? h = "" : ka(l) && l.length === 1 && (h = l.id()), u.length === 1 && h) {
      var d = u[0]._private, f = d.traversalCache = d.traversalCache || {}, p = f[r] = f[r] || [], g = Cu(h), m = p[g];
      return m || (p[g] = e.call(u, i, a, s, o));
    } else
      return e.call(u, i, a, s, o);
  };
}, Md = {
  parent: function(e) {
    var r = [];
    if (this.length === 1) {
      var n = this[0]._private.parent;
      if (n)
        return n;
    }
    for (var i = 0; i < this.length; i++) {
      var a = this[i], s = a._private.parent;
      s && r.push(s);
    }
    return this.spawn(r, !0).filter(e);
  },
  parents: function(e) {
    for (var r = [], n = this.parent(); n.nonempty(); ) {
      for (var i = 0; i < n.length; i++) {
        var a = n[i];
        r.push(a);
      }
      n = n.parent();
    }
    return this.spawn(r, !0).filter(e);
  },
  commonAncestors: function(e) {
    for (var r, n = 0; n < this.length; n++) {
      var i = this[n], a = i.parents();
      r = r || a, r = r.intersect(a);
    }
    return r.filter(e);
  },
  orphans: function(e) {
    return this.stdFilter(function(r) {
      return r.isOrphan();
    }).filter(e);
  },
  nonorphans: function(e) {
    return this.stdFilter(function(r) {
      return r.isChild();
    }).filter(e);
  },
  children: Xa(function(t) {
    for (var e = [], r = 0; r < this.length; r++)
      for (var n = this[r], i = n._private.children, a = 0; a < i.length; a++)
        e.push(i[a]);
    return this.spawn(e, !0).filter(t);
  }, "children"),
  siblings: function(e) {
    return this.parent().children().not(this).filter(e);
  },
  isParent: function() {
    var e = this[0];
    if (e)
      return e.isNode() && e._private.children.length !== 0;
  },
  isChildless: function() {
    var e = this[0];
    if (e)
      return e.isNode() && e._private.children.length === 0;
  },
  isChild: function() {
    var e = this[0];
    if (e)
      return e.isNode() && e._private.parent != null;
  },
  isOrphan: function() {
    var e = this[0];
    if (e)
      return e.isNode() && e._private.parent == null;
  },
  descendants: function(e) {
    var r = [];
    function n(i) {
      for (var a = 0; a < i.length; a++) {
        var s = i[a];
        r.push(s), s.children().nonempty() && n(s.children());
      }
    }
    return n(this.children()), this.spawn(r, !0).filter(e);
  }
};
function oS(t, e, r, n) {
  for (var i = [], a = new tf(), s = t.cy(), o = s.hasCompoundNodes(), l = 0; l < t.length; l++) {
    var u = t[l];
    r ? i.push(u) : o && n(i, a, u);
  }
  for (; i.length > 0; ) {
    var h = i.shift();
    e(h), a.add(h.id()), o && n(i, a, h);
  }
  return t;
}
function ZV(t, e, r) {
  if (r.isParent())
    for (var n = r._private.children, i = 0; i < n.length; i++) {
      var a = n[i];
      e.has(a.id()) || t.push(a);
    }
}
Md.forEachDown = function(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return oS(this, t, e, ZV);
};
function QV(t, e, r) {
  if (r.isChild()) {
    var n = r._private.parent;
    e.has(n.id()) || t.push(n);
  }
}
Md.forEachUp = function(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return oS(this, t, e, QV);
};
function Ube(t, e, r) {
  QV(t, e, r), ZV(t, e, r);
}
Md.forEachUpAndDown = function(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return oS(this, t, e, Ube);
};
Md.ancestors = Md.parents;
var Fp, JV;
Fp = JV = {
  data: Ar.data({
    field: "data",
    bindingEvent: "data",
    allowBinding: !0,
    allowSetting: !0,
    settingEvent: "data",
    settingTriggersEvent: !0,
    triggerFnName: "trigger",
    allowGetting: !0,
    immutableKeys: {
      id: !0,
      source: !0,
      target: !0,
      parent: !0
    },
    updateStyle: !0
  }),
  removeData: Ar.removeData({
    field: "data",
    event: "data",
    triggerFnName: "trigger",
    triggerEvent: !0,
    immutableKeys: {
      id: !0,
      source: !0,
      target: !0,
      parent: !0
    },
    updateStyle: !0
  }),
  scratch: Ar.data({
    field: "scratch",
    bindingEvent: "scratch",
    allowBinding: !0,
    allowSetting: !0,
    settingEvent: "scratch",
    settingTriggersEvent: !0,
    triggerFnName: "trigger",
    allowGetting: !0,
    updateStyle: !0
  }),
  removeScratch: Ar.removeData({
    field: "scratch",
    event: "scratch",
    triggerFnName: "trigger",
    triggerEvent: !0,
    updateStyle: !0
  }),
  rscratch: Ar.data({
    field: "rscratch",
    allowBinding: !1,
    allowSetting: !0,
    settingTriggersEvent: !1,
    allowGetting: !0
  }),
  removeRscratch: Ar.removeData({
    field: "rscratch",
    triggerEvent: !1
  }),
  id: function() {
    var e = this[0];
    if (e)
      return e._private.data.id;
  }
};
Fp.attr = Fp.data;
Fp.removeAttr = Fp.removeData;
var Hbe = JV, Dx = {};
function Z3(t) {
  return function(e) {
    var r = this;
    if (e === void 0 && (e = !0), r.length !== 0)
      if (r.isNode() && !r.removed()) {
        for (var n = 0, i = r[0], a = i._private.edges, s = 0; s < a.length; s++) {
          var o = a[s];
          !e && o.isLoop() || (n += t(i, o));
        }
        return n;
      } else
        return;
  };
}
Gt(Dx, {
  degree: Z3(function(t, e) {
    return e.source().same(e.target()) ? 2 : 1;
  }),
  indegree: Z3(function(t, e) {
    return e.target().same(t) ? 1 : 0;
  }),
  outdegree: Z3(function(t, e) {
    return e.source().same(t) ? 1 : 0;
  })
});
function xh(t, e) {
  return function(r) {
    for (var n, i = this.nodes(), a = 0; a < i.length; a++) {
      var s = i[a], o = s[t](r);
      o !== void 0 && (n === void 0 || e(o, n)) && (n = o);
    }
    return n;
  };
}
Gt(Dx, {
  minDegree: xh("degree", function(t, e) {
    return t < e;
  }),
  maxDegree: xh("degree", function(t, e) {
    return t > e;
  }),
  minIndegree: xh("indegree", function(t, e) {
    return t < e;
  }),
  maxIndegree: xh("indegree", function(t, e) {
    return t > e;
  }),
  minOutdegree: xh("outdegree", function(t, e) {
    return t < e;
  }),
  maxOutdegree: xh("outdegree", function(t, e) {
    return t > e;
  })
});
Gt(Dx, {
  totalDegree: function(e) {
    for (var r = 0, n = this.nodes(), i = 0; i < n.length; i++)
      r += n[i].degree(e);
    return r;
  }
});
var bs, eU, tU = function(e, r, n) {
  for (var i = 0; i < e.length; i++) {
    var a = e[i];
    if (!a.locked()) {
      var s = a._private.position, o = {
        x: r.x != null ? r.x - s.x : 0,
        y: r.y != null ? r.y - s.y : 0
      };
      a.isParent() && !(o.x === 0 && o.y === 0) && a.children().shift(o, n), a.dirtyBoundingBoxCache();
    }
  }
}, $9 = {
  field: "position",
  bindingEvent: "position",
  allowBinding: !0,
  allowSetting: !0,
  settingEvent: "position",
  settingTriggersEvent: !0,
  triggerFnName: "emitAndNotify",
  allowGetting: !0,
  validKeys: ["x", "y"],
  beforeGet: function(e) {
    e.updateCompoundBounds();
  },
  beforeSet: function(e, r) {
    tU(e, r, !1);
  },
  onSet: function(e) {
    e.dirtyCompoundBoundsCache();
  },
  canSet: function(e) {
    return !e.locked();
  }
};
bs = eU = {
  position: Ar.data($9),
  // position but no notification to renderer
  silentPosition: Ar.data(Gt({}, $9, {
    allowBinding: !1,
    allowSetting: !0,
    settingTriggersEvent: !1,
    allowGetting: !1,
    beforeSet: function(e, r) {
      tU(e, r, !0);
    },
    onSet: function(e) {
      e.dirtyCompoundBoundsCache();
    }
  })),
  positions: function(e, r) {
    if (mr(e))
      r ? this.silentPosition(e) : this.position(e);
    else if (an(e)) {
      var n = e, i = this.cy();
      i.startBatch();
      for (var a = 0; a < this.length; a++) {
        var s = this[a], o = void 0;
        (o = n(s, a)) && (r ? s.silentPosition(o) : s.position(o));
      }
      i.endBatch();
    }
    return this;
  },
  silentPositions: function(e) {
    return this.positions(e, !0);
  },
  shift: function(e, r, n) {
    var i;
    if (mr(e) ? (i = {
      x: mt(e.x) ? e.x : 0,
      y: mt(e.y) ? e.y : 0
    }, n = r) : Bt(e) && mt(r) && (i = {
      x: 0,
      y: 0
    }, i[e] = r), i != null) {
      var a = this.cy();
      a.startBatch();
      for (var s = 0; s < this.length; s++) {
        var o = this[s];
        if (!(a.hasCompoundNodes() && o.isChild() && o.ancestors().anySame(this))) {
          var l = o.position(), u = {
            x: l.x + i.x,
            y: l.y + i.y
          };
          n ? o.silentPosition(u) : o.position(u);
        }
      }
      a.endBatch();
    }
    return this;
  },
  silentShift: function(e, r) {
    return mr(e) ? this.shift(e, !0) : Bt(e) && mt(r) && this.shift(e, r, !0), this;
  },
  // get/set the rendered (i.e. on screen) positon of the element
  renderedPosition: function(e, r) {
    var n = this[0], i = this.cy(), a = i.zoom(), s = i.pan(), o = mr(e) ? e : void 0, l = o !== void 0 || r !== void 0 && Bt(e);
    if (n && n.isNode())
      if (l)
        for (var u = 0; u < this.length; u++) {
          var h = this[u];
          r !== void 0 ? h.position(e, (r - s[e]) / a) : o !== void 0 && h.position(LV(o, a, s));
        }
      else {
        var d = n.position();
        return o = _x(d, a, s), e === void 0 ? o : o[e];
      }
    else if (!l)
      return;
    return this;
  },
  // get/set the position relative to the parent
  relativePosition: function(e, r) {
    var n = this[0], i = this.cy(), a = mr(e) ? e : void 0, s = a !== void 0 || r !== void 0 && Bt(e), o = i.hasCompoundNodes();
    if (n && n.isNode())
      if (s)
        for (var l = 0; l < this.length; l++) {
          var u = this[l], h = o ? u.parent() : null, d = h && h.length > 0, f = d;
          d && (h = h[0]);
          var p = f ? h.position() : {
            x: 0,
            y: 0
          };
          r !== void 0 ? u.position(e, r + p[e]) : a !== void 0 && u.position({
            x: a.x + p.x,
            y: a.y + p.y
          });
        }
      else {
        var g = n.position(), m = o ? n.parent() : null, v = m && m.length > 0, y = v;
        v && (m = m[0]);
        var b = y ? m.position() : {
          x: 0,
          y: 0
        };
        return a = {
          x: g.x - b.x,
          y: g.y - b.y
        }, e === void 0 ? a : a[e];
      }
    else if (!s)
      return;
    return this;
  }
};
bs.modelPosition = bs.point = bs.position;
bs.modelPositions = bs.points = bs.positions;
bs.renderedPoint = bs.renderedPosition;
bs.relativePoint = bs.relativePosition;
var qbe = eU, id, yc;
id = yc = {};
yc.renderedBoundingBox = function(t) {
  var e = this.boundingBox(t), r = this.cy(), n = r.zoom(), i = r.pan(), a = e.x1 * n + i.x, s = e.x2 * n + i.x, o = e.y1 * n + i.y, l = e.y2 * n + i.y;
  return {
    x1: a,
    x2: s,
    y1: o,
    y2: l,
    w: s - a,
    h: l - o
  };
};
yc.dirtyCompoundBoundsCache = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, e = this.cy();
  return !e.styleEnabled() || !e.hasCompoundNodes() ? this : (this.forEachUp(function(r) {
    if (r.isParent()) {
      var n = r._private;
      n.compoundBoundsClean = !1, n.bbCache = null, t || r.emitAndNotify("bounds");
    }
  }), this);
};
yc.updateCompoundBounds = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, e = this.cy();
  if (!e.styleEnabled() || !e.hasCompoundNodes())
    return this;
  if (!t && e.batching())
    return this;
  function r(s) {
    if (!s.isParent())
      return;
    var o = s._private, l = s.children(), u = s.pstyle("compound-sizing-wrt-labels").value === "include", h = {
      width: {
        val: s.pstyle("min-width").pfValue,
        left: s.pstyle("min-width-bias-left"),
        right: s.pstyle("min-width-bias-right")
      },
      height: {
        val: s.pstyle("min-height").pfValue,
        top: s.pstyle("min-height-bias-top"),
        bottom: s.pstyle("min-height-bias-bottom")
      }
    }, d = l.boundingBox({
      includeLabels: u,
      includeOverlays: !1,
      // updating the compound bounds happens outside of the regular
      // cache cycle (i.e. before fired events)
      useCache: !1
    }), f = o.position;
    (d.w === 0 || d.h === 0) && (d = {
      w: s.pstyle("width").pfValue,
      h: s.pstyle("height").pfValue
    }, d.x1 = f.x - d.w / 2, d.x2 = f.x + d.w / 2, d.y1 = f.y - d.h / 2, d.y2 = f.y + d.h / 2);
    function p(A, R, _) {
      var O = 0, P = 0, S = R + _;
      return A > 0 && S > 0 && (O = R / S * A, P = _ / S * A), {
        biasDiff: O,
        biasComplementDiff: P
      };
    }
    function g(A, R, _, O) {
      if (_.units === "%")
        switch (O) {
          case "width":
            return A > 0 ? _.pfValue * A : 0;
          case "height":
            return R > 0 ? _.pfValue * R : 0;
          case "average":
            return A > 0 && R > 0 ? _.pfValue * (A + R) / 2 : 0;
          case "min":
            return A > 0 && R > 0 ? A > R ? _.pfValue * R : _.pfValue * A : 0;
          case "max":
            return A > 0 && R > 0 ? A > R ? _.pfValue * A : _.pfValue * R : 0;
          default:
            return 0;
        }
      else return _.units === "px" ? _.pfValue : 0;
    }
    var m = h.width.left.value;
    h.width.left.units === "px" && h.width.val > 0 && (m = m * 100 / h.width.val);
    var v = h.width.right.value;
    h.width.right.units === "px" && h.width.val > 0 && (v = v * 100 / h.width.val);
    var y = h.height.top.value;
    h.height.top.units === "px" && h.height.val > 0 && (y = y * 100 / h.height.val);
    var b = h.height.bottom.value;
    h.height.bottom.units === "px" && h.height.val > 0 && (b = b * 100 / h.height.val);
    var w = p(h.width.val - d.w, m, v), T = w.biasDiff, E = w.biasComplementDiff, L = p(h.height.val - d.h, y, b), k = L.biasDiff, C = L.biasComplementDiff;
    o.autoPadding = g(d.w, d.h, s.pstyle("padding"), s.pstyle("padding-relative-to").value), o.autoWidth = Math.max(d.w, h.width.val), f.x = (-T + d.x1 + d.x2 + E) / 2, o.autoHeight = Math.max(d.h, h.height.val), f.y = (-k + d.y1 + d.y2 + C) / 2;
  }
  for (var n = 0; n < this.length; n++) {
    var i = this[n], a = i._private;
    (!a.compoundBoundsClean || t) && (r(i), e.batching() || (a.compoundBoundsClean = !0));
  }
  return this;
};
var Va = function(e) {
  return e === 1 / 0 || e === -1 / 0 ? 0 : e;
}, hs = function(e, r, n, i, a) {
  i - r === 0 || a - n === 0 || r == null || n == null || i == null || a == null || (e.x1 = r < e.x1 ? r : e.x1, e.x2 = i > e.x2 ? i : e.x2, e.y1 = n < e.y1 ? n : e.y1, e.y2 = a > e.y2 ? a : e.y2, e.w = e.x2 - e.x1, e.h = e.y2 - e.y1);
}, Cl = function(e, r) {
  return r == null ? e : hs(e, r.x1, r.y1, r.x2, r.y2);
}, Mf = function(e, r, n) {
  return na(e, r, n);
}, N1 = function(e, r, n) {
  if (!r.cy().headless()) {
    var i = r._private, a = i.rstyle, s = a.arrowWidth / 2, o = r.pstyle(n + "-arrow-shape").value, l, u;
    if (o !== "none") {
      n === "source" ? (l = a.srcX, u = a.srcY) : n === "target" ? (l = a.tgtX, u = a.tgtY) : (l = a.midX, u = a.midY);
      var h = i.arrowBounds = i.arrowBounds || {}, d = h[n] = h[n] || {};
      d.x1 = l - s, d.y1 = u - s, d.x2 = l + s, d.y2 = u + s, d.w = d.x2 - d.x1, d.h = d.y2 - d.y1, Om(d, 1), hs(e, d.x1, d.y1, d.x2, d.y2);
    }
  }
}, Q3 = function(e, r, n) {
  if (!r.cy().headless()) {
    var i;
    n ? i = n + "-" : i = "";
    var a = r._private, s = a.rstyle, o = r.pstyle(i + "label").strValue;
    if (o) {
      var l = r.pstyle("text-halign"), u = r.pstyle("text-valign"), h = Mf(s, "labelWidth", n), d = Mf(s, "labelHeight", n), f = Mf(s, "labelX", n), p = Mf(s, "labelY", n), g = r.pstyle(i + "text-margin-x").pfValue, m = r.pstyle(i + "text-margin-y").pfValue, v = r.isEdge(), y = r.pstyle(i + "text-rotation"), b = r.pstyle("text-outline-width").pfValue, w = r.pstyle("text-border-width").pfValue, T = w / 2, E = r.pstyle("text-background-padding").pfValue, L = 2, k = d, C = h, A = C / 2, R = k / 2, _, O, P, S;
      if (v)
        _ = f - A, O = f + A, P = p - R, S = p + R;
      else {
        switch (l.value) {
          case "left":
            _ = f - C, O = f;
            break;
          case "center":
            _ = f - A, O = f + A;
            break;
          case "right":
            _ = f, O = f + C;
            break;
        }
        switch (u.value) {
          case "top":
            P = p - k, S = p;
            break;
          case "center":
            P = p - R, S = p + R;
            break;
          case "bottom":
            P = p, S = p + k;
            break;
        }
      }
      var M = g - Math.max(b, T) - E - L, N = g + Math.max(b, T) + E + L, D = m - Math.max(b, T) - E - L, I = m + Math.max(b, T) + E + L;
      _ += M, O += N, P += D, S += I;
      var B = n || "main", z = a.labelBounds, F = z[B] = z[B] || {};
      F.x1 = _, F.y1 = P, F.x2 = O, F.y2 = S, F.w = O - _, F.h = S - P, F.leftPad = M, F.rightPad = N, F.topPad = D, F.botPad = I;
      var V = v && y.strValue === "autorotate", H = y.pfValue != null && y.pfValue !== 0;
      if (V || H) {
        var J = V ? Mf(a.rstyle, "labelAngle", n) : y.pfValue, q = Math.cos(J), ae = Math.sin(J), re = (_ + O) / 2, pe = (P + S) / 2;
        if (!v) {
          switch (l.value) {
            case "left":
              re = O;
              break;
            case "right":
              re = _;
              break;
          }
          switch (u.value) {
            case "top":
              pe = S;
              break;
            case "bottom":
              pe = P;
              break;
          }
        }
        var K = function(Ae, W) {
          return Ae = Ae - re, W = W - pe, {
            x: Ae * q - W * ae + re,
            y: Ae * ae + W * q + pe
          };
        }, Z = K(_, P), X = K(_, S), Y = K(O, P), ee = K(O, S);
        _ = Math.min(Z.x, X.x, Y.x, ee.x), O = Math.max(Z.x, X.x, Y.x, ee.x), P = Math.min(Z.y, X.y, Y.y, ee.y), S = Math.max(Z.y, X.y, Y.y, ee.y);
      }
      var j = B + "Rot", fe = z[j] = z[j] || {};
      fe.x1 = _, fe.y1 = P, fe.x2 = O, fe.y2 = S, fe.w = O - _, fe.h = S - P, hs(e, _, P, O, S), hs(a.labelBounds.all, _, P, O, S);
    }
    return e;
  }
}, z9 = function(e, r) {
  if (!r.cy().headless()) {
    var n = r.pstyle("outline-opacity").value, i = r.pstyle("outline-width").value, a = r.pstyle("outline-offset").value, s = i + a;
    rU(e, r, n, s, "outside", s / 2);
  }
}, rU = function(e, r, n, i, a, s) {
  if (!(n === 0 || i <= 0 || a === "inside")) {
    var o = r.cy(), l = r.pstyle("shape").value, u = o.renderer().nodeShapes[l], h = r.position(), d = h.x, f = h.y, p = r.width(), g = r.height();
    if (u.hasMiterBounds) {
      a === "center" && (i /= 2);
      var m = u.miterBounds(d, f, p, g, i);
      Cl(e, m);
    } else s != null && s > 0 && Pm(e, [s, s, s, s]);
  }
}, Wbe = function(e, r) {
  if (!r.cy().headless()) {
    var n = r.pstyle("border-opacity").value, i = r.pstyle("border-width").pfValue, a = r.pstyle("border-position").value;
    rU(e, r, n, i, a);
  }
}, Ybe = function(e, r) {
  var n = e._private.cy, i = n.styleEnabled(), a = n.headless(), s = qi(), o = e._private, l = e.isNode(), u = e.isEdge(), h, d, f, p, g, m, v = o.rstyle, y = l && i ? e.pstyle("bounds-expansion").pfValue : [0], b = function(te) {
    return te.pstyle("display").value !== "none";
  }, w = !i || b(e) && (!u || b(e.source()) && b(e.target()));
  if (w) {
    var T = 0, E = 0;
    i && r.includeOverlays && (T = e.pstyle("overlay-opacity").value, T !== 0 && (E = e.pstyle("overlay-padding").value));
    var L = 0, k = 0;
    i && r.includeUnderlays && (L = e.pstyle("underlay-opacity").value, L !== 0 && (k = e.pstyle("underlay-padding").value));
    var C = Math.max(E, k), A = 0, R = 0;
    if (i && (A = e.pstyle("width").pfValue, R = A / 2), l && r.includeNodes) {
      var _ = e.position();
      g = _.x, m = _.y;
      var O = e.outerWidth(), P = O / 2, S = e.outerHeight(), M = S / 2;
      h = g - P, d = g + P, f = m - M, p = m + M, hs(s, h, f, d, p), i && z9(s, e), i && r.includeOutlines && !a && z9(s, e), i && Wbe(s, e);
    } else if (u && r.includeEdges)
      if (i && !a) {
        var N = e.pstyle("curve-style").strValue;
        if (h = Math.min(v.srcX, v.midX, v.tgtX), d = Math.max(v.srcX, v.midX, v.tgtX), f = Math.min(v.srcY, v.midY, v.tgtY), p = Math.max(v.srcY, v.midY, v.tgtY), h -= R, d += R, f -= R, p += R, hs(s, h, f, d, p), N === "haystack") {
          var D = v.haystackPts;
          if (D && D.length === 2) {
            if (h = D[0].x, f = D[0].y, d = D[1].x, p = D[1].y, h > d) {
              var I = h;
              h = d, d = I;
            }
            if (f > p) {
              var B = f;
              f = p, p = B;
            }
            hs(s, h - R, f - R, d + R, p + R);
          }
        } else if (N === "bezier" || N === "unbundled-bezier" || Il(N, "segments") || Il(N, "taxi")) {
          var z;
          switch (N) {
            case "bezier":
            case "unbundled-bezier":
              z = v.bezierPts;
              break;
            case "segments":
            case "taxi":
            case "round-segments":
            case "round-taxi":
              z = v.linePts;
              break;
          }
          if (z != null)
            for (var F = 0; F < z.length; F++) {
              var V = z[F];
              h = V.x - R, d = V.x + R, f = V.y - R, p = V.y + R, hs(s, h, f, d, p);
            }
        }
      } else {
        var H = e.source(), J = H.position(), q = e.target(), ae = q.position();
        if (h = J.x, d = ae.x, f = J.y, p = ae.y, h > d) {
          var re = h;
          h = d, d = re;
        }
        if (f > p) {
          var pe = f;
          f = p, p = pe;
        }
        h -= R, d += R, f -= R, p += R, hs(s, h, f, d, p);
      }
    if (i && r.includeEdges && u && (N1(s, e, "mid-source"), N1(s, e, "mid-target"), N1(s, e, "source"), N1(s, e, "target")), i) {
      var K = e.pstyle("ghost").value === "yes";
      if (K) {
        var Z = e.pstyle("ghost-offset-x").pfValue, X = e.pstyle("ghost-offset-y").pfValue;
        hs(s, s.x1 + Z, s.y1 + X, s.x2 + Z, s.y2 + X);
      }
    }
    var Y = o.bodyBounds = o.bodyBounds || {};
    S_(Y, s), Pm(Y, y), Om(Y, 1), i && (h = s.x1, d = s.x2, f = s.y1, p = s.y2, hs(s, h - C, f - C, d + C, p + C));
    var ee = o.overlayBounds = o.overlayBounds || {};
    S_(ee, s), Pm(ee, y), Om(ee, 1);
    var j = o.labelBounds = o.labelBounds || {};
    j.all != null ? _2e(j.all) : j.all = qi(), i && r.includeLabels && (r.includeMainLabels && Q3(s, e, null), u && (r.includeSourceLabels && Q3(s, e, "source"), r.includeTargetLabels && Q3(s, e, "target")));
  }
  return s.x1 = Va(s.x1), s.y1 = Va(s.y1), s.x2 = Va(s.x2), s.y2 = Va(s.y2), s.w = Va(s.x2 - s.x1), s.h = Va(s.y2 - s.y1), s.w > 0 && s.h > 0 && w && (Pm(s, y), Om(s, 1)), s;
}, nU = function(e) {
  var r = 0, n = function(s) {
    return (s ? 1 : 0) << r++;
  }, i = 0;
  return i += n(e.incudeNodes), i += n(e.includeEdges), i += n(e.includeLabels), i += n(e.includeMainLabels), i += n(e.includeSourceLabels), i += n(e.includeTargetLabels), i += n(e.includeOverlays), i += n(e.includeOutlines), i;
}, iU = function(e) {
  var r = function(o) {
    return Math.round(o);
  };
  if (e.isEdge()) {
    var n = e.source().position(), i = e.target().position();
    return x_([r(n.x), r(n.y), r(i.x), r(i.y)]);
  } else {
    var a = e.position();
    return x_([r(a.x), r(a.y)]);
  }
}, G9 = function(e, r) {
  var n = e._private, i, a = e.isEdge(), s = r == null ? V9 : nU(r), o = s === V9;
  if (n.bbCache == null ? (i = Ybe(e, $p), n.bbCache = i, n.bbCachePosKey = iU(e)) : i = n.bbCache, !o) {
    var l = e.isNode();
    i = qi(), (r.includeNodes && l || r.includeEdges && !l) && (r.includeOverlays ? Cl(i, n.overlayBounds) : Cl(i, n.bodyBounds)), r.includeLabels && (r.includeMainLabels && (!a || r.includeSourceLabels && r.includeTargetLabels) ? Cl(i, n.labelBounds.all) : (r.includeMainLabels && Cl(i, n.labelBounds.mainRot), r.includeSourceLabels && Cl(i, n.labelBounds.sourceRot), r.includeTargetLabels && Cl(i, n.labelBounds.targetRot))), i.w = i.x2 - i.x1, i.h = i.y2 - i.y1;
  }
  return i;
}, $p = {
  includeNodes: !0,
  includeEdges: !0,
  includeLabels: !0,
  includeMainLabels: !0,
  includeSourceLabels: !0,
  includeTargetLabels: !0,
  includeOverlays: !0,
  includeUnderlays: !0,
  includeOutlines: !0,
  useCache: !0
}, V9 = nU($p), U9 = fi($p);
yc.boundingBox = function(t) {
  var e, r = t === void 0 || t.useCache === void 0 || t.useCache === !0, n = Ld(function(h) {
    var d = h._private;
    return d.bbCache == null || d.styleDirty || d.bbCachePosKey !== iU(h);
  }, function(h) {
    return h.id();
  });
  if (r && this.length === 1 && !n(this[0]))
    t === void 0 ? t = $p : t = U9(t), e = G9(this[0], t);
  else {
    e = qi(), t = t || $p;
    var i = U9(t), a = this, s = a.cy(), o = s.styleEnabled();
    this.edges().forEach(n), this.nodes().forEach(n), o && this.recalculateRenderedStyle(r), this.updateCompoundBounds(!r);
    for (var l = 0; l < a.length; l++) {
      var u = a[l];
      n(u) && u.dirtyBoundingBoxCache(), Cl(e, G9(u, i));
    }
  }
  return e.x1 = Va(e.x1), e.y1 = Va(e.y1), e.x2 = Va(e.x2), e.y2 = Va(e.y2), e.w = Va(e.x2 - e.x1), e.h = Va(e.y2 - e.y1), e;
};
yc.dirtyBoundingBoxCache = function() {
  for (var t = 0; t < this.length; t++) {
    var e = this[t]._private;
    e.bbCache = null, e.bbCachePosKey = null, e.bodyBounds = null, e.overlayBounds = null, e.labelBounds.all = null, e.labelBounds.source = null, e.labelBounds.target = null, e.labelBounds.main = null, e.labelBounds.sourceRot = null, e.labelBounds.targetRot = null, e.labelBounds.mainRot = null, e.arrowBounds.source = null, e.arrowBounds.target = null, e.arrowBounds["mid-source"] = null, e.arrowBounds["mid-target"] = null;
  }
  return this.emitAndNotify("bounds"), this;
};
yc.boundingBoxAt = function(t) {
  var e = this.nodes(), r = this.cy(), n = r.hasCompoundNodes(), i = r.collection();
  if (n && (i = e.filter(function(u) {
    return u.isParent();
  }), e = e.not(i)), mr(t)) {
    var a = t;
    t = function() {
      return a;
    };
  }
  var s = function(h, d) {
    return h._private.bbAtOldPos = t(h, d);
  }, o = function(h) {
    return h._private.bbAtOldPos;
  };
  r.startBatch(), e.forEach(s).silentPositions(t), n && (i.dirtyCompoundBoundsCache(), i.dirtyBoundingBoxCache(), i.updateCompoundBounds(!0));
  var l = A2e(this.boundingBox({
    useCache: !1
  }));
  return e.silentPositions(o), n && (i.dirtyCompoundBoundsCache(), i.dirtyBoundingBoxCache(), i.updateCompoundBounds(!0)), r.endBatch(), l;
};
id.boundingbox = id.bb = id.boundingBox;
id.renderedBoundingbox = id.renderedBoundingBox;
var Xbe = yc, t0, Lg;
t0 = Lg = {};
var aU = function(e) {
  e.uppercaseName = i_(e.name), e.autoName = "auto" + e.uppercaseName, e.labelName = "label" + e.uppercaseName, e.outerName = "outer" + e.uppercaseName, e.uppercaseOuterName = i_(e.outerName), t0[e.name] = function() {
    var n = this[0], i = n._private, a = i.cy, s = a._private.styleEnabled;
    if (n)
      if (s) {
        if (n.isParent())
          return n.updateCompoundBounds(), i[e.autoName] || 0;
        var o = n.pstyle(e.name);
        return o.strValue === "label" ? (n.recalculateRenderedStyle(), i.rstyle[e.labelName] || 0) : o.pfValue;
      } else
        return 1;
  }, t0["outer" + e.uppercaseName] = function() {
    var n = this[0], i = n._private, a = i.cy, s = a._private.styleEnabled;
    if (n)
      if (s) {
        var o = n[e.name](), l = n.pstyle("border-position").value, u;
        l === "center" ? u = n.pstyle("border-width").pfValue : l === "outside" ? u = 2 * n.pstyle("border-width").pfValue : u = 0;
        var h = 2 * n.padding();
        return o + u + h;
      } else
        return 1;
  }, t0["rendered" + e.uppercaseName] = function() {
    var n = this[0];
    if (n) {
      var i = n[e.name]();
      return i * this.cy().zoom();
    }
  }, t0["rendered" + e.uppercaseOuterName] = function() {
    var n = this[0];
    if (n) {
      var i = n[e.outerName]();
      return i * this.cy().zoom();
    }
  };
};
aU({
  name: "width"
});
aU({
  name: "height"
});
Lg.padding = function() {
  var t = this[0], e = t._private;
  return t.isParent() ? (t.updateCompoundBounds(), e.autoPadding !== void 0 ? e.autoPadding : t.pstyle("padding").pfValue) : t.pstyle("padding").pfValue;
};
Lg.paddedHeight = function() {
  var t = this[0];
  return t.height() + 2 * t.padding();
};
Lg.paddedWidth = function() {
  var t = this[0];
  return t.width() + 2 * t.padding();
};
var jbe = Lg, Kbe = function(e, r) {
  if (e.isEdge() && e.takesUpSpace())
    return r(e);
}, Zbe = function(e, r) {
  if (e.isEdge() && e.takesUpSpace()) {
    var n = e.cy();
    return _x(r(e), n.zoom(), n.pan());
  }
}, Qbe = function(e, r) {
  if (e.isEdge() && e.takesUpSpace()) {
    var n = e.cy(), i = n.pan(), a = n.zoom();
    return r(e).map(function(s) {
      return _x(s, a, i);
    });
  }
}, Jbe = function(e) {
  return e.renderer().getControlPoints(e);
}, e4e = function(e) {
  return e.renderer().getSegmentPoints(e);
}, t4e = function(e) {
  return e.renderer().getSourceEndpoint(e);
}, r4e = function(e) {
  return e.renderer().getTargetEndpoint(e);
}, n4e = function(e) {
  return e.renderer().getEdgeMidpoint(e);
}, H9 = {
  controlPoints: {
    get: Jbe,
    mult: !0
  },
  segmentPoints: {
    get: e4e,
    mult: !0
  },
  sourceEndpoint: {
    get: t4e
  },
  targetEndpoint: {
    get: r4e
  },
  midpoint: {
    get: n4e
  }
}, i4e = function(e) {
  return "rendered" + e[0].toUpperCase() + e.substr(1);
}, a4e = Object.keys(H9).reduce(function(t, e) {
  var r = H9[e], n = i4e(e);
  return t[e] = function() {
    return Kbe(this, r.get);
  }, r.mult ? t[n] = function() {
    return Qbe(this, r.get);
  } : t[n] = function() {
    return Zbe(this, r.get);
  }, t;
}, {}), s4e = Gt({}, qbe, Xbe, jbe, a4e);
var sU = function(e, r) {
  this.recycle(e, r);
};
function Nf() {
  return !1;
}
function I1() {
  return !0;
}
sU.prototype = {
  instanceString: function() {
    return "event";
  },
  recycle: function(e, r) {
    if (this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = Nf, e != null && e.preventDefault ? (this.type = e.type, this.isDefaultPrevented = e.defaultPrevented ? I1 : Nf) : e != null && e.type ? r = e : this.type = e, r != null && (this.originalEvent = r.originalEvent, this.type = r.type != null ? r.type : this.type, this.cy = r.cy, this.target = r.target, this.position = r.position, this.renderedPosition = r.renderedPosition, this.namespace = r.namespace, this.layout = r.layout), this.cy != null && this.position != null && this.renderedPosition == null) {
      var n = this.position, i = this.cy.zoom(), a = this.cy.pan();
      this.renderedPosition = {
        x: n.x * i + a.x,
        y: n.y * i + a.y
      };
    }
    this.timeStamp = e && e.timeStamp || Date.now();
  },
  preventDefault: function() {
    this.isDefaultPrevented = I1;
    var e = this.originalEvent;
    e && e.preventDefault && e.preventDefault();
  },
  stopPropagation: function() {
    this.isPropagationStopped = I1;
    var e = this.originalEvent;
    e && e.stopPropagation && e.stopPropagation();
  },
  stopImmediatePropagation: function() {
    this.isImmediatePropagationStopped = I1, this.stopPropagation();
  },
  isDefaultPrevented: Nf,
  isPropagationStopped: Nf,
  isImmediatePropagationStopped: Nf
};
var oU = /^([^.]+)(\.(?:[^.]+))?$/, o4e = ".*", lU = {
  qualifierCompare: function(e, r) {
    return e === r;
  },
  eventMatches: function() {
    return !0;
  },
  addEventFields: function() {
  },
  callbackContext: function(e) {
    return e;
  },
  beforeEmit: function() {
  },
  afterEmit: function() {
  },
  bubble: function() {
    return !1;
  },
  parent: function() {
    return null;
  },
  context: null
}, q9 = Object.keys(lU), l4e = {};
function Ox() {
  for (var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : l4e, e = arguments.length > 1 ? arguments[1] : void 0, r = 0; r < q9.length; r++) {
    var n = q9[r];
    this[n] = t[n] || lU[n];
  }
  this.context = e || this.context, this.listeners = [], this.emitting = 0;
}
var rc = Ox.prototype, cU = function(e, r, n, i, a, s, o) {
  an(i) && (a = i, i = null), o && (s == null ? s = o : s = Gt({}, s, o));
  for (var l = Or(n) ? n : n.split(/\s+/), u = 0; u < l.length; u++) {
    var h = l[u];
    if (!Zl(h)) {
      var d = h.match(oU);
      if (d) {
        var f = d[1], p = d[2] ? d[2] : null, g = r(e, h, f, p, i, a, s);
        if (g === !1)
          break;
      }
    }
  }
}, W9 = function(e, r) {
  return e.addEventFields(e.context, r), new sU(r.type, r);
}, c4e = function(e, r, n) {
  if (gye(n)) {
    r(e, n);
    return;
  } else if (mr(n)) {
    r(e, W9(e, n));
    return;
  }
  for (var i = Or(n) ? n : n.split(/\s+/), a = 0; a < i.length; a++) {
    var s = i[a];
    if (!Zl(s)) {
      var o = s.match(oU);
      if (o) {
        var l = o[1], u = o[2] ? o[2] : null, h = W9(e, {
          type: l,
          namespace: u,
          target: e.context
        });
        r(e, h);
      }
    }
  }
};
rc.on = rc.addListener = function(t, e, r, n, i) {
  return cU(this, function(a, s, o, l, u, h, d) {
    an(h) && a.listeners.push({
      event: s,
      // full event string
      callback: h,
      // callback to run
      type: o,
      // the event type (e.g. 'click')
      namespace: l,
      // the event namespace (e.g. ".foo")
      qualifier: u,
      // a restriction on whether to match this emitter
      conf: d
      // additional configuration
    });
  }, t, e, r, n, i), this;
};
rc.one = function(t, e, r, n) {
  return this.on(t, e, r, n, {
    one: !0
  });
};
rc.removeListener = rc.off = function(t, e, r, n) {
  var i = this;
  this.emitting !== 0 && (this.listeners = Zye(this.listeners));
  for (var a = this.listeners, s = function(u) {
    var h = a[u];
    cU(i, function(d, f, p, g, m, v) {
      if ((h.type === p || t === "*") && (!g && h.namespace !== ".*" || h.namespace === g) && (!m || d.qualifierCompare(h.qualifier, m)) && (!v || h.callback === v))
        return a.splice(u, 1), !1;
    }, t, e, r, n);
  }, o = a.length - 1; o >= 0; o--)
    s(o);
  return this;
};
rc.removeAllListeners = function() {
  return this.removeListener("*");
};
rc.emit = rc.trigger = function(t, e, r) {
  var n = this.listeners, i = n.length;
  return this.emitting++, Or(e) || (e = [e]), c4e(this, function(a, s) {
    r != null && (n = [{
      event: s.event,
      type: s.type,
      namespace: s.namespace,
      callback: r
    }], i = n.length);
    for (var o = function() {
      var h = n[l];
      if (h.type === s.type && (!h.namespace || h.namespace === s.namespace || h.namespace === o4e) && a.eventMatches(a.context, h, s)) {
        var d = [s];
        e != null && Jye(d, e), a.beforeEmit(a.context, h, s), h.conf && h.conf.one && (a.listeners = a.listeners.filter(function(g) {
          return g !== h;
        }));
        var f = a.callbackContext(a.context, h, s), p = h.callback.apply(f, d);
        a.afterEmit(a.context, h, s), p === !1 && (s.stopPropagation(), s.preventDefault());
      }
    }, l = 0; l < i; l++)
      o();
    a.bubble(a.context) && !s.isPropagationStopped() && a.parent(a.context).emit(s, e);
  }, t), this.emitting--, this;
};
var u4e = {
  qualifierCompare: function(e, r) {
    return e == null || r == null ? e == null && r == null : e.sameText(r);
  },
  eventMatches: function(e, r, n) {
    var i = r.qualifier;
    return i != null ? e !== n.target && Eg(n.target) && i.matches(n.target) : !0;
  },
  addEventFields: function(e, r) {
    r.cy = e.cy(), r.target = e;
  },
  callbackContext: function(e, r, n) {
    return r.qualifier != null ? n.target : e;
  },
  beforeEmit: function(e, r) {
    r.conf && r.conf.once && r.conf.onceCollection.removeListener(r.event, r.qualifier, r.callback);
  },
  bubble: function() {
    return !0;
  },
  parent: function(e) {
    return e.isChild() ? e.parent() : e.cy();
  }
}, D1 = function(e) {
  return Bt(e) ? new ec(e) : e;
}, uU = {
  createEmitter: function() {
    for (var e = 0; e < this.length; e++) {
      var r = this[e], n = r._private;
      n.emitter || (n.emitter = new Ox(u4e, r));
    }
    return this;
  },
  emitter: function() {
    return this._private.emitter;
  },
  on: function(e, r, n) {
    for (var i = D1(r), a = 0; a < this.length; a++) {
      var s = this[a];
      s.emitter().on(e, i, n);
    }
    return this;
  },
  removeListener: function(e, r, n) {
    for (var i = D1(r), a = 0; a < this.length; a++) {
      var s = this[a];
      s.emitter().removeListener(e, i, n);
    }
    return this;
  },
  removeAllListeners: function() {
    for (var e = 0; e < this.length; e++) {
      var r = this[e];
      r.emitter().removeAllListeners();
    }
    return this;
  },
  one: function(e, r, n) {
    for (var i = D1(r), a = 0; a < this.length; a++) {
      var s = this[a];
      s.emitter().one(e, i, n);
    }
    return this;
  },
  once: function(e, r, n) {
    for (var i = D1(r), a = 0; a < this.length; a++) {
      var s = this[a];
      s.emitter().on(e, i, n, {
        once: !0,
        onceCollection: this
      });
    }
  },
  emit: function(e, r) {
    for (var n = 0; n < this.length; n++) {
      var i = this[n];
      i.emitter().emit(e, r);
    }
    return this;
  },
  emitAndNotify: function(e, r) {
    if (this.length !== 0)
      return this.cy().notify(e, this), this.emit(e, r), this;
  }
};
Ar.eventAliasesOn(uU);
var hU = {
  nodes: function(e) {
    return this.filter(function(r) {
      return r.isNode();
    }).filter(e);
  },
  edges: function(e) {
    return this.filter(function(r) {
      return r.isEdge();
    }).filter(e);
  },
  // internal helper to get nodes and edges as separate collections with single iteration over elements
  byGroup: function() {
    for (var e = this.spawn(), r = this.spawn(), n = 0; n < this.length; n++) {
      var i = this[n];
      i.isNode() ? e.push(i) : r.push(i);
    }
    return {
      nodes: e,
      edges: r
    };
  },
  filter: function(e, r) {
    if (e === void 0)
      return this;
    if (Bt(e) || ka(e))
      return new ec(e).filter(this);
    if (an(e)) {
      for (var n = this.spawn(), i = this, a = 0; a < i.length; a++) {
        var s = i[a], o = r ? e.apply(r, [s, a, i]) : e(s, a, i);
        o && n.push(s);
      }
      return n;
    }
    return this.spawn();
  },
  not: function(e) {
    if (e) {
      Bt(e) && (e = this.filter(e));
      for (var r = this.spawn(), n = 0; n < this.length; n++) {
        var i = this[n], a = e.has(i);
        a || r.push(i);
      }
      return r;
    } else
      return this;
  },
  absoluteComplement: function() {
    var e = this.cy();
    return e.mutableElements().not(this);
  },
  intersect: function(e) {
    if (Bt(e)) {
      var r = e;
      return this.filter(r);
    }
    for (var n = this.spawn(), i = this, a = e, s = this.length < e.length, o = s ? i : a, l = s ? a : i, u = 0; u < o.length; u++) {
      var h = o[u];
      l.has(h) && n.push(h);
    }
    return n;
  },
  xor: function(e) {
    var r = this._private.cy;
    Bt(e) && (e = r.$(e));
    var n = this.spawn(), i = this, a = e, s = function(l, u) {
      for (var h = 0; h < l.length; h++) {
        var d = l[h], f = d._private.data.id, p = u.hasElementWithId(f);
        p || n.push(d);
      }
    };
    return s(i, a), s(a, i), n;
  },
  diff: function(e) {
    var r = this._private.cy;
    Bt(e) && (e = r.$(e));
    var n = this.spawn(), i = this.spawn(), a = this.spawn(), s = this, o = e, l = function(h, d, f) {
      for (var p = 0; p < h.length; p++) {
        var g = h[p], m = g._private.data.id, v = d.hasElementWithId(m);
        v ? a.merge(g) : f.push(g);
      }
    };
    return l(s, o, n), l(o, s, i), {
      left: n,
      right: i,
      both: a
    };
  },
  add: function(e) {
    var r = this._private.cy;
    if (!e)
      return this;
    if (Bt(e)) {
      var n = e;
      e = r.mutableElements().filter(n);
    }
    for (var i = this.spawnSelf(), a = 0; a < e.length; a++) {
      var s = e[a], o = !this.has(s);
      o && i.push(s);
    }
    return i;
  },
  // in place merge on calling collection
  merge: function(e) {
    var r = this._private, n = r.cy;
    if (!e)
      return this;
    if (e && Bt(e)) {
      var i = e;
      e = n.mutableElements().filter(i);
    }
    for (var a = r.map, s = 0; s < e.length; s++) {
      var o = e[s], l = o._private.data.id, u = !a.has(l);
      if (u) {
        var h = this.length++;
        this[h] = o, a.set(l, {
          ele: o,
          index: h
        });
      }
    }
    return this;
  },
  unmergeAt: function(e) {
    var r = this[e], n = r.id(), i = this._private, a = i.map;
    this[e] = void 0, a.delete(n);
    var s = e === this.length - 1;
    if (this.length > 1 && !s) {
      var o = this.length - 1, l = this[o], u = l._private.data.id;
      this[o] = void 0, this[e] = l, a.set(u, {
        ele: l,
        index: e
      });
    }
    return this.length--, this;
  },
  // remove single ele in place in calling collection
  unmergeOne: function(e) {
    e = e[0];
    var r = this._private, n = e._private.data.id, i = r.map, a = i.get(n);
    if (!a)
      return this;
    var s = a.index;
    return this.unmergeAt(s), this;
  },
  // remove eles in place on calling collection
  unmerge: function(e) {
    var r = this._private.cy;
    if (!e)
      return this;
    if (e && Bt(e)) {
      var n = e;
      e = r.mutableElements().filter(n);
    }
    for (var i = 0; i < e.length; i++)
      this.unmergeOne(e[i]);
    return this;
  },
  unmergeBy: function(e) {
    for (var r = this.length - 1; r >= 0; r--) {
      var n = this[r];
      e(n) && this.unmergeAt(r);
    }
    return this;
  },
  map: function(e, r) {
    for (var n = [], i = this, a = 0; a < i.length; a++) {
      var s = i[a], o = r ? e.apply(r, [s, a, i]) : e(s, a, i);
      n.push(o);
    }
    return n;
  },
  reduce: function(e, r) {
    for (var n = r, i = this, a = 0; a < i.length; a++)
      n = e(n, i[a], a, i);
    return n;
  },
  max: function(e, r) {
    for (var n = -1 / 0, i, a = this, s = 0; s < a.length; s++) {
      var o = a[s], l = r ? e.apply(r, [o, s, a]) : e(o, s, a);
      l > n && (n = l, i = o);
    }
    return {
      value: n,
      ele: i
    };
  },
  min: function(e, r) {
    for (var n = 1 / 0, i, a = this, s = 0; s < a.length; s++) {
      var o = a[s], l = r ? e.apply(r, [o, s, a]) : e(o, s, a);
      l < n && (n = l, i = o);
    }
    return {
      value: n,
      ele: i
    };
  }
}, wr = hU;
wr.u = wr["|"] = wr["+"] = wr.union = wr.or = wr.add;
wr["\\"] = wr["!"] = wr["-"] = wr.difference = wr.relativeComplement = wr.subtract = wr.not;
wr.n = wr["&"] = wr["."] = wr.and = wr.intersection = wr.intersect;
wr["^"] = wr["(+)"] = wr["(-)"] = wr.symmetricDifference = wr.symdiff = wr.xor;
wr.fnFilter = wr.filterFn = wr.stdFilter = wr.filter;
wr.complement = wr.abscomp = wr.absoluteComplement;
var h4e = {
  isNode: function() {
    return this.group() === "nodes";
  },
  isEdge: function() {
    return this.group() === "edges";
  },
  isLoop: function() {
    return this.isEdge() && this.source()[0] === this.target()[0];
  },
  isSimple: function() {
    return this.isEdge() && this.source()[0] !== this.target()[0];
  },
  group: function() {
    var e = this[0];
    if (e)
      return e._private.group;
  }
}, dU = function(e, r) {
  var n = e.cy(), i = n.hasCompoundNodes();
  function a(h) {
    var d = h.pstyle("z-compound-depth");
    return d.value === "auto" ? i ? h.zDepth() : 0 : d.value === "bottom" ? -1 : d.value === "top" ? Kk : 0;
  }
  var s = a(e) - a(r);
  if (s !== 0)
    return s;
  function o(h) {
    var d = h.pstyle("z-index-compare");
    return d.value === "auto" && h.isNode() ? 1 : 0;
  }
  var l = o(e) - o(r);
  if (l !== 0)
    return l;
  var u = e.pstyle("z-index").value - r.pstyle("z-index").value;
  return u !== 0 ? u : e.poolIndex() - r.poolIndex();
}, Ry = {
  forEach: function(e, r) {
    if (an(e))
      for (var n = this.length, i = 0; i < n; i++) {
        var a = this[i], s = r ? e.apply(r, [a, i, this]) : e(a, i, this);
        if (s === !1)
          break;
      }
    return this;
  },
  toArray: function() {
    for (var e = [], r = 0; r < this.length; r++)
      e.push(this[r]);
    return e;
  },
  slice: function(e, r) {
    var n = [], i = this.length;
    r == null && (r = i), e == null && (e = 0), e < 0 && (e = i + e), r < 0 && (r = i + r);
    for (var a = e; a >= 0 && a < r && a < i; a++)
      n.push(this[a]);
    return this.spawn(n);
  },
  size: function() {
    return this.length;
  },
  eq: function(e) {
    return this[e] || this.spawn();
  },
  first: function() {
    return this[0] || this.spawn();
  },
  last: function() {
    return this[this.length - 1] || this.spawn();
  },
  empty: function() {
    return this.length === 0;
  },
  nonempty: function() {
    return !this.empty();
  },
  sort: function(e) {
    if (!an(e))
      return this;
    var r = this.toArray().sort(e);
    return this.spawn(r);
  },
  sortByZIndex: function() {
    return this.sort(dU);
  },
  zDepth: function() {
    var e = this[0];
    if (e) {
      var r = e._private, n = r.group;
      if (n === "nodes") {
        var i = r.data.parent ? e.parents().size() : 0;
        return e.isParent() ? i : Kk - 1;
      } else {
        var a = r.source, s = r.target, o = a.zDepth(), l = s.zDepth();
        return Math.max(o, l, 0);
      }
    }
  }
};
Ry.each = Ry.forEach;
var d4e = function() {
  var e = "undefined", r = (typeof Symbol > "u" ? "undefined" : zn(Symbol)) != e && zn(Symbol.iterator) != e;
  r && (Ry[Symbol.iterator] = function() {
    var n = this, i = {
      value: void 0,
      done: !1
    }, a = 0, s = this.length;
    return uV({
      next: function() {
        return a < s ? i.value = n[a++] : (i.value = void 0, i.done = !0), i;
      }
    }, Symbol.iterator, function() {
      return this;
    });
  });
};
d4e();
var f4e = fi({
  nodeDimensionsIncludeLabels: !1
}), Fm = {
  // Calculates and returns node dimensions { x, y } based on options given
  layoutDimensions: function(e) {
    e = f4e(e);
    var r;
    if (!this.takesUpSpace())
      r = {
        w: 0,
        h: 0
      };
    else if (e.nodeDimensionsIncludeLabels) {
      var n = this.boundingBox();
      r = {
        w: n.w,
        h: n.h
      };
    } else
      r = {
        w: this.outerWidth(),
        h: this.outerHeight()
      };
    return (r.w === 0 || r.h === 0) && (r.w = r.h = 1), r;
  },
  // using standard layout options, apply position function (w/ or w/o animation)
  layoutPositions: function(e, r, n) {
    var i = this.nodes().filter(function(E) {
      return !E.isParent();
    }), a = this.cy(), s = r.eles, o = function(L) {
      return L.id();
    }, l = Ld(n, o);
    e.emit({
      type: "layoutstart",
      layout: e
    }), e.animations = [];
    var u = function(L, k, C) {
      var A = {
        x: k.x1 + k.w / 2,
        y: k.y1 + k.h / 2
      }, R = {
        // scale from center of bounding box (not necessarily 0,0)
        x: (C.x - A.x) * L,
        y: (C.y - A.y) * L
      };
      return {
        x: A.x + R.x,
        y: A.y + R.y
      };
    }, h = r.spacingFactor && r.spacingFactor !== 1, d = function() {
      if (!h)
        return null;
      for (var L = qi(), k = 0; k < i.length; k++) {
        var C = i[k], A = l(C, k);
        RV(L, A.x, A.y);
      }
      return L;
    }, f = d(), p = Ld(function(E, L) {
      var k = l(E, L);
      if (h) {
        var C = Math.abs(r.spacingFactor);
        k = u(C, f, k);
      }
      return r.transform != null && (k = r.transform(E, k)), k;
    }, o);
    if (r.animate) {
      for (var g = 0; g < i.length; g++) {
        var m = i[g], v = p(m, g), y = r.animateFilter == null || r.animateFilter(m, g);
        if (y) {
          var b = m.animation({
            position: v,
            duration: r.animationDuration,
            easing: r.animationEasing
          });
          e.animations.push(b);
        } else
          m.position(v);
      }
      if (r.fit) {
        var w = a.animation({
          fit: {
            boundingBox: s.boundingBoxAt(p),
            padding: r.padding
          },
          duration: r.animationDuration,
          easing: r.animationEasing
        });
        e.animations.push(w);
      } else if (r.zoom !== void 0 && r.pan !== void 0) {
        var T = a.animation({
          zoom: r.zoom,
          pan: r.pan,
          duration: r.animationDuration,
          easing: r.animationEasing
        });
        e.animations.push(T);
      }
      e.animations.forEach(function(E) {
        return E.play();
      }), e.one("layoutready", r.ready), e.emit({
        type: "layoutready",
        layout: e
      }), rf.all(e.animations.map(function(E) {
        return E.promise();
      })).then(function() {
        e.one("layoutstop", r.stop), e.emit({
          type: "layoutstop",
          layout: e
        });
      });
    } else
      i.positions(p), r.fit && a.fit(r.eles, r.padding), r.zoom != null && a.zoom(r.zoom), r.pan && a.pan(r.pan), e.one("layoutready", r.ready), e.emit({
        type: "layoutready",
        layout: e
      }), e.one("layoutstop", r.stop), e.emit({
        type: "layoutstop",
        layout: e
      });
    return this;
  },
  layout: function(e) {
    var r = this.cy();
    return r.makeLayout(Gt({}, e, {
      eles: this
    }));
  }
};
Fm.createLayout = Fm.makeLayout = Fm.layout;
function fU(t, e, r) {
  var n = r._private, i = n.styleCache = n.styleCache || [], a;
  return (a = i[t]) != null || (a = i[t] = e(r)), a;
}
function Px(t, e) {
  return t = Cu(t), function(n) {
    return fU(t, e, n);
  };
}
function Bx(t, e) {
  t = Cu(t);
  var r = function(i) {
    return e.call(i);
  };
  return function() {
    var i = this[0];
    if (i)
      return fU(t, r, i);
  };
}
var ci = {
  recalculateRenderedStyle: function(e) {
    var r = this.cy(), n = r.renderer(), i = r.styleEnabled();
    return n && i && n.recalculateRenderedStyle(this, e), this;
  },
  dirtyStyleCache: function() {
    var e = this.cy(), r = function(a) {
      return a._private.styleCache = null;
    };
    if (e.hasCompoundNodes()) {
      var n;
      n = this.spawnSelf().merge(this.descendants()).merge(this.parents()), n.merge(n.connectedEdges()), n.forEach(r);
    } else
      this.forEach(function(i) {
        r(i), i.connectedEdges().forEach(r);
      });
    return this;
  },
  // fully updates (recalculates) the style for the elements
  updateStyle: function(e) {
    var r = this._private.cy;
    if (!r.styleEnabled())
      return this;
    if (r.batching()) {
      var n = r._private.batchStyleEles;
      return n.merge(this), this;
    }
    var i = r.hasCompoundNodes(), a = this;
    e = !!(e || e === void 0), i && (a = this.spawnSelf().merge(this.descendants()).merge(this.parents()));
    var s = a;
    return e ? s.emitAndNotify("style") : s.emit("style"), a.forEach(function(o) {
      return o._private.styleDirty = !0;
    }), this;
  },
  // private: clears dirty flag and recalculates style
  cleanStyle: function() {
    var e = this.cy();
    if (e.styleEnabled())
      for (var r = 0; r < this.length; r++) {
        var n = this[r];
        n._private.styleDirty && (n._private.styleDirty = !1, e.style().apply(n));
      }
  },
  // get the internal parsed style object for the specified property
  parsedStyle: function(e) {
    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, n = this[0], i = n.cy();
    if (i.styleEnabled() && n) {
      n._private.styleDirty && (n._private.styleDirty = !1, i.style().apply(n));
      var a = n._private.style[e];
      return a ?? (r ? i.style().getDefaultProperty(e) : null);
    }
  },
  numericStyle: function(e) {
    var r = this[0];
    if (r.cy().styleEnabled() && r) {
      var n = r.pstyle(e);
      return n.pfValue !== void 0 ? n.pfValue : n.value;
    }
  },
  numericStyleUnits: function(e) {
    var r = this[0];
    if (r.cy().styleEnabled() && r)
      return r.pstyle(e).units;
  },
  // get the specified css property as a rendered value (i.e. on-screen value)
  // or get the whole rendered style if no property specified (NB doesn't allow setting)
  renderedStyle: function(e) {
    var r = this.cy();
    if (!r.styleEnabled())
      return this;
    var n = this[0];
    if (n)
      return r.style().getRenderedStyle(n, e);
  },
  // read the calculated css style of the element or override the style (via a bypass)
  style: function(e, r) {
    var n = this.cy();
    if (!n.styleEnabled())
      return this;
    var i = !1, a = n.style();
    if (mr(e)) {
      var s = e;
      a.applyBypass(this, s, i), this.emitAndNotify("style");
    } else if (Bt(e))
      if (r === void 0) {
        var o = this[0];
        return o ? a.getStylePropertyValue(o, e) : void 0;
      } else
        a.applyBypass(this, e, r, i), this.emitAndNotify("style");
    else if (e === void 0) {
      var l = this[0];
      return l ? a.getRawStyle(l) : void 0;
    }
    return this;
  },
  removeStyle: function(e) {
    var r = this.cy();
    if (!r.styleEnabled())
      return this;
    var n = !1, i = r.style(), a = this;
    if (e === void 0)
      for (var s = 0; s < a.length; s++) {
        var o = a[s];
        i.removeAllBypasses(o, n);
      }
    else {
      e = e.split(/\s+/);
      for (var l = 0; l < a.length; l++) {
        var u = a[l];
        i.removeBypasses(u, e, n);
      }
    }
    return this.emitAndNotify("style"), this;
  },
  show: function() {
    return this.css("display", "element"), this;
  },
  hide: function() {
    return this.css("display", "none"), this;
  },
  effectiveOpacity: function() {
    var e = this.cy();
    if (!e.styleEnabled())
      return 1;
    var r = e.hasCompoundNodes(), n = this[0];
    if (n) {
      var i = n._private, a = n.pstyle("opacity").value;
      if (!r)
        return a;
      var s = i.data.parent ? n.parents() : null;
      if (s)
        for (var o = 0; o < s.length; o++) {
          var l = s[o], u = l.pstyle("opacity").value;
          a = u * a;
        }
      return a;
    }
  },
  transparent: function() {
    var e = this.cy();
    if (!e.styleEnabled())
      return !1;
    var r = this[0], n = r.cy().hasCompoundNodes();
    if (r)
      return n ? r.effectiveOpacity() === 0 : r.pstyle("opacity").value === 0;
  },
  backgrounding: function() {
    var e = this.cy();
    if (!e.styleEnabled())
      return !1;
    var r = this[0];
    return !!r._private.backgrounding;
  }
};
function J3(t, e) {
  var r = t._private, n = r.data.parent ? t.parents() : null;
  if (n)
    for (var i = 0; i < n.length; i++) {
      var a = n[i];
      if (!e(a))
        return !1;
    }
  return !0;
}
function lS(t) {
  var e = t.ok, r = t.edgeOkViaNode || t.ok, n = t.parentOk || t.ok;
  return function() {
    var i = this.cy();
    if (!i.styleEnabled())
      return !0;
    var a = this[0], s = i.hasCompoundNodes();
    if (a) {
      var o = a._private;
      if (!e(a))
        return !1;
      if (a.isNode())
        return !s || J3(a, n);
      var l = o.source, u = o.target;
      return r(l) && (!s || J3(l, r)) && (l === u || r(u) && (!s || J3(u, r)));
    }
  };
}
var nf = Px("eleTakesUpSpace", function(t) {
  return t.pstyle("display").value === "element" && t.width() !== 0 && (t.isNode() ? t.height() !== 0 : !0);
});
ci.takesUpSpace = Bx("takesUpSpace", lS({
  ok: nf
}));
var p4e = Px("eleInteractive", function(t) {
  return t.pstyle("events").value === "yes" && t.pstyle("visibility").value === "visible" && nf(t);
}), g4e = Px("parentInteractive", function(t) {
  return t.pstyle("visibility").value === "visible" && nf(t);
});
ci.interactive = Bx("interactive", lS({
  ok: p4e,
  parentOk: g4e,
  edgeOkViaNode: nf
}));
ci.noninteractive = function() {
  var t = this[0];
  if (t)
    return !t.interactive();
};
var m4e = Px("eleVisible", function(t) {
  return t.pstyle("visibility").value === "visible" && t.pstyle("opacity").pfValue !== 0 && nf(t);
}), v4e = nf;
ci.visible = Bx("visible", lS({
  ok: m4e,
  edgeOkViaNode: v4e
}));
ci.hidden = function() {
  var t = this[0];
  if (t)
    return !t.visible();
};
ci.isBundledBezier = Bx("isBundledBezier", function() {
  return this.cy().styleEnabled() ? !this.removed() && this.pstyle("curve-style").value === "bezier" && this.takesUpSpace() : !1;
});
ci.bypass = ci.css = ci.style;
ci.renderedCss = ci.renderedStyle;
ci.removeBypass = ci.removeCss = ci.removeStyle;
ci.pstyle = ci.parsedStyle;
var Gl = {};
function Y9(t) {
  return function() {
    var e = arguments, r = [];
    if (e.length === 2) {
      var n = e[0], i = e[1];
      this.on(t.event, n, i);
    } else if (e.length === 1 && an(e[0])) {
      var a = e[0];
      this.on(t.event, a);
    } else if (e.length === 0 || e.length === 1 && Or(e[0])) {
      for (var s = e.length === 1 ? e[0] : null, o = 0; o < this.length; o++) {
        var l = this[o], u = !t.ableField || l._private[t.ableField], h = l._private[t.field] != t.value;
        if (t.overrideAble) {
          var d = t.overrideAble(l);
          if (d !== void 0 && (u = d, !d))
            return this;
        }
        u && (l._private[t.field] = t.value, h && r.push(l));
      }
      var f = this.spawn(r);
      f.updateStyle(), f.emit(t.event), s && f.emit(s);
    }
    return this;
  };
}
function af(t) {
  Gl[t.field] = function() {
    var e = this[0];
    if (e) {
      if (t.overrideField) {
        var r = t.overrideField(e);
        if (r !== void 0)
          return r;
      }
      return e._private[t.field];
    }
  }, Gl[t.on] = Y9({
    event: t.on,
    field: t.field,
    ableField: t.ableField,
    overrideAble: t.overrideAble,
    value: !0
  }), Gl[t.off] = Y9({
    event: t.off,
    field: t.field,
    ableField: t.ableField,
    overrideAble: t.overrideAble,
    value: !1
  });
}
af({
  field: "locked",
  overrideField: function(e) {
    return e.cy().autolock() ? !0 : void 0;
  },
  on: "lock",
  off: "unlock"
});
af({
  field: "grabbable",
  overrideField: function(e) {
    return e.cy().autoungrabify() || e.pannable() ? !1 : void 0;
  },
  on: "grabify",
  off: "ungrabify"
});
af({
  field: "selected",
  ableField: "selectable",
  overrideAble: function(e) {
    return e.cy().autounselectify() ? !1 : void 0;
  },
  on: "select",
  off: "unselect"
});
af({
  field: "selectable",
  overrideField: function(e) {
    return e.cy().autounselectify() ? !1 : void 0;
  },
  on: "selectify",
  off: "unselectify"
});
Gl.deselect = Gl.unselect;
Gl.grabbed = function() {
  var t = this[0];
  if (t)
    return t._private.grabbed;
};
af({
  field: "active",
  on: "activate",
  off: "unactivate"
});
af({
  field: "pannable",
  on: "panify",
  off: "unpanify"
});
Gl.inactive = function() {
  var t = this[0];
  if (t)
    return !t._private.active;
};
var Si = {}, X9 = function(e) {
  return function(n) {
    for (var i = this, a = [], s = 0; s < i.length; s++) {
      var o = i[s];
      if (o.isNode()) {
        for (var l = !1, u = o.connectedEdges(), h = 0; h < u.length; h++) {
          var d = u[h], f = d.source(), p = d.target();
          if (e.noIncomingEdges && p === o && f !== o || e.noOutgoingEdges && f === o && p !== o) {
            l = !0;
            break;
          }
        }
        l || a.push(o);
      }
    }
    return this.spawn(a, !0).filter(n);
  };
}, j9 = function(e) {
  return function(r) {
    for (var n = this, i = [], a = 0; a < n.length; a++) {
      var s = n[a];
      if (s.isNode())
        for (var o = s.connectedEdges(), l = 0; l < o.length; l++) {
          var u = o[l], h = u.source(), d = u.target();
          e.outgoing && h === s ? (i.push(u), i.push(d)) : e.incoming && d === s && (i.push(u), i.push(h));
        }
    }
    return this.spawn(i, !0).filter(r);
  };
}, K9 = function(e) {
  return function(r) {
    for (var n = this, i = [], a = {}; ; ) {
      var s = e.outgoing ? n.outgoers() : n.incomers();
      if (s.length === 0)
        break;
      for (var o = !1, l = 0; l < s.length; l++) {
        var u = s[l], h = u.id();
        a[h] || (a[h] = !0, i.push(u), o = !0);
      }
      if (!o)
        break;
      n = s;
    }
    return this.spawn(i, !0).filter(r);
  };
};
Si.clearTraversalCache = function() {
  for (var t = 0; t < this.length; t++)
    this[t]._private.traversalCache = null;
};
Gt(Si, {
  // get the root nodes in the DAG
  roots: X9({
    noIncomingEdges: !0
  }),
  // get the leaf nodes in the DAG
  leaves: X9({
    noOutgoingEdges: !0
  }),
  // normally called children in graph theory
  // these nodes =edges=> outgoing nodes
  outgoers: Xa(j9({
    outgoing: !0
  }), "outgoers"),
  // aka DAG descendants
  successors: K9({
    outgoing: !0
  }),
  // normally called parents in graph theory
  // these nodes <=edges= incoming nodes
  incomers: Xa(j9({
    incoming: !0
  }), "incomers"),
  // aka DAG ancestors
  predecessors: K9({})
});
Gt(Si, {
  neighborhood: Xa(function(t) {
    for (var e = [], r = this.nodes(), n = 0; n < r.length; n++)
      for (var i = r[n], a = i.connectedEdges(), s = 0; s < a.length; s++) {
        var o = a[s], l = o.source(), u = o.target(), h = i === l ? u : l;
        h.length > 0 && e.push(h[0]), e.push(o[0]);
      }
    return this.spawn(e, !0).filter(t);
  }, "neighborhood"),
  closedNeighborhood: function(e) {
    return this.neighborhood().add(this).filter(e);
  },
  openNeighborhood: function(e) {
    return this.neighborhood(e);
  }
});
Si.neighbourhood = Si.neighborhood;
Si.closedNeighbourhood = Si.closedNeighborhood;
Si.openNeighbourhood = Si.openNeighborhood;
Gt(Si, {
  source: Xa(function(e) {
    var r = this[0], n;
    return r && (n = r._private.source || r.cy().collection()), n && e ? n.filter(e) : n;
  }, "source"),
  target: Xa(function(e) {
    var r = this[0], n;
    return r && (n = r._private.target || r.cy().collection()), n && e ? n.filter(e) : n;
  }, "target"),
  sources: Z9({
    attr: "source"
  }),
  targets: Z9({
    attr: "target"
  })
});
function Z9(t) {
  return function(r) {
    for (var n = [], i = 0; i < this.length; i++) {
      var a = this[i], s = a._private[t.attr];
      s && n.push(s);
    }
    return this.spawn(n, !0).filter(r);
  };
}
Gt(Si, {
  edgesWith: Xa(Q9(), "edgesWith"),
  edgesTo: Xa(Q9({
    thisIsSrc: !0
  }), "edgesTo")
});
function Q9(t) {
  return function(r) {
    var n = [], i = this._private.cy, a = t || {};
    Bt(r) && (r = i.$(r));
    for (var s = 0; s < r.length; s++)
      for (var o = r[s]._private.edges, l = 0; l < o.length; l++) {
        var u = o[l], h = u._private.data, d = this.hasElementWithId(h.source) && r.hasElementWithId(h.target), f = r.hasElementWithId(h.source) && this.hasElementWithId(h.target), p = d || f;
        p && ((a.thisIsSrc || a.thisIsTgt) && (a.thisIsSrc && !d || a.thisIsTgt && !f) || n.push(u));
      }
    return this.spawn(n, !0);
  };
}
Gt(Si, {
  connectedEdges: Xa(function(t) {
    for (var e = [], r = this, n = 0; n < r.length; n++) {
      var i = r[n];
      if (i.isNode())
        for (var a = i._private.edges, s = 0; s < a.length; s++) {
          var o = a[s];
          e.push(o);
        }
    }
    return this.spawn(e, !0).filter(t);
  }, "connectedEdges"),
  connectedNodes: Xa(function(t) {
    for (var e = [], r = this, n = 0; n < r.length; n++) {
      var i = r[n];
      i.isEdge() && (e.push(i.source()[0]), e.push(i.target()[0]));
    }
    return this.spawn(e, !0).filter(t);
  }, "connectedNodes"),
  parallelEdges: Xa(J9(), "parallelEdges"),
  codirectedEdges: Xa(J9({
    codirected: !0
  }), "codirectedEdges")
});
function J9(t) {
  var e = {
    codirected: !1
  };
  return t = Gt({}, e, t), function(n) {
    for (var i = [], a = this.edges(), s = t, o = 0; o < a.length; o++)
      for (var l = a[o], u = l._private, h = u.source, d = h._private.data.id, f = u.data.target, p = h._private.edges, g = 0; g < p.length; g++) {
        var m = p[g], v = m._private.data, y = v.target, b = v.source, w = y === f && b === d, T = d === y && f === b;
        (s.codirected && w || !s.codirected && (w || T)) && i.push(m);
      }
    return this.spawn(i, !0).filter(n);
  };
}
Gt(Si, {
  components: function(e) {
    var r = this, n = r.cy(), i = n.collection(), a = e == null ? r.nodes() : e.nodes(), s = [];
    e != null && a.empty() && (a = e.sources());
    var o = function(h, d) {
      i.merge(h), a.unmerge(h), d.merge(h);
    };
    if (a.empty())
      return r.spawn();
    var l = function() {
      var h = n.collection();
      s.push(h);
      var d = a[0];
      o(d, h), r.bfs({
        directed: !1,
        roots: d,
        visit: function(p) {
          return o(p, h);
        }
      }), h.forEach(function(f) {
        f.connectedEdges().forEach(function(p) {
          r.has(p) && h.has(p.source()) && h.has(p.target()) && h.merge(p);
        });
      });
    };
    do
      l();
    while (a.length > 0);
    return s;
  },
  component: function() {
    var e = this[0];
    return e.cy().mutableElements().components(e)[0];
  }
});
Si.componentsOf = Si.components;
var ui = function(e, r) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (e === void 0) {
    Zr("A collection must have a reference to the core");
    return;
  }
  var a = new Go(), s = !1;
  if (!r)
    r = [];
  else if (r.length > 0 && mr(r[0]) && !Eg(r[0])) {
    s = !0;
    for (var o = [], l = new tf(), u = 0, h = r.length; u < h; u++) {
      var d = r[u];
      d.data == null && (d.data = {});
      var f = d.data;
      if (f.id == null)
        f.id = AV();
      else if (e.hasElementWithId(f.id) || l.has(f.id))
        continue;
      var p = new Ax(e, d, !1);
      o.push(p), l.add(f.id);
    }
    r = o;
  }
  this.length = 0;
  for (var g = 0, m = r.length; g < m; g++) {
    var v = r[g][0];
    if (v != null) {
      var y = v._private.data.id;
      (!n || !a.has(y)) && (n && a.set(y, {
        index: this.length,
        ele: v
      }), this[this.length] = v, this.length++);
    }
  }
  this._private = {
    eles: this,
    cy: e,
    get map() {
      return this.lazyMap == null && this.rebuildMap(), this.lazyMap;
    },
    set map(b) {
      this.lazyMap = b;
    },
    rebuildMap: function() {
      for (var w = this.lazyMap = new Go(), T = this.eles, E = 0; E < T.length; E++) {
        var L = T[E];
        w.set(L.id(), {
          index: E,
          ele: L
        });
      }
    }
  }, n && (this._private.map = a), s && !i && this.restore();
}, Vr = Ax.prototype = ui.prototype = Object.create(Array.prototype);
Vr.instanceString = function() {
  return "collection";
};
Vr.spawn = function(t, e) {
  return new ui(this.cy(), t, e);
};
Vr.spawnSelf = function() {
  return this.spawn(this);
};
Vr.cy = function() {
  return this._private.cy;
};
Vr.renderer = function() {
  return this._private.cy.renderer();
};
Vr.element = function() {
  return this[0];
};
Vr.collection = function() {
  return fV(this) ? this : new ui(this._private.cy, [this]);
};
Vr.unique = function() {
  return new ui(this._private.cy, this, !0);
};
Vr.hasElementWithId = function(t) {
  return t = "" + t, this._private.map.has(t);
};
Vr.getElementById = function(t) {
  t = "" + t;
  var e = this._private.cy, r = this._private.map.get(t);
  return r ? r.ele : new ui(e);
};
Vr.$id = Vr.getElementById;
Vr.poolIndex = function() {
  var t = this._private.cy, e = t._private.elements, r = this[0]._private.data.id;
  return e._private.map.get(r).index;
};
Vr.indexOf = function(t) {
  var e = t[0]._private.data.id;
  return this._private.map.get(e).index;
};
Vr.indexOfId = function(t) {
  return t = "" + t, this._private.map.get(t).index;
};
Vr.json = function(t) {
  var e = this.element(), r = this.cy();
  if (e == null && t)
    return this;
  if (e != null) {
    var n = e._private;
    if (mr(t)) {
      if (r.startBatch(), t.data) {
        e.data(t.data);
        var i = n.data;
        if (e.isEdge()) {
          var a = !1, s = {}, o = t.data.source, l = t.data.target;
          o != null && o != i.source && (s.source = "" + o, a = !0), l != null && l != i.target && (s.target = "" + l, a = !0), a && (e = e.move(s));
        } else {
          var u = "parent" in t.data, h = t.data.parent;
          u && (h != null || i.parent != null) && h != i.parent && (h === void 0 && (h = null), h != null && (h = "" + h), e = e.move({
            parent: h
          }));
        }
      }
      t.position && e.position(t.position);
      var d = function(m, v, y) {
        var b = t[m];
        b != null && b !== n[m] && (b ? e[v]() : e[y]());
      };
      return d("removed", "remove", "restore"), d("selected", "select", "unselect"), d("selectable", "selectify", "unselectify"), d("locked", "lock", "unlock"), d("grabbable", "grabify", "ungrabify"), d("pannable", "panify", "unpanify"), t.classes != null && e.classes(t.classes), r.endBatch(), this;
    } else if (t === void 0) {
      var f = {
        data: Zs(n.data),
        position: Zs(n.position),
        group: n.group,
        removed: n.removed,
        selected: n.selected,
        selectable: n.selectable,
        locked: n.locked,
        grabbable: n.grabbable,
        pannable: n.pannable,
        classes: null
      };
      f.classes = "";
      var p = 0;
      return n.classes.forEach(function(g) {
        return f.classes += p++ === 0 ? g : " " + g;
      }), f;
    }
  }
};
Vr.jsons = function() {
  for (var t = [], e = 0; e < this.length; e++) {
    var r = this[e], n = r.json();
    t.push(n);
  }
  return t;
};
Vr.clone = function() {
  for (var t = this.cy(), e = [], r = 0; r < this.length; r++) {
    var n = this[r], i = n.json(), a = new Ax(t, i, !1);
    e.push(a);
  }
  return new ui(t, e);
};
Vr.copy = Vr.clone;
Vr.restore = function() {
  for (var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, r = this, n = r.cy(), i = n._private, a = [], s = [], o, l = 0, u = r.length; l < u; l++) {
    var h = r[l];
    e && !h.removed() || (h.isNode() ? a.push(h) : s.push(h));
  }
  o = a.concat(s);
  var d, f = function() {
    o.splice(d, 1), d--;
  };
  for (d = 0; d < o.length; d++) {
    var p = o[d], g = p._private, m = g.data;
    if (p.clearTraversalCache(), !(!e && !g.removed)) {
      if (m.id === void 0)
        m.id = AV();
      else if (mt(m.id))
        m.id = "" + m.id;
      else if (Zl(m.id) || !Bt(m.id)) {
        Zr("Can not create element with invalid string ID `" + m.id + "`"), f();
        continue;
      } else if (n.hasElementWithId(m.id)) {
        Zr("Can not create second element with ID `" + m.id + "`"), f();
        continue;
      }
    }
    var v = m.id;
    if (p.isNode()) {
      var y = g.position;
      y.x == null && (y.x = 0), y.y == null && (y.y = 0);
    }
    if (p.isEdge()) {
      for (var b = p, w = ["source", "target"], T = w.length, E = !1, L = 0; L < T; L++) {
        var k = w[L], C = m[k];
        mt(C) && (C = m[k] = "" + m[k]), C == null || C === "" ? (Zr("Can not create edge `" + v + "` with unspecified " + k), E = !0) : n.hasElementWithId(C) || (Zr("Can not create edge `" + v + "` with nonexistant " + k + " `" + C + "`"), E = !0);
      }
      if (E) {
        f();
        continue;
      }
      var A = n.getElementById(m.source), R = n.getElementById(m.target);
      A.same(R) ? A._private.edges.push(b) : (A._private.edges.push(b), R._private.edges.push(b)), b._private.source = A, b._private.target = R;
    }
    g.map = new Go(), g.map.set(v, {
      ele: p,
      index: 0
    }), g.removed = !1, e && n.addToPool(p);
  }
  for (var _ = 0; _ < a.length; _++) {
    var O = a[_], P = O._private.data;
    mt(P.parent) && (P.parent = "" + P.parent);
    var S = P.parent, M = S != null;
    if (M || O._private.parent) {
      var N = O._private.parent ? n.collection().merge(O._private.parent) : n.getElementById(S);
      if (N.empty())
        P.parent = void 0;
      else if (N[0].removed())
        Lr("Node added with missing parent, reference to parent removed"), P.parent = void 0, O._private.parent = null;
      else {
        for (var D = !1, I = N; !I.empty(); ) {
          if (O.same(I)) {
            D = !0, P.parent = void 0;
            break;
          }
          I = I.parent();
        }
        D || (N[0]._private.children.push(O), O._private.parent = N[0], i.hasCompoundNodes = !0);
      }
    }
  }
  if (o.length > 0) {
    for (var B = o.length === r.length ? r : new ui(n, o), z = 0; z < B.length; z++) {
      var F = B[z];
      F.isNode() || (F.parallelEdges().clearTraversalCache(), F.source().clearTraversalCache(), F.target().clearTraversalCache());
    }
    var V;
    i.hasCompoundNodes ? V = n.collection().merge(B).merge(B.connectedNodes()).merge(B.parent()) : V = B, V.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(t), t ? B.emitAndNotify("add") : e && B.emit("add");
  }
  return r;
};
Vr.removed = function() {
  var t = this[0];
  return t && t._private.removed;
};
Vr.inside = function() {
  var t = this[0];
  return t && !t._private.removed;
};
Vr.remove = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, r = this, n = [], i = {}, a = r._private.cy;
  function s(S) {
    for (var M = S._private.edges, N = 0; N < M.length; N++)
      l(M[N]);
  }
  function o(S) {
    for (var M = S._private.children, N = 0; N < M.length; N++)
      l(M[N]);
  }
  function l(S) {
    var M = i[S.id()];
    e && S.removed() || M || (i[S.id()] = !0, S.isNode() ? (n.push(S), s(S), o(S)) : n.unshift(S));
  }
  for (var u = 0, h = r.length; u < h; u++) {
    var d = r[u];
    l(d);
  }
  function f(S, M) {
    var N = S._private.edges;
    Ql(N, M), S.clearTraversalCache();
  }
  function p(S) {
    S.clearTraversalCache();
  }
  var g = [];
  g.ids = {};
  function m(S, M) {
    M = M[0], S = S[0];
    var N = S._private.children, D = S.id();
    Ql(N, M), M._private.parent = null, g.ids[D] || (g.ids[D] = !0, g.push(S));
  }
  r.dirtyCompoundBoundsCache(), e && a.removeFromPool(n);
  for (var v = 0; v < n.length; v++) {
    var y = n[v];
    if (y.isEdge()) {
      var b = y.source()[0], w = y.target()[0];
      f(b, y), f(w, y);
      for (var T = y.parallelEdges(), E = 0; E < T.length; E++) {
        var L = T[E];
        p(L), L.isBundledBezier() && L.dirtyBoundingBoxCache();
      }
    } else {
      var k = y.parent();
      k.length !== 0 && m(k, y);
    }
    e && (y._private.removed = !0);
  }
  var C = a._private.elements;
  a._private.hasCompoundNodes = !1;
  for (var A = 0; A < C.length; A++) {
    var R = C[A];
    if (R.isParent()) {
      a._private.hasCompoundNodes = !0;
      break;
    }
  }
  var _ = new ui(this.cy(), n);
  _.size() > 0 && (t ? _.emitAndNotify("remove") : e && _.emit("remove"));
  for (var O = 0; O < g.length; O++) {
    var P = g[O];
    (!e || !P.removed()) && P.updateStyle();
  }
  return _;
};
Vr.move = function(t) {
  var e = this._private.cy, r = this, n = !1, i = !1, a = function(g) {
    return g == null ? g : "" + g;
  };
  if (t.source !== void 0 || t.target !== void 0) {
    var s = a(t.source), o = a(t.target), l = s != null && e.hasElementWithId(s), u = o != null && e.hasElementWithId(o);
    (l || u) && (e.batch(function() {
      r.remove(n, i), r.emitAndNotify("moveout");
      for (var p = 0; p < r.length; p++) {
        var g = r[p], m = g._private.data;
        g.isEdge() && (l && (m.source = s), u && (m.target = o));
      }
      r.restore(n, i);
    }), r.emitAndNotify("move"));
  } else if (t.parent !== void 0) {
    var h = a(t.parent), d = h === null || e.hasElementWithId(h);
    if (d) {
      var f = h === null ? void 0 : h;
      e.batch(function() {
        var p = r.remove(n, i);
        p.emitAndNotify("moveout");
        for (var g = 0; g < r.length; g++) {
          var m = r[g], v = m._private.data;
          m.isNode() && (v.parent = f);
        }
        p.restore(n, i);
      }), r.emitAndNotify("move");
    }
  }
  return this;
};
[$V, _be, Bm, zl, Md, Hbe, Dx, s4e, uU, hU, h4e, Ry, Fm, ci, Gl, Si].forEach(function(t) {
  Gt(Vr, t);
});
var y4e = {
  add: function(e) {
    var r, n = this;
    if (ka(e)) {
      var i = e;
      if (i._private.cy === n)
        r = i.restore();
      else {
        for (var a = [], s = 0; s < i.length; s++) {
          var o = i[s];
          a.push(o.json());
        }
        r = new ui(n, a);
      }
    } else if (Or(e)) {
      var l = e;
      r = new ui(n, l);
    } else if (mr(e) && (Or(e.nodes) || Or(e.edges))) {
      for (var u = e, h = [], d = ["nodes", "edges"], f = 0, p = d.length; f < p; f++) {
        var g = d[f], m = u[g];
        if (Or(m))
          for (var v = 0, y = m.length; v < y; v++) {
            var b = Gt({
              group: g
            }, m[v]);
            h.push(b);
          }
      }
      r = new ui(n, h);
    } else {
      var w = e;
      r = new Ax(n, w).collection();
    }
    return r;
  },
  remove: function(e) {
    if (!ka(e)) {
      if (Bt(e)) {
        var r = e;
        e = this.$(r);
      }
    }
    return e.remove();
  }
};
function x4e(t, e, r, n) {
  var i = 4, a = 1e-3, s = 1e-7, o = 10, l = 11, u = 1 / (l - 1), h = typeof Float32Array < "u";
  if (arguments.length !== 4)
    return !1;
  for (var d = 0; d < 4; ++d)
    if (typeof arguments[d] != "number" || isNaN(arguments[d]) || !isFinite(arguments[d]))
      return !1;
  t = Math.min(t, 1), r = Math.min(r, 1), t = Math.max(t, 0), r = Math.max(r, 0);
  var f = h ? new Float32Array(l) : new Array(l);
  function p(R, _) {
    return 1 - 3 * _ + 3 * R;
  }
  function g(R, _) {
    return 3 * _ - 6 * R;
  }
  function m(R) {
    return 3 * R;
  }
  function v(R, _, O) {
    return ((p(_, O) * R + g(_, O)) * R + m(_)) * R;
  }
  function y(R, _, O) {
    return 3 * p(_, O) * R * R + 2 * g(_, O) * R + m(_);
  }
  function b(R, _) {
    for (var O = 0; O < i; ++O) {
      var P = y(_, t, r);
      if (P === 0)
        return _;
      var S = v(_, t, r) - R;
      _ -= S / P;
    }
    return _;
  }
  function w() {
    for (var R = 0; R < l; ++R)
      f[R] = v(R * u, t, r);
  }
  function T(R, _, O) {
    var P, S, M = 0;
    do
      S = _ + (O - _) / 2, P = v(S, t, r) - R, P > 0 ? O = S : _ = S;
    while (Math.abs(P) > s && ++M < o);
    return S;
  }
  function E(R) {
    for (var _ = 0, O = 1, P = l - 1; O !== P && f[O] <= R; ++O)
      _ += u;
    --O;
    var S = (R - f[O]) / (f[O + 1] - f[O]), M = _ + S * u, N = y(M, t, r);
    return N >= a ? b(R, M) : N === 0 ? M : T(R, _, _ + u);
  }
  var L = !1;
  function k() {
    L = !0, (t !== e || r !== n) && w();
  }
  var C = function(_) {
    return L || k(), t === e && r === n ? _ : _ === 0 ? 0 : _ === 1 ? 1 : v(E(_), e, n);
  };
  C.getControlPoints = function() {
    return [{
      x: t,
      y: e
    }, {
      x: r,
      y: n
    }];
  };
  var A = "generateBezier(" + [t, e, r, n] + ")";
  return C.toString = function() {
    return A;
  }, C;
}
var b4e = /* @__PURE__ */ (function() {
  function t(n) {
    return -n.tension * n.x - n.friction * n.v;
  }
  function e(n, i, a) {
    var s = {
      x: n.x + a.dx * i,
      v: n.v + a.dv * i,
      tension: n.tension,
      friction: n.friction
    };
    return {
      dx: s.v,
      dv: t(s)
    };
  }
  function r(n, i) {
    var a = {
      dx: n.v,
      dv: t(n)
    }, s = e(n, i * 0.5, a), o = e(n, i * 0.5, s), l = e(n, i, o), u = 1 / 6 * (a.dx + 2 * (s.dx + o.dx) + l.dx), h = 1 / 6 * (a.dv + 2 * (s.dv + o.dv) + l.dv);
    return n.x = n.x + u * i, n.v = n.v + h * i, n;
  }
  return function n(i, a, s) {
    var o = {
      x: -1,
      v: 0,
      tension: null,
      friction: null
    }, l = [0], u = 0, h = 1 / 1e4, d = 16 / 1e3, f, p, g;
    for (i = parseFloat(i) || 500, a = parseFloat(a) || 20, s = s || null, o.tension = i, o.friction = a, f = s !== null, f ? (u = n(i, a), p = u / s * d) : p = d; g = r(g || o, p), l.push(1 + g.x), u += 16, Math.abs(g.x) > h && Math.abs(g.v) > h; )
      ;
    return f ? function(m) {
      return l[m * (l.length - 1) | 0];
    } : u;
  };
})(), Br = function(e, r, n, i) {
  var a = x4e(e, r, n, i);
  return function(s, o, l) {
    return s + (o - s) * a(l);
  };
}, $m = {
  linear: function(e, r, n) {
    return e + (r - e) * n;
  },
  // default easings
  ease: Br(0.25, 0.1, 0.25, 1),
  "ease-in": Br(0.42, 0, 1, 1),
  "ease-out": Br(0, 0, 0.58, 1),
  "ease-in-out": Br(0.42, 0, 0.58, 1),
  // sine
  "ease-in-sine": Br(0.47, 0, 0.745, 0.715),
  "ease-out-sine": Br(0.39, 0.575, 0.565, 1),
  "ease-in-out-sine": Br(0.445, 0.05, 0.55, 0.95),
  // quad
  "ease-in-quad": Br(0.55, 0.085, 0.68, 0.53),
  "ease-out-quad": Br(0.25, 0.46, 0.45, 0.94),
  "ease-in-out-quad": Br(0.455, 0.03, 0.515, 0.955),
  // cubic
  "ease-in-cubic": Br(0.55, 0.055, 0.675, 0.19),
  "ease-out-cubic": Br(0.215, 0.61, 0.355, 1),
  "ease-in-out-cubic": Br(0.645, 0.045, 0.355, 1),
  // quart
  "ease-in-quart": Br(0.895, 0.03, 0.685, 0.22),
  "ease-out-quart": Br(0.165, 0.84, 0.44, 1),
  "ease-in-out-quart": Br(0.77, 0, 0.175, 1),
  // quint
  "ease-in-quint": Br(0.755, 0.05, 0.855, 0.06),
  "ease-out-quint": Br(0.23, 1, 0.32, 1),
  "ease-in-out-quint": Br(0.86, 0, 0.07, 1),
  // expo
  "ease-in-expo": Br(0.95, 0.05, 0.795, 0.035),
  "ease-out-expo": Br(0.19, 1, 0.22, 1),
  "ease-in-out-expo": Br(1, 0, 0, 1),
  // circ
  "ease-in-circ": Br(0.6, 0.04, 0.98, 0.335),
  "ease-out-circ": Br(0.075, 0.82, 0.165, 1),
  "ease-in-out-circ": Br(0.785, 0.135, 0.15, 0.86),
  // user param easings...
  spring: function(e, r, n) {
    if (n === 0)
      return $m.linear;
    var i = b4e(e, r, n);
    return function(a, s, o) {
      return a + (s - a) * i(o);
    };
  },
  "cubic-bezier": Br
};
function eL(t, e, r, n, i) {
  if (n === 1 || e === r)
    return r;
  var a = i(e, r, n);
  return t == null || ((t.roundValue || t.color) && (a = Math.round(a)), t.min !== void 0 && (a = Math.max(a, t.min)), t.max !== void 0 && (a = Math.min(a, t.max))), a;
}
function tL(t, e) {
  return t.pfValue != null || t.value != null ? t.pfValue != null && (e == null || e.type.units !== "%") ? t.pfValue : t.value : t;
}
function bh(t, e, r, n, i) {
  var a = i != null ? i.type : null;
  r < 0 ? r = 0 : r > 1 && (r = 1);
  var s = tL(t, i), o = tL(e, i);
  if (mt(s) && mt(o))
    return eL(a, s, o, r, n);
  if (Or(s) && Or(o)) {
    for (var l = [], u = 0; u < o.length; u++) {
      var h = s[u], d = o[u];
      if (h != null && d != null) {
        var f = eL(a, h, d, r, n);
        l.push(f);
      } else
        l.push(d);
    }
    return l;
  }
}
function w4e(t, e, r, n) {
  var i = !n, a = t._private, s = e._private, o = s.easing, l = s.startTime, u = n ? t : t.cy(), h = u.style();
  if (!s.easingImpl)
    if (o == null)
      s.easingImpl = $m.linear;
    else {
      var d;
      if (Bt(o)) {
        var f = h.parse("transition-timing-function", o);
        d = f.value;
      } else
        d = o;
      var p, g;
      Bt(d) ? (p = d, g = []) : (p = d[1], g = d.slice(2).map(function(B) {
        return +B;
      })), g.length > 0 ? (p === "spring" && g.push(s.duration), s.easingImpl = $m[p].apply(null, g)) : s.easingImpl = $m[p];
    }
  var m = s.easingImpl, v;
  if (s.duration === 0 ? v = 1 : v = (r - l) / s.duration, s.applying && (v = s.progress), v < 0 ? v = 0 : v > 1 && (v = 1), s.delay == null) {
    var y = s.startPosition, b = s.position;
    if (b && i && !t.locked()) {
      var w = {};
      If(y.x, b.x) && (w.x = bh(y.x, b.x, v, m)), If(y.y, b.y) && (w.y = bh(y.y, b.y, v, m)), t.position(w);
    }
    var T = s.startPan, E = s.pan, L = a.pan, k = E != null && n;
    k && (If(T.x, E.x) && (L.x = bh(T.x, E.x, v, m)), If(T.y, E.y) && (L.y = bh(T.y, E.y, v, m)), t.emit("pan"));
    var C = s.startZoom, A = s.zoom, R = A != null && n;
    R && (If(C, A) && (a.zoom = Pp(a.minZoom, bh(C, A, v, m), a.maxZoom)), t.emit("zoom")), (k || R) && t.emit("viewport");
    var _ = s.style;
    if (_ && _.length > 0 && i) {
      for (var O = 0; O < _.length; O++) {
        var P = _[O], S = P.name, M = P, N = s.startStyle[S], D = h.properties[N.name], I = bh(N, M, v, m, D);
        h.overrideBypass(t, S, I);
      }
      t.emit("style");
    }
  }
  return s.progress = v, v;
}
function If(t, e) {
  return t == null || e == null ? !1 : mt(t) && mt(e) ? !0 : !!(t && e);
}
function T4e(t, e, r, n) {
  var i = e._private;
  i.started = !0, i.startTime = r - i.progress * i.duration;
}
function rL(t, e) {
  var r = e._private.aniEles, n = [];
  function i(h, d) {
    var f = h._private, p = f.animation.current, g = f.animation.queue, m = !1;
    if (p.length === 0) {
      var v = g.shift();
      v && p.push(v);
    }
    for (var y = function(L) {
      for (var k = L.length - 1; k >= 0; k--) {
        var C = L[k];
        C();
      }
      L.splice(0, L.length);
    }, b = p.length - 1; b >= 0; b--) {
      var w = p[b], T = w._private;
      if (T.stopped) {
        p.splice(b, 1), T.hooked = !1, T.playing = !1, T.started = !1, y(T.frames);
        continue;
      }
      !T.playing && !T.applying || (T.playing && T.applying && (T.applying = !1), T.started || T4e(h, w, t), w4e(h, w, t, d), T.applying && (T.applying = !1), y(T.frames), T.step != null && T.step(t), w.completed() && (p.splice(b, 1), T.hooked = !1, T.playing = !1, T.started = !1, y(T.completes)), m = !0);
    }
    return !d && p.length === 0 && g.length === 0 && n.push(h), m;
  }
  for (var a = !1, s = 0; s < r.length; s++) {
    var o = r[s], l = i(o);
    a = a || l;
  }
  var u = i(e, !0);
  (a || u) && (r.length > 0 ? e.notify("draw", r) : e.notify("draw")), r.unmerge(n), e.emit("step");
}
var E4e = {
  // pull in animation functions
  animate: Ar.animate(),
  animation: Ar.animation(),
  animated: Ar.animated(),
  clearQueue: Ar.clearQueue(),
  delay: Ar.delay(),
  delayAnimation: Ar.delayAnimation(),
  stop: Ar.stop(),
  addToAnimationPool: function(e) {
    var r = this;
    r.styleEnabled() && r._private.aniEles.merge(e);
  },
  stopAnimationLoop: function() {
    this._private.animationsRunning = !1;
  },
  startAnimationLoop: function() {
    var e = this;
    if (e._private.animationsRunning = !0, !e.styleEnabled())
      return;
    function r() {
      e._private.animationsRunning && Sy(function(a) {
        rL(a, e), r();
      });
    }
    var n = e.renderer();
    n && n.beforeRender ? n.beforeRender(function(a, s) {
      rL(s, e);
    }, n.beforeRenderPriorities.animations) : r();
  }
}, k4e = {
  qualifierCompare: function(e, r) {
    return e == null || r == null ? e == null && r == null : e.sameText(r);
  },
  eventMatches: function(e, r, n) {
    var i = r.qualifier;
    return i != null ? e !== n.target && Eg(n.target) && i.matches(n.target) : !0;
  },
  addEventFields: function(e, r) {
    r.cy = e, r.target = e;
  },
  callbackContext: function(e, r, n) {
    return r.qualifier != null ? n.target : e;
  }
}, O1 = function(e) {
  return Bt(e) ? new ec(e) : e;
}, pU = {
  createEmitter: function() {
    var e = this._private;
    return e.emitter || (e.emitter = new Ox(k4e, this)), this;
  },
  emitter: function() {
    return this._private.emitter;
  },
  on: function(e, r, n) {
    return this.emitter().on(e, O1(r), n), this;
  },
  removeListener: function(e, r, n) {
    return this.emitter().removeListener(e, O1(r), n), this;
  },
  removeAllListeners: function() {
    return this.emitter().removeAllListeners(), this;
  },
  one: function(e, r, n) {
    return this.emitter().one(e, O1(r), n), this;
  },
  once: function(e, r, n) {
    return this.emitter().one(e, O1(r), n), this;
  },
  emit: function(e, r) {
    return this.emitter().emit(e, r), this;
  },
  emitAndNotify: function(e, r) {
    return this.emit(e), this.notify(e, r), this;
  }
};
Ar.eventAliasesOn(pU);
var wT = {
  png: function(e) {
    var r = this._private.renderer;
    return e = e || {}, r.png(e);
  },
  jpg: function(e) {
    var r = this._private.renderer;
    return e = e || {}, e.bg = e.bg || "#fff", r.jpg(e);
  }
};
wT.jpeg = wT.jpg;
var zm = {
  layout: function(e) {
    var r = this;
    if (e == null) {
      Zr("Layout options must be specified to make a layout");
      return;
    }
    if (e.name == null) {
      Zr("A `name` must be specified to make a layout");
      return;
    }
    var n = e.name, i = r.extension("layout", n);
    if (i == null) {
      Zr("No such layout `" + n + "` found.  Did you forget to import it and `cytoscape.use()` it?");
      return;
    }
    var a;
    Bt(e.eles) ? a = r.$(e.eles) : a = e.eles != null ? e.eles : r.$();
    var s = new i(Gt({}, e, {
      cy: r,
      eles: a
    }));
    return s;
  }
};
zm.createLayout = zm.makeLayout = zm.layout;
var S4e = {
  notify: function(e, r) {
    var n = this._private;
    if (this.batching()) {
      n.batchNotifications = n.batchNotifications || {};
      var i = n.batchNotifications[e] = n.batchNotifications[e] || this.collection();
      r != null && i.merge(r);
      return;
    }
    if (n.notificationsEnabled) {
      var a = this.renderer();
      this.destroyed() || !a || a.notify(e, r);
    }
  },
  notifications: function(e) {
    var r = this._private;
    return e === void 0 ? r.notificationsEnabled : (r.notificationsEnabled = !!e, this);
  },
  noNotifications: function(e) {
    this.notifications(!1), e(), this.notifications(!0);
  },
  batching: function() {
    return this._private.batchCount > 0;
  },
  startBatch: function() {
    var e = this._private;
    return e.batchCount == null && (e.batchCount = 0), e.batchCount === 0 && (e.batchStyleEles = this.collection(), e.batchNotifications = {}), e.batchCount++, this;
  },
  endBatch: function() {
    var e = this._private;
    if (e.batchCount === 0)
      return this;
    if (e.batchCount--, e.batchCount === 0) {
      e.batchStyleEles.updateStyle();
      var r = this.renderer();
      Object.keys(e.batchNotifications).forEach(function(n) {
        var i = e.batchNotifications[n];
        i.empty() ? r.notify(n) : r.notify(n, i);
      });
    }
    return this;
  },
  batch: function(e) {
    return this.startBatch(), e(), this.endBatch(), this;
  },
  // for backwards compatibility
  batchData: function(e) {
    var r = this;
    return this.batch(function() {
      for (var n = Object.keys(e), i = 0; i < n.length; i++) {
        var a = n[i], s = e[a], o = r.getElementById(a);
        o.data(s);
      }
    });
  }
}, C4e = fi({
  hideEdgesOnViewport: !1,
  textureOnViewport: !1,
  motionBlur: !1,
  motionBlurOpacity: 0.05,
  pixelRatio: void 0,
  desktopTapThreshold: 4,
  touchTapThreshold: 8,
  wheelSensitivity: 1,
  debug: !1,
  showFps: !1,
  // webgl options
  webgl: !1,
  webglDebug: !1,
  webglDebugShowAtlases: !1,
  // defaults good for mobile
  webglTexSize: 2048,
  webglTexRows: 36,
  webglTexRowsNodes: 18,
  webglBatchSize: 2048,
  webglTexPerBatch: 14,
  webglBgColor: [255, 255, 255]
}), TT = {
  renderTo: function(e, r, n, i) {
    var a = this._private.renderer;
    return a.renderTo(e, r, n, i), this;
  },
  renderer: function() {
    return this._private.renderer;
  },
  forceRender: function() {
    return this.notify("draw"), this;
  },
  resize: function() {
    return this.invalidateSize(), this.emitAndNotify("resize"), this;
  },
  initRenderer: function(e) {
    var r = this, n = r.extension("renderer", e.name);
    if (n == null) {
      Zr("Can not initialise: No such renderer `".concat(e.name, "` found. Did you forget to import it and `cytoscape.use()` it?"));
      return;
    }
    e.wheelSensitivity !== void 0 && Lr("You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.");
    var i = C4e(e);
    i.cy = r, r._private.renderer = new n(i), this.notify("init");
  },
  destroyRenderer: function() {
    var e = this;
    e.notify("destroy");
    var r = e.container();
    if (r)
      for (r._cyreg = null; r.childNodes.length > 0; )
        r.removeChild(r.childNodes[0]);
    e._private.renderer = null, e.mutableElements().forEach(function(n) {
      var i = n._private;
      i.rscratch = {}, i.rstyle = {}, i.animation.current = [], i.animation.queue = [];
    });
  },
  onRender: function(e) {
    return this.on("render", e);
  },
  offRender: function(e) {
    return this.off("render", e);
  }
};
TT.invalidateDimensions = TT.resize;
var Gm = {
  // get a collection
  // - empty collection on no args
  // - collection of elements in the graph on selector arg
  // - guarantee a returned collection when elements or collection specified
  collection: function(e, r) {
    return Bt(e) ? this.$(e) : ka(e) ? e.collection() : Or(e) ? (r || (r = {}), new ui(this, e, r.unique, r.removed)) : new ui(this);
  },
  nodes: function(e) {
    var r = this.$(function(n) {
      return n.isNode();
    });
    return e ? r.filter(e) : r;
  },
  edges: function(e) {
    var r = this.$(function(n) {
      return n.isEdge();
    });
    return e ? r.filter(e) : r;
  },
  // search the graph like jQuery
  $: function(e) {
    var r = this._private.elements;
    return e ? r.filter(e) : r.spawnSelf();
  },
  mutableElements: function() {
    return this._private.elements;
  }
};
Gm.elements = Gm.filter = Gm.$;
var Jn = {}, ep = "t", A4e = "f";
Jn.apply = function(t) {
  for (var e = this, r = e._private, n = r.cy, i = n.collection(), a = 0; a < t.length; a++) {
    var s = t[a], o = e.getContextMeta(s);
    if (!o.empty) {
      var l = e.getContextStyle(o), u = e.applyContextStyle(o, l, s);
      s._private.appliedInitStyle ? e.updateTransitions(s, u.diffProps) : s._private.appliedInitStyle = !0;
      var h = e.updateStyleHints(s);
      h && i.push(s);
    }
  }
  return i;
};
Jn.getPropertiesDiff = function(t, e) {
  var r = this, n = r._private.propDiffs = r._private.propDiffs || {}, i = t + "-" + e, a = n[i];
  if (a)
    return a;
  for (var s = [], o = {}, l = 0; l < r.length; l++) {
    var u = r[l], h = t[l] === ep, d = e[l] === ep, f = h !== d, p = u.mappedProperties.length > 0;
    if (f || d && p) {
      var g = void 0;
      f && p || f ? g = u.properties : p && (g = u.mappedProperties);
      for (var m = 0; m < g.length; m++) {
        for (var v = g[m], y = v.name, b = !1, w = l + 1; w < r.length; w++) {
          var T = r[w], E = e[w] === ep;
          if (E && (b = T.properties[v.name] != null, b))
            break;
        }
        !o[y] && !b && (o[y] = !0, s.push(y));
      }
    }
  }
  return n[i] = s, s;
};
Jn.getContextMeta = function(t) {
  for (var e = this, r = "", n, i = t._private.styleCxtKey || "", a = 0; a < e.length; a++) {
    var s = e[a], o = s.selector && s.selector.matches(t);
    o ? r += ep : r += A4e;
  }
  return n = e.getPropertiesDiff(i, r), t._private.styleCxtKey = r, {
    key: r,
    diffPropNames: n,
    empty: n.length === 0
  };
};
Jn.getContextStyle = function(t) {
  var e = t.key, r = this, n = this._private.contextStyles = this._private.contextStyles || {};
  if (n[e])
    return n[e];
  for (var i = {
    _private: {
      key: e
    }
  }, a = 0; a < r.length; a++) {
    var s = r[a], o = e[a] === ep;
    if (o)
      for (var l = 0; l < s.properties.length; l++) {
        var u = s.properties[l];
        i[u.name] = u;
      }
  }
  return n[e] = i, i;
};
Jn.applyContextStyle = function(t, e, r) {
  for (var n = this, i = t.diffPropNames, a = {}, s = n.types, o = 0; o < i.length; o++) {
    var l = i[o], u = e[l], h = r.pstyle(l);
    if (!u)
      if (h)
        h.bypass ? u = {
          name: l,
          deleteBypassed: !0
        } : u = {
          name: l,
          delete: !0
        };
      else continue;
    if (h !== u) {
      if (u.mapped === s.fn && h != null && h.mapping != null && h.mapping.value === u.value) {
        var d = h.mapping, f = d.fnValue = u.value(r);
        if (f === d.prevFnValue)
          continue;
      }
      var p = a[l] = {
        prev: h
      };
      n.applyParsedProperty(r, u), p.next = r.pstyle(l), p.next && p.next.bypass && (p.next = p.next.bypassed);
    }
  }
  return {
    diffProps: a
  };
};
Jn.updateStyleHints = function(t) {
  var e = t._private, r = this, n = r.propertyGroupNames, i = r.propertyGroupKeys, a = function(Y, ee, j) {
    return r.getPropertiesHash(Y, ee, j);
  }, s = e.styleKey;
  if (t.removed())
    return !1;
  var o = e.group === "nodes", l = t._private.style;
  n = Object.keys(l);
  for (var u = 0; u < i.length; u++) {
    var h = i[u];
    e.styleKeys[h] = [Kc, Nh];
  }
  for (var d = function(Y, ee) {
    return e.styleKeys[ee][0] = Ip(Y, e.styleKeys[ee][0]);
  }, f = function(Y, ee) {
    return e.styleKeys[ee][1] = Dp(Y, e.styleKeys[ee][1]);
  }, p = function(Y, ee) {
    d(Y, ee), f(Y, ee);
  }, g = function(Y, ee) {
    for (var j = 0; j < Y.length; j++) {
      var fe = Y.charCodeAt(j);
      d(fe, ee), f(fe, ee);
    }
  }, m = 2e9, v = function(Y) {
    return -128 < Y && Y < 128 && Math.floor(Y) !== Y ? m - (Y * 1024 | 0) : Y;
  }, y = 0; y < n.length; y++) {
    var b = n[y], w = l[b];
    if (w != null) {
      var T = this.properties[b], E = T.type, L = T.groupKey, k = void 0;
      T.hashOverride != null ? k = T.hashOverride(t, w) : w.pfValue != null && (k = w.pfValue);
      var C = T.enums == null ? w.value : null, A = k != null, R = C != null, _ = A || R, O = w.units;
      if (E.number && _ && !E.multiple) {
        var P = A ? k : C;
        p(v(P), L), !A && O != null && g(O, L);
      } else
        g(w.strValue, L);
    }
  }
  for (var S = [Kc, Nh], M = 0; M < i.length; M++) {
    var N = i[M], D = e.styleKeys[N];
    S[0] = Ip(D[0], S[0]), S[1] = Dp(D[1], S[1]);
  }
  e.styleKey = Uye(S[0], S[1]);
  var I = e.styleKeys;
  e.labelDimsKey = Tl(I.labelDimensions);
  var B = a(t, ["label"], I.labelDimensions);
  if (e.labelKey = Tl(B), e.labelStyleKey = Tl(A1(I.commonLabel, B)), !o) {
    var z = a(t, ["source-label"], I.labelDimensions);
    e.sourceLabelKey = Tl(z), e.sourceLabelStyleKey = Tl(A1(I.commonLabel, z));
    var F = a(t, ["target-label"], I.labelDimensions);
    e.targetLabelKey = Tl(F), e.targetLabelStyleKey = Tl(A1(I.commonLabel, F));
  }
  if (o) {
    var V = e.styleKeys, H = V.nodeBody, J = V.nodeBorder, q = V.nodeOutline, ae = V.backgroundImage, re = V.compound, pe = V.pie, K = V.stripe, Z = [H, J, q, ae, re, pe, K].filter(function(X) {
      return X != null;
    }).reduce(A1, [Kc, Nh]);
    e.nodeKey = Tl(Z), e.hasPie = pe != null && pe[0] !== Kc && pe[1] !== Nh, e.hasStripe = K != null && K[0] !== Kc && K[1] !== Nh;
  }
  return s !== e.styleKey;
};
Jn.clearStyleHints = function(t) {
  var e = t._private;
  e.styleCxtKey = "", e.styleKeys = {}, e.styleKey = null, e.labelKey = null, e.labelStyleKey = null, e.sourceLabelKey = null, e.sourceLabelStyleKey = null, e.targetLabelKey = null, e.targetLabelStyleKey = null, e.nodeKey = null, e.hasPie = null, e.hasStripe = null;
};
Jn.applyParsedProperty = function(t, e) {
  var r = this, n = e, i = t._private.style, a, s = r.types, o = r.properties[n.name].type, l = n.bypass, u = i[n.name], h = u && u.bypass, d = t._private, f = "mapping", p = function(H) {
    return H == null ? null : H.pfValue != null ? H.pfValue : H.value;
  }, g = function() {
    var H = p(u), J = p(n);
    r.checkTriggers(t, n.name, H, J);
  };
  if (e.name === "curve-style" && t.isEdge() && // loops must be bundled beziers
  (e.value !== "bezier" && t.isLoop() || // edges connected to compound nodes can not be haystacks
  e.value === "haystack" && (t.source().isParent() || t.target().isParent())) && (n = e = this.parse(e.name, "bezier", l)), n.delete)
    return i[n.name] = void 0, g(), !0;
  if (n.deleteBypassed)
    return u ? u.bypass ? (u.bypassed = void 0, g(), !0) : !1 : (g(), !0);
  if (n.deleteBypass)
    return u ? u.bypass ? (i[n.name] = u.bypassed, g(), !0) : !1 : (g(), !0);
  var m = function() {
    Lr("Do not assign mappings to elements without corresponding data (i.e. ele `" + t.id() + "` has no mapping for property `" + n.name + "` with data field `" + n.field + "`); try a `[" + n.field + "]` selector to limit scope to elements with `" + n.field + "` defined");
  };
  switch (n.mapped) {
    // flatten the property if mapped
    case s.mapData: {
      for (var v = n.field.split("."), y = d.data, b = 0; b < v.length && y; b++) {
        var w = v[b];
        y = y[w];
      }
      if (y == null)
        return m(), !1;
      var T;
      if (mt(y)) {
        var E = n.fieldMax - n.fieldMin;
        E === 0 ? T = 0 : T = (y - n.fieldMin) / E;
      } else
        return Lr("Do not use continuous mappers without specifying numeric data (i.e. `" + n.field + ": " + y + "` for `" + t.id() + "` is non-numeric)"), !1;
      if (T < 0 ? T = 0 : T > 1 && (T = 1), o.color) {
        var L = n.valueMin[0], k = n.valueMax[0], C = n.valueMin[1], A = n.valueMax[1], R = n.valueMin[2], _ = n.valueMax[2], O = n.valueMin[3] == null ? 1 : n.valueMin[3], P = n.valueMax[3] == null ? 1 : n.valueMax[3], S = [Math.round(L + (k - L) * T), Math.round(C + (A - C) * T), Math.round(R + (_ - R) * T), Math.round(O + (P - O) * T)];
        a = {
          // colours are simple, so just create the flat property instead of expensive string parsing
          bypass: n.bypass,
          // we're a bypass if the mapping property is a bypass
          name: n.name,
          value: S,
          strValue: "rgb(" + S[0] + ", " + S[1] + ", " + S[2] + ")"
        };
      } else if (o.number) {
        var M = n.valueMin + (n.valueMax - n.valueMin) * T;
        a = this.parse(n.name, M, n.bypass, f);
      } else
        return !1;
      if (!a)
        return m(), !1;
      a.mapping = n, n = a;
      break;
    }
    // direct mapping
    case s.data: {
      for (var N = n.field.split("."), D = d.data, I = 0; I < N.length && D; I++) {
        var B = N[I];
        D = D[B];
      }
      if (D != null && (a = this.parse(n.name, D, n.bypass, f)), !a)
        return m(), !1;
      a.mapping = n, n = a;
      break;
    }
    case s.fn: {
      var z = n.value, F = n.fnValue != null ? n.fnValue : z(t);
      if (n.prevFnValue = F, F == null)
        return Lr("Custom function mappers may not return null (i.e. `" + n.name + "` for ele `" + t.id() + "` is null)"), !1;
      if (a = this.parse(n.name, F, n.bypass, f), !a)
        return Lr("Custom function mappers may not return invalid values for the property type (i.e. `" + n.name + "` for ele `" + t.id() + "` is invalid)"), !1;
      a.mapping = Zs(n), n = a;
      break;
    }
    case void 0:
      break;
    // just set the property
    default:
      return !1;
  }
  return l ? (h ? n.bypassed = u.bypassed : n.bypassed = u, i[n.name] = n) : h ? u.bypassed = n : i[n.name] = n, g(), !0;
};
Jn.cleanElements = function(t, e) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    if (this.clearStyleHints(n), n.dirtyCompoundBoundsCache(), n.dirtyBoundingBoxCache(), !e)
      n._private.style = {};
    else
      for (var i = n._private.style, a = Object.keys(i), s = 0; s < a.length; s++) {
        var o = a[s], l = i[o];
        l != null && (l.bypass ? l.bypassed = null : i[o] = null);
      }
  }
};
Jn.update = function() {
  var t = this._private.cy, e = t.mutableElements();
  e.updateStyle();
};
Jn.updateTransitions = function(t, e) {
  var r = this, n = t._private, i = t.pstyle("transition-property").value, a = t.pstyle("transition-duration").pfValue, s = t.pstyle("transition-delay").pfValue;
  if (i.length > 0 && a > 0) {
    for (var o = {}, l = !1, u = 0; u < i.length; u++) {
      var h = i[u], d = t.pstyle(h), f = e[h];
      if (f) {
        var p = f.prev, g = p, m = f.next != null ? f.next : d, v = !1, y = void 0, b = 1e-6;
        g && (mt(g.pfValue) && mt(m.pfValue) ? (v = m.pfValue - g.pfValue, y = g.pfValue + b * v) : mt(g.value) && mt(m.value) ? (v = m.value - g.value, y = g.value + b * v) : Or(g.value) && Or(m.value) && (v = g.value[0] !== m.value[0] || g.value[1] !== m.value[1] || g.value[2] !== m.value[2], y = g.strValue), v && (o[h] = m.strValue, this.applyBypass(t, h, y), l = !0));
      }
    }
    if (!l)
      return;
    n.transitioning = !0, new rf(function(w) {
      s > 0 ? t.delayAnimation(s).play().promise().then(w) : w();
    }).then(function() {
      return t.animation({
        style: o,
        duration: a,
        easing: t.pstyle("transition-timing-function").value,
        queue: !1
      }).play().promise();
    }).then(function() {
      r.removeBypasses(t, i), t.emitAndNotify("style"), n.transitioning = !1;
    });
  } else n.transitioning && (this.removeBypasses(t, i), t.emitAndNotify("style"), n.transitioning = !1);
};
Jn.checkTrigger = function(t, e, r, n, i, a) {
  var s = this.properties[e], o = i(s);
  t.removed() || o != null && o(r, n, t) && a(s);
};
Jn.checkZOrderTrigger = function(t, e, r, n) {
  var i = this;
  this.checkTrigger(t, e, r, n, function(a) {
    return a.triggersZOrder;
  }, function() {
    i._private.cy.notify("zorder", t);
  });
};
Jn.checkBoundsTrigger = function(t, e, r, n) {
  this.checkTrigger(t, e, r, n, function(i) {
    return i.triggersBounds;
  }, function(i) {
    t.dirtyCompoundBoundsCache(), t.dirtyBoundingBoxCache();
  });
};
Jn.checkConnectedEdgesBoundsTrigger = function(t, e, r, n) {
  this.checkTrigger(t, e, r, n, function(i) {
    return i.triggersBoundsOfConnectedEdges;
  }, function(i) {
    t.connectedEdges().forEach(function(a) {
      a.dirtyBoundingBoxCache();
    });
  });
};
Jn.checkParallelEdgesBoundsTrigger = function(t, e, r, n) {
  this.checkTrigger(t, e, r, n, function(i) {
    return i.triggersBoundsOfParallelEdges;
  }, function(i) {
    t.parallelEdges().forEach(function(a) {
      a.dirtyBoundingBoxCache();
    });
  });
};
Jn.checkTriggers = function(t, e, r, n) {
  t.dirtyStyleCache(), this.checkZOrderTrigger(t, e, r, n), this.checkBoundsTrigger(t, e, r, n), this.checkConnectedEdgesBoundsTrigger(t, e, r, n), this.checkParallelEdgesBoundsTrigger(t, e, r, n);
};
var Rg = {};
Rg.applyBypass = function(t, e, r, n) {
  var i = this, a = [], s = !0;
  if (e === "*" || e === "**") {
    if (r !== void 0)
      for (var o = 0; o < i.properties.length; o++) {
        var l = i.properties[o], u = l.name, h = this.parse(u, r, !0);
        h && a.push(h);
      }
  } else if (Bt(e)) {
    var d = this.parse(e, r, !0);
    d && a.push(d);
  } else if (mr(e)) {
    var f = e;
    n = r;
    for (var p = Object.keys(f), g = 0; g < p.length; g++) {
      var m = p[g], v = f[m];
      if (v === void 0 && (v = f[Sx(m)]), v !== void 0) {
        var y = this.parse(m, v, !0);
        y && a.push(y);
      }
    }
  } else
    return !1;
  if (a.length === 0)
    return !1;
  for (var b = !1, w = 0; w < t.length; w++) {
    for (var T = t[w], E = {}, L = void 0, k = 0; k < a.length; k++) {
      var C = a[k];
      if (n) {
        var A = T.pstyle(C.name);
        L = E[C.name] = {
          prev: A
        };
      }
      b = this.applyParsedProperty(T, Zs(C)) || b, n && (L.next = T.pstyle(C.name));
    }
    b && this.updateStyleHints(T), n && this.updateTransitions(T, E, s);
  }
  return b;
};
Rg.overrideBypass = function(t, e, r) {
  e = Xk(e);
  for (var n = 0; n < t.length; n++) {
    var i = t[n], a = i._private.style[e], s = this.properties[e].type, o = s.color, l = s.mutiple, u = a ? a.pfValue != null ? a.pfValue : a.value : null;
    !a || !a.bypass ? this.applyBypass(i, e, r) : (a.value = r, a.pfValue != null && (a.pfValue = r), o ? a.strValue = "rgb(" + r.join(",") + ")" : l ? a.strValue = r.join(" ") : a.strValue = "" + r, this.updateStyleHints(i)), this.checkTriggers(i, e, u, r);
  }
};
Rg.removeAllBypasses = function(t, e) {
  return this.removeBypasses(t, this.propertyNames, e);
};
Rg.removeBypasses = function(t, e, r) {
  for (var n = !0, i = 0; i < t.length; i++) {
    for (var a = t[i], s = {}, o = 0; o < e.length; o++) {
      var l = e[o], u = this.properties[l], h = a.pstyle(u.name);
      if (!(!h || !h.bypass)) {
        var d = "", f = this.parse(l, d, !0), p = s[u.name] = {
          prev: h
        };
        this.applyParsedProperty(a, f), p.next = a.pstyle(u.name);
      }
    }
    this.updateStyleHints(a), r && this.updateTransitions(a, s, n);
  }
};
var cS = {};
cS.getEmSizeInPixels = function() {
  var t = this.containerCss("font-size");
  return t != null ? parseFloat(t) : 1;
};
cS.containerCss = function(t) {
  var e = this._private.cy, r = e.container(), n = e.window();
  if (n && r && n.getComputedStyle)
    return n.getComputedStyle(r).getPropertyValue(t);
};
var so = {};
so.getRenderedStyle = function(t, e) {
  return e ? this.getStylePropertyValue(t, e, !0) : this.getRawStyle(t, !0);
};
so.getRawStyle = function(t, e) {
  var r = this;
  if (t = t[0], t) {
    for (var n = {}, i = 0; i < r.properties.length; i++) {
      var a = r.properties[i], s = r.getStylePropertyValue(t, a.name, e);
      s != null && (n[a.name] = s, n[Sx(a.name)] = s);
    }
    return n;
  }
};
so.getIndexedStyle = function(t, e, r, n) {
  var i = t.pstyle(e)[r][n];
  return i ?? t.cy().style().getDefaultProperty(e)[r][0];
};
so.getStylePropertyValue = function(t, e, r) {
  var n = this;
  if (t = t[0], t) {
    var i = n.properties[e];
    i.alias && (i = i.pointsTo);
    var a = i.type, s = t.pstyle(i.name);
    if (s) {
      var o = s.value, l = s.units, u = s.strValue;
      if (r && a.number && o != null && mt(o)) {
        var h = t.cy().zoom(), d = function(v) {
          return v * h;
        }, f = function(v, y) {
          return d(v) + y;
        }, p = Or(o), g = p ? l.every(function(m) {
          return m != null;
        }) : l != null;
        return g ? p ? o.map(function(m, v) {
          return f(m, l[v]);
        }).join(" ") : f(o, l) : p ? o.map(function(m) {
          return Bt(m) ? m : "" + d(m);
        }).join(" ") : "" + d(o);
      } else if (u != null)
        return u;
    }
    return null;
  }
};
so.getAnimationStartStyle = function(t, e) {
  for (var r = {}, n = 0; n < e.length; n++) {
    var i = e[n], a = i.name, s = t.pstyle(a);
    s !== void 0 && (mr(s) ? s = this.parse(a, s.strValue) : s = this.parse(a, s)), s && (r[a] = s);
  }
  return r;
};
so.getPropsList = function(t) {
  var e = this, r = [], n = t, i = e.properties;
  if (n)
    for (var a = Object.keys(n), s = 0; s < a.length; s++) {
      var o = a[s], l = n[o], u = i[o] || i[Xk(o)], h = this.parse(u.name, l);
      h && r.push(h);
    }
  return r;
};
so.getNonDefaultPropertiesHash = function(t, e, r) {
  var n = r.slice(), i, a, s, o, l, u;
  for (l = 0; l < e.length; l++)
    if (i = e[l], a = t.pstyle(i, !1), a != null)
      if (a.pfValue != null)
        n[0] = Ip(o, n[0]), n[1] = Dp(o, n[1]);
      else
        for (s = a.strValue, u = 0; u < s.length; u++)
          o = s.charCodeAt(u), n[0] = Ip(o, n[0]), n[1] = Dp(o, n[1]);
  return n;
};
so.getPropertiesHash = so.getNonDefaultPropertiesHash;
var Fx = {};
Fx.appendFromJson = function(t) {
  for (var e = this, r = 0; r < t.length; r++) {
    var n = t[r], i = n.selector, a = n.style || n.css, s = Object.keys(a);
    e.selector(i);
    for (var o = 0; o < s.length; o++) {
      var l = s[o], u = a[l];
      e.css(l, u);
    }
  }
  return e;
};
Fx.fromJson = function(t) {
  var e = this;
  return e.resetToDefault(), e.appendFromJson(t), e;
};
Fx.json = function() {
  for (var t = [], e = this.defaultLength; e < this.length; e++) {
    for (var r = this[e], n = r.selector, i = r.properties, a = {}, s = 0; s < i.length; s++) {
      var o = i[s];
      a[o.name] = o.strValue;
    }
    t.push({
      selector: n ? n.toString() : "core",
      style: a
    });
  }
  return t;
};
var uS = {};
uS.appendFromString = function(t) {
  var e = this, r = this, n = "" + t, i, a, s;
  n = n.replace(/[/][*](\s|.)+?[*][/]/g, "");
  function o() {
    n.length > i.length ? n = n.substr(i.length) : n = "";
  }
  function l() {
    a.length > s.length ? a = a.substr(s.length) : a = "";
  }
  for (; ; ) {
    var u = n.match(/^\s*$/);
    if (u)
      break;
    var h = n.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);
    if (!h) {
      Lr("Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: " + n);
      break;
    }
    i = h[0];
    var d = h[1];
    if (d !== "core") {
      var f = new ec(d);
      if (f.invalid) {
        Lr("Skipping parsing of block: Invalid selector found in string stylesheet: " + d), o();
        continue;
      }
    }
    var p = h[2], g = !1;
    a = p;
    for (var m = []; ; ) {
      var v = a.match(/^\s*$/);
      if (v)
        break;
      var y = a.match(/^\s*(.+?)\s*:\s*(.+?)(?:\s*;|\s*$)/);
      if (!y) {
        Lr("Skipping parsing of block: Invalid formatting of style property and value definitions found in:" + p), g = !0;
        break;
      }
      s = y[0];
      var b = y[1], w = y[2], T = e.properties[b];
      if (!T) {
        Lr("Skipping property: Invalid property name in: " + s), l();
        continue;
      }
      var E = r.parse(b, w);
      if (!E) {
        Lr("Skipping property: Invalid property definition in: " + s), l();
        continue;
      }
      m.push({
        name: b,
        val: w
      }), l();
    }
    if (g) {
      o();
      break;
    }
    r.selector(d);
    for (var L = 0; L < m.length; L++) {
      var k = m[L];
      r.css(k.name, k.val);
    }
    o();
  }
  return r;
};
uS.fromString = function(t) {
  var e = this;
  return e.resetToDefault(), e.appendFromString(t), e;
};
var Tn = {};
(function() {
  var t = Fn, e = wye, r = Eye, n = kye, i = Sye, a = function(X) {
    return "^" + X + "\\s*\\(\\s*([\\w\\.]+)\\s*\\)$";
  }, s = function(X) {
    var Y = t + "|\\w+|" + e + "|" + r + "|" + n + "|" + i;
    return "^" + X + "\\s*\\(([\\w\\.]+)\\s*\\,\\s*(" + t + ")\\s*\\,\\s*(" + t + ")\\s*,\\s*(" + Y + ")\\s*\\,\\s*(" + Y + ")\\)$";
  }, o = [`^url\\s*\\(\\s*['"]?(.+?)['"]?\\s*\\)$`, "^(none)$", "^(.+)$"];
  Tn.types = {
    time: {
      number: !0,
      min: 0,
      units: "s|ms",
      implicitUnits: "ms"
    },
    percent: {
      number: !0,
      min: 0,
      max: 100,
      units: "%",
      implicitUnits: "%"
    },
    percentages: {
      number: !0,
      min: 0,
      max: 100,
      units: "%",
      implicitUnits: "%",
      multiple: !0
    },
    zeroOneNumber: {
      number: !0,
      min: 0,
      max: 1,
      unitless: !0
    },
    zeroOneNumbers: {
      number: !0,
      min: 0,
      max: 1,
      unitless: !0,
      multiple: !0
    },
    nOneOneNumber: {
      number: !0,
      min: -1,
      max: 1,
      unitless: !0
    },
    nonNegativeInt: {
      number: !0,
      min: 0,
      integer: !0,
      unitless: !0
    },
    nonNegativeNumber: {
      number: !0,
      min: 0,
      unitless: !0
    },
    position: {
      enums: ["parent", "origin"]
    },
    nodeSize: {
      number: !0,
      min: 0,
      enums: ["label"]
    },
    number: {
      number: !0,
      unitless: !0
    },
    numbers: {
      number: !0,
      unitless: !0,
      multiple: !0
    },
    positiveNumber: {
      number: !0,
      unitless: !0,
      min: 0,
      strictMin: !0
    },
    size: {
      number: !0,
      min: 0
    },
    bidirectionalSize: {
      number: !0
    },
    // allows negative
    bidirectionalSizeMaybePercent: {
      number: !0,
      allowPercent: !0
    },
    // allows negative
    bidirectionalSizes: {
      number: !0,
      multiple: !0
    },
    // allows negative
    sizeMaybePercent: {
      number: !0,
      min: 0,
      allowPercent: !0
    },
    axisDirection: {
      enums: ["horizontal", "leftward", "rightward", "vertical", "upward", "downward", "auto"]
    },
    axisDirectionExplicit: {
      enums: ["leftward", "rightward", "upward", "downward"]
    },
    axisDirectionPrimary: {
      enums: ["horizontal", "vertical"]
    },
    paddingRelativeTo: {
      enums: ["width", "height", "average", "min", "max"]
    },
    bgWH: {
      number: !0,
      min: 0,
      allowPercent: !0,
      enums: ["auto"],
      multiple: !0
    },
    bgPos: {
      number: !0,
      allowPercent: !0,
      multiple: !0
    },
    bgRelativeTo: {
      enums: ["inner", "include-padding"],
      multiple: !0
    },
    bgRepeat: {
      enums: ["repeat", "repeat-x", "repeat-y", "no-repeat"],
      multiple: !0
    },
    bgFit: {
      enums: ["none", "contain", "cover"],
      multiple: !0
    },
    bgCrossOrigin: {
      enums: ["anonymous", "use-credentials", "null"],
      multiple: !0
    },
    bgClip: {
      enums: ["none", "node"],
      multiple: !0
    },
    bgContainment: {
      enums: ["inside", "over"],
      multiple: !0
    },
    boxSelection: {
      enums: ["contain", "overlap", "none"]
    },
    color: {
      color: !0
    },
    colors: {
      color: !0,
      multiple: !0
    },
    fill: {
      enums: ["solid", "linear-gradient", "radial-gradient"]
    },
    bool: {
      enums: ["yes", "no"]
    },
    bools: {
      enums: ["yes", "no"],
      multiple: !0
    },
    lineStyle: {
      enums: ["solid", "dotted", "dashed"]
    },
    lineCap: {
      enums: ["butt", "round", "square"]
    },
    linePosition: {
      enums: ["center", "inside", "outside"]
    },
    lineJoin: {
      enums: ["round", "bevel", "miter"]
    },
    borderStyle: {
      enums: ["solid", "dotted", "dashed", "double"]
    },
    curveStyle: {
      enums: ["bezier", "unbundled-bezier", "haystack", "segments", "straight", "straight-triangle", "taxi", "round-segments", "round-taxi"]
    },
    radiusType: {
      enums: ["arc-radius", "influence-radius"],
      multiple: !0
    },
    fontFamily: {
      regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$'
    },
    fontStyle: {
      enums: ["italic", "normal", "oblique"]
    },
    fontWeight: {
      enums: ["normal", "bold", "bolder", "lighter", "100", "200", "300", "400", "500", "600", "800", "900", 100, 200, 300, 400, 500, 600, 700, 800, 900]
    },
    textDecoration: {
      enums: ["none", "underline", "overline", "line-through"]
    },
    textTransform: {
      enums: ["none", "uppercase", "lowercase"]
    },
    textWrap: {
      enums: ["none", "wrap", "ellipsis"]
    },
    textOverflowWrap: {
      enums: ["whitespace", "anywhere"]
    },
    textBackgroundShape: {
      enums: ["rectangle", "roundrectangle", "round-rectangle", "circle"]
    },
    nodeShape: {
      enums: ["rectangle", "roundrectangle", "round-rectangle", "cutrectangle", "cut-rectangle", "bottomroundrectangle", "bottom-round-rectangle", "barrel", "ellipse", "triangle", "round-triangle", "square", "pentagon", "round-pentagon", "hexagon", "round-hexagon", "concavehexagon", "concave-hexagon", "heptagon", "round-heptagon", "octagon", "round-octagon", "tag", "round-tag", "star", "diamond", "round-diamond", "vee", "rhomboid", "right-rhomboid", "polygon"]
    },
    overlayShape: {
      enums: ["roundrectangle", "round-rectangle", "ellipse"]
    },
    cornerRadius: {
      number: !0,
      min: 0,
      units: "px|em",
      implicitUnits: "px",
      enums: ["auto"]
    },
    compoundIncludeLabels: {
      enums: ["include", "exclude"]
    },
    arrowShape: {
      enums: ["tee", "triangle", "triangle-tee", "circle-triangle", "triangle-cross", "triangle-backcurve", "vee", "square", "circle", "diamond", "chevron", "none"]
    },
    arrowFill: {
      enums: ["filled", "hollow"]
    },
    arrowWidth: {
      number: !0,
      units: "%|px|em",
      implicitUnits: "px",
      enums: ["match-line"]
    },
    display: {
      enums: ["element", "none"]
    },
    visibility: {
      enums: ["hidden", "visible"]
    },
    zCompoundDepth: {
      enums: ["bottom", "orphan", "auto", "top"]
    },
    zIndexCompare: {
      enums: ["auto", "manual"]
    },
    valign: {
      enums: ["top", "center", "bottom"]
    },
    halign: {
      enums: ["left", "center", "right"]
    },
    justification: {
      enums: ["left", "center", "right", "auto"]
    },
    text: {
      string: !0
    },
    data: {
      mapping: !0,
      regex: a("data")
    },
    layoutData: {
      mapping: !0,
      regex: a("layoutData")
    },
    scratch: {
      mapping: !0,
      regex: a("scratch")
    },
    mapData: {
      mapping: !0,
      regex: s("mapData")
    },
    mapLayoutData: {
      mapping: !0,
      regex: s("mapLayoutData")
    },
    mapScratch: {
      mapping: !0,
      regex: s("mapScratch")
    },
    fn: {
      mapping: !0,
      fn: !0
    },
    url: {
      regexes: o,
      singleRegexMatchValue: !0
    },
    urls: {
      regexes: o,
      singleRegexMatchValue: !0,
      multiple: !0
    },
    propList: {
      propList: !0
    },
    angle: {
      number: !0,
      units: "deg|rad",
      implicitUnits: "rad"
    },
    textRotation: {
      number: !0,
      units: "deg|rad",
      implicitUnits: "rad",
      enums: ["none", "autorotate"]
    },
    polygonPointList: {
      number: !0,
      multiple: !0,
      evenMultiple: !0,
      min: -1,
      max: 1,
      unitless: !0
    },
    edgeDistances: {
      enums: ["intersection", "node-position", "endpoints"]
    },
    edgeEndpoint: {
      number: !0,
      multiple: !0,
      units: "%|px|em|deg|rad",
      implicitUnits: "px",
      enums: ["inside-to-node", "outside-to-node", "outside-to-node-or-label", "outside-to-line", "outside-to-line-or-label"],
      singleEnum: !0,
      validate: function(X, Y) {
        switch (X.length) {
          case 2:
            return Y[0] !== "deg" && Y[0] !== "rad" && Y[1] !== "deg" && Y[1] !== "rad";
          case 1:
            return Bt(X[0]) || Y[0] === "deg" || Y[0] === "rad";
          default:
            return !1;
        }
      }
    },
    easing: {
      regexes: ["^(spring)\\s*\\(\\s*(" + t + ")\\s*,\\s*(" + t + ")\\s*\\)$", "^(cubic-bezier)\\s*\\(\\s*(" + t + ")\\s*,\\s*(" + t + ")\\s*,\\s*(" + t + ")\\s*,\\s*(" + t + ")\\s*\\)$"],
      enums: ["linear", "ease", "ease-in", "ease-out", "ease-in-out", "ease-in-sine", "ease-out-sine", "ease-in-out-sine", "ease-in-quad", "ease-out-quad", "ease-in-out-quad", "ease-in-cubic", "ease-out-cubic", "ease-in-out-cubic", "ease-in-quart", "ease-out-quart", "ease-in-out-quart", "ease-in-quint", "ease-out-quint", "ease-in-out-quint", "ease-in-expo", "ease-out-expo", "ease-in-out-expo", "ease-in-circ", "ease-out-circ", "ease-in-out-circ"]
    },
    gradientDirection: {
      enums: [
        "to-bottom",
        "to-top",
        "to-left",
        "to-right",
        "to-bottom-right",
        "to-bottom-left",
        "to-top-right",
        "to-top-left",
        "to-right-bottom",
        "to-left-bottom",
        "to-right-top",
        "to-left-top"
        // different order
      ]
    },
    boundsExpansion: {
      number: !0,
      multiple: !0,
      min: 0,
      validate: function(X) {
        var Y = X.length;
        return Y === 1 || Y === 2 || Y === 4;
      }
    }
  };
  var l = {
    zeroNonZero: function(X, Y) {
      return (X == null || Y == null) && X !== Y || X == 0 && Y != 0 ? !0 : X != 0 && Y == 0;
    },
    any: function(X, Y) {
      return X != Y;
    },
    emptyNonEmpty: function(X, Y) {
      var ee = Zl(X), j = Zl(Y);
      return ee && !j || !ee && j;
    }
  }, u = Tn.types, h = [{
    name: "label",
    type: u.text,
    triggersBounds: l.any,
    triggersZOrder: l.emptyNonEmpty
  }, {
    name: "text-rotation",
    type: u.textRotation,
    triggersBounds: l.any
  }, {
    name: "text-margin-x",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "text-margin-y",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }], d = [{
    name: "source-label",
    type: u.text,
    triggersBounds: l.any
  }, {
    name: "source-text-rotation",
    type: u.textRotation,
    triggersBounds: l.any
  }, {
    name: "source-text-margin-x",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "source-text-margin-y",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "source-text-offset",
    type: u.size,
    triggersBounds: l.any
  }], f = [{
    name: "target-label",
    type: u.text,
    triggersBounds: l.any
  }, {
    name: "target-text-rotation",
    type: u.textRotation,
    triggersBounds: l.any
  }, {
    name: "target-text-margin-x",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "target-text-margin-y",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "target-text-offset",
    type: u.size,
    triggersBounds: l.any
  }], p = [{
    name: "font-family",
    type: u.fontFamily,
    triggersBounds: l.any
  }, {
    name: "font-style",
    type: u.fontStyle,
    triggersBounds: l.any
  }, {
    name: "font-weight",
    type: u.fontWeight,
    triggersBounds: l.any
  }, {
    name: "font-size",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "text-transform",
    type: u.textTransform,
    triggersBounds: l.any
  }, {
    name: "text-wrap",
    type: u.textWrap,
    triggersBounds: l.any
  }, {
    name: "text-overflow-wrap",
    type: u.textOverflowWrap,
    triggersBounds: l.any
  }, {
    name: "text-max-width",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "text-outline-width",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "line-height",
    type: u.positiveNumber,
    triggersBounds: l.any
  }], g = [{
    name: "text-valign",
    type: u.valign,
    triggersBounds: l.any
  }, {
    name: "text-halign",
    type: u.halign,
    triggersBounds: l.any
  }, {
    name: "color",
    type: u.color
  }, {
    name: "text-outline-color",
    type: u.color
  }, {
    name: "text-outline-opacity",
    type: u.zeroOneNumber
  }, {
    name: "text-background-color",
    type: u.color
  }, {
    name: "text-background-opacity",
    type: u.zeroOneNumber
  }, {
    name: "text-background-padding",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "text-border-opacity",
    type: u.zeroOneNumber
  }, {
    name: "text-border-color",
    type: u.color
  }, {
    name: "text-border-width",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "text-border-style",
    type: u.borderStyle,
    triggersBounds: l.any
  }, {
    name: "text-background-shape",
    type: u.textBackgroundShape,
    triggersBounds: l.any
  }, {
    name: "text-justification",
    type: u.justification
  }, {
    name: "box-select-labels",
    type: u.bool,
    triggersBounds: l.any
  }], m = [{
    name: "events",
    type: u.bool,
    triggersZOrder: l.any
  }, {
    name: "text-events",
    type: u.bool,
    triggersZOrder: l.any
  }, {
    name: "box-selection",
    type: u.boxSelection,
    triggersZOrder: l.any
  }], v = [{
    name: "display",
    type: u.display,
    triggersZOrder: l.any,
    triggersBounds: l.any,
    triggersBoundsOfConnectedEdges: l.any,
    triggersBoundsOfParallelEdges: function(X, Y, ee) {
      return X === Y ? !1 : ee.pstyle("curve-style").value === "bezier";
    }
  }, {
    name: "visibility",
    type: u.visibility,
    triggersZOrder: l.any
  }, {
    name: "opacity",
    type: u.zeroOneNumber,
    triggersZOrder: l.zeroNonZero
  }, {
    name: "text-opacity",
    type: u.zeroOneNumber
  }, {
    name: "min-zoomed-font-size",
    type: u.size
  }, {
    name: "z-compound-depth",
    type: u.zCompoundDepth,
    triggersZOrder: l.any
  }, {
    name: "z-index-compare",
    type: u.zIndexCompare,
    triggersZOrder: l.any
  }, {
    name: "z-index",
    type: u.number,
    triggersZOrder: l.any
  }], y = [{
    name: "overlay-padding",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "overlay-color",
    type: u.color
  }, {
    name: "overlay-opacity",
    type: u.zeroOneNumber,
    triggersBounds: l.zeroNonZero
  }, {
    name: "overlay-shape",
    type: u.overlayShape,
    triggersBounds: l.any
  }, {
    name: "overlay-corner-radius",
    type: u.cornerRadius
  }], b = [{
    name: "underlay-padding",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "underlay-color",
    type: u.color
  }, {
    name: "underlay-opacity",
    type: u.zeroOneNumber,
    triggersBounds: l.zeroNonZero
  }, {
    name: "underlay-shape",
    type: u.overlayShape,
    triggersBounds: l.any
  }, {
    name: "underlay-corner-radius",
    type: u.cornerRadius
  }], w = [{
    name: "transition-property",
    type: u.propList
  }, {
    name: "transition-duration",
    type: u.time
  }, {
    name: "transition-delay",
    type: u.time
  }, {
    name: "transition-timing-function",
    type: u.easing
  }], T = function(X, Y) {
    return Y.value === "label" ? -X.poolIndex() : Y.pfValue;
  }, E = [{
    name: "height",
    type: u.nodeSize,
    triggersBounds: l.any,
    hashOverride: T
  }, {
    name: "width",
    type: u.nodeSize,
    triggersBounds: l.any,
    hashOverride: T
  }, {
    name: "shape",
    type: u.nodeShape,
    triggersBounds: l.any
  }, {
    name: "shape-polygon-points",
    type: u.polygonPointList,
    triggersBounds: l.any
  }, {
    name: "corner-radius",
    type: u.cornerRadius
  }, {
    name: "background-color",
    type: u.color
  }, {
    name: "background-fill",
    type: u.fill
  }, {
    name: "background-opacity",
    type: u.zeroOneNumber
  }, {
    name: "background-blacken",
    type: u.nOneOneNumber
  }, {
    name: "background-gradient-stop-colors",
    type: u.colors
  }, {
    name: "background-gradient-stop-positions",
    type: u.percentages
  }, {
    name: "background-gradient-direction",
    type: u.gradientDirection
  }, {
    name: "padding",
    type: u.sizeMaybePercent,
    triggersBounds: l.any
  }, {
    name: "padding-relative-to",
    type: u.paddingRelativeTo,
    triggersBounds: l.any
  }, {
    name: "bounds-expansion",
    type: u.boundsExpansion,
    triggersBounds: l.any
  }], L = [{
    name: "border-color",
    type: u.color
  }, {
    name: "border-opacity",
    type: u.zeroOneNumber
  }, {
    name: "border-width",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "border-style",
    type: u.borderStyle
  }, {
    name: "border-cap",
    type: u.lineCap
  }, {
    name: "border-join",
    type: u.lineJoin
  }, {
    name: "border-dash-pattern",
    type: u.numbers
  }, {
    name: "border-dash-offset",
    type: u.number
  }, {
    name: "border-position",
    type: u.linePosition
  }], k = [{
    name: "outline-color",
    type: u.color
  }, {
    name: "outline-opacity",
    type: u.zeroOneNumber
  }, {
    name: "outline-width",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "outline-style",
    type: u.borderStyle
  }, {
    name: "outline-offset",
    type: u.size,
    triggersBounds: l.any
  }], C = [{
    name: "background-image",
    type: u.urls
  }, {
    name: "background-image-crossorigin",
    type: u.bgCrossOrigin
  }, {
    name: "background-image-opacity",
    type: u.zeroOneNumbers
  }, {
    name: "background-image-containment",
    type: u.bgContainment
  }, {
    name: "background-image-smoothing",
    type: u.bools
  }, {
    name: "background-position-x",
    type: u.bgPos
  }, {
    name: "background-position-y",
    type: u.bgPos
  }, {
    name: "background-width-relative-to",
    type: u.bgRelativeTo
  }, {
    name: "background-height-relative-to",
    type: u.bgRelativeTo
  }, {
    name: "background-repeat",
    type: u.bgRepeat
  }, {
    name: "background-fit",
    type: u.bgFit
  }, {
    name: "background-clip",
    type: u.bgClip
  }, {
    name: "background-width",
    type: u.bgWH
  }, {
    name: "background-height",
    type: u.bgWH
  }, {
    name: "background-offset-x",
    type: u.bgPos
  }, {
    name: "background-offset-y",
    type: u.bgPos
  }], A = [{
    name: "position",
    type: u.position,
    triggersBounds: l.any
  }, {
    name: "compound-sizing-wrt-labels",
    type: u.compoundIncludeLabels,
    triggersBounds: l.any
  }, {
    name: "min-width",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "min-width-bias-left",
    type: u.sizeMaybePercent,
    triggersBounds: l.any
  }, {
    name: "min-width-bias-right",
    type: u.sizeMaybePercent,
    triggersBounds: l.any
  }, {
    name: "min-height",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "min-height-bias-top",
    type: u.sizeMaybePercent,
    triggersBounds: l.any
  }, {
    name: "min-height-bias-bottom",
    type: u.sizeMaybePercent,
    triggersBounds: l.any
  }], R = [{
    name: "line-style",
    type: u.lineStyle
  }, {
    name: "line-color",
    type: u.color
  }, {
    name: "line-fill",
    type: u.fill
  }, {
    name: "line-cap",
    type: u.lineCap
  }, {
    name: "line-opacity",
    type: u.zeroOneNumber
  }, {
    name: "line-dash-pattern",
    type: u.numbers
  }, {
    name: "line-dash-offset",
    type: u.number
  }, {
    name: "line-outline-width",
    type: u.size
  }, {
    name: "line-outline-color",
    type: u.color
  }, {
    name: "line-gradient-stop-colors",
    type: u.colors
  }, {
    name: "line-gradient-stop-positions",
    type: u.percentages
  }, {
    name: "curve-style",
    type: u.curveStyle,
    triggersBounds: l.any,
    triggersBoundsOfParallelEdges: function(X, Y) {
      return X === Y ? !1 : X === "bezier" || // remove from bundle
      Y === "bezier";
    }
  }, {
    name: "haystack-radius",
    type: u.zeroOneNumber,
    triggersBounds: l.any
  }, {
    name: "source-endpoint",
    type: u.edgeEndpoint,
    triggersBounds: l.any
  }, {
    name: "target-endpoint",
    type: u.edgeEndpoint,
    triggersBounds: l.any
  }, {
    name: "control-point-step-size",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "control-point-distances",
    type: u.bidirectionalSizes,
    triggersBounds: l.any
  }, {
    name: "control-point-weights",
    type: u.numbers,
    triggersBounds: l.any
  }, {
    name: "segment-distances",
    type: u.bidirectionalSizes,
    triggersBounds: l.any
  }, {
    name: "segment-weights",
    type: u.numbers,
    triggersBounds: l.any
  }, {
    name: "segment-radii",
    type: u.numbers,
    triggersBounds: l.any
  }, {
    name: "radius-type",
    type: u.radiusType,
    triggersBounds: l.any
  }, {
    name: "taxi-turn",
    type: u.bidirectionalSizeMaybePercent,
    triggersBounds: l.any
  }, {
    name: "taxi-turn-min-distance",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "taxi-direction",
    type: u.axisDirection,
    triggersBounds: l.any
  }, {
    name: "taxi-radius",
    type: u.number,
    triggersBounds: l.any
  }, {
    name: "edge-distances",
    type: u.edgeDistances,
    triggersBounds: l.any
  }, {
    name: "arrow-scale",
    type: u.positiveNumber,
    triggersBounds: l.any
  }, {
    name: "loop-direction",
    type: u.angle,
    triggersBounds: l.any
  }, {
    name: "loop-sweep",
    type: u.angle,
    triggersBounds: l.any
  }, {
    name: "source-distance-from-node",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "target-distance-from-node",
    type: u.size,
    triggersBounds: l.any
  }], _ = [{
    name: "ghost",
    type: u.bool,
    triggersBounds: l.any
  }, {
    name: "ghost-offset-x",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "ghost-offset-y",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "ghost-opacity",
    type: u.zeroOneNumber
  }], O = [{
    name: "selection-box-color",
    type: u.color
  }, {
    name: "selection-box-opacity",
    type: u.zeroOneNumber
  }, {
    name: "selection-box-border-color",
    type: u.color
  }, {
    name: "selection-box-border-width",
    type: u.size
  }, {
    name: "active-bg-color",
    type: u.color
  }, {
    name: "active-bg-opacity",
    type: u.zeroOneNumber
  }, {
    name: "active-bg-size",
    type: u.size
  }, {
    name: "outside-texture-bg-color",
    type: u.color
  }, {
    name: "outside-texture-bg-opacity",
    type: u.zeroOneNumber
  }], P = [];
  Tn.pieBackgroundN = 16, P.push({
    name: "pie-size",
    type: u.sizeMaybePercent
  }), P.push({
    name: "pie-hole",
    type: u.sizeMaybePercent
  }), P.push({
    name: "pie-start-angle",
    type: u.angle
  });
  for (var S = 1; S <= Tn.pieBackgroundN; S++)
    P.push({
      name: "pie-" + S + "-background-color",
      type: u.color
    }), P.push({
      name: "pie-" + S + "-background-size",
      type: u.percent
    }), P.push({
      name: "pie-" + S + "-background-opacity",
      type: u.zeroOneNumber
    });
  var M = [];
  Tn.stripeBackgroundN = 16, M.push({
    name: "stripe-size",
    type: u.sizeMaybePercent
  }), M.push({
    name: "stripe-direction",
    type: u.axisDirectionPrimary
  });
  for (var N = 1; N <= Tn.stripeBackgroundN; N++)
    M.push({
      name: "stripe-" + N + "-background-color",
      type: u.color
    }), M.push({
      name: "stripe-" + N + "-background-size",
      type: u.percent
    }), M.push({
      name: "stripe-" + N + "-background-opacity",
      type: u.zeroOneNumber
    });
  var D = [], I = Tn.arrowPrefixes = ["source", "mid-source", "target", "mid-target"];
  [{
    name: "arrow-shape",
    type: u.arrowShape,
    triggersBounds: l.any
  }, {
    name: "arrow-color",
    type: u.color
  }, {
    name: "arrow-fill",
    type: u.arrowFill
  }, {
    name: "arrow-width",
    type: u.arrowWidth
  }].forEach(function(Z) {
    I.forEach(function(X) {
      var Y = X + "-" + Z.name, ee = Z.type, j = Z.triggersBounds;
      D.push({
        name: Y,
        type: ee,
        triggersBounds: j
      });
    });
  }, {});
  var B = Tn.properties = [].concat(m, w, v, y, b, _, g, p, h, d, f, E, L, k, C, P, M, A, R, D, O), z = Tn.propertyGroups = {
    // common to all eles
    behavior: m,
    transition: w,
    visibility: v,
    overlay: y,
    underlay: b,
    ghost: _,
    // labels
    commonLabel: g,
    labelDimensions: p,
    mainLabel: h,
    sourceLabel: d,
    targetLabel: f,
    // node props
    nodeBody: E,
    nodeBorder: L,
    nodeOutline: k,
    backgroundImage: C,
    pie: P,
    stripe: M,
    compound: A,
    // edge props
    edgeLine: R,
    edgeArrow: D,
    core: O
  }, F = Tn.propertyGroupNames = {}, V = Tn.propertyGroupKeys = Object.keys(z);
  V.forEach(function(Z) {
    F[Z] = z[Z].map(function(X) {
      return X.name;
    }), z[Z].forEach(function(X) {
      return X.groupKey = Z;
    });
  });
  var H = Tn.aliases = [{
    name: "content",
    pointsTo: "label"
  }, {
    name: "control-point-distance",
    pointsTo: "control-point-distances"
  }, {
    name: "control-point-weight",
    pointsTo: "control-point-weights"
  }, {
    name: "segment-distance",
    pointsTo: "segment-distances"
  }, {
    name: "segment-weight",
    pointsTo: "segment-weights"
  }, {
    name: "segment-radius",
    pointsTo: "segment-radii"
  }, {
    name: "edge-text-rotation",
    pointsTo: "text-rotation"
  }, {
    name: "padding-left",
    pointsTo: "padding"
  }, {
    name: "padding-right",
    pointsTo: "padding"
  }, {
    name: "padding-top",
    pointsTo: "padding"
  }, {
    name: "padding-bottom",
    pointsTo: "padding"
  }];
  Tn.propertyNames = B.map(function(Z) {
    return Z.name;
  });
  for (var J = 0; J < B.length; J++) {
    var q = B[J];
    B[q.name] = q;
  }
  for (var ae = 0; ae < H.length; ae++) {
    var re = H[ae], pe = B[re.pointsTo], K = {
      name: re.name,
      alias: !0,
      pointsTo: pe
    };
    B.push(K), B[re.name] = K;
  }
})();
Tn.getDefaultProperty = function(t) {
  return this.getDefaultProperties()[t];
};
Tn.getDefaultProperties = function() {
  var t = this._private;
  if (t.defaultProperties != null)
    return t.defaultProperties;
  for (var e = Gt({
    // core props
    "selection-box-color": "#ddd",
    "selection-box-opacity": 0.65,
    "selection-box-border-color": "#aaa",
    "selection-box-border-width": 1,
    "active-bg-color": "black",
    "active-bg-opacity": 0.15,
    "active-bg-size": 30,
    "outside-texture-bg-color": "#000",
    "outside-texture-bg-opacity": 0.125,
    // common node/edge props
    events: "yes",
    "text-events": "no",
    "text-valign": "top",
    "text-halign": "center",
    "text-justification": "auto",
    "line-height": 1,
    color: "#000",
    "box-selection": "contain",
    "text-outline-color": "#000",
    "text-outline-width": 0,
    "text-outline-opacity": 1,
    "text-opacity": 1,
    "text-decoration": "none",
    "text-transform": "none",
    "text-wrap": "none",
    "text-overflow-wrap": "whitespace",
    "text-max-width": 9999,
    "text-background-color": "#000",
    "text-background-opacity": 0,
    "text-background-shape": "rectangle",
    "text-background-padding": 0,
    "text-border-opacity": 0,
    "text-border-width": 0,
    "text-border-style": "solid",
    "text-border-color": "#000",
    "font-family": "Helvetica Neue, Helvetica, sans-serif",
    "font-style": "normal",
    "font-weight": "normal",
    "font-size": 16,
    "min-zoomed-font-size": 0,
    "text-rotation": "none",
    "source-text-rotation": "none",
    "target-text-rotation": "none",
    visibility: "visible",
    display: "element",
    opacity: 1,
    "z-compound-depth": "auto",
    "z-index-compare": "auto",
    "z-index": 0,
    label: "",
    "text-margin-x": 0,
    "text-margin-y": 0,
    "source-label": "",
    "source-text-offset": 0,
    "source-text-margin-x": 0,
    "source-text-margin-y": 0,
    "target-label": "",
    "target-text-offset": 0,
    "target-text-margin-x": 0,
    "target-text-margin-y": 0,
    "overlay-opacity": 0,
    "overlay-color": "#000",
    "overlay-padding": 10,
    "overlay-shape": "round-rectangle",
    "overlay-corner-radius": "auto",
    "underlay-opacity": 0,
    "underlay-color": "#000",
    "underlay-padding": 10,
    "underlay-shape": "round-rectangle",
    "underlay-corner-radius": "auto",
    "transition-property": "none",
    "transition-duration": 0,
    "transition-delay": 0,
    "transition-timing-function": "linear",
    "box-select-labels": "no",
    // node props
    "background-blacken": 0,
    "background-color": "#999",
    "background-fill": "solid",
    "background-opacity": 1,
    "background-image": "none",
    "background-image-crossorigin": "anonymous",
    "background-image-opacity": 1,
    "background-image-containment": "inside",
    "background-image-smoothing": "yes",
    "background-position-x": "50%",
    "background-position-y": "50%",
    "background-offset-x": 0,
    "background-offset-y": 0,
    "background-width-relative-to": "include-padding",
    "background-height-relative-to": "include-padding",
    "background-repeat": "no-repeat",
    "background-fit": "none",
    "background-clip": "node",
    "background-width": "auto",
    "background-height": "auto",
    "border-color": "#000",
    "border-opacity": 1,
    "border-width": 0,
    "border-style": "solid",
    "border-dash-pattern": [4, 2],
    "border-dash-offset": 0,
    "border-cap": "butt",
    "border-join": "miter",
    "border-position": "center",
    "outline-color": "#999",
    "outline-opacity": 1,
    "outline-width": 0,
    "outline-offset": 0,
    "outline-style": "solid",
    height: 30,
    width: 30,
    shape: "ellipse",
    "shape-polygon-points": "-1, -1,   1, -1,   1, 1,   -1, 1",
    "corner-radius": "auto",
    "bounds-expansion": 0,
    // node gradient
    "background-gradient-direction": "to-bottom",
    "background-gradient-stop-colors": "#999",
    "background-gradient-stop-positions": "0%",
    // ghost props
    ghost: "no",
    "ghost-offset-y": 0,
    "ghost-offset-x": 0,
    "ghost-opacity": 0,
    // compound props
    padding: 0,
    "padding-relative-to": "width",
    position: "origin",
    "compound-sizing-wrt-labels": "include",
    "min-width": 0,
    "min-width-bias-left": 0,
    "min-width-bias-right": 0,
    "min-height": 0,
    "min-height-bias-top": 0,
    "min-height-bias-bottom": 0
  }, {
    // node pie bg
    "pie-size": "100%",
    "pie-hole": 0,
    "pie-start-angle": "0deg"
  }, [{
    name: "pie-{{i}}-background-color",
    value: "black"
  }, {
    name: "pie-{{i}}-background-size",
    value: "0%"
  }, {
    name: "pie-{{i}}-background-opacity",
    value: 1
  }].reduce(function(l, u) {
    for (var h = 1; h <= Tn.pieBackgroundN; h++) {
      var d = u.name.replace("{{i}}", h), f = u.value;
      l[d] = f;
    }
    return l;
  }, {}), {
    // node stripes bg
    "stripe-size": "100%",
    "stripe-direction": "horizontal"
  }, [{
    name: "stripe-{{i}}-background-color",
    value: "black"
  }, {
    name: "stripe-{{i}}-background-size",
    value: "0%"
  }, {
    name: "stripe-{{i}}-background-opacity",
    value: 1
  }].reduce(function(l, u) {
    for (var h = 1; h <= Tn.stripeBackgroundN; h++) {
      var d = u.name.replace("{{i}}", h), f = u.value;
      l[d] = f;
    }
    return l;
  }, {}), {
    // edge props
    "line-style": "solid",
    "line-color": "#999",
    "line-fill": "solid",
    "line-cap": "butt",
    "line-opacity": 1,
    "line-outline-width": 0,
    "line-outline-color": "#000",
    "line-gradient-stop-colors": "#999",
    "line-gradient-stop-positions": "0%",
    "control-point-step-size": 40,
    "control-point-weights": 0.5,
    "segment-weights": 0.5,
    "segment-distances": 20,
    "segment-radii": 15,
    "radius-type": "arc-radius",
    "taxi-turn": "50%",
    "taxi-radius": 15,
    "taxi-turn-min-distance": 10,
    "taxi-direction": "auto",
    "edge-distances": "intersection",
    "curve-style": "haystack",
    "haystack-radius": 0,
    "arrow-scale": 1,
    "loop-direction": "-45deg",
    "loop-sweep": "-90deg",
    "source-distance-from-node": 0,
    "target-distance-from-node": 0,
    "source-endpoint": "outside-to-node",
    "target-endpoint": "outside-to-node",
    "line-dash-pattern": [6, 3],
    "line-dash-offset": 0
  }, [{
    name: "arrow-shape",
    value: "none"
  }, {
    name: "arrow-color",
    value: "#999"
  }, {
    name: "arrow-fill",
    value: "filled"
  }, {
    name: "arrow-width",
    value: 1
  }].reduce(function(l, u) {
    return Tn.arrowPrefixes.forEach(function(h) {
      var d = h + "-" + u.name, f = u.value;
      l[d] = f;
    }), l;
  }, {})), r = {}, n = 0; n < this.properties.length; n++) {
    var i = this.properties[n];
    if (!i.pointsTo) {
      var a = i.name, s = e[a], o = this.parse(a, s);
      r[a] = o;
    }
  }
  return t.defaultProperties = r, t.defaultProperties;
};
Tn.addDefaultStylesheet = function() {
  this.selector(":parent").css({
    shape: "rectangle",
    padding: 10,
    "background-color": "#eee",
    "border-color": "#ccc",
    "border-width": 1
  }).selector("edge").css({
    width: 3
  }).selector(":loop").css({
    "curve-style": "bezier"
  }).selector("edge:compound").css({
    "curve-style": "bezier",
    "source-endpoint": "outside-to-line",
    "target-endpoint": "outside-to-line"
  }).selector(":selected").css({
    "background-color": "#0169D9",
    "line-color": "#0169D9",
    "source-arrow-color": "#0169D9",
    "target-arrow-color": "#0169D9",
    "mid-source-arrow-color": "#0169D9",
    "mid-target-arrow-color": "#0169D9"
  }).selector(":parent:selected").css({
    "background-color": "#CCE1F9",
    "border-color": "#aec8e5"
  }).selector(":active").css({
    "overlay-color": "black",
    "overlay-padding": 10,
    "overlay-opacity": 0.25
  }), this.defaultLength = this.length;
};
var $x = {};
$x.parse = function(t, e, r, n) {
  var i = this;
  if (an(e))
    return i.parseImplWarn(t, e, r, n);
  var a = n === "mapping" || n === !0 || n === !1 || n == null ? "dontcare" : n, s = r ? "t" : "f", o = "" + e, l = kV(t, o, s, a), u = i.propCache = i.propCache || [], h;
  return (h = u[l]) || (h = u[l] = i.parseImplWarn(t, e, r, n)), (r || n === "mapping") && (h = Zs(h), h && (h.value = Zs(h.value))), h;
};
$x.parseImplWarn = function(t, e, r, n) {
  var i = this.parseImpl(t, e, r, n);
  return !i && e != null && Lr("The style property `".concat(t, ": ").concat(e, "` is invalid")), i && (i.name === "width" || i.name === "height") && e === "label" && Lr("The style value of `label` is deprecated for `" + i.name + "`"), i;
};
$x.parseImpl = function(t, e, r, n) {
  var i = this;
  t = Xk(t);
  var a = i.properties[t], s = e, o = i.types;
  if (!a || e === void 0)
    return null;
  a.alias && (a = a.pointsTo, t = a.name);
  var l = Bt(e);
  l && (e = e.trim());
  var u = a.type;
  if (!u)
    return null;
  if (r && (e === "" || e === null))
    return {
      name: t,
      value: e,
      bypass: !0,
      deleteBypass: !0
    };
  if (an(e))
    return {
      name: t,
      value: e,
      strValue: "fn",
      mapped: o.fn,
      bypass: r
    };
  var h, d;
  if (!(!l || n || e.length < 7 || e[1] !== "a")) {
    if (e.length >= 7 && e[0] === "d" && (h = new RegExp(o.data.regex).exec(e))) {
      if (r)
        return !1;
      var f = o.data;
      return {
        name: t,
        value: h,
        strValue: "" + e,
        mapped: f,
        field: h[1],
        bypass: r
      };
    } else if (e.length >= 10 && e[0] === "m" && (d = new RegExp(o.mapData.regex).exec(e))) {
      if (r || u.multiple)
        return !1;
      var p = o.mapData;
      if (!(u.color || u.number))
        return !1;
      var g = this.parse(t, d[4]);
      if (!g || g.mapped)
        return !1;
      var m = this.parse(t, d[5]);
      if (!m || m.mapped)
        return !1;
      if (g.pfValue === m.pfValue || g.strValue === m.strValue)
        return Lr("`" + t + ": " + e + "` is not a valid mapper because the output range is zero; converting to `" + t + ": " + g.strValue + "`"), this.parse(t, g.strValue);
      if (u.color) {
        var v = g.value, y = m.value, b = v[0] === y[0] && v[1] === y[1] && v[2] === y[2] && // optional alpha
        (v[3] === y[3] || (v[3] == null || v[3] === 1) && (y[3] == null || y[3] === 1));
        if (b)
          return !1;
      }
      return {
        name: t,
        value: d,
        strValue: "" + e,
        mapped: p,
        field: d[1],
        fieldMin: parseFloat(d[2]),
        // min & max are numeric
        fieldMax: parseFloat(d[3]),
        valueMin: g.value,
        valueMax: m.value,
        bypass: r
      };
    }
  }
  if (u.multiple && n !== "multiple") {
    var w;
    if (l ? w = e.split(/\s+/) : Or(e) ? w = e : w = [e], u.evenMultiple && w.length % 2 !== 0)
      return null;
    for (var T = [], E = [], L = [], k = "", C = !1, A = 0; A < w.length; A++) {
      var R = i.parse(t, w[A], r, "multiple");
      C = C || Bt(R.value), T.push(R.value), L.push(R.pfValue != null ? R.pfValue : R.value), E.push(R.units), k += (A > 0 ? " " : "") + R.strValue;
    }
    return u.validate && !u.validate(T, E) ? null : u.singleEnum && C ? T.length === 1 && Bt(T[0]) ? {
      name: t,
      value: T[0],
      strValue: T[0],
      bypass: r
    } : null : {
      name: t,
      value: T,
      pfValue: L,
      strValue: k,
      bypass: r,
      units: E
    };
  }
  var _ = function() {
    for (var K = 0; K < u.enums.length; K++) {
      var Z = u.enums[K];
      if (Z === e)
        return {
          name: t,
          value: e,
          strValue: "" + e,
          bypass: r
        };
    }
    return null;
  };
  if (u.number) {
    var O, P = "px";
    if (u.units && (O = u.units), u.implicitUnits && (P = u.implicitUnits), !u.unitless)
      if (l) {
        var S = "px|em" + (u.allowPercent ? "|\\%" : "");
        O && (S = O);
        var M = e.match("^(" + Fn + ")(" + S + ")?$");
        M && (e = M[1], O = M[2] || P);
      } else (!O || u.implicitUnits) && (O = P);
    if (e = parseFloat(e), isNaN(e) && u.enums === void 0)
      return null;
    if (isNaN(e) && u.enums !== void 0)
      return e = s, _();
    if (u.integer && !pye(e) || u.min !== void 0 && (e < u.min || u.strictMin && e === u.min) || u.max !== void 0 && (e > u.max || u.strictMax && e === u.max))
      return null;
    var N = {
      name: t,
      value: e,
      strValue: "" + e + (O || ""),
      units: O,
      bypass: r
    };
    return u.unitless || O !== "px" && O !== "em" ? N.pfValue = e : N.pfValue = O === "px" || !O ? e : this.getEmSizeInPixels() * e, (O === "ms" || O === "s") && (N.pfValue = O === "ms" ? e : 1e3 * e), (O === "deg" || O === "rad") && (N.pfValue = O === "rad" ? e : k2e(e)), O === "%" && (N.pfValue = e / 100), N;
  } else if (u.propList) {
    var D = [], I = "" + e;
    if (I !== "none") {
      for (var B = I.split(/\s*,\s*|\s+/), z = 0; z < B.length; z++) {
        var F = B[z].trim();
        i.properties[F] ? D.push(F) : Lr("`" + F + "` is not a valid property name");
      }
      if (D.length === 0)
        return null;
    }
    return {
      name: t,
      value: D,
      strValue: D.length === 0 ? "none" : D.join(" "),
      bypass: r
    };
  } else if (u.color) {
    var V = vV(e);
    return V ? {
      name: t,
      value: V,
      pfValue: V,
      strValue: "rgb(" + V[0] + "," + V[1] + "," + V[2] + ")",
      // n.b. no spaces b/c of multiple support
      bypass: r
    } : null;
  } else if (u.regex || u.regexes) {
    if (u.enums) {
      var H = _();
      if (H)
        return H;
    }
    for (var J = u.regexes ? u.regexes : [u.regex], q = 0; q < J.length; q++) {
      var ae = new RegExp(J[q]), re = ae.exec(e);
      if (re)
        return {
          name: t,
          value: u.singleRegexMatchValue ? re[1] : re,
          strValue: "" + e,
          bypass: r
        };
    }
    return null;
  } else return u.string ? {
    name: t,
    value: "" + e,
    strValue: "" + e,
    bypass: r
  } : u.enums ? _() : null;
};
var jn = function(e) {
  if (!(this instanceof jn))
    return new jn(e);
  if (!Yk(e)) {
    Zr("A style must have a core reference");
    return;
  }
  this._private = {
    cy: e,
    coreStyle: {}
  }, this.length = 0, this.resetToDefault();
}, Ci = jn.prototype;
Ci.instanceString = function() {
  return "style";
};
Ci.clear = function() {
  for (var t = this._private, e = t.cy, r = e.elements(), n = 0; n < this.length; n++)
    this[n] = void 0;
  return this.length = 0, t.contextStyles = {}, t.propDiffs = {}, this.cleanElements(r, !0), r.forEach(function(i) {
    var a = i[0]._private;
    a.styleDirty = !0, a.appliedInitStyle = !1;
  }), this;
};
Ci.resetToDefault = function() {
  return this.clear(), this.addDefaultStylesheet(), this;
};
Ci.core = function(t) {
  return this._private.coreStyle[t] || this.getDefaultProperty(t);
};
Ci.selector = function(t) {
  var e = t === "core" ? null : new ec(t), r = this.length++;
  return this[r] = {
    selector: e,
    properties: [],
    mappedProperties: [],
    index: r
  }, this;
};
Ci.css = function() {
  var t = this, e = arguments;
  if (e.length === 1)
    for (var r = e[0], n = 0; n < t.properties.length; n++) {
      var i = t.properties[n], a = r[i.name];
      a === void 0 && (a = r[Sx(i.name)]), a !== void 0 && this.cssRule(i.name, a);
    }
  else e.length === 2 && this.cssRule(e[0], e[1]);
  return this;
};
Ci.style = Ci.css;
Ci.cssRule = function(t, e) {
  var r = this.parse(t, e);
  if (r) {
    var n = this.length - 1;
    this[n].properties.push(r), this[n].properties[r.name] = r, r.name.match(/pie-(\d+)-background-size/) && r.value && (this._private.hasPie = !0), r.name.match(/stripe-(\d+)-background-size/) && r.value && (this._private.hasStripe = !0), r.mapped && this[n].mappedProperties.push(r);
    var i = !this[n].selector;
    i && (this._private.coreStyle[r.name] = r);
  }
  return this;
};
Ci.append = function(t) {
  return pV(t) ? t.appendToStyle(this) : Or(t) ? this.appendFromJson(t) : Bt(t) && this.appendFromString(t), this;
};
jn.fromJson = function(t, e) {
  var r = new jn(t);
  return r.fromJson(e), r;
};
jn.fromString = function(t, e) {
  return new jn(t).fromString(e);
};
[Jn, Rg, cS, so, Fx, uS, Tn, $x].forEach(function(t) {
  Gt(Ci, t);
});
jn.types = Ci.types;
jn.properties = Ci.properties;
jn.propertyGroups = Ci.propertyGroups;
jn.propertyGroupNames = Ci.propertyGroupNames;
jn.propertyGroupKeys = Ci.propertyGroupKeys;
var _4e = {
  style: function(e) {
    if (e) {
      var r = this.setStyle(e);
      r.update();
    }
    return this._private.style;
  },
  setStyle: function(e) {
    var r = this._private;
    return pV(e) ? r.style = e.generateStyle(this) : Or(e) ? r.style = jn.fromJson(this, e) : Bt(e) ? r.style = jn.fromString(this, e) : r.style = jn(this), r.style;
  },
  // e.g. cy.data() changed => recalc ele mappers
  updateStyle: function() {
    this.mutableElements().updateStyle();
  }
}, L4e = "single", Lu = {
  autolock: function(e) {
    if (e !== void 0)
      this._private.autolock = !!e;
    else
      return this._private.autolock;
    return this;
  },
  autoungrabify: function(e) {
    if (e !== void 0)
      this._private.autoungrabify = !!e;
    else
      return this._private.autoungrabify;
    return this;
  },
  autounselectify: function(e) {
    if (e !== void 0)
      this._private.autounselectify = !!e;
    else
      return this._private.autounselectify;
    return this;
  },
  selectionType: function(e) {
    var r = this._private;
    if (r.selectionType == null && (r.selectionType = L4e), e !== void 0)
      (e === "additive" || e === "single") && (r.selectionType = e);
    else
      return r.selectionType;
    return this;
  },
  panningEnabled: function(e) {
    if (e !== void 0)
      this._private.panningEnabled = !!e;
    else
      return this._private.panningEnabled;
    return this;
  },
  userPanningEnabled: function(e) {
    if (e !== void 0)
      this._private.userPanningEnabled = !!e;
    else
      return this._private.userPanningEnabled;
    return this;
  },
  zoomingEnabled: function(e) {
    if (e !== void 0)
      this._private.zoomingEnabled = !!e;
    else
      return this._private.zoomingEnabled;
    return this;
  },
  userZoomingEnabled: function(e) {
    if (e !== void 0)
      this._private.userZoomingEnabled = !!e;
    else
      return this._private.userZoomingEnabled;
    return this;
  },
  boxSelectionEnabled: function(e) {
    if (e !== void 0)
      this._private.boxSelectionEnabled = !!e;
    else
      return this._private.boxSelectionEnabled;
    return this;
  },
  pan: function() {
    var e = arguments, r = this._private.pan, n, i, a, s, o;
    switch (e.length) {
      case 0:
        return r;
      case 1:
        if (Bt(e[0]))
          return n = e[0], r[n];
        if (mr(e[0])) {
          if (!this._private.panningEnabled)
            return this;
          a = e[0], s = a.x, o = a.y, mt(s) && (r.x = s), mt(o) && (r.y = o), this.emit("pan viewport");
        }
        break;
      case 2:
        if (!this._private.panningEnabled)
          return this;
        n = e[0], i = e[1], (n === "x" || n === "y") && mt(i) && (r[n] = i), this.emit("pan viewport");
        break;
    }
    return this.notify("viewport"), this;
  },
  panBy: function(e, r) {
    var n = arguments, i = this._private.pan, a, s, o, l, u;
    if (!this._private.panningEnabled)
      return this;
    switch (n.length) {
      case 1:
        mr(e) && (o = n[0], l = o.x, u = o.y, mt(l) && (i.x += l), mt(u) && (i.y += u), this.emit("pan viewport"));
        break;
      case 2:
        a = e, s = r, (a === "x" || a === "y") && mt(s) && (i[a] += s), this.emit("pan viewport");
        break;
    }
    return this.notify("viewport"), this;
  },
  gc: function() {
    this.notify("gc");
  },
  fit: function(e, r) {
    var n = this.getFitViewport(e, r);
    if (n) {
      var i = this._private;
      i.zoom = n.zoom, i.pan = n.pan, this.emit("pan zoom viewport"), this.notify("viewport");
    }
    return this;
  },
  getFitViewport: function(e, r) {
    if (mt(e) && r === void 0 && (r = e, e = void 0), !(!this._private.panningEnabled || !this._private.zoomingEnabled)) {
      var n;
      if (Bt(e)) {
        var i = e;
        e = this.$(i);
      } else if (vye(e)) {
        var a = e;
        n = {
          x1: a.x1,
          y1: a.y1,
          x2: a.x2,
          y2: a.y2
        }, n.w = n.x2 - n.x1, n.h = n.y2 - n.y1;
      } else ka(e) || (e = this.mutableElements());
      if (!(ka(e) && e.empty())) {
        n = n || e.boundingBox();
        var s = this.width(), o = this.height(), l;
        if (r = mt(r) ? r : 0, !isNaN(s) && !isNaN(o) && s > 0 && o > 0 && !isNaN(n.w) && !isNaN(n.h) && n.w > 0 && n.h > 0) {
          l = Math.min((s - 2 * r) / n.w, (o - 2 * r) / n.h), l = l > this._private.maxZoom ? this._private.maxZoom : l, l = l < this._private.minZoom ? this._private.minZoom : l;
          var u = {
            // now pan to middle
            x: (s - l * (n.x1 + n.x2)) / 2,
            y: (o - l * (n.y1 + n.y2)) / 2
          };
          return {
            zoom: l,
            pan: u
          };
        }
      }
    }
  },
  zoomRange: function(e, r) {
    var n = this._private;
    if (r == null) {
      var i = e;
      e = i.min, r = i.max;
    }
    return mt(e) && mt(r) && e <= r ? (n.minZoom = e, n.maxZoom = r) : mt(e) && r === void 0 && e <= n.maxZoom ? n.minZoom = e : mt(r) && e === void 0 && r >= n.minZoom && (n.maxZoom = r), this;
  },
  minZoom: function(e) {
    return e === void 0 ? this._private.minZoom : this.zoomRange({
      min: e
    });
  },
  maxZoom: function(e) {
    return e === void 0 ? this._private.maxZoom : this.zoomRange({
      max: e
    });
  },
  getZoomedViewport: function(e) {
    var r = this._private, n = r.pan, i = r.zoom, a, s, o = !1;
    if (r.zoomingEnabled || (o = !0), mt(e) ? s = e : mr(e) && (s = e.level, e.position != null ? a = _x(e.position, i, n) : e.renderedPosition != null && (a = e.renderedPosition), a != null && !r.panningEnabled && (o = !0)), s = s > r.maxZoom ? r.maxZoom : s, s = s < r.minZoom ? r.minZoom : s, o || !mt(s) || s === i || a != null && (!mt(a.x) || !mt(a.y)))
      return null;
    if (a != null) {
      var l = n, u = i, h = s, d = {
        x: -h / u * (a.x - l.x) + a.x,
        y: -h / u * (a.y - l.y) + a.y
      };
      return {
        zoomed: !0,
        panned: !0,
        zoom: h,
        pan: d
      };
    } else
      return {
        zoomed: !0,
        panned: !1,
        zoom: s,
        pan: n
      };
  },
  zoom: function(e) {
    if (e === void 0)
      return this._private.zoom;
    var r = this.getZoomedViewport(e), n = this._private;
    return r == null || !r.zoomed ? this : (n.zoom = r.zoom, r.panned && (n.pan.x = r.pan.x, n.pan.y = r.pan.y), this.emit("zoom" + (r.panned ? " pan" : "") + " viewport"), this.notify("viewport"), this);
  },
  viewport: function(e) {
    var r = this._private, n = !0, i = !0, a = [], s = !1, o = !1;
    if (!e)
      return this;
    if (mt(e.zoom) || (n = !1), mr(e.pan) || (i = !1), !n && !i)
      return this;
    if (n) {
      var l = e.zoom;
      l < r.minZoom || l > r.maxZoom || !r.zoomingEnabled ? s = !0 : (r.zoom = l, a.push("zoom"));
    }
    if (i && (!s || !e.cancelOnFailedZoom) && r.panningEnabled) {
      var u = e.pan;
      mt(u.x) && (r.pan.x = u.x, o = !1), mt(u.y) && (r.pan.y = u.y, o = !1), o || a.push("pan");
    }
    return a.length > 0 && (a.push("viewport"), this.emit(a.join(" ")), this.notify("viewport")), this;
  },
  center: function(e) {
    var r = this.getCenterPan(e);
    return r && (this._private.pan = r, this.emit("pan viewport"), this.notify("viewport")), this;
  },
  getCenterPan: function(e, r) {
    if (this._private.panningEnabled) {
      if (Bt(e)) {
        var n = e;
        e = this.mutableElements().filter(n);
      } else ka(e) || (e = this.mutableElements());
      if (e.length !== 0) {
        var i = e.boundingBox(), a = this.width(), s = this.height();
        r = r === void 0 ? this._private.zoom : r;
        var o = {
          // middle
          x: (a - r * (i.x1 + i.x2)) / 2,
          y: (s - r * (i.y1 + i.y2)) / 2
        };
        return o;
      }
    }
  },
  reset: function() {
    return !this._private.panningEnabled || !this._private.zoomingEnabled ? this : (this.viewport({
      pan: {
        x: 0,
        y: 0
      },
      zoom: 1
    }), this);
  },
  invalidateSize: function() {
    this._private.sizeCache = null;
  },
  size: function() {
    var e = this._private, r = e.container, n = this;
    return e.sizeCache = e.sizeCache || (r ? (function() {
      var i = n.window().getComputedStyle(r), a = function(o) {
        return parseFloat(i.getPropertyValue(o));
      };
      return {
        width: r.clientWidth - a("padding-left") - a("padding-right"),
        height: r.clientHeight - a("padding-top") - a("padding-bottom")
      };
    })() : {
      // fallback if no container (not 0 b/c can be used for dividing etc)
      width: 1,
      height: 1
    });
  },
  width: function() {
    return this.size().width;
  },
  height: function() {
    return this.size().height;
  },
  extent: function() {
    var e = this._private.pan, r = this._private.zoom, n = this.renderedExtent(), i = {
      x1: (n.x1 - e.x) / r,
      x2: (n.x2 - e.x) / r,
      y1: (n.y1 - e.y) / r,
      y2: (n.y2 - e.y) / r
    };
    return i.w = i.x2 - i.x1, i.h = i.y2 - i.y1, i;
  },
  renderedExtent: function() {
    var e = this.width(), r = this.height();
    return {
      x1: 0,
      y1: 0,
      x2: e,
      y2: r,
      w: e,
      h: r
    };
  },
  multiClickDebounceTime: function(e) {
    if (e) this._private.multiClickDebounceTime = e;
    else return this._private.multiClickDebounceTime;
    return this;
  }
};
Lu.centre = Lu.center;
Lu.autolockNodes = Lu.autolock;
Lu.autoungrabifyNodes = Lu.autoungrabify;
var zp = {
  data: Ar.data({
    field: "data",
    bindingEvent: "data",
    allowBinding: !0,
    allowSetting: !0,
    settingEvent: "data",
    settingTriggersEvent: !0,
    triggerFnName: "trigger",
    allowGetting: !0,
    updateStyle: !0
  }),
  removeData: Ar.removeData({
    field: "data",
    event: "data",
    triggerFnName: "trigger",
    triggerEvent: !0,
    updateStyle: !0
  }),
  scratch: Ar.data({
    field: "scratch",
    bindingEvent: "scratch",
    allowBinding: !0,
    allowSetting: !0,
    settingEvent: "scratch",
    settingTriggersEvent: !0,
    triggerFnName: "trigger",
    allowGetting: !0,
    updateStyle: !0
  }),
  removeScratch: Ar.removeData({
    field: "scratch",
    event: "scratch",
    triggerFnName: "trigger",
    triggerEvent: !0,
    updateStyle: !0
  })
};
zp.attr = zp.data;
zp.removeAttr = zp.removeData;
var Gp = function(e) {
  var r = this;
  e = Gt({}, e);
  var n = e.container;
  n && !ky(n) && ky(n[0]) && (n = n[0]);
  var i = n ? n._cyreg : null;
  i = i || {}, i && i.cy && (i.cy.destroy(), i = {});
  var a = i.readies = i.readies || [];
  n && (n._cyreg = i), i.cy = r;
  var s = Dn !== void 0 && n !== void 0 && !e.headless, o = e;
  o.layout = Gt({
    name: s ? "grid" : "null"
  }, o.layout), o.renderer = Gt({
    name: s ? "canvas" : "null"
  }, o.renderer);
  var l = function(g, m, v) {
    return m !== void 0 ? m : v !== void 0 ? v : g;
  }, u = this._private = {
    container: n,
    // html dom ele container
    ready: !1,
    // whether ready has been triggered
    options: o,
    // cached options
    elements: new ui(this),
    // elements in the graph
    listeners: [],
    // list of listeners
    aniEles: new ui(this),
    // elements being animated
    data: o.data || {},
    // data for the core
    scratch: {},
    // scratch object for core
    layout: null,
    renderer: null,
    destroyed: !1,
    // whether destroy was called
    notificationsEnabled: !0,
    // whether notifications are sent to the renderer
    minZoom: 1e-50,
    maxZoom: 1e50,
    zoomingEnabled: l(!0, o.zoomingEnabled),
    userZoomingEnabled: l(!0, o.userZoomingEnabled),
    panningEnabled: l(!0, o.panningEnabled),
    userPanningEnabled: l(!0, o.userPanningEnabled),
    boxSelectionEnabled: l(!0, o.boxSelectionEnabled),
    autolock: l(!1, o.autolock, o.autolockNodes),
    autoungrabify: l(!1, o.autoungrabify, o.autoungrabifyNodes),
    autounselectify: l(!1, o.autounselectify),
    styleEnabled: o.styleEnabled === void 0 ? s : o.styleEnabled,
    zoom: mt(o.zoom) ? o.zoom : 1,
    pan: {
      x: mr(o.pan) && mt(o.pan.x) ? o.pan.x : 0,
      y: mr(o.pan) && mt(o.pan.y) ? o.pan.y : 0
    },
    animation: {
      // object for currently-running animations
      current: [],
      queue: []
    },
    hasCompoundNodes: !1,
    multiClickDebounceTime: l(250, o.multiClickDebounceTime)
  };
  this.createEmitter(), this.selectionType(o.selectionType), this.zoomRange({
    min: o.minZoom,
    max: o.maxZoom
  });
  var h = function(g, m) {
    var v = g.some(yye);
    if (v)
      return rf.all(g).then(m);
    m(g);
  };
  u.styleEnabled && r.setStyle([]);
  var d = Gt({}, o, o.renderer);
  r.initRenderer(d);
  var f = function(g, m, v) {
    r.notifications(!1);
    var y = r.mutableElements();
    y.length > 0 && y.remove(), g != null && (mr(g) || Or(g)) && r.add(g), r.one("layoutready", function(w) {
      r.notifications(!0), r.emit(w), r.one("load", m), r.emitAndNotify("load");
    }).one("layoutstop", function() {
      r.one("done", v), r.emit("done");
    });
    var b = Gt({}, r._private.options.layout);
    b.eles = r.elements(), r.layout(b).run();
  };
  h([o.style, o.elements], function(p) {
    var g = p[0], m = p[1];
    u.styleEnabled && r.style().append(g), f(m, function() {
      r.startAnimationLoop(), u.ready = !0, an(o.ready) && r.on("ready", o.ready);
      for (var v = 0; v < a.length; v++) {
        var y = a[v];
        r.on("ready", y);
      }
      i && (i.readies = []), r.emit("ready");
    }, o.done);
  });
}, My = Gp.prototype;
Gt(My, {
  instanceString: function() {
    return "core";
  },
  isReady: function() {
    return this._private.ready;
  },
  destroyed: function() {
    return this._private.destroyed;
  },
  ready: function(e) {
    return this.isReady() ? this.emitter().emit("ready", [], e) : this.on("ready", e), this;
  },
  destroy: function() {
    var e = this;
    if (!e.destroyed())
      return e.stopAnimationLoop(), e.destroyRenderer(), this.emit("destroy"), e._private.destroyed = !0, e;
  },
  hasElementWithId: function(e) {
    return this._private.elements.hasElementWithId(e);
  },
  getElementById: function(e) {
    return this._private.elements.getElementById(e);
  },
  hasCompoundNodes: function() {
    return this._private.hasCompoundNodes;
  },
  headless: function() {
    return this._private.renderer.isHeadless();
  },
  styleEnabled: function() {
    return this._private.styleEnabled;
  },
  addToPool: function(e) {
    return this._private.elements.merge(e), this;
  },
  removeFromPool: function(e) {
    return this._private.elements.unmerge(e), this;
  },
  container: function() {
    return this._private.container || null;
  },
  window: function() {
    var e = this._private.container;
    if (e == null) return Dn;
    var r = this._private.container.ownerDocument;
    return r === void 0 || r == null ? Dn : r.defaultView || Dn;
  },
  mount: function(e) {
    if (e != null) {
      var r = this, n = r._private, i = n.options;
      return !ky(e) && ky(e[0]) && (e = e[0]), r.stopAnimationLoop(), r.destroyRenderer(), n.container = e, n.styleEnabled = !0, r.invalidateSize(), r.initRenderer(Gt({}, i, i.renderer, {
        // allow custom renderer name to be re-used, otherwise use canvas
        name: i.renderer.name === "null" ? "canvas" : i.renderer.name
      })), r.startAnimationLoop(), r.style(i.style), r.emit("mount"), r;
    }
  },
  unmount: function() {
    var e = this;
    return e.stopAnimationLoop(), e.destroyRenderer(), e.initRenderer({
      name: "null"
    }), e.emit("unmount"), e;
  },
  options: function() {
    return Zs(this._private.options);
  },
  json: function(e) {
    var r = this, n = r._private, i = r.mutableElements(), a = function(T) {
      return r.getElementById(T.id());
    };
    if (mr(e)) {
      if (r.startBatch(), e.elements) {
        var s = {}, o = function(T, E) {
          for (var L = [], k = [], C = 0; C < T.length; C++) {
            var A = T[C];
            if (!A.data.id) {
              Lr("cy.json() cannot handle elements without an ID attribute");
              continue;
            }
            var R = "" + A.data.id, _ = r.getElementById(R);
            s[R] = !0, _.length !== 0 ? k.push({
              ele: _,
              json: A
            }) : (E && (A.group = E), L.push(A));
          }
          r.add(L);
          for (var O = 0; O < k.length; O++) {
            var P = k[O], S = P.ele, M = P.json;
            S.json(M);
          }
        };
        if (Or(e.elements))
          o(e.elements);
        else
          for (var l = ["nodes", "edges"], u = 0; u < l.length; u++) {
            var h = l[u], d = e.elements[h];
            Or(d) && o(d, h);
          }
        var f = r.collection();
        i.filter(function(w) {
          return !s[w.id()];
        }).forEach(function(w) {
          w.isParent() ? f.merge(w) : w.remove();
        }), f.forEach(function(w) {
          return w.children().move({
            parent: null
          });
        }), f.forEach(function(w) {
          return a(w).remove();
        });
      }
      e.style && r.style(e.style), e.zoom != null && e.zoom !== n.zoom && r.zoom(e.zoom), e.pan && (e.pan.x !== n.pan.x || e.pan.y !== n.pan.y) && r.pan(e.pan), e.data && r.data(e.data);
      for (var p = ["minZoom", "maxZoom", "zoomingEnabled", "userZoomingEnabled", "panningEnabled", "userPanningEnabled", "boxSelectionEnabled", "autolock", "autoungrabify", "autounselectify", "multiClickDebounceTime"], g = 0; g < p.length; g++) {
        var m = p[g];
        e[m] != null && r[m](e[m]);
      }
      return r.endBatch(), this;
    } else {
      var v = !!e, y = {};
      v ? y.elements = this.elements().map(function(w) {
        return w.json();
      }) : (y.elements = {}, i.forEach(function(w) {
        var T = w.group();
        y.elements[T] || (y.elements[T] = []), y.elements[T].push(w.json());
      })), this._private.styleEnabled && (y.style = r.style().json()), y.data = Zs(r.data());
      var b = n.options;
      return y.zoomingEnabled = n.zoomingEnabled, y.userZoomingEnabled = n.userZoomingEnabled, y.zoom = n.zoom, y.minZoom = n.minZoom, y.maxZoom = n.maxZoom, y.panningEnabled = n.panningEnabled, y.userPanningEnabled = n.userPanningEnabled, y.pan = Zs(n.pan), y.boxSelectionEnabled = n.boxSelectionEnabled, y.renderer = Zs(b.renderer), y.hideEdgesOnViewport = b.hideEdgesOnViewport, y.textureOnViewport = b.textureOnViewport, y.wheelSensitivity = b.wheelSensitivity, y.motionBlur = b.motionBlur, y.multiClickDebounceTime = b.multiClickDebounceTime, y;
    }
  }
});
My.$id = My.getElementById;
[y4e, E4e, pU, wT, zm, S4e, TT, Gm, _4e, Lu, zp].forEach(function(t) {
  Gt(My, t);
});
var R4e = {
  fit: !0,
  // whether to fit the viewport to the graph
  directed: !1,
  // whether the tree is directed downwards (or edges can point in any direction if false)
  direction: "downward",
  // determines the direction in which the tree structure is drawn.  The possible values are 'downward', 'upward', 'rightward', or 'leftward'.
  padding: 30,
  // padding on fit
  circle: !1,
  // put depths in concentric circles if true, put depths top down if false
  grid: !1,
  // whether to create an even grid into which the DAG is placed (circle:false only)
  spacingFactor: 1.75,
  // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: !0,
  // prevents node overlap, may overflow boundingBox if not enough space
  nodeDimensionsIncludeLabels: !1,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  roots: void 0,
  // the roots of the trees
  depthSort: void 0,
  // a sorting function to order nodes at equal depth. e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: !1,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled,
  animateFilter: function(e, r) {
    return !0;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: function(e, r) {
    return r;
  }
  // transform a given node position. Useful for changing flow direction in discrete layouts
}, M4e = {
  maximal: !1,
  // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only); setting acyclic to true sets maximal to true also
  acyclic: !1
  // whether the tree is acyclic and thus a node could be shifted (due to the maximal option) multiple times without causing an infinite loop; setting to true sets maximal to true also; if you are uncertain whether a tree is acyclic, set to false to avoid potential infinite loops
}, wh = function(e) {
  return e.scratch("breadthfirst");
}, nL = function(e, r) {
  return e.scratch("breadthfirst", r);
};
function gU(t) {
  this.options = Gt({}, R4e, M4e, t);
}
gU.prototype.run = function() {
  var t = this.options, e = t.cy, r = t.eles, n = r.nodes().filter(function(De) {
    return De.isChildless();
  }), i = r, a = t.directed, s = t.acyclic || t.maximal || t.maximalAdjustments > 0, o = !!t.boundingBox, l = qi(o ? t.boundingBox : structuredClone(e.extent())), u;
  if (ka(t.roots))
    u = t.roots;
  else if (Or(t.roots)) {
    for (var h = [], d = 0; d < t.roots.length; d++) {
      var f = t.roots[d], p = e.getElementById(f);
      h.push(p);
    }
    u = e.collection(h);
  } else if (Bt(t.roots))
    u = e.$(t.roots);
  else if (a)
    u = n.roots();
  else {
    var g = r.components();
    u = e.collection();
    for (var m = function() {
      var ue = g[v], ze = ue.maxDegree(!1), Ge = ue.filter(function(Ve) {
        return Ve.degree(!1) === ze;
      });
      u = u.add(Ge);
    }, v = 0; v < g.length; v++)
      m();
  }
  var y = [], b = {}, w = function(ue, ze) {
    y[ze] == null && (y[ze] = []);
    var Ge = y[ze].length;
    y[ze].push(ue), nL(ue, {
      index: Ge,
      depth: ze
    });
  }, T = function(ue, ze) {
    var Ge = wh(ue), Ve = Ge.depth, ke = Ge.index;
    y[Ve][ke] = null, ue.isChildless() && w(ue, ze);
  };
  i.bfs({
    roots: u,
    directed: t.directed,
    visit: function(ue, ze, Ge, Ve, ke) {
      var Oe = ue[0], Se = Oe.id();
      Oe.isChildless() && w(Oe, ke), b[Se] = !0;
    }
  });
  for (var E = [], L = 0; L < n.length; L++) {
    var k = n[L];
    b[k.id()] || E.push(k);
  }
  var C = function(ue) {
    for (var ze = y[ue], Ge = 0; Ge < ze.length; Ge++) {
      var Ve = ze[Ge];
      if (Ve == null) {
        ze.splice(Ge, 1), Ge--;
        continue;
      }
      nL(Ve, {
        depth: ue,
        index: Ge
      });
    }
  }, A = function(ue, ze) {
    for (var Ge = wh(ue), Ve = ue.incomers().filter(function(Ne) {
      return Ne.isNode() && r.has(Ne);
    }), ke = -1, Oe = ue.id(), Se = 0; Se < Ve.length; Se++) {
      var _e = Ve[Se], $e = wh(_e);
      ke = Math.max(ke, $e.depth);
    }
    if (Ge.depth <= ke) {
      if (!t.acyclic && ze[Oe])
        return null;
      var me = ke + 1;
      return T(ue, me), ze[Oe] = me, !0;
    }
    return !1;
  };
  if (a && s) {
    var R = [], _ = {}, O = function(ue) {
      return R.push(ue);
    }, P = function() {
      return R.shift();
    };
    for (n.forEach(function(De) {
      return R.push(De);
    }); R.length > 0; ) {
      var S = P(), M = A(S, _);
      if (M)
        S.outgoers().filter(function(De) {
          return De.isNode() && r.has(De);
        }).forEach(O);
      else if (M === null) {
        Lr("Detected double maximal shift for node `" + S.id() + "`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.");
        break;
      }
    }
  }
  var N = 0;
  if (t.avoidOverlap)
    for (var D = 0; D < n.length; D++) {
      var I = n[D], B = I.layoutDimensions(t), z = B.w, F = B.h;
      N = Math.max(N, z, F);
    }
  var V = {}, H = function(ue) {
    if (V[ue.id()])
      return V[ue.id()];
    for (var ze = wh(ue).depth, Ge = ue.neighborhood(), Ve = 0, ke = 0, Oe = 0; Oe < Ge.length; Oe++) {
      var Se = Ge[Oe];
      if (!(Se.isEdge() || Se.isParent() || !n.has(Se))) {
        var _e = wh(Se);
        if (_e != null) {
          var $e = _e.index, me = _e.depth;
          if (!($e == null || me == null)) {
            var Ne = y[me].length;
            me < ze && (Ve += $e / Ne, ke++);
          }
        }
      }
    }
    return ke = Math.max(1, ke), Ve = Ve / ke, ke === 0 && (Ve = 0), V[ue.id()] = Ve, Ve;
  }, J = function(ue, ze) {
    var Ge = H(ue), Ve = H(ze), ke = Ge - Ve;
    return ke === 0 ? mV(ue.id(), ze.id()) : ke;
  };
  t.depthSort !== void 0 && (J = t.depthSort);
  for (var q = y.length, ae = 0; ae < q; ae++)
    y[ae].sort(J), C(ae);
  for (var re = [], pe = 0; pe < E.length; pe++)
    re.push(E[pe]);
  var K = function() {
    for (var ue = 0; ue < q; ue++)
      C(ue);
  };
  re.length && (y.unshift(re), q = y.length, K());
  for (var Z = 0, X = 0; X < q; X++)
    Z = Math.max(y[X].length, Z);
  var Y = {
    x: l.x1 + l.w / 2,
    y: l.y1 + l.h / 2
  }, ee = n.reduce(function(De, ue) {
    return (function(ze) {
      return {
        w: De.w === -1 ? ze.w : (De.w + ze.w) / 2,
        h: De.h === -1 ? ze.h : (De.h + ze.h) / 2
      };
    })(ue.boundingBox({
      includeLabels: t.nodeDimensionsIncludeLabels
    }));
  }, {
    w: -1,
    h: -1
  }), j = Math.max(
    // only one depth
    q === 1 ? 0 : (
      // inside a bounding box, no need for top & bottom padding
      o ? (l.h - t.padding * 2 - ee.h) / (q - 1) : (l.h - t.padding * 2 - ee.h) / (q + 1)
    ),
    N
  ), fe = y.reduce(function(De, ue) {
    return Math.max(De, ue.length);
  }, 0), te = function(ue) {
    var ze = wh(ue), Ge = ze.depth, Ve = ze.index;
    if (t.circle) {
      var ke = Math.min(l.w / 2 / q, l.h / 2 / q);
      ke = Math.max(ke, N);
      var Oe = ke * Ge + ke - (q > 0 && y[0].length <= 3 ? ke / 2 : 0), Se = 2 * Math.PI / y[Ge].length * Ve;
      return Ge === 0 && y[0].length === 1 && (Oe = 1), {
        x: Y.x + Oe * Math.cos(Se),
        y: Y.y + Oe * Math.sin(Se)
      };
    } else {
      var _e = y[Ge].length, $e = Math.max(
        // only one depth
        _e === 1 ? 0 : (
          // inside a bounding box, no need for left & right padding
          o ? (l.w - t.padding * 2 - ee.w) / ((t.grid ? fe : _e) - 1) : (l.w - t.padding * 2 - ee.w) / ((t.grid ? fe : _e) + 1)
        ),
        N
      ), me = {
        x: Y.x + (Ve + 1 - (_e + 1) / 2) * $e,
        y: Y.y + (Ge + 1 - (q + 1) / 2) * j
      };
      return me;
    }
  }, Ae = {
    downward: 0,
    leftward: 90,
    upward: 180,
    rightward: -90
  };
  Object.keys(Ae).indexOf(t.direction) === -1 && Zr("Invalid direction '".concat(t.direction, "' specified for breadthfirst layout. Valid values are: ").concat(Object.keys(Ae).join(", ")));
  var W = function(ue) {
    return Yye(te(ue), l, Ae[t.direction]);
  };
  return r.nodes().layoutPositions(this, t, W), this;
};
var N4e = {
  fit: !0,
  // whether to fit the viewport to the graph
  padding: 30,
  // the padding on fit
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: !0,
  // prevents node overlap, may overflow boundingBox and radius if not enough space
  nodeDimensionsIncludeLabels: !1,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  spacingFactor: void 0,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  radius: void 0,
  // the radius of the circle
  startAngle: 3 / 2 * Math.PI,
  // where nodes start in radians
  sweep: void 0,
  // how many radians should be between the first and last node (defaults to full circle)
  clockwise: !0,
  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  sort: void 0,
  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: !1,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: function(e, r) {
    return !0;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: function(e, r) {
    return r;
  }
  // transform a given node position. Useful for changing flow direction in discrete layouts 
};
function mU(t) {
  this.options = Gt({}, N4e, t);
}
mU.prototype.run = function() {
  var t = this.options, e = t, r = t.cy, n = e.eles, i = e.counterclockwise !== void 0 ? !e.counterclockwise : e.clockwise, a = n.nodes().not(":parent");
  e.sort && (a = a.sort(e.sort));
  for (var s = qi(e.boundingBox ? e.boundingBox : {
    x1: 0,
    y1: 0,
    w: r.width(),
    h: r.height()
  }), o = {
    x: s.x1 + s.w / 2,
    y: s.y1 + s.h / 2
  }, l = e.sweep === void 0 ? 2 * Math.PI - 2 * Math.PI / a.length : e.sweep, u = l / Math.max(1, a.length - 1), h, d = 0, f = 0; f < a.length; f++) {
    var p = a[f], g = p.layoutDimensions(e), m = g.w, v = g.h;
    d = Math.max(d, m, v);
  }
  if (mt(e.radius) ? h = e.radius : a.length <= 1 ? h = 0 : h = Math.min(s.h, s.w) / 2 - d, a.length > 1 && e.avoidOverlap) {
    d *= 1.75;
    var y = Math.cos(u) - Math.cos(0), b = Math.sin(u) - Math.sin(0), w = Math.sqrt(d * d / (y * y + b * b));
    h = Math.max(w, h);
  }
  var T = function(L, k) {
    var C = e.startAngle + k * u * (i ? 1 : -1), A = h * Math.cos(C), R = h * Math.sin(C), _ = {
      x: o.x + A,
      y: o.y + R
    };
    return _;
  };
  return n.nodes().layoutPositions(this, e, T), this;
};
var I4e = {
  fit: !0,
  // whether to fit the viewport to the graph
  padding: 30,
  // the padding on fit
  startAngle: 3 / 2 * Math.PI,
  // where nodes start in radians
  sweep: void 0,
  // how many radians should be between the first and last node (defaults to full circle)
  clockwise: !0,
  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  equidistant: !1,
  // whether levels have an equal radial distance betwen them, may cause bounding box overflow
  minNodeSpacing: 10,
  // min spacing between outside of nodes (used for radius adjustment)
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: !0,
  // prevents node overlap, may overflow boundingBox if not enough space
  nodeDimensionsIncludeLabels: !1,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  height: void 0,
  // height of layout area (overrides container height)
  width: void 0,
  // width of layout area (overrides container width)
  spacingFactor: void 0,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  concentric: function(e) {
    return e.degree();
  },
  levelWidth: function(e) {
    return e.maxDegree() / 4;
  },
  animate: !1,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: function(e, r) {
    return !0;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: function(e, r) {
    return r;
  }
  // transform a given node position. Useful for changing flow direction in discrete layouts
};
function vU(t) {
  this.options = Gt({}, I4e, t);
}
vU.prototype.run = function() {
  for (var t = this.options, e = t, r = e.counterclockwise !== void 0 ? !e.counterclockwise : e.clockwise, n = t.cy, i = e.eles, a = i.nodes().not(":parent"), s = qi(e.boundingBox ? e.boundingBox : {
    x1: 0,
    y1: 0,
    w: n.width(),
    h: n.height()
  }), o = {
    x: s.x1 + s.w / 2,
    y: s.y1 + s.h / 2
  }, l = [], u = 0, h = 0; h < a.length; h++) {
    var d = a[h], f = void 0;
    f = e.concentric(d), l.push({
      value: f,
      node: d
    }), d._private.scratch.concentric = f;
  }
  a.updateStyle();
  for (var p = 0; p < a.length; p++) {
    var g = a[p], m = g.layoutDimensions(e);
    u = Math.max(u, m.w, m.h);
  }
  l.sort(function(j, fe) {
    return fe.value - j.value;
  });
  for (var v = e.levelWidth(a), y = [[]], b = y[0], w = 0; w < l.length; w++) {
    var T = l[w];
    if (b.length > 0) {
      var E = Math.abs(b[0].value - T.value);
      E >= v && (b = [], y.push(b));
    }
    b.push(T);
  }
  var L = u + e.minNodeSpacing;
  if (!e.avoidOverlap) {
    var k = y.length > 0 && y[0].length > 1, C = Math.min(s.w, s.h) / 2 - L, A = C / (y.length + k ? 1 : 0);
    L = Math.min(L, A);
  }
  for (var R = 0, _ = 0; _ < y.length; _++) {
    var O = y[_], P = e.sweep === void 0 ? 2 * Math.PI - 2 * Math.PI / O.length : e.sweep, S = O.dTheta = P / Math.max(1, O.length - 1);
    if (O.length > 1 && e.avoidOverlap) {
      var M = Math.cos(S) - Math.cos(0), N = Math.sin(S) - Math.sin(0), D = Math.sqrt(L * L / (M * M + N * N));
      R = Math.max(D, R);
    }
    O.r = R, R += L;
  }
  if (e.equidistant) {
    for (var I = 0, B = 0, z = 0; z < y.length; z++) {
      var F = y[z], V = F.r - B;
      I = Math.max(I, V);
    }
    B = 0;
    for (var H = 0; H < y.length; H++) {
      var J = y[H];
      H === 0 && (B = J.r), J.r = B, B += I;
    }
  }
  for (var q = {}, ae = 0; ae < y.length; ae++)
    for (var re = y[ae], pe = re.dTheta, K = re.r, Z = 0; Z < re.length; Z++) {
      var X = re[Z], Y = e.startAngle + (r ? 1 : -1) * pe * Z, ee = {
        x: o.x + K * Math.cos(Y),
        y: o.y + K * Math.sin(Y)
      };
      q[X.node.id()] = ee;
    }
  return i.nodes().layoutPositions(this, e, function(j) {
    var fe = j.id();
    return q[fe];
  }), this;
};
var e5, D4e = {
  // Called on `layoutready`
  ready: function() {
  },
  // Called on `layoutstop`
  stop: function() {
  },
  // Whether to animate while running the layout
  // true : Animate continuously as the layout is running
  // false : Just show the end result
  // 'end' : Animate with the end result, from the initial positions to the end positions
  animate: !0,
  // Easing of the animation for animate:'end'
  animationEasing: void 0,
  // The duration of the animation for animate:'end'
  animationDuration: void 0,
  // A function that determines whether the node should be animated
  // All nodes animated by default on animate enabled
  // Non-animated nodes are positioned immediately when the layout starts
  animateFilter: function(e, r) {
    return !0;
  },
  // The layout animates only after this many milliseconds for animate:true
  // (prevents flashing on fast runs)
  animationThreshold: 250,
  // Number of iterations between consecutive screen positions update
  refresh: 20,
  // Whether to fit the network view after when done
  fit: !0,
  // Padding on fit
  padding: 30,
  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  boundingBox: void 0,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  nodeDimensionsIncludeLabels: !1,
  // Randomize the initial positions of the nodes (true) or use existing positions (false)
  randomize: !1,
  // Extra spacing between components in non-compound graphs
  componentSpacing: 40,
  // Node repulsion (non overlapping) multiplier
  nodeRepulsion: function(e) {
    return 2048;
  },
  // Node repulsion (overlapping) multiplier
  nodeOverlap: 4,
  // Ideal edge (non nested) length
  idealEdgeLength: function(e) {
    return 32;
  },
  // Divisor to compute edge forces
  edgeElasticity: function(e) {
    return 32;
  },
  // Nesting factor (multiplier) to compute ideal edge length for nested edges
  nestingFactor: 1.2,
  // Gravity force (constant)
  gravity: 1,
  // Maximum number of iterations to perform
  numIter: 1e3,
  // Initial temperature (maximum node displacement)
  initialTemp: 1e3,
  // Cooling factor (how the temperature is reduced between consecutive iterations
  coolingFactor: 0.99,
  // Lower temperature threshold (below this point the layout will end)
  minTemp: 1
};
function zx(t) {
  this.options = Gt({}, D4e, t), this.options.layout = this;
  var e = this.options.eles.nodes(), r = this.options.eles.edges(), n = r.filter(function(i) {
    var a = i.source().data("id"), s = i.target().data("id"), o = e.some(function(u) {
      return u.data("id") === a;
    }), l = e.some(function(u) {
      return u.data("id") === s;
    });
    return !o || !l;
  });
  this.options.eles = this.options.eles.not(n);
}
zx.prototype.run = function() {
  var t = this.options, e = t.cy, r = this;
  r.stopped = !1, (t.animate === !0 || t.animate === !1) && r.emit({
    type: "layoutstart",
    layout: r
  }), t.debug === !0 ? e5 = !0 : e5 = !1;
  var n = O4e(e, r, t);
  e5 && B4e(n), t.randomize && F4e(n);
  var i = nl(), a = function() {
    $4e(n, e, t), t.fit === !0 && e.fit(t.padding);
  }, s = function(f) {
    return !(r.stopped || f >= t.numIter || (z4e(n, t), n.temperature = n.temperature * t.coolingFactor, n.temperature < t.minTemp));
  }, o = function() {
    if (t.animate === !0 || t.animate === !1)
      a(), r.one("layoutstop", t.stop), r.emit({
        type: "layoutstop",
        layout: r
      });
    else {
      var f = t.eles.nodes(), p = xU(n, t, f);
      f.layoutPositions(r, t, p);
    }
  }, l = 0, u = !0;
  if (t.animate === !0) {
    var h = function() {
      for (var f = 0; u && f < t.refresh; )
        u = s(l), l++, f++;
      if (!u)
        aL(n, t), o();
      else {
        var p = nl();
        p - i >= t.animationThreshold && a(), Sy(h);
      }
    };
    h();
  } else {
    for (; u; )
      u = s(l), l++;
    aL(n, t), o();
  }
  return this;
};
zx.prototype.stop = function() {
  return this.stopped = !0, this.thread && this.thread.stop(), this.emit("layoutstop"), this;
};
zx.prototype.destroy = function() {
  return this.thread && this.thread.stop(), this;
};
var O4e = function(e, r, n) {
  for (var i = n.eles.edges(), a = n.eles.nodes(), s = qi(n.boundingBox ? n.boundingBox : {
    x1: 0,
    y1: 0,
    w: e.width(),
    h: e.height()
  }), o = {
    isCompound: e.hasCompoundNodes(),
    layoutNodes: [],
    idToIndex: {},
    nodeSize: a.size(),
    graphSet: [],
    indexToGraph: [],
    layoutEdges: [],
    edgeSize: i.size(),
    temperature: n.initialTemp,
    clientWidth: s.w,
    clientHeight: s.h,
    boundingBox: s
  }, l = n.eles.components(), u = {}, h = 0; h < l.length; h++)
    for (var d = l[h], f = 0; f < d.length; f++) {
      var p = d[f];
      u[p.id()] = h;
    }
  for (var h = 0; h < o.nodeSize; h++) {
    var g = a[h], m = g.layoutDimensions(n), v = {};
    v.isLocked = g.locked(), v.id = g.data("id"), v.parentId = g.data("parent"), v.cmptId = u[g.id()], v.children = [], v.positionX = g.position("x"), v.positionY = g.position("y"), v.offsetX = 0, v.offsetY = 0, v.height = m.w, v.width = m.h, v.maxX = v.positionX + v.width / 2, v.minX = v.positionX - v.width / 2, v.maxY = v.positionY + v.height / 2, v.minY = v.positionY - v.height / 2, v.padLeft = parseFloat(g.style("padding")), v.padRight = parseFloat(g.style("padding")), v.padTop = parseFloat(g.style("padding")), v.padBottom = parseFloat(g.style("padding")), v.nodeRepulsion = an(n.nodeRepulsion) ? n.nodeRepulsion(g) : n.nodeRepulsion, o.layoutNodes.push(v), o.idToIndex[v.id] = h;
  }
  for (var y = [], b = 0, w = -1, T = [], h = 0; h < o.nodeSize; h++) {
    var g = o.layoutNodes[h], E = g.parentId;
    E != null ? o.layoutNodes[o.idToIndex[E]].children.push(g.id) : (y[++w] = g.id, T.push(g.id));
  }
  for (o.graphSet.push(T); b <= w; ) {
    var L = y[b++], k = o.idToIndex[L], p = o.layoutNodes[k], C = p.children;
    if (C.length > 0) {
      o.graphSet.push(C);
      for (var h = 0; h < C.length; h++)
        y[++w] = C[h];
    }
  }
  for (var h = 0; h < o.graphSet.length; h++)
    for (var A = o.graphSet[h], f = 0; f < A.length; f++) {
      var R = o.idToIndex[A[f]];
      o.indexToGraph[R] = h;
    }
  for (var h = 0; h < o.edgeSize; h++) {
    var _ = i[h], O = {};
    O.id = _.data("id"), O.sourceId = _.data("source"), O.targetId = _.data("target");
    var P = an(n.idealEdgeLength) ? n.idealEdgeLength(_) : n.idealEdgeLength, S = an(n.edgeElasticity) ? n.edgeElasticity(_) : n.edgeElasticity, M = o.idToIndex[O.sourceId], N = o.idToIndex[O.targetId], D = o.indexToGraph[M], I = o.indexToGraph[N];
    if (D != I) {
      for (var B = P4e(O.sourceId, O.targetId, o), z = o.graphSet[B], F = 0, v = o.layoutNodes[M]; z.indexOf(v.id) === -1; )
        v = o.layoutNodes[o.idToIndex[v.parentId]], F++;
      for (v = o.layoutNodes[N]; z.indexOf(v.id) === -1; )
        v = o.layoutNodes[o.idToIndex[v.parentId]], F++;
      P *= F * n.nestingFactor;
    }
    O.idealLength = P, O.elasticity = S, o.layoutEdges.push(O);
  }
  return o;
}, P4e = function(e, r, n) {
  var i = yU(e, r, 0, n);
  return 2 > i.count ? 0 : i.graph;
}, yU = function(e, r, n, i) {
  var a = i.graphSet[n];
  if (-1 < a.indexOf(e) && -1 < a.indexOf(r))
    return {
      count: 2,
      graph: n
    };
  for (var s = 0, o = 0; o < a.length; o++) {
    var l = a[o], u = i.idToIndex[l], h = i.layoutNodes[u].children;
    if (h.length !== 0) {
      var d = i.indexToGraph[i.idToIndex[h[0]]], f = yU(e, r, d, i);
      if (f.count !== 0)
        if (f.count === 1) {
          if (s++, s === 2)
            break;
        } else
          return f;
    }
  }
  return {
    count: s,
    graph: n
  };
}, B4e, F4e = function(e, r) {
  for (var n = e.clientWidth, i = e.clientHeight, a = 0; a < e.nodeSize; a++) {
    var s = e.layoutNodes[a];
    s.children.length === 0 && !s.isLocked && (s.positionX = Math.random() * n, s.positionY = Math.random() * i);
  }
}, xU = function(e, r, n) {
  var i = e.boundingBox, a = {
    x1: 1 / 0,
    x2: -1 / 0,
    y1: 1 / 0,
    y2: -1 / 0
  };
  return r.boundingBox && (n.forEach(function(s) {
    var o = e.layoutNodes[e.idToIndex[s.data("id")]];
    a.x1 = Math.min(a.x1, o.positionX), a.x2 = Math.max(a.x2, o.positionX), a.y1 = Math.min(a.y1, o.positionY), a.y2 = Math.max(a.y2, o.positionY);
  }), a.w = a.x2 - a.x1, a.h = a.y2 - a.y1), function(s, o) {
    var l = e.layoutNodes[e.idToIndex[s.data("id")]];
    if (r.boundingBox) {
      var u = a.w === 0 ? 0.5 : (l.positionX - a.x1) / a.w, h = a.h === 0 ? 0.5 : (l.positionY - a.y1) / a.h;
      return {
        x: i.x1 + u * i.w,
        y: i.y1 + h * i.h
      };
    } else
      return {
        x: l.positionX,
        y: l.positionY
      };
  };
}, $4e = function(e, r, n) {
  var i = n.layout, a = n.eles.nodes(), s = xU(e, n, a);
  a.positions(s), e.ready !== !0 && (e.ready = !0, i.one("layoutready", n.ready), i.emit({
    type: "layoutready",
    layout: this
  }));
}, z4e = function(e, r, n) {
  G4e(e, r), H4e(e), q4e(e, r), W4e(e), Y4e(e);
}, G4e = function(e, r) {
  for (var n = 0; n < e.graphSet.length; n++)
    for (var i = e.graphSet[n], a = i.length, s = 0; s < a; s++)
      for (var o = e.layoutNodes[e.idToIndex[i[s]]], l = s + 1; l < a; l++) {
        var u = e.layoutNodes[e.idToIndex[i[l]]];
        V4e(o, u, e, r);
      }
}, iL = function(e) {
  return -1 + 2 * e * Math.random();
}, V4e = function(e, r, n, i) {
  var a = e.cmptId, s = r.cmptId;
  if (!(a !== s && !n.isCompound)) {
    var o = r.positionX - e.positionX, l = r.positionY - e.positionY, u = 1;
    o === 0 && l === 0 && (o = iL(u), l = iL(u));
    var h = U4e(e, r, o, l);
    if (h > 0)
      var d = i.nodeOverlap * h, f = Math.sqrt(o * o + l * l), p = d * o / f, g = d * l / f;
    else
      var m = Ny(e, o, l), v = Ny(r, -1 * o, -1 * l), y = v.x - m.x, b = v.y - m.y, w = y * y + b * b, f = Math.sqrt(w), d = (e.nodeRepulsion + r.nodeRepulsion) / w, p = d * y / f, g = d * b / f;
    e.isLocked || (e.offsetX -= p, e.offsetY -= g), r.isLocked || (r.offsetX += p, r.offsetY += g);
  }
}, U4e = function(e, r, n, i) {
  if (n > 0)
    var a = e.maxX - r.minX;
  else
    var a = r.maxX - e.minX;
  if (i > 0)
    var s = e.maxY - r.minY;
  else
    var s = r.maxY - e.minY;
  return a >= 0 && s >= 0 ? Math.sqrt(a * a + s * s) : 0;
}, Ny = function(e, r, n) {
  var i = e.positionX, a = e.positionY, s = e.height || 1, o = e.width || 1, l = n / r, u = s / o, h = {};
  return r === 0 && 0 < n || r === 0 && 0 > n ? (h.x = i, h.y = a + s / 2, h) : 0 < r && -1 * u <= l && l <= u ? (h.x = i + o / 2, h.y = a + o * n / 2 / r, h) : 0 > r && -1 * u <= l && l <= u ? (h.x = i - o / 2, h.y = a - o * n / 2 / r, h) : 0 < n && (l <= -1 * u || l >= u) ? (h.x = i + s * r / 2 / n, h.y = a + s / 2, h) : (0 > n && (l <= -1 * u || l >= u) && (h.x = i - s * r / 2 / n, h.y = a - s / 2), h);
}, H4e = function(e, r) {
  for (var n = 0; n < e.edgeSize; n++) {
    var i = e.layoutEdges[n], a = e.idToIndex[i.sourceId], s = e.layoutNodes[a], o = e.idToIndex[i.targetId], l = e.layoutNodes[o], u = l.positionX - s.positionX, h = l.positionY - s.positionY;
    if (!(u === 0 && h === 0)) {
      var d = Ny(s, u, h), f = Ny(l, -1 * u, -1 * h), p = f.x - d.x, g = f.y - d.y, m = Math.sqrt(p * p + g * g), v = Math.pow(i.idealLength - m, 2) / i.elasticity;
      if (m !== 0)
        var y = v * p / m, b = v * g / m;
      else
        var y = 0, b = 0;
      s.isLocked || (s.offsetX += y, s.offsetY += b), l.isLocked || (l.offsetX -= y, l.offsetY -= b);
    }
  }
}, q4e = function(e, r) {
  if (r.gravity !== 0)
    for (var n = 1, i = 0; i < e.graphSet.length; i++) {
      var a = e.graphSet[i], s = a.length;
      if (i === 0)
        var o = e.clientHeight / 2, l = e.clientWidth / 2;
      else
        var u = e.layoutNodes[e.idToIndex[a[0]]], h = e.layoutNodes[e.idToIndex[u.parentId]], o = h.positionX, l = h.positionY;
      for (var d = 0; d < s; d++) {
        var f = e.layoutNodes[e.idToIndex[a[d]]];
        if (!f.isLocked) {
          var p = o - f.positionX, g = l - f.positionY, m = Math.sqrt(p * p + g * g);
          if (m > n) {
            var v = r.gravity * p / m, y = r.gravity * g / m;
            f.offsetX += v, f.offsetY += y;
          }
        }
      }
    }
}, W4e = function(e, r) {
  var n = [], i = 0, a = -1;
  for (n.push.apply(n, e.graphSet[0]), a += e.graphSet[0].length; i <= a; ) {
    var s = n[i++], o = e.idToIndex[s], l = e.layoutNodes[o], u = l.children;
    if (0 < u.length && !l.isLocked) {
      for (var h = l.offsetX, d = l.offsetY, f = 0; f < u.length; f++) {
        var p = e.layoutNodes[e.idToIndex[u[f]]];
        p.offsetX += h, p.offsetY += d, n[++a] = u[f];
      }
      l.offsetX = 0, l.offsetY = 0;
    }
  }
}, Y4e = function(e, r) {
  for (var n = 0; n < e.nodeSize; n++) {
    var i = e.layoutNodes[n];
    0 < i.children.length && (i.maxX = void 0, i.minX = void 0, i.maxY = void 0, i.minY = void 0);
  }
  for (var n = 0; n < e.nodeSize; n++) {
    var i = e.layoutNodes[n];
    if (!(0 < i.children.length || i.isLocked)) {
      var a = X4e(i.offsetX, i.offsetY, e.temperature);
      i.positionX += a.x, i.positionY += a.y, i.offsetX = 0, i.offsetY = 0, i.minX = i.positionX - i.width, i.maxX = i.positionX + i.width, i.minY = i.positionY - i.height, i.maxY = i.positionY + i.height, bU(i, e);
    }
  }
  for (var n = 0; n < e.nodeSize; n++) {
    var i = e.layoutNodes[n];
    0 < i.children.length && !i.isLocked && (i.positionX = (i.maxX + i.minX) / 2, i.positionY = (i.maxY + i.minY) / 2, i.width = i.maxX - i.minX, i.height = i.maxY - i.minY);
  }
}, X4e = function(e, r, n) {
  var i = Math.sqrt(e * e + r * r);
  if (i > n)
    var a = {
      x: n * e / i,
      y: n * r / i
    };
  else
    var a = {
      x: e,
      y: r
    };
  return a;
}, bU = function(e, r) {
  var n = e.parentId;
  if (n != null) {
    var i = r.layoutNodes[r.idToIndex[n]], a = !1;
    if ((i.maxX == null || e.maxX + i.padRight > i.maxX) && (i.maxX = e.maxX + i.padRight, a = !0), (i.minX == null || e.minX - i.padLeft < i.minX) && (i.minX = e.minX - i.padLeft, a = !0), (i.maxY == null || e.maxY + i.padBottom > i.maxY) && (i.maxY = e.maxY + i.padBottom, a = !0), (i.minY == null || e.minY - i.padTop < i.minY) && (i.minY = e.minY - i.padTop, a = !0), a)
      return bU(i, r);
  }
}, aL = function(e, r) {
  for (var n = e.layoutNodes, i = [], a = 0; a < n.length; a++) {
    var s = n[a], o = s.cmptId, l = i[o] = i[o] || [];
    l.push(s);
  }
  for (var u = 0, a = 0; a < i.length; a++) {
    var h = i[a];
    if (h) {
      h.x1 = 1 / 0, h.x2 = -1 / 0, h.y1 = 1 / 0, h.y2 = -1 / 0;
      for (var d = 0; d < h.length; d++) {
        var f = h[d];
        h.x1 = Math.min(h.x1, f.positionX - f.width / 2), h.x2 = Math.max(h.x2, f.positionX + f.width / 2), h.y1 = Math.min(h.y1, f.positionY - f.height / 2), h.y2 = Math.max(h.y2, f.positionY + f.height / 2);
      }
      h.w = h.x2 - h.x1, h.h = h.y2 - h.y1, u += h.w * h.h;
    }
  }
  i.sort(function(b, w) {
    return w.w * w.h - b.w * b.h;
  });
  for (var p = 0, g = 0, m = 0, v = 0, y = Math.sqrt(u) * e.clientWidth / e.clientHeight, a = 0; a < i.length; a++) {
    var h = i[a];
    if (h) {
      for (var d = 0; d < h.length; d++) {
        var f = h[d];
        f.isLocked || (f.positionX += p - h.x1, f.positionY += g - h.y1);
      }
      p += h.w + r.componentSpacing, m += h.w + r.componentSpacing, v = Math.max(v, h.h), m > y && (g += v + r.componentSpacing, p = 0, m = 0, v = 0);
    }
  }
}, j4e = {
  fit: !0,
  // whether to fit the viewport to the graph
  padding: 30,
  // padding used on fit
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: !0,
  // prevents node overlap, may overflow boundingBox if not enough space
  avoidOverlapPadding: 10,
  // extra spacing around nodes when avoidOverlap: true
  nodeDimensionsIncludeLabels: !1,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  spacingFactor: void 0,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  condense: !1,
  // uses all available space on false, uses minimal space on true
  rows: void 0,
  // force num of rows in the grid
  cols: void 0,
  // force num of columns in the grid
  position: function(e) {
  },
  // returns { row, col } for element
  sort: void 0,
  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: !1,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: function(e, r) {
    return !0;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: function(e, r) {
    return r;
  }
  // transform a given node position. Useful for changing flow direction in discrete layouts 
};
function wU(t) {
  this.options = Gt({}, j4e, t);
}
wU.prototype.run = function() {
  var t = this.options, e = t, r = t.cy, n = e.eles, i = n.nodes().not(":parent");
  e.sort && (i = i.sort(e.sort));
  var a = qi(e.boundingBox ? e.boundingBox : {
    x1: 0,
    y1: 0,
    w: r.width(),
    h: r.height()
  });
  if (a.h === 0 || a.w === 0)
    n.nodes().layoutPositions(this, e, function(H) {
      return {
        x: a.x1,
        y: a.y1
      };
    });
  else {
    var s = i.size(), o = Math.sqrt(s * a.h / a.w), l = Math.round(o), u = Math.round(a.w / a.h * o), h = function(J) {
      if (J == null)
        return Math.min(l, u);
      var q = Math.min(l, u);
      q == l ? l = J : u = J;
    }, d = function(J) {
      if (J == null)
        return Math.max(l, u);
      var q = Math.max(l, u);
      q == l ? l = J : u = J;
    }, f = e.rows, p = e.cols != null ? e.cols : e.columns;
    if (f != null && p != null)
      l = f, u = p;
    else if (f != null && p == null)
      l = f, u = Math.ceil(s / l);
    else if (f == null && p != null)
      u = p, l = Math.ceil(s / u);
    else if (u * l > s) {
      var g = h(), m = d();
      (g - 1) * m >= s ? h(g - 1) : (m - 1) * g >= s && d(m - 1);
    } else
      for (; u * l < s; ) {
        var v = h(), y = d();
        (y + 1) * v >= s ? d(y + 1) : h(v + 1);
      }
    var b = a.w / u, w = a.h / l;
    if (e.condense && (b = 0, w = 0), e.avoidOverlap)
      for (var T = 0; T < i.length; T++) {
        var E = i[T], L = E._private.position;
        (L.x == null || L.y == null) && (L.x = 0, L.y = 0);
        var k = E.layoutDimensions(e), C = e.avoidOverlapPadding, A = k.w + C, R = k.h + C;
        b = Math.max(b, A), w = Math.max(w, R);
      }
    for (var _ = {}, O = function(J, q) {
      return !!_["c-" + J + "-" + q];
    }, P = function(J, q) {
      _["c-" + J + "-" + q] = !0;
    }, S = 0, M = 0, N = function() {
      M++, M >= u && (M = 0, S++);
    }, D = {}, I = 0; I < i.length; I++) {
      var B = i[I], z = e.position(B);
      if (z && (z.row !== void 0 || z.col !== void 0)) {
        var F = {
          row: z.row,
          col: z.col
        };
        if (F.col === void 0)
          for (F.col = 0; O(F.row, F.col); )
            F.col++;
        else if (F.row === void 0)
          for (F.row = 0; O(F.row, F.col); )
            F.row++;
        D[B.id()] = F, P(F.row, F.col);
      }
    }
    var V = function(J, q) {
      var ae, re;
      if (J.locked() || J.isParent())
        return !1;
      var pe = D[J.id()];
      if (pe)
        ae = pe.col * b + b / 2 + a.x1, re = pe.row * w + w / 2 + a.y1;
      else {
        for (; O(S, M); )
          N();
        ae = M * b + b / 2 + a.x1, re = S * w + w / 2 + a.y1, P(S, M), N();
      }
      return {
        x: ae,
        y: re
      };
    };
    i.layoutPositions(this, e, V);
  }
  return this;
};
var K4e = {
  ready: function() {
  },
  // on layoutready
  stop: function() {
  }
  // on layoutstop
};
function hS(t) {
  this.options = Gt({}, K4e, t);
}
hS.prototype.run = function() {
  var t = this.options, e = t.eles, r = this;
  return t.cy, r.emit("layoutstart"), e.nodes().positions(function() {
    return {
      x: 0,
      y: 0
    };
  }), r.one("layoutready", t.ready), r.emit("layoutready"), r.one("layoutstop", t.stop), r.emit("layoutstop"), this;
};
hS.prototype.stop = function() {
  return this;
};
var Z4e = {
  positions: void 0,
  // map of (node id) => (position obj); or function(node){ return somPos; }
  zoom: void 0,
  // the zoom level to set (prob want fit = false if set)
  pan: void 0,
  // the pan level to set (prob want fit = false if set)
  fit: !0,
  // whether to fit to viewport
  padding: 30,
  // padding on fit
  spacingFactor: void 0,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  animate: !1,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: function(e, r) {
    return !0;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: function(e, r) {
    return r;
  }
  // transform a given node position. Useful for changing flow direction in discrete layouts
};
function TU(t) {
  this.options = Gt({}, Z4e, t);
}
TU.prototype.run = function() {
  var t = this.options, e = t.eles, r = e.nodes(), n = an(t.positions);
  function i(a) {
    if (t.positions == null)
      return x2e(a.position());
    if (n)
      return t.positions(a);
    var s = t.positions[a._private.data.id];
    return s ?? null;
  }
  return r.layoutPositions(this, t, function(a, s) {
    var o = i(a);
    return a.locked() || o == null ? !1 : o;
  }), this;
};
var Q4e = {
  fit: !0,
  // whether to fit to viewport
  padding: 30,
  // fit padding
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  animate: !1,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: function(e, r) {
    return !0;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: function(e, r) {
    return r;
  }
  // transform a given node position. Useful for changing flow direction in discrete layouts 
};
function EU(t) {
  this.options = Gt({}, Q4e, t);
}
EU.prototype.run = function() {
  var t = this.options, e = t.cy, r = t.eles, n = qi(t.boundingBox ? t.boundingBox : {
    x1: 0,
    y1: 0,
    w: e.width(),
    h: e.height()
  }), i = function(s, o) {
    return {
      x: n.x1 + Math.round(Math.random() * n.w),
      y: n.y1 + Math.round(Math.random() * n.h)
    };
  };
  return r.nodes().layoutPositions(this, t, i), this;
};
var J4e = [{
  name: "breadthfirst",
  impl: gU
}, {
  name: "circle",
  impl: mU
}, {
  name: "concentric",
  impl: vU
}, {
  name: "cose",
  impl: zx
}, {
  name: "grid",
  impl: wU
}, {
  name: "null",
  impl: hS
}, {
  name: "preset",
  impl: TU
}, {
  name: "random",
  impl: EU
}];
function kU(t) {
  this.options = t, this.notifications = 0;
}
var sL = function() {
}, oL = function() {
  throw new Error("A headless instance can not render images");
};
kU.prototype = {
  recalculateRenderedStyle: sL,
  notify: function() {
    this.notifications++;
  },
  init: sL,
  isHeadless: function() {
    return !0;
  },
  png: oL,
  jpg: oL
};
var dS = {};
dS.arrowShapeWidth = 0.3;
dS.registerArrowShapes = function() {
  var t = this.arrowShapes = {}, e = this, r = function(u, h, d, f, p, g, m) {
    var v = p.x - d / 2 - m, y = p.x + d / 2 + m, b = p.y - d / 2 - m, w = p.y + d / 2 + m, T = v <= u && u <= y && b <= h && h <= w;
    return T;
  }, n = function(u, h, d, f, p) {
    var g = u * Math.cos(f) - h * Math.sin(f), m = u * Math.sin(f) + h * Math.cos(f), v = g * d, y = m * d, b = v + p.x, w = y + p.y;
    return {
      x: b,
      y: w
    };
  }, i = function(u, h, d, f) {
    for (var p = [], g = 0; g < u.length; g += 2) {
      var m = u[g], v = u[g + 1];
      p.push(n(m, v, h, d, f));
    }
    return p;
  }, a = function(u) {
    for (var h = [], d = 0; d < u.length; d++) {
      var f = u[d];
      h.push(f.x, f.y);
    }
    return h;
  }, s = function(u) {
    return u.pstyle("width").pfValue * u.pstyle("arrow-scale").pfValue * 2;
  }, o = function(u, h) {
    Bt(h) && (h = t[h]), t[u] = Gt({
      name: u,
      points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],
      collide: function(f, p, g, m, v, y) {
        var b = a(i(this.points, g + 2 * y, m, v)), w = ia(f, p, b);
        return w;
      },
      roughCollide: r,
      draw: function(f, p, g, m) {
        var v = i(this.points, p, g, m);
        e.arrowShapeImpl("polygon")(f, v);
      },
      spacing: function(f) {
        return 0;
      },
      gap: s
    }, h);
  };
  o("none", {
    collide: Cy,
    roughCollide: Cy,
    draw: Zk,
    spacing: w_,
    gap: w_
  }), o("triangle", {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3]
  }), o("arrow", "triangle"), o("triangle-backcurve", {
    points: t.triangle.points,
    controlPoint: [0, -0.15],
    roughCollide: r,
    draw: function(u, h, d, f, p) {
      var g = i(this.points, h, d, f), m = this.controlPoint, v = n(m[0], m[1], h, d, f);
      e.arrowShapeImpl(this.name)(u, g, v);
    },
    gap: function(u) {
      return s(u) * 0.8;
    }
  }), o("triangle-tee", {
    points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
    pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],
    collide: function(u, h, d, f, p, g, m) {
      var v = a(i(this.points, d + 2 * m, f, p)), y = a(i(this.pointsTee, d + 2 * m, f, p)), b = ia(u, h, v) || ia(u, h, y);
      return b;
    },
    draw: function(u, h, d, f, p) {
      var g = i(this.points, h, d, f), m = i(this.pointsTee, h, d, f);
      e.arrowShapeImpl(this.name)(u, g, m);
    }
  }), o("circle-triangle", {
    radius: 0.15,
    pointsTr: [0, -0.15, 0.15, -0.45, -0.15, -0.45, 0, -0.15],
    collide: function(u, h, d, f, p, g, m) {
      var v = p, y = Math.pow(v.x - u, 2) + Math.pow(v.y - h, 2) <= Math.pow((d + 2 * m) * this.radius, 2), b = a(i(this.points, d + 2 * m, f, p));
      return ia(u, h, b) || y;
    },
    draw: function(u, h, d, f, p) {
      var g = i(this.pointsTr, h, d, f);
      e.arrowShapeImpl(this.name)(u, g, f.x, f.y, this.radius * h);
    },
    spacing: function(u) {
      return e.getArrowWidth(u.pstyle("width").pfValue, u.pstyle("arrow-scale").value) * this.radius;
    }
  }), o("triangle-cross", {
    points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
    baseCrossLinePts: [
      -0.15,
      -0.4,
      // first half of the rectangle
      -0.15,
      -0.4,
      0.15,
      -0.4,
      // second half of the rectangle
      0.15,
      -0.4
    ],
    crossLinePts: function(u, h) {
      var d = this.baseCrossLinePts.slice(), f = h / u, p = 3, g = 5;
      return d[p] = d[p] - f, d[g] = d[g] - f, d;
    },
    collide: function(u, h, d, f, p, g, m) {
      var v = a(i(this.points, d + 2 * m, f, p)), y = a(i(this.crossLinePts(d, g), d + 2 * m, f, p)), b = ia(u, h, v) || ia(u, h, y);
      return b;
    },
    draw: function(u, h, d, f, p) {
      var g = i(this.points, h, d, f), m = i(this.crossLinePts(h, p), h, d, f);
      e.arrowShapeImpl(this.name)(u, g, m);
    }
  }), o("vee", {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],
    gap: function(u) {
      return s(u) * 0.525;
    }
  }), o("circle", {
    radius: 0.15,
    collide: function(u, h, d, f, p, g, m) {
      var v = p, y = Math.pow(v.x - u, 2) + Math.pow(v.y - h, 2) <= Math.pow((d + 2 * m) * this.radius, 2);
      return y;
    },
    draw: function(u, h, d, f, p) {
      e.arrowShapeImpl(this.name)(u, f.x, f.y, this.radius * h);
    },
    spacing: function(u) {
      return e.getArrowWidth(u.pstyle("width").pfValue, u.pstyle("arrow-scale").value) * this.radius;
    }
  }), o("tee", {
    points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],
    spacing: function(u) {
      return 1;
    },
    gap: function(u) {
      return 1;
    }
  }), o("square", {
    points: [-0.15, 0, 0.15, 0, 0.15, -0.3, -0.15, -0.3]
  }), o("diamond", {
    points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],
    gap: function(u) {
      return u.pstyle("width").pfValue * u.pstyle("arrow-scale").value;
    }
  }), o("chevron", {
    points: [0, 0, -0.15, -0.15, -0.1, -0.2, 0, -0.1, 0.1, -0.2, 0.15, -0.15],
    gap: function(u) {
      return 0.95 * u.pstyle("width").pfValue * u.pstyle("arrow-scale").value;
    }
  });
};
var eh = {};
eh.projectIntoViewport = function(t, e) {
  var r = this.cy, n = this.findContainerClientCoords(), i = n[0], a = n[1], s = n[4], o = r.pan(), l = r.zoom(), u = ((t - i) / s - o.x) / l, h = ((e - a) / s - o.y) / l;
  return [u, h];
};
eh.findContainerClientCoords = function() {
  if (this.containerBB)
    return this.containerBB;
  var t = this.container, e = t.getBoundingClientRect(), r = this.cy.window().getComputedStyle(t), n = function(y) {
    return parseFloat(r.getPropertyValue(y));
  }, i = {
    left: n("padding-left"),
    right: n("padding-right"),
    top: n("padding-top"),
    bottom: n("padding-bottom")
  }, a = {
    left: n("border-left-width"),
    right: n("border-right-width"),
    top: n("border-top-width"),
    bottom: n("border-bottom-width")
  }, s = t.clientWidth, o = t.clientHeight, l = i.left + i.right, u = i.top + i.bottom, h = a.left + a.right, d = e.width / (s + h), f = s - l, p = o - u, g = e.left + i.left + a.left, m = e.top + i.top + a.top;
  return this.containerBB = [g, m, f, p, d];
};
eh.invalidateContainerClientCoordsCache = function() {
  this.containerBB = null;
};
eh.findNearestElement = function(t, e, r, n) {
  return this.findNearestElements(t, e, r, n)[0];
};
eh.findNearestElements = function(t, e, r, n) {
  var i = this, a = this, s = a.getCachedZSortedEles(), o = [], l = a.cy.zoom(), u = a.cy.hasCompoundNodes(), h = (n ? 24 : 8) / l, d = (n ? 8 : 2) / l, f = (n ? 8 : 2) / l, p = 1 / 0, g, m;
  r && (s = s.interactive);
  function v(k, C) {
    if (k.isNode()) {
      if (m)
        return;
      m = k, o.push(k);
    }
    if (k.isEdge() && (C == null || C < p))
      if (g) {
        if (g.pstyle("z-compound-depth").value === k.pstyle("z-compound-depth").value && g.pstyle("z-compound-depth").value === k.pstyle("z-compound-depth").value) {
          for (var A = 0; A < o.length; A++)
            if (o[A].isEdge()) {
              o[A] = k, g = k, p = C ?? p;
              break;
            }
        }
      } else
        o.push(k), g = k, p = C ?? p;
  }
  function y(k) {
    var C = k.outerWidth() + 2 * d, A = k.outerHeight() + 2 * d, R = C / 2, _ = A / 2, O = k.position(), P = k.pstyle("corner-radius").value === "auto" ? "auto" : k.pstyle("corner-radius").pfValue, S = k._private.rscratch;
    if (O.x - R <= t && t <= O.x + R && O.y - _ <= e && e <= O.y + _) {
      var M = a.nodeShapes[i.getNodeShape(k)];
      if (M.checkPoint(t, e, 0, C, A, O.x, O.y, P, S))
        return v(k, 0), !0;
    }
  }
  function b(k) {
    var C = k._private, A = C.rscratch, R = k.pstyle("width").pfValue, _ = k.pstyle("arrow-scale").value, O = R / 2 + h, P = O * O, S = O * 2, I = C.source, B = C.target, M;
    if (A.edgeType === "segments" || A.edgeType === "straight" || A.edgeType === "haystack") {
      for (var N = A.allpts, D = 0; D + 3 < N.length; D += 2)
        if (I2e(t, e, N[D], N[D + 1], N[D + 2], N[D + 3], S) && P > (M = F2e(t, e, N[D], N[D + 1], N[D + 2], N[D + 3])))
          return v(k, M), !0;
    } else if (A.edgeType === "bezier" || A.edgeType === "multibezier" || A.edgeType === "self" || A.edgeType === "compound") {
      for (var N = A.allpts, D = 0; D + 5 < A.allpts.length; D += 4)
        if (D2e(t, e, N[D], N[D + 1], N[D + 2], N[D + 3], N[D + 4], N[D + 5], S) && P > (M = B2e(t, e, N[D], N[D + 1], N[D + 2], N[D + 3], N[D + 4], N[D + 5])))
          return v(k, M), !0;
    }
    for (var I = I || C.source, B = B || C.target, z = i.getArrowWidth(R, _), F = [{
      name: "source",
      x: A.arrowStartX,
      y: A.arrowStartY,
      angle: A.srcArrowAngle
    }, {
      name: "target",
      x: A.arrowEndX,
      y: A.arrowEndY,
      angle: A.tgtArrowAngle
    }, {
      name: "mid-source",
      x: A.midX,
      y: A.midY,
      angle: A.midsrcArrowAngle
    }, {
      name: "mid-target",
      x: A.midX,
      y: A.midY,
      angle: A.midtgtArrowAngle
    }], D = 0; D < F.length; D++) {
      var V = F[D], H = a.arrowShapes[k.pstyle(V.name + "-arrow-shape").value], J = k.pstyle("width").pfValue;
      if (H.roughCollide(t, e, z, V.angle, {
        x: V.x,
        y: V.y
      }, J, h) && H.collide(t, e, z, V.angle, {
        x: V.x,
        y: V.y
      }, J, h))
        return v(k), !0;
    }
    u && o.length > 0 && (y(I), y(B));
  }
  function w(k, C, A) {
    return na(k, C, A);
  }
  function T(k, C) {
    var A = k._private, R = f, _;
    C ? _ = C + "-" : _ = "", k.boundingBox();
    var O = A.labelBounds[C || "main"], P = k.pstyle(_ + "label").value, S = k.pstyle("text-events").strValue === "yes";
    if (!(!S || !P)) {
      var M = w(A.rscratch, "labelX", C), N = w(A.rscratch, "labelY", C), D = w(A.rscratch, "labelAngle", C), I = k.pstyle(_ + "text-margin-x").pfValue, B = k.pstyle(_ + "text-margin-y").pfValue, z = O.x1 - R - I, F = O.x2 + R - I, V = O.y1 - R - B, H = O.y2 + R - B;
      if (D) {
        var J = Math.cos(D), q = Math.sin(D), ae = function(ee, j) {
          return ee = ee - M, j = j - N, {
            x: ee * J - j * q + M,
            y: ee * q + j * J + N
          };
        }, re = ae(z, V), pe = ae(z, H), K = ae(F, V), Z = ae(F, H), X = [
          // with the margin added after the rotation is applied
          re.x + I,
          re.y + B,
          K.x + I,
          K.y + B,
          Z.x + I,
          Z.y + B,
          pe.x + I,
          pe.y + B
        ];
        if (ia(t, e, X))
          return v(k), !0;
      } else if (Dl(O, t, e))
        return v(k), !0;
    }
  }
  for (var E = s.length - 1; E >= 0; E--) {
    var L = s[E];
    L.isNode() ? y(L) || T(L) : b(L) || T(L) || T(L, "source") || T(L, "target");
  }
  return o;
};
eh.getAllInBox = function(t, e, r, n) {
  var i = this.getCachedZSortedEles().interactive, a = this.cy.zoom(), s = 2 / a, o = [], l = Math.min(t, r), u = Math.max(t, r), h = Math.min(e, n), d = Math.max(e, n);
  t = l, r = u, e = h, n = d;
  var f = qi({
    x1: t,
    y1: e,
    x2: r,
    y2: n
  }), p = [{
    x: f.x1,
    y: f.y1
  }, {
    x: f.x2,
    y: f.y1
  }, {
    x: f.x2,
    y: f.y2
  }, {
    x: f.x1,
    y: f.y2
  }], g = [[p[0], p[1]], [p[1], p[2]], [p[2], p[3]], [p[3], p[0]]];
  function m(ee, j, fe) {
    return na(ee, j, fe);
  }
  function v(ee, j) {
    var fe = ee._private, te = s, Ae = "";
    ee.boundingBox();
    var W = fe.labelBounds.main;
    if (!W)
      return null;
    var De = m(fe.rscratch, "labelX", j), ue = m(fe.rscratch, "labelY", j), ze = m(fe.rscratch, "labelAngle", j), Ge = ee.pstyle(Ae + "text-margin-x").pfValue, Ve = ee.pstyle(Ae + "text-margin-y").pfValue, ke = W.x1 - te - Ge, Oe = W.x2 + te - Ge, Se = W.y1 - te - Ve, _e = W.y2 + te - Ve;
    if (ze) {
      var $e = Math.cos(ze), me = Math.sin(ze), Ne = function(ce, $) {
        return ce = ce - De, $ = $ - ue, {
          x: ce * $e - $ * me + De,
          y: ce * me + $ * $e + ue
        };
      };
      return [Ne(ke, Se), Ne(Oe, Se), Ne(Oe, _e), Ne(ke, _e)];
    } else
      return [{
        x: ke,
        y: Se
      }, {
        x: Oe,
        y: Se
      }, {
        x: Oe,
        y: _e
      }, {
        x: ke,
        y: _e
      }];
  }
  function y(ee, j, fe, te) {
    function Ae(W, De, ue) {
      return (ue.y - W.y) * (De.x - W.x) > (De.y - W.y) * (ue.x - W.x);
    }
    return Ae(ee, fe, te) !== Ae(j, fe, te) && Ae(ee, j, fe) !== Ae(ee, j, te);
  }
  for (var b = 0; b < i.length; b++) {
    var w = i[b];
    if (w.isNode()) {
      var T = w, E = T.pstyle("text-events").strValue === "yes", L = T.pstyle("box-selection").strValue, k = T.pstyle("box-select-labels").strValue === "yes";
      if (L === "none")
        continue;
      var C = (L === "overlap" || k) && E, A = T.boundingBox({
        includeNodes: !0,
        includeEdges: !1,
        includeLabels: C
      });
      if (L === "contain") {
        var R = !1;
        if (k && E) {
          var _ = v(T);
          _ && Q4(_, p) && (o.push(T), R = !0);
        }
        !R && MV(f, A) && o.push(T);
      } else if (L === "overlap" && tS(f, A)) {
        var O = T.boundingBox({
          includeNodes: !0,
          includeEdges: !0,
          includeLabels: !1,
          includeMainLabels: !1,
          includeSourceLabels: !1,
          includeTargetLabels: !1
        }), P = [{
          x: O.x1,
          y: O.y1
        }, {
          x: O.x2,
          y: O.y1
        }, {
          x: O.x2,
          y: O.y2
        }, {
          x: O.x1,
          y: O.y2
        }];
        if (Q4(P, p))
          o.push(T);
        else {
          var S = v(T);
          S && Q4(S, p) && o.push(T);
        }
      }
    } else {
      var M = w, N = M._private, D = N.rscratch, I = M.pstyle("box-selection").strValue;
      if (I === "none")
        continue;
      if (I === "contain") {
        if (D.startX != null && D.startY != null && !Dl(f, D.startX, D.startY) || D.endX != null && D.endY != null && !Dl(f, D.endX, D.endY))
          continue;
        if (D.edgeType === "bezier" || D.edgeType === "multibezier" || D.edgeType === "self" || D.edgeType === "compound" || D.edgeType === "segments" || D.edgeType === "haystack") {
          for (var B = N.rstyle.bezierPts || N.rstyle.linePts || N.rstyle.haystackPts, z = !0, F = 0; F < B.length; F++)
            if (!C_(f, B[F])) {
              z = !1;
              break;
            }
          z && o.push(M);
        } else D.edgeType === "straight" && o.push(M);
      } else if (I === "overlap") {
        var V = !1;
        if (D.startX != null && D.startY != null && D.endX != null && D.endY != null && (Dl(f, D.startX, D.startY) || Dl(f, D.endX, D.endY)))
          o.push(M), V = !0;
        else if (!V && D.edgeType === "haystack") {
          for (var H = N.rstyle.haystackPts, J = 0; J < H.length; J++)
            if (C_(f, H[J])) {
              o.push(M), V = !0;
              break;
            }
        }
        if (!V) {
          var q = N.rstyle.bezierPts || N.rstyle.linePts || N.rstyle.haystackPts;
          if ((!q || q.length < 2) && D.edgeType === "straight" && D.startX != null && D.startY != null && D.endX != null && D.endY != null && (q = [{
            x: D.startX,
            y: D.startY
          }, {
            x: D.endX,
            y: D.endY
          }]), !q || q.length < 2) continue;
          for (var ae = 0; ae < q.length - 1; ae++) {
            for (var re = q[ae], pe = q[ae + 1], K = 0; K < g.length; K++) {
              var Z = En(g[K], 2), X = Z[0], Y = Z[1];
              if (y(re, pe, X, Y)) {
                o.push(M), V = !0;
                break;
              }
            }
            if (V) break;
          }
        }
      }
    }
  }
  return o;
};
var Iy = {};
Iy.calculateArrowAngles = function(t) {
  var e = t._private.rscratch, r = e.edgeType === "haystack", n = e.edgeType === "bezier", i = e.edgeType === "multibezier", a = e.edgeType === "segments", s = e.edgeType === "compound", o = e.edgeType === "self", l, u, h, d, f, p, y, b;
  if (r ? (h = e.haystackPts[0], d = e.haystackPts[1], f = e.haystackPts[2], p = e.haystackPts[3]) : (h = e.arrowStartX, d = e.arrowStartY, f = e.arrowEndX, p = e.arrowEndY), y = e.midX, b = e.midY, a)
    l = h - e.segpts[0], u = d - e.segpts[1];
  else if (i || s || o || n) {
    var g = e.allpts, m = Yn(g[0], g[2], g[4], 0.1), v = Yn(g[1], g[3], g[5], 0.1);
    l = h - m, u = d - v;
  } else
    l = h - y, u = d - b;
  e.srcArrowAngle = _1(l, u);
  var y = e.midX, b = e.midY;
  if (r && (y = (h + f) / 2, b = (d + p) / 2), l = f - h, u = p - d, a) {
    var g = e.allpts;
    if (g.length / 2 % 2 === 0) {
      var w = g.length / 2, T = w - 2;
      l = g[w] - g[T], u = g[w + 1] - g[T + 1];
    } else if (e.isRound)
      l = e.midVector[1], u = -e.midVector[0];
    else {
      var w = g.length / 2 - 1, T = w - 2;
      l = g[w] - g[T], u = g[w + 1] - g[T + 1];
    }
  } else if (i || s || o) {
    var g = e.allpts, E = e.ctrlpts, L, k, C, A;
    if (E.length / 2 % 2 === 0) {
      var R = g.length / 2 - 1, _ = R + 2, O = _ + 2;
      L = Yn(g[R], g[_], g[O], 0), k = Yn(g[R + 1], g[_ + 1], g[O + 1], 0), C = Yn(g[R], g[_], g[O], 1e-4), A = Yn(g[R + 1], g[_ + 1], g[O + 1], 1e-4);
    } else {
      var _ = g.length / 2 - 1, R = _ - 2, O = _ + 2;
      L = Yn(g[R], g[_], g[O], 0.4999), k = Yn(g[R + 1], g[_ + 1], g[O + 1], 0.4999), C = Yn(g[R], g[_], g[O], 0.5), A = Yn(g[R + 1], g[_ + 1], g[O + 1], 0.5);
    }
    l = C - L, u = A - k;
  }
  if (e.midtgtArrowAngle = _1(l, u), e.midDispX = l, e.midDispY = u, l *= -1, u *= -1, a) {
    var g = e.allpts;
    if (g.length / 2 % 2 !== 0) {
      if (!e.isRound) {
        var w = g.length / 2 - 1, P = w + 2;
        l = -(g[P] - g[w]), u = -(g[P + 1] - g[w + 1]);
      }
    }
  }
  if (e.midsrcArrowAngle = _1(l, u), a)
    l = f - e.segpts[e.segpts.length - 2], u = p - e.segpts[e.segpts.length - 1];
  else if (i || s || o || n) {
    var g = e.allpts, S = g.length, m = Yn(g[S - 6], g[S - 4], g[S - 2], 0.9), v = Yn(g[S - 5], g[S - 3], g[S - 1], 0.9);
    l = f - m, u = p - v;
  } else
    l = f - y, u = p - b;
  e.tgtArrowAngle = _1(l, u);
};
Iy.getArrowWidth = Iy.getArrowHeight = function(t, e) {
  var r = this.arrowWidthCache = this.arrowWidthCache || {}, n = r[t + ", " + e];
  return n || (n = Math.max(Math.pow(t * 13.37, 0.9), 29) * e, r[t + ", " + e] = n, n);
};
var ET, kT, Gs = {}, Fa = {}, lL, cL, Zc, Vm, Co, $c, Yc, Ps, Th, P1, SU, CU, ST, CT, uL, hL = function(e, r, n) {
  n.x = r.x - e.x, n.y = r.y - e.y, n.len = Math.sqrt(n.x * n.x + n.y * n.y), n.nx = n.x / n.len, n.ny = n.y / n.len, n.ang = Math.atan2(n.ny, n.nx);
}, e3e = function(e, r) {
  r.x = e.x * -1, r.y = e.y * -1, r.nx = e.nx * -1, r.ny = e.ny * -1, r.ang = e.ang > 0 ? -(Math.PI - e.ang) : Math.PI + e.ang;
}, t3e = function(e, r, n, i, a) {
  if (e !== uL ? hL(r, e, Gs) : e3e(Fa, Gs), hL(r, n, Fa), lL = Gs.nx * Fa.ny - Gs.ny * Fa.nx, cL = Gs.nx * Fa.nx - Gs.ny * -Fa.ny, Co = Math.asin(Math.max(-1, Math.min(1, lL))), Math.abs(Co) < 1e-6) {
    ET = r.x, kT = r.y, Yc = Th = 0;
    return;
  }
  Zc = 1, Vm = !1, cL < 0 ? Co < 0 ? Co = Math.PI + Co : (Co = Math.PI - Co, Zc = -1, Vm = !0) : Co > 0 && (Zc = -1, Vm = !0), r.radius !== void 0 ? Th = r.radius : Th = i, $c = Co / 2, P1 = Math.min(Gs.len / 2, Fa.len / 2), a ? (Ps = Math.abs(Math.cos($c) * Th / Math.sin($c)), Ps > P1 ? (Ps = P1, Yc = Math.abs(Ps * Math.sin($c) / Math.cos($c))) : Yc = Th) : (Ps = Math.min(P1, Th), Yc = Math.abs(Ps * Math.sin($c) / Math.cos($c))), ST = r.x + Fa.nx * Ps, CT = r.y + Fa.ny * Ps, ET = ST - Fa.ny * Yc * Zc, kT = CT + Fa.nx * Yc * Zc, SU = r.x + Gs.nx * Ps, CU = r.y + Gs.ny * Ps, uL = r;
};
function AU(t, e) {
  e.radius === 0 ? t.lineTo(e.cx, e.cy) : t.arc(e.cx, e.cy, e.radius, e.startAngle, e.endAngle, e.counterClockwise);
}
function fS(t, e, r, n) {
  var i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0;
  return n === 0 || e.radius === 0 ? {
    cx: e.x,
    cy: e.y,
    radius: 0,
    startX: e.x,
    startY: e.y,
    stopX: e.x,
    stopY: e.y,
    startAngle: void 0,
    endAngle: void 0,
    counterClockwise: void 0
  } : (t3e(t, e, r, n, i), {
    cx: ET,
    cy: kT,
    radius: Yc,
    startX: SU,
    startY: CU,
    stopX: ST,
    stopY: CT,
    startAngle: Gs.ang + Math.PI / 2 * Zc,
    endAngle: Fa.ang - Math.PI / 2 * Zc,
    counterClockwise: Vm
  });
}
var Vp = 0.01, r3e = Math.sqrt(2 * Vp), Li = {};
Li.findMidptPtsEtc = function(t, e) {
  var r = e.posPts, n = e.intersectionPts, i = e.vectorNormInverse, a, s = t.pstyle("source-endpoint"), o = t.pstyle("target-endpoint"), l = s.units != null && o.units != null, u = function(E, L, k, C) {
    var A = C - L, R = k - E, _ = Math.sqrt(R * R + A * A);
    return {
      x: -A / _,
      y: R / _
    };
  }, h = t.pstyle("edge-distances").value;
  switch (h) {
    case "node-position":
      a = r;
      break;
    case "intersection":
      a = n;
      break;
    case "endpoints": {
      if (l) {
        var d = this.manualEndptToPx(t.source()[0], s), f = En(d, 2), p = f[0], g = f[1], m = this.manualEndptToPx(t.target()[0], o), v = En(m, 2), y = v[0], b = v[1], w = {
          x1: p,
          y1: g,
          x2: y,
          y2: b
        };
        i = u(p, g, y, b), a = w;
      } else
        Lr("Edge ".concat(t.id(), " has edge-distances:endpoints specified without manual endpoints specified via source-endpoint and target-endpoint.  Falling back on edge-distances:intersection (default).")), a = n;
      break;
    }
  }
  return {
    midptPts: a,
    vectorNormInverse: i
  };
};
Li.findHaystackPoints = function(t) {
  for (var e = 0; e < t.length; e++) {
    var r = t[e], n = r._private, i = n.rscratch;
    if (!i.haystack) {
      var a = Math.random() * 2 * Math.PI;
      i.source = {
        x: Math.cos(a),
        y: Math.sin(a)
      }, a = Math.random() * 2 * Math.PI, i.target = {
        x: Math.cos(a),
        y: Math.sin(a)
      };
    }
    var s = n.source, o = n.target, l = s.position(), u = o.position(), h = s.width(), d = o.width(), f = s.height(), p = o.height(), g = r.pstyle("haystack-radius").value, m = g / 2;
    i.haystackPts = i.allpts = [i.source.x * h * m + l.x, i.source.y * f * m + l.y, i.target.x * d * m + u.x, i.target.y * p * m + u.y], i.midX = (i.allpts[0] + i.allpts[2]) / 2, i.midY = (i.allpts[1] + i.allpts[3]) / 2, i.edgeType = "haystack", i.haystack = !0, this.storeEdgeProjections(r), this.calculateArrowAngles(r), this.recalculateEdgeLabelProjections(r), this.calculateLabelAngles(r);
  }
};
Li.findSegmentsPoints = function(t, e) {
  var r = t._private.rscratch, n = t.pstyle("segment-weights"), i = t.pstyle("segment-distances"), a = t.pstyle("segment-radii"), s = t.pstyle("radius-type"), o = Math.min(n.pfValue.length, i.pfValue.length), l = a.pfValue[a.pfValue.length - 1], u = s.pfValue[s.pfValue.length - 1];
  r.edgeType = "segments", r.segpts = [], r.radii = [], r.isArcRadius = [];
  for (var h = 0; h < o; h++) {
    var d = n.pfValue[h], f = i.pfValue[h], p = 1 - d, g = d, m = this.findMidptPtsEtc(t, e), v = m.midptPts, y = m.vectorNormInverse, b = {
      x: v.x1 * p + v.x2 * g,
      y: v.y1 * p + v.y2 * g
    };
    r.segpts.push(b.x + y.x * f, b.y + y.y * f), r.radii.push(a.pfValue[h] !== void 0 ? a.pfValue[h] : l), r.isArcRadius.push((s.pfValue[h] !== void 0 ? s.pfValue[h] : u) === "arc-radius");
  }
};
Li.findLoopPoints = function(t, e, r, n) {
  var i = t._private.rscratch, a = e.dirCounts, s = e.srcPos, o = t.pstyle("control-point-distances"), l = o ? o.pfValue[0] : void 0, u = t.pstyle("loop-direction").pfValue, h = t.pstyle("loop-sweep").pfValue, d = t.pstyle("control-point-step-size").pfValue;
  i.edgeType = "self";
  var f = r, p = d;
  n && (f = 0, p = l);
  var g = u - Math.PI / 2, m = g - h / 2, v = g + h / 2, y = u + "_" + h;
  f = a[y] === void 0 ? a[y] = 0 : ++a[y], i.ctrlpts = [s.x + Math.cos(m) * 1.4 * p * (f / 3 + 1), s.y + Math.sin(m) * 1.4 * p * (f / 3 + 1), s.x + Math.cos(v) * 1.4 * p * (f / 3 + 1), s.y + Math.sin(v) * 1.4 * p * (f / 3 + 1)];
};
Li.findCompoundLoopPoints = function(t, e, r, n) {
  var i = t._private.rscratch;
  i.edgeType = "compound";
  var a = e.srcPos, s = e.tgtPos, o = e.srcW, l = e.srcH, u = e.tgtW, h = e.tgtH, d = t.pstyle("control-point-step-size").pfValue, f = t.pstyle("control-point-distances"), p = f ? f.pfValue[0] : void 0, g = r, m = d;
  n && (g = 0, m = p);
  var v = 50, y = {
    x: a.x - o / 2,
    y: a.y - l / 2
  }, b = {
    x: s.x - u / 2,
    y: s.y - h / 2
  }, w = {
    x: Math.min(y.x, b.x),
    y: Math.min(y.y, b.y)
  }, T = 0.5, E = Math.max(T, Math.log(o * Vp)), L = Math.max(T, Math.log(u * Vp));
  i.ctrlpts = [w.x, w.y - (1 + Math.pow(v, 1.12) / 100) * m * (g / 3 + 1) * E, w.x - (1 + Math.pow(v, 1.12) / 100) * m * (g / 3 + 1) * L, w.y];
};
Li.findStraightEdgePoints = function(t) {
  t._private.rscratch.edgeType = "straight";
};
Li.findBezierPoints = function(t, e, r, n, i) {
  var a = t._private.rscratch, s = t.pstyle("control-point-step-size").pfValue, o = t.pstyle("control-point-distances"), l = t.pstyle("control-point-weights"), u = o && l ? Math.min(o.value.length, l.value.length) : 1, h = o ? o.pfValue[0] : void 0, d = l.value[0], f = n;
  a.edgeType = f ? "multibezier" : "bezier", a.ctrlpts = [];
  for (var p = 0; p < u; p++) {
    var g = (0.5 - e.eles.length / 2 + r) * s * (i ? -1 : 1), m = void 0, v = eS(g);
    f && (h = o ? o.pfValue[p] : s, d = l.value[p]), n ? m = h : m = h !== void 0 ? v * h : void 0;
    var y = m !== void 0 ? m : g, b = 1 - d, w = d, T = this.findMidptPtsEtc(t, e), E = T.midptPts, L = T.vectorNormInverse, k = {
      x: E.x1 * b + E.x2 * w,
      y: E.y1 * b + E.y2 * w
    };
    a.ctrlpts.push(k.x + L.x * y, k.y + L.y * y);
  }
};
Li.findTaxiPoints = function(t, e) {
  var r = t._private.rscratch;
  r.edgeType = "segments";
  var n = "vertical", i = "horizontal", a = "leftward", s = "rightward", o = "downward", l = "upward", u = "auto", h = e.posPts, d = e.srcW, f = e.srcH, p = e.tgtW, g = e.tgtH, m = t.pstyle("edge-distances").value, v = m !== "node-position", y = t.pstyle("taxi-direction").value, b = y, w = t.pstyle("taxi-turn"), T = w.units === "%", E = w.pfValue, L = E < 0, k = t.pstyle("taxi-turn-min-distance").pfValue, C = v ? (d + p) / 2 : 0, A = v ? (f + g) / 2 : 0, R = h.x2 - h.x1, _ = h.y2 - h.y1, O = function($, oe) {
    return $ > 0 ? Math.max($ - oe, 0) : Math.min($ + oe, 0);
  }, P = O(R, C), S = O(_, A), M = !1;
  b === u ? y = Math.abs(P) > Math.abs(S) ? i : n : b === l || b === o ? (y = n, M = !0) : (b === a || b === s) && (y = i, M = !0);
  var N = y === n, D = N ? S : P, I = N ? _ : R, B = eS(I), z = !1;
  !(M && (T || L)) && (b === o && I < 0 || b === l && I > 0 || b === a && I > 0 || b === s && I < 0) && (B *= -1, D = B * Math.abs(D), z = !0);
  var F;
  if (T) {
    var V = E < 0 ? 1 + E : E;
    F = V * D;
  } else {
    var H = E < 0 ? D : 0;
    F = H + E * B;
  }
  var J = function($) {
    return Math.abs($) < k || Math.abs($) >= Math.abs(D);
  }, q = J(F), ae = J(Math.abs(D) - Math.abs(F)), re = q || ae;
  if (re && !z)
    if (N) {
      var pe = Math.abs(I) <= f / 2, K = Math.abs(R) <= p / 2;
      if (pe) {
        var Z = (h.x1 + h.x2) / 2, X = h.y1, Y = h.y2;
        r.segpts = [Z, X, Z, Y];
      } else if (K) {
        var ee = (h.y1 + h.y2) / 2, j = h.x1, fe = h.x2;
        r.segpts = [j, ee, fe, ee];
      } else
        r.segpts = [h.x1, h.y2];
    } else {
      var te = Math.abs(I) <= d / 2, Ae = Math.abs(_) <= g / 2;
      if (te) {
        var W = (h.y1 + h.y2) / 2, De = h.x1, ue = h.x2;
        r.segpts = [De, W, ue, W];
      } else if (Ae) {
        var ze = (h.x1 + h.x2) / 2, Ge = h.y1, Ve = h.y2;
        r.segpts = [ze, Ge, ze, Ve];
      } else
        r.segpts = [h.x2, h.y1];
    }
  else if (N) {
    var ke = h.y1 + F + (v ? f / 2 * B : 0), Oe = h.x1, Se = h.x2;
    r.segpts = [Oe, ke, Se, ke];
  } else {
    var _e = h.x1 + F + (v ? d / 2 * B : 0), $e = h.y1, me = h.y2;
    r.segpts = [_e, $e, _e, me];
  }
  if (r.isRound) {
    var Ne = t.pstyle("taxi-radius").value, Q = t.pstyle("radius-type").value[0] === "arc-radius";
    r.radii = new Array(r.segpts.length / 2).fill(Ne), r.isArcRadius = new Array(r.segpts.length / 2).fill(Q);
  }
};
Li.tryToCorrectInvalidPoints = function(t, e) {
  var r = t._private.rscratch;
  if (r.edgeType === "bezier") {
    var n = e.srcPos, i = e.tgtPos, a = e.srcW, s = e.srcH, o = e.tgtW, l = e.tgtH, u = e.srcShape, h = e.tgtShape, d = e.srcCornerRadius, f = e.tgtCornerRadius, p = e.srcRs, g = e.tgtRs, m = !mt(r.startX) || !mt(r.startY), v = !mt(r.arrowStartX) || !mt(r.arrowStartY), y = !mt(r.endX) || !mt(r.endY), b = !mt(r.arrowEndX) || !mt(r.arrowEndY), w = 3, T = this.getArrowWidth(t.pstyle("width").pfValue, t.pstyle("arrow-scale").value) * this.arrowShapeWidth, E = w * T, L = Au({
      x: r.ctrlpts[0],
      y: r.ctrlpts[1]
    }, {
      x: r.startX,
      y: r.startY
    }), k = L < E, C = Au({
      x: r.ctrlpts[0],
      y: r.ctrlpts[1]
    }, {
      x: r.endX,
      y: r.endY
    }), A = C < E, R = !1;
    if (m || v || k) {
      R = !0;
      var _ = {
        // delta
        x: r.ctrlpts[0] - n.x,
        y: r.ctrlpts[1] - n.y
      }, O = Math.sqrt(_.x * _.x + _.y * _.y), P = {
        // normalised delta
        x: _.x / O,
        y: _.y / O
      }, S = Math.max(a, s), M = {
        // *2 radius guarantees outside shape
        x: r.ctrlpts[0] + P.x * 2 * S,
        y: r.ctrlpts[1] + P.y * 2 * S
      }, N = u.intersectLine(n.x, n.y, a, s, M.x, M.y, 0, d, p);
      k ? (r.ctrlpts[0] = r.ctrlpts[0] + P.x * (E - L), r.ctrlpts[1] = r.ctrlpts[1] + P.y * (E - L)) : (r.ctrlpts[0] = N[0] + P.x * E, r.ctrlpts[1] = N[1] + P.y * E);
    }
    if (y || b || A) {
      R = !0;
      var D = {
        // delta
        x: r.ctrlpts[0] - i.x,
        y: r.ctrlpts[1] - i.y
      }, I = Math.sqrt(D.x * D.x + D.y * D.y), B = {
        // normalised delta
        x: D.x / I,
        y: D.y / I
      }, z = Math.max(a, s), F = {
        // *2 radius guarantees outside shape
        x: r.ctrlpts[0] + B.x * 2 * z,
        y: r.ctrlpts[1] + B.y * 2 * z
      }, V = h.intersectLine(i.x, i.y, o, l, F.x, F.y, 0, f, g);
      A ? (r.ctrlpts[0] = r.ctrlpts[0] + B.x * (E - C), r.ctrlpts[1] = r.ctrlpts[1] + B.y * (E - C)) : (r.ctrlpts[0] = V[0] + B.x * E, r.ctrlpts[1] = V[1] + B.y * E);
    }
    R && this.findEndpoints(t);
  }
};
Li.storeAllpts = function(t) {
  var e = t._private.rscratch;
  if (e.edgeType === "multibezier" || e.edgeType === "bezier" || e.edgeType === "self" || e.edgeType === "compound") {
    e.allpts = [], e.allpts.push(e.startX, e.startY);
    for (var r = 0; r + 1 < e.ctrlpts.length; r += 2)
      e.allpts.push(e.ctrlpts[r], e.ctrlpts[r + 1]), r + 3 < e.ctrlpts.length && e.allpts.push((e.ctrlpts[r] + e.ctrlpts[r + 2]) / 2, (e.ctrlpts[r + 1] + e.ctrlpts[r + 3]) / 2);
    e.allpts.push(e.endX, e.endY);
    var n, i;
    e.ctrlpts.length / 2 % 2 === 0 ? (n = e.allpts.length / 2 - 1, e.midX = e.allpts[n], e.midY = e.allpts[n + 1]) : (n = e.allpts.length / 2 - 3, i = 0.5, e.midX = Yn(e.allpts[n], e.allpts[n + 2], e.allpts[n + 4], i), e.midY = Yn(e.allpts[n + 1], e.allpts[n + 3], e.allpts[n + 5], i));
  } else if (e.edgeType === "straight")
    e.allpts = [e.startX, e.startY, e.endX, e.endY], e.midX = (e.startX + e.endX + e.arrowStartX + e.arrowEndX) / 4, e.midY = (e.startY + e.endY + e.arrowStartY + e.arrowEndY) / 4;
  else if (e.edgeType === "segments") {
    if (e.allpts = [], e.allpts.push(e.startX, e.startY), e.allpts.push.apply(e.allpts, e.segpts), e.allpts.push(e.endX, e.endY), e.isRound) {
      e.roundCorners = [];
      for (var a = 2; a + 3 < e.allpts.length; a += 2) {
        var s = e.radii[a / 2 - 1], o = e.isArcRadius[a / 2 - 1];
        e.roundCorners.push(fS({
          x: e.allpts[a - 2],
          y: e.allpts[a - 1]
        }, {
          x: e.allpts[a],
          y: e.allpts[a + 1],
          radius: s
        }, {
          x: e.allpts[a + 2],
          y: e.allpts[a + 3]
        }, s, o));
      }
    }
    if (e.segpts.length % 4 === 0) {
      var l = e.segpts.length / 2, u = l - 2;
      e.midX = (e.segpts[u] + e.segpts[l]) / 2, e.midY = (e.segpts[u + 1] + e.segpts[l + 1]) / 2;
    } else {
      var h = e.segpts.length / 2 - 1;
      if (!e.isRound)
        e.midX = e.segpts[h], e.midY = e.segpts[h + 1];
      else {
        var d = {
          x: e.segpts[h],
          y: e.segpts[h + 1]
        }, f = e.roundCorners[h / 2];
        if (f.radius === 0) {
          var p = {
            x: e.segpts[h + 2],
            y: e.segpts[h + 3]
          };
          e.midX = d.x, e.midY = d.y, e.midVector = [d.y - p.y, p.x - d.x];
        } else {
          var g = [d.x - f.cx, d.y - f.cy], m = f.radius / Math.sqrt(Math.pow(g[0], 2) + Math.pow(g[1], 2));
          g = g.map(function(v) {
            return v * m;
          }), e.midX = f.cx + g[0], e.midY = f.cy + g[1], e.midVector = g;
        }
      }
    }
  }
};
Li.checkForInvalidEdgeWarning = function(t) {
  var e = t[0]._private.rscratch;
  e.nodesOverlap || mt(e.startX) && mt(e.startY) && mt(e.endX) && mt(e.endY) ? e.loggedErr = !1 : e.loggedErr || (e.loggedErr = !0, Lr("Edge `" + t.id() + "` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap."));
};
Li.findEdgeControlPoints = function(t) {
  var e = this;
  if (!(!t || t.length === 0)) {
    for (var r = this, n = r.cy, i = n.hasCompoundNodes(), a = new Go(), s = function(A, R) {
      return [].concat(Ey(A), [R ? 1 : 0]).join("-");
    }, o = [], l = [], u = 0; u < t.length; u++) {
      var h = t[u], d = h._private, f = h.pstyle("curve-style").value;
      if (!(h.removed() || !h.takesUpSpace())) {
        if (f === "haystack") {
          l.push(h);
          continue;
        }
        var p = f === "unbundled-bezier" || Il(f, "segments") || f === "straight" || f === "straight-triangle" || Il(f, "taxi"), g = f === "unbundled-bezier" || f === "bezier", m = d.source, v = d.target, y = m.poolIndex(), b = v.poolIndex(), w = [y, b].sort(), T = s(w, p), E = a.get(T);
        E == null && (E = {
          eles: []
        }, o.push({
          pairId: w,
          edgeIsUnbundled: p
        }), a.set(T, E)), E.eles.push(h), p && (E.hasUnbundled = !0), g && (E.hasBezier = !0);
      }
    }
    for (var L = function() {
      var A = o[k], R = A.pairId, _ = A.edgeIsUnbundled, O = s(R, _), P = a.get(O), S;
      if (!P.hasUnbundled) {
        var M = P.eles[0].parallelEdges().filter(function(Q) {
          return Q.isBundledBezier();
        });
        Qk(P.eles), M.forEach(function(Q) {
          return P.eles.push(Q);
        }), P.eles.sort(function(Q, ce) {
          return Q.poolIndex() - ce.poolIndex();
        });
      }
      var N = P.eles[0], D = N.source(), I = N.target();
      if (D.poolIndex() > I.poolIndex()) {
        var B = D;
        D = I, I = B;
      }
      var z = P.srcPos = D.position(), F = P.tgtPos = I.position(), V = P.srcW = D.outerWidth(), H = P.srcH = D.outerHeight(), J = P.tgtW = I.outerWidth(), q = P.tgtH = I.outerHeight(), ae = P.srcShape = r.nodeShapes[e.getNodeShape(D)], re = P.tgtShape = r.nodeShapes[e.getNodeShape(I)], pe = P.srcCornerRadius = D.pstyle("corner-radius").value === "auto" ? "auto" : D.pstyle("corner-radius").pfValue, K = P.tgtCornerRadius = I.pstyle("corner-radius").value === "auto" ? "auto" : I.pstyle("corner-radius").pfValue, Z = P.tgtRs = I._private.rscratch, X = P.srcRs = D._private.rscratch;
      P.dirCounts = {
        north: 0,
        west: 0,
        south: 0,
        east: 0,
        northwest: 0,
        southwest: 0,
        northeast: 0,
        southeast: 0
      };
      for (var Y = 0; Y < P.eles.length; Y++) {
        var ee = P.eles[Y], j = ee[0]._private.rscratch, fe = ee.pstyle("curve-style").value, te = fe === "unbundled-bezier" || Il(fe, "segments") || Il(fe, "taxi"), Ae = !D.same(ee.source());
        if (!P.calculatedIntersection && D !== I && (P.hasBezier || P.hasUnbundled)) {
          P.calculatedIntersection = !0;
          var W = ae.intersectLine(z.x, z.y, V, H, F.x, F.y, 0, pe, X), De = P.srcIntn = W, ue = re.intersectLine(F.x, F.y, J, q, z.x, z.y, 0, K, Z), ze = P.tgtIntn = ue, Ge = P.intersectionPts = {
            x1: W[0],
            x2: ue[0],
            y1: W[1],
            y2: ue[1]
          }, Ve = P.posPts = {
            x1: z.x,
            x2: F.x,
            y1: z.y,
            y2: F.y
          }, ke = ue[1] - W[1], Oe = ue[0] - W[0], Se = Math.sqrt(Oe * Oe + ke * ke);
          mt(Se) && Se >= r3e || (Se = Math.sqrt(Math.max(Oe * Oe, Vp) + Math.max(ke * ke, Vp)));
          var _e = P.vector = {
            x: Oe,
            y: ke
          }, $e = P.vectorNorm = {
            x: _e.x / Se,
            y: _e.y / Se
          }, me = {
            x: -$e.y,
            y: $e.x
          };
          P.nodesOverlap = !mt(Se) || re.checkPoint(W[0], W[1], 0, J, q, F.x, F.y, K, Z) || ae.checkPoint(ue[0], ue[1], 0, V, H, z.x, z.y, pe, X), P.vectorNormInverse = me, S = {
            nodesOverlap: P.nodesOverlap,
            dirCounts: P.dirCounts,
            calculatedIntersection: !0,
            hasBezier: P.hasBezier,
            hasUnbundled: P.hasUnbundled,
            eles: P.eles,
            srcPos: F,
            srcRs: Z,
            tgtPos: z,
            tgtRs: X,
            srcW: J,
            srcH: q,
            tgtW: V,
            tgtH: H,
            srcIntn: ze,
            tgtIntn: De,
            srcShape: re,
            tgtShape: ae,
            posPts: {
              x1: Ve.x2,
              y1: Ve.y2,
              x2: Ve.x1,
              y2: Ve.y1
            },
            intersectionPts: {
              x1: Ge.x2,
              y1: Ge.y2,
              x2: Ge.x1,
              y2: Ge.y1
            },
            vector: {
              x: -_e.x,
              y: -_e.y
            },
            vectorNorm: {
              x: -$e.x,
              y: -$e.y
            },
            vectorNormInverse: {
              x: -me.x,
              y: -me.y
            }
          };
        }
        var Ne = Ae ? S : P;
        j.nodesOverlap = Ne.nodesOverlap, j.srcIntn = Ne.srcIntn, j.tgtIntn = Ne.tgtIntn, j.isRound = fe.startsWith("round"), i && (D.isParent() || D.isChild() || I.isParent() || I.isChild()) && (D.parents().anySame(I) || I.parents().anySame(D) || D.same(I) && D.isParent()) ? e.findCompoundLoopPoints(ee, Ne, Y, te) : D === I ? e.findLoopPoints(ee, Ne, Y, te) : fe.endsWith("segments") ? e.findSegmentsPoints(ee, Ne) : fe.endsWith("taxi") ? e.findTaxiPoints(ee, Ne) : fe === "straight" || !te && P.eles.length % 2 === 1 && Y === Math.floor(P.eles.length / 2) ? e.findStraightEdgePoints(ee) : e.findBezierPoints(ee, Ne, Y, te, Ae), e.findEndpoints(ee), e.tryToCorrectInvalidPoints(ee, Ne), e.checkForInvalidEdgeWarning(ee), e.storeAllpts(ee), e.storeEdgeProjections(ee), e.calculateArrowAngles(ee), e.recalculateEdgeLabelProjections(ee), e.calculateLabelAngles(ee);
      }
    }, k = 0; k < o.length; k++)
      L();
    this.findHaystackPoints(l);
  }
};
function _U(t) {
  var e = [];
  if (t != null) {
    for (var r = 0; r < t.length; r += 2) {
      var n = t[r], i = t[r + 1];
      e.push({
        x: n,
        y: i
      });
    }
    return e;
  }
}
Li.getSegmentPoints = function(t) {
  var e = t[0]._private.rscratch;
  this.recalculateRenderedStyle(t);
  var r = e.edgeType;
  if (r === "segments")
    return _U(e.segpts);
};
Li.getControlPoints = function(t) {
  var e = t[0]._private.rscratch;
  this.recalculateRenderedStyle(t);
  var r = e.edgeType;
  if (r === "bezier" || r === "multibezier" || r === "self" || r === "compound")
    return _U(e.ctrlpts);
};
Li.getEdgeMidpoint = function(t) {
  var e = t[0]._private.rscratch;
  return this.recalculateRenderedStyle(t), {
    x: e.midX,
    y: e.midY
  };
};
var Mg = {};
Mg.manualEndptToPx = function(t, e) {
  var r = this, n = t.position(), i = t.outerWidth(), a = t.outerHeight(), s = t._private.rscratch;
  if (e.value.length === 2) {
    var o = [e.pfValue[0], e.pfValue[1]];
    return e.units[0] === "%" && (o[0] = o[0] * i), e.units[1] === "%" && (o[1] = o[1] * a), o[0] += n.x, o[1] += n.y, o;
  } else {
    var l = e.pfValue[0];
    l = -Math.PI / 2 + l;
    var u = 2 * Math.max(i, a), h = [n.x + Math.cos(l) * u, n.y + Math.sin(l) * u];
    return r.nodeShapes[this.getNodeShape(t)].intersectLine(n.x, n.y, i, a, h[0], h[1], 0, t.pstyle("corner-radius").value === "auto" ? "auto" : t.pstyle("corner-radius").pfValue, s);
  }
};
Mg.findEndpoints = function(t) {
  var e, r, n, i, a = this, s, o = t.source()[0], l = t.target()[0], u = o.position(), h = l.position(), d = t.pstyle("target-arrow-shape").value, f = t.pstyle("source-arrow-shape").value, p = t.pstyle("target-distance-from-node").pfValue, g = t.pstyle("source-distance-from-node").pfValue, m = o._private.rscratch, v = l._private.rscratch, y = t.pstyle("curve-style").value, b = t._private.rscratch, w = b.edgeType, T = Il(y, "taxi"), E = w === "self" || w === "compound", L = w === "bezier" || w === "multibezier" || E, k = w !== "bezier", C = w === "straight" || w === "segments", A = w === "segments", R = L || k || C, _ = E || T, O = t.pstyle("source-endpoint"), P = _ ? "outside-to-node" : O.value, S = o.pstyle("corner-radius").value === "auto" ? "auto" : o.pstyle("corner-radius").pfValue, M = t.pstyle("target-endpoint"), N = _ ? "outside-to-node" : M.value, D = l.pstyle("corner-radius").value === "auto" ? "auto" : l.pstyle("corner-radius").pfValue;
  b.srcManEndpt = O, b.tgtManEndpt = M;
  var I, B, z, F, V = (e = (M == null || (r = M.pfValue) === null || r === void 0 ? void 0 : r.length) === 2 ? M.pfValue : null) !== null && e !== void 0 ? e : [0, 0], H = (n = (O == null || (i = O.pfValue) === null || i === void 0 ? void 0 : i.length) === 2 ? O.pfValue : null) !== null && n !== void 0 ? n : [0, 0];
  if (L) {
    var J = [b.ctrlpts[0], b.ctrlpts[1]], q = k ? [b.ctrlpts[b.ctrlpts.length - 2], b.ctrlpts[b.ctrlpts.length - 1]] : J;
    I = q, B = J;
  } else if (C) {
    var ae = A ? b.segpts.slice(0, 2) : [h.x + V[0], h.y + V[1]], re = A ? b.segpts.slice(b.segpts.length - 2) : [u.x + H[0], u.y + H[1]];
    I = re, B = ae;
  }
  if (N === "inside-to-node")
    s = [h.x, h.y];
  else if (M.units)
    s = this.manualEndptToPx(l, M);
  else if (N === "outside-to-line")
    s = b.tgtIntn;
  else if (N === "outside-to-node" || N === "outside-to-node-or-label" ? z = I : (N === "outside-to-line" || N === "outside-to-line-or-label") && (z = [u.x, u.y]), s = a.nodeShapes[this.getNodeShape(l)].intersectLine(h.x, h.y, l.outerWidth(), l.outerHeight(), z[0], z[1], 0, D, v), N === "outside-to-node-or-label" || N === "outside-to-line-or-label") {
    var pe = l._private.rscratch, K = pe.labelWidth, Z = pe.labelHeight, X = pe.labelX, Y = pe.labelY, ee = K / 2, j = Z / 2, fe = l.pstyle("text-valign").value;
    fe === "top" ? Y -= j : fe === "bottom" && (Y += j);
    var te = l.pstyle("text-halign").value;
    te === "left" ? X -= ee : te === "right" && (X += ee);
    var Ae = Bp(z[0], z[1], [X - ee, Y - j, X + ee, Y - j, X + ee, Y + j, X - ee, Y + j], h.x, h.y);
    if (Ae.length > 0) {
      var W = u, De = Wc(W, Gh(s)), ue = Wc(W, Gh(Ae)), ze = De;
      if (ue < De && (s = Ae, ze = ue), Ae.length > 2) {
        var Ge = Wc(W, {
          x: Ae[2],
          y: Ae[3]
        });
        Ge < ze && (s = [Ae[2], Ae[3]]);
      }
    }
  }
  var Ve = L1(s, I, a.arrowShapes[d].spacing(t) + p), ke = L1(s, I, a.arrowShapes[d].gap(t) + p);
  if (b.endX = ke[0], b.endY = ke[1], b.arrowEndX = Ve[0], b.arrowEndY = Ve[1], P === "inside-to-node")
    s = [u.x, u.y];
  else if (O.units)
    s = this.manualEndptToPx(o, O);
  else if (P === "outside-to-line")
    s = b.srcIntn;
  else if (P === "outside-to-node" || P === "outside-to-node-or-label" ? F = B : (P === "outside-to-line" || P === "outside-to-line-or-label") && (F = [h.x, h.y]), s = a.nodeShapes[this.getNodeShape(o)].intersectLine(u.x, u.y, o.outerWidth(), o.outerHeight(), F[0], F[1], 0, S, m), P === "outside-to-node-or-label" || P === "outside-to-line-or-label") {
    var Oe = o._private.rscratch, Se = Oe.labelWidth, _e = Oe.labelHeight, $e = Oe.labelX, me = Oe.labelY, Ne = Se / 2, Q = _e / 2, ce = o.pstyle("text-valign").value;
    ce === "top" ? me -= Q : ce === "bottom" && (me += Q);
    var $ = o.pstyle("text-halign").value;
    $ === "left" ? $e -= Ne : $ === "right" && ($e += Ne);
    var oe = Bp(F[0], F[1], [$e - Ne, me - Q, $e + Ne, me - Q, $e + Ne, me + Q, $e - Ne, me + Q], u.x, u.y);
    if (oe.length > 0) {
      var se = h, ge = Wc(se, Gh(s)), he = Wc(se, Gh(oe)), be = ge;
      if (he < ge && (s = [oe[0], oe[1]], be = he), oe.length > 2) {
        var Ce = Wc(se, {
          x: oe[2],
          y: oe[3]
        });
        Ce < be && (s = [oe[2], oe[3]]);
      }
    }
  }
  var Te = L1(s, B, a.arrowShapes[f].spacing(t) + g), Me = L1(s, B, a.arrowShapes[f].gap(t) + g);
  b.startX = Me[0], b.startY = Me[1], b.arrowStartX = Te[0], b.arrowStartY = Te[1], R && (!mt(b.startX) || !mt(b.startY) || !mt(b.endX) || !mt(b.endY) ? b.badLine = !0 : b.badLine = !1);
};
Mg.getSourceEndpoint = function(t) {
  var e = t[0]._private.rscratch;
  return this.recalculateRenderedStyle(t), e.edgeType === "haystack" ? {
    x: e.haystackPts[0],
    y: e.haystackPts[1]
  } : {
    x: e.arrowStartX,
    y: e.arrowStartY
  };
};
Mg.getTargetEndpoint = function(t) {
  var e = t[0]._private.rscratch;
  return this.recalculateRenderedStyle(t), e.edgeType === "haystack" ? {
    x: e.haystackPts[2],
    y: e.haystackPts[3]
  } : {
    x: e.arrowEndX,
    y: e.arrowEndY
  };
};
var pS = {};
function n3e(t, e, r) {
  for (var n = function(u, h, d, f) {
    return Yn(u, h, d, f);
  }, i = e._private, a = i.rstyle.bezierPts, s = 0; s < t.bezierProjPcts.length; s++) {
    var o = t.bezierProjPcts[s];
    a.push({
      x: n(r[0], r[2], r[4], o),
      y: n(r[1], r[3], r[5], o)
    });
  }
}
pS.storeEdgeProjections = function(t) {
  var e = t._private, r = e.rscratch, n = r.edgeType;
  if (e.rstyle.bezierPts = null, e.rstyle.linePts = null, e.rstyle.haystackPts = null, n === "multibezier" || n === "bezier" || n === "self" || n === "compound") {
    e.rstyle.bezierPts = [];
    for (var i = 0; i + 5 < r.allpts.length; i += 4)
      n3e(this, t, r.allpts.slice(i, i + 6));
  } else if (n === "segments")
    for (var a = e.rstyle.linePts = [], i = 0; i + 1 < r.allpts.length; i += 2)
      a.push({
        x: r.allpts[i],
        y: r.allpts[i + 1]
      });
  else if (n === "haystack") {
    var s = r.haystackPts;
    e.rstyle.haystackPts = [{
      x: s[0],
      y: s[1]
    }, {
      x: s[2],
      y: s[3]
    }];
  }
  e.rstyle.arrowWidth = this.getArrowWidth(t.pstyle("width").pfValue, t.pstyle("arrow-scale").value) * this.arrowShapeWidth;
};
pS.recalculateEdgeProjections = function(t) {
  this.findEdgeControlPoints(t);
};
var go = {};
go.recalculateNodeLabelProjection = function(t) {
  var e = t.pstyle("label").strValue;
  if (!Zl(e)) {
    var r, n, i = t._private, a = t.width(), s = t.height(), o = t.padding(), l = t.position(), u = t.pstyle("text-halign").strValue, h = t.pstyle("text-valign").strValue, d = i.rscratch, f = i.rstyle;
    switch (u) {
      case "left":
        r = l.x - a / 2 - o;
        break;
      case "right":
        r = l.x + a / 2 + o;
        break;
      default:
        r = l.x;
    }
    switch (h) {
      case "top":
        n = l.y - s / 2 - o;
        break;
      case "bottom":
        n = l.y + s / 2 + o;
        break;
      default:
        n = l.y;
    }
    d.labelX = r, d.labelY = n, f.labelX = r, f.labelY = n, this.calculateLabelAngles(t), this.applyLabelDimensions(t);
  }
};
var LU = function(e, r) {
  var n = Math.atan(r / e);
  return e === 0 && n < 0 && (n = n * -1), n;
}, RU = function(e, r) {
  var n = r.x - e.x, i = r.y - e.y;
  return LU(n, i);
}, i3e = function(e, r, n, i) {
  var a = Pp(0, i - 1e-3, 1), s = Pp(0, i + 1e-3, 1), o = td(e, r, n, a), l = td(e, r, n, s);
  return RU(o, l);
};
go.recalculateEdgeLabelProjections = function(t) {
  var e, r = t._private, n = r.rscratch, i = this, a = {
    mid: t.pstyle("label").strValue,
    source: t.pstyle("source-label").strValue,
    target: t.pstyle("target-label").strValue
  };
  if (a.mid || a.source || a.target) {
    e = {
      x: n.midX,
      y: n.midY
    };
    var s = function(d, f, p) {
      Do(r.rscratch, d, f, p), Do(r.rstyle, d, f, p);
    };
    s("labelX", null, e.x), s("labelY", null, e.y);
    var o = LU(n.midDispX, n.midDispY);
    s("labelAutoAngle", null, o);
    var l = function() {
      if (l.cache)
        return l.cache;
      for (var d = [], f = 0; f + 5 < n.allpts.length; f += 4) {
        var p = {
          x: n.allpts[f],
          y: n.allpts[f + 1]
        }, g = {
          x: n.allpts[f + 2],
          y: n.allpts[f + 3]
        }, m = {
          x: n.allpts[f + 4],
          y: n.allpts[f + 5]
        };
        d.push({
          p0: p,
          p1: g,
          p2: m,
          startDist: 0,
          length: 0,
          segments: []
        });
      }
      var v = r.rstyle.bezierPts, y = i.bezierProjPcts.length;
      function b(k, C, A, R, _) {
        var O = Au(C, A), P = k.segments[k.segments.length - 1], S = {
          p0: C,
          p1: A,
          t0: R,
          t1: _,
          startDist: P ? P.startDist + P.length : 0,
          length: O
        };
        k.segments.push(S), k.length += O;
      }
      for (var w = 0; w < d.length; w++) {
        var T = d[w], E = d[w - 1];
        E && (T.startDist = E.startDist + E.length), b(T, T.p0, v[w * y], 0, i.bezierProjPcts[0]);
        for (var L = 0; L < y - 1; L++)
          b(T, v[w * y + L], v[w * y + L + 1], i.bezierProjPcts[L], i.bezierProjPcts[L + 1]);
        b(T, v[w * y + y - 1], T.p2, i.bezierProjPcts[y - 1], 1);
      }
      return l.cache = d;
    }, u = function(d) {
      var f, p = d === "source";
      if (a[d]) {
        var g = t.pstyle(d + "-text-offset").pfValue;
        switch (n.edgeType) {
          case "self":
          case "compound":
          case "bezier":
          case "multibezier": {
            for (var m = l(), v, y = 0, b = 0, w = 0; w < m.length; w++) {
              for (var T = m[p ? w : m.length - 1 - w], E = 0; E < T.segments.length; E++) {
                var L = T.segments[p ? E : T.segments.length - 1 - E], k = w === m.length - 1 && E === T.segments.length - 1;
                if (y = b, b += L.length, b >= g || k) {
                  v = {
                    cp: T,
                    segment: L
                  };
                  break;
                }
              }
              if (v)
                break;
            }
            var C = v.cp, A = v.segment, R = (g - y) / A.length, _ = A.t1 - A.t0, O = p ? A.t0 + _ * R : A.t1 - _ * R;
            O = Pp(0, O, 1), e = td(C.p0, C.p1, C.p2, O), f = i3e(C.p0, C.p1, C.p2, O);
            break;
          }
          case "straight":
          case "segments":
          case "haystack": {
            for (var P = 0, S, M, N, D, I = n.allpts.length, B = 0; B + 3 < I && (p ? (N = {
              x: n.allpts[B],
              y: n.allpts[B + 1]
            }, D = {
              x: n.allpts[B + 2],
              y: n.allpts[B + 3]
            }) : (N = {
              x: n.allpts[I - 2 - B],
              y: n.allpts[I - 1 - B]
            }, D = {
              x: n.allpts[I - 4 - B],
              y: n.allpts[I - 3 - B]
            }), S = Au(N, D), M = P, P += S, !(P >= g)); B += 2)
              ;
            var z = g - M, F = z / S;
            F = Pp(0, F, 1), e = C2e(N, D, F), f = RU(N, D);
            break;
          }
        }
        s("labelX", d, e.x), s("labelY", d, e.y), s("labelAutoAngle", d, f);
      }
    };
    u("source"), u("target"), this.applyLabelDimensions(t);
  }
};
go.applyLabelDimensions = function(t) {
  this.applyPrefixedLabelDimensions(t), t.isEdge() && (this.applyPrefixedLabelDimensions(t, "source"), this.applyPrefixedLabelDimensions(t, "target"));
};
go.applyPrefixedLabelDimensions = function(t, e) {
  var r = t._private, n = this.getLabelText(t, e), i = Cu(n, t._private.labelDimsKey);
  if (na(r.rscratch, "prefixedLabelDimsKey", e) !== i) {
    Do(r.rscratch, "prefixedLabelDimsKey", e, i);
    var a = this.calculateLabelDimensions(t, n), s = t.pstyle("line-height").pfValue, o = t.pstyle("text-wrap").strValue, l = na(r.rscratch, "labelWrapCachedLines", e) || [], u = o !== "wrap" ? 1 : Math.max(l.length, 1), h = a.height / u, d = h * s, f = a.width, p = a.height + (u - 1) * (s - 1) * h;
    Do(r.rstyle, "labelWidth", e, f), Do(r.rscratch, "labelWidth", e, f), Do(r.rstyle, "labelHeight", e, p), Do(r.rscratch, "labelHeight", e, p), Do(r.rscratch, "labelLineHeight", e, d);
  }
};
go.getLabelText = function(t, e) {
  var r = t._private, n = e ? e + "-" : "", i = t.pstyle(n + "label").strValue, a = t.pstyle("text-transform").value, s = function(H, J) {
    return J ? (Do(r.rscratch, H, e, J), J) : na(r.rscratch, H, e);
  };
  if (!i)
    return "";
  a == "none" || (a == "uppercase" ? i = i.toUpperCase() : a == "lowercase" && (i = i.toLowerCase()));
  var o = t.pstyle("text-wrap").value;
  if (o === "wrap") {
    var l = s("labelKey");
    if (l != null && s("labelWrapKey") === l)
      return s("labelWrapCachedText");
    for (var u = "", h = i.split(`
`), d = t.pstyle("text-max-width").pfValue, f = t.pstyle("text-overflow-wrap").value, p = f === "anywhere", g = [], m = /[\s\u200b]+|$/g, v = 0; v < h.length; v++) {
      var y = h[v], b = this.calculateLabelDimensions(t, y), w = b.width;
      if (p) {
        var T = y.split("").join(u);
        y = T;
      }
      if (w > d) {
        var E = y.matchAll(m), L = "", k = 0, C = oa(E), A;
        try {
          for (C.s(); !(A = C.n()).done; ) {
            var R = A.value, _ = R[0], O = y.substring(k, R.index);
            k = R.index + _.length;
            var P = L.length === 0 ? O : L + O + _, S = this.calculateLabelDimensions(t, P), M = S.width;
            M <= d ? L += O + _ : (L && g.push(L), L = O + _);
          }
        } catch (V) {
          C.e(V);
        } finally {
          C.f();
        }
        L.match(/^[\s\u200b]+$/) || g.push(L);
      } else
        g.push(y);
    }
    s("labelWrapCachedLines", g), i = s("labelWrapCachedText", g.join(`
`)), s("labelWrapKey", l);
  } else if (o === "ellipsis") {
    var N = t.pstyle("text-max-width").pfValue, D = "", I = "", B = !1;
    if (this.calculateLabelDimensions(t, i).width < N)
      return i;
    for (var z = 0; z < i.length; z++) {
      var F = this.calculateLabelDimensions(t, D + i[z] + I).width;
      if (F > N)
        break;
      D += i[z], z === i.length - 1 && (B = !0);
    }
    return B || (D += I), D;
  }
  return i;
};
go.getLabelJustification = function(t) {
  var e = t.pstyle("text-justification").strValue, r = t.pstyle("text-halign").strValue;
  if (e === "auto")
    if (t.isNode())
      switch (r) {
        case "left":
          return "right";
        case "right":
          return "left";
        default:
          return "center";
      }
    else
      return "center";
  else
    return e;
};
go.calculateLabelDimensions = function(t, e) {
  var r = this, n = r.cy.window(), i = n.document, a = 0, s = t.pstyle("font-style").strValue, o = t.pstyle("font-size").pfValue, l = t.pstyle("font-family").strValue, u = t.pstyle("font-weight").strValue, h = this.labelCalcCanvas, d = this.labelCalcCanvasContext;
  if (!h) {
    h = this.labelCalcCanvas = i.createElement("canvas"), d = this.labelCalcCanvasContext = h.getContext("2d");
    var f = h.style;
    f.position = "absolute", f.left = "-9999px", f.top = "-9999px", f.zIndex = "-1", f.visibility = "hidden", f.pointerEvents = "none";
  }
  d.font = "".concat(s, " ").concat(u, " ").concat(o, "px ").concat(l);
  for (var p = 0, g = 0, m = e.split(`
`), v = 0; v < m.length; v++) {
    var y = m[v], b = d.measureText(y), w = Math.ceil(b.width), T = o;
    p = Math.max(w, p), g += T;
  }
  return p += a, g += a, {
    width: p,
    height: g
  };
};
go.calculateLabelAngle = function(t, e) {
  var r = t._private, n = r.rscratch, i = t.isEdge(), a = e ? e + "-" : "", s = t.pstyle(a + "text-rotation"), o = s.strValue;
  return o === "none" ? 0 : i && o === "autorotate" ? n.labelAutoAngle : o === "autorotate" ? 0 : s.pfValue;
};
go.calculateLabelAngles = function(t) {
  var e = this, r = t.isEdge(), n = t._private, i = n.rscratch;
  i.labelAngle = e.calculateLabelAngle(t), r && (i.sourceLabelAngle = e.calculateLabelAngle(t, "source"), i.targetLabelAngle = e.calculateLabelAngle(t, "target"));
};
var MU = {}, dL = 28, fL = !1;
MU.getNodeShape = function(t) {
  var e = this, r = t.pstyle("shape").value;
  if (r === "cutrectangle" && (t.width() < dL || t.height() < dL))
    return fL || (Lr("The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead"), fL = !0), "rectangle";
  if (t.isParent())
    return r === "rectangle" || r === "roundrectangle" || r === "round-rectangle" || r === "cutrectangle" || r === "cut-rectangle" || r === "barrel" ? r : "rectangle";
  if (r === "polygon") {
    var n = t.pstyle("shape-polygon-points").value;
    return e.nodeShapes.makePolygon(n).name;
  }
  return r;
};
var Gx = {};
Gx.registerCalculationListeners = function() {
  var t = this.cy, e = t.collection(), r = this, n = function(s) {
    var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    if (e.merge(s), o)
      for (var l = 0; l < s.length; l++) {
        var u = s[l], h = u._private, d = h.rstyle;
        d.clean = !1, d.cleanConnected = !1;
      }
  };
  r.binder(t).on("bounds.* dirty.*", function(s) {
    var o = s.target;
    n(o);
  }).on("style.* background.*", function(s) {
    var o = s.target;
    n(o, !1);
  });
  var i = function(s) {
    if (s) {
      var o = r.onUpdateEleCalcsFns;
      e.cleanStyle();
      for (var l = 0; l < e.length; l++) {
        var u = e[l], h = u._private.rstyle;
        u.isNode() && !h.cleanConnected && (n(u.connectedEdges()), h.cleanConnected = !0);
      }
      if (o)
        for (var d = 0; d < o.length; d++) {
          var f = o[d];
          f(s, e);
        }
      r.recalculateRenderedStyle(e), e = t.collection();
    }
  };
  r.flushRenderedStyleQueue = function() {
    i(!0);
  }, r.beforeRender(i, r.beforeRenderPriorities.eleCalcs);
};
Gx.onUpdateEleCalcs = function(t) {
  var e = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];
  e.push(t);
};
Gx.recalculateRenderedStyle = function(t, e) {
  var r = function(T) {
    return T._private.rstyle.cleanConnected;
  };
  if (t.length !== 0) {
    var n = [], i = [];
    if (!this.destroyed) {
      e === void 0 && (e = !0);
      for (var a = 0; a < t.length; a++) {
        var s = t[a], o = s._private, l = o.rstyle;
        s.isEdge() && (!r(s.source()) || !r(s.target())) && (l.clean = !1), s.isEdge() && s.isBundledBezier() && s.parallelEdges().some(function(w) {
          return !w._private.rstyle.clean && w.isBundledBezier();
        }) && (l.clean = !1), !(e && l.clean || s.removed()) && s.pstyle("display").value !== "none" && (o.group === "nodes" ? i.push(s) : n.push(s), l.clean = !0);
      }
      for (var u = 0; u < i.length; u++) {
        var h = i[u], d = h._private, f = d.rstyle, p = h.position();
        this.recalculateNodeLabelProjection(h), f.nodeX = p.x, f.nodeY = p.y, f.nodeW = h.pstyle("width").pfValue, f.nodeH = h.pstyle("height").pfValue;
      }
      this.recalculateEdgeProjections(n);
      for (var g = 0; g < n.length; g++) {
        var m = n[g], v = m._private, y = v.rstyle, b = v.rscratch;
        y.srcX = b.arrowStartX, y.srcY = b.arrowStartY, y.tgtX = b.arrowEndX, y.tgtY = b.arrowEndY, y.midX = b.midX, y.midY = b.midY, y.labelAngle = b.labelAngle, y.sourceLabelAngle = b.sourceLabelAngle, y.targetLabelAngle = b.targetLabelAngle;
      }
    }
  }
};
var Vx = {};
Vx.updateCachedGrabbedEles = function() {
  var t = this.cachedZSortedEles;
  if (t) {
    t.drag = [], t.nondrag = [];
    for (var e = [], r = 0; r < t.length; r++) {
      var n = t[r], i = n._private.rscratch;
      n.grabbed() && !n.isParent() ? e.push(n) : i.inDragLayer ? t.drag.push(n) : t.nondrag.push(n);
    }
    for (var r = 0; r < e.length; r++) {
      var n = e[r];
      t.drag.push(n);
    }
  }
};
Vx.invalidateCachedZSortedEles = function() {
  this.cachedZSortedEles = null;
};
Vx.getCachedZSortedEles = function(t) {
  if (t || !this.cachedZSortedEles) {
    var e = this.cy.mutableElements().toArray();
    e.sort(dU), e.interactive = e.filter(function(r) {
      return r.interactive();
    }), this.cachedZSortedEles = e, this.updateCachedGrabbedEles();
  } else
    e = this.cachedZSortedEles;
  return e;
};
var NU = {};
[eh, Iy, Li, Mg, pS, go, MU, Gx, Vx].forEach(function(t) {
  Gt(NU, t);
});
var IU = {};
IU.getCachedImage = function(t, e, r) {
  var n = this, i = n.imageCache = n.imageCache || {}, a = i[t];
  if (a)
    return a.image.complete || a.image.addEventListener("load", r), a.image;
  a = i[t] = i[t] || {};
  var s = a.image = new Image();
  s.addEventListener("load", r), s.addEventListener("error", function() {
    s.error = !0;
  });
  var o = "data:", l = t.substring(0, o.length).toLowerCase() === o;
  return l || (e = e === "null" ? null : e, s.crossOrigin = e), s.src = t, s;
};
var sf = {};
sf.registerBinding = function(t, e, r, n) {
  var i = Array.prototype.slice.apply(arguments, [1]);
  if (Array.isArray(t)) {
    for (var a = [], s = 0; s < t.length; s++) {
      var o = t[s];
      if (o !== void 0) {
        var l = this.binder(o);
        a.push(l.on.apply(l, i));
      }
    }
    return a;
  }
  var l = this.binder(t);
  return l.on.apply(l, i);
};
sf.binder = function(t) {
  var e = this, r = e.cy.window(), n = t === r || t === r.document || t === r.document.body || mye(t);
  if (e.supportsPassiveEvents == null) {
    var i = !1;
    try {
      var a = Object.defineProperty({}, "passive", {
        get: function() {
          return i = !0, !0;
        }
      });
      r.addEventListener("test", null, a);
    } catch {
    }
    e.supportsPassiveEvents = i;
  }
  var s = function(l, u, h) {
    var d = Array.prototype.slice.call(arguments);
    return n && e.supportsPassiveEvents && (d[2] = {
      capture: h ?? !1,
      passive: !1,
      once: !1
    }), e.bindings.push({
      target: t,
      args: d
    }), (t.addEventListener || t.on).apply(t, d), this;
  };
  return {
    on: s,
    addEventListener: s,
    addListener: s,
    bind: s
  };
};
sf.nodeIsDraggable = function(t) {
  return t && t.isNode() && !t.locked() && t.grabbable();
};
sf.nodeIsGrabbable = function(t) {
  return this.nodeIsDraggable(t) && t.interactive();
};
sf.load = function() {
  var t = this, e = t.cy.window(), r = function($) {
    return $.selected();
  }, n = function($) {
    var oe = $.getRootNode();
    if (oe && oe.nodeType === 11 && oe.host !== void 0)
      return oe;
  }, i = function($, oe, se, ge) {
    $ == null && ($ = t.cy);
    for (var he = 0; he < oe.length; he++) {
      var be = oe[he];
      $.emit({
        originalEvent: se,
        type: be,
        position: ge
      });
    }
  }, a = function($) {
    return $.shiftKey || $.metaKey || $.ctrlKey;
  }, s = function($, oe) {
    var se = !0;
    if (t.cy.hasCompoundNodes() && $ && $.pannable())
      for (var ge = 0; oe && ge < oe.length; ge++) {
        var $ = oe[ge];
        if ($.isNode() && $.isParent() && !$.pannable()) {
          se = !1;
          break;
        }
      }
    else
      se = !0;
    return se;
  }, o = function($) {
    $[0]._private.grabbed = !0;
  }, l = function($) {
    $[0]._private.grabbed = !1;
  }, u = function($) {
    $[0]._private.rscratch.inDragLayer = !0;
  }, h = function($) {
    $[0]._private.rscratch.inDragLayer = !1;
  }, d = function($) {
    $[0]._private.rscratch.isGrabTarget = !0;
  }, f = function($) {
    $[0]._private.rscratch.isGrabTarget = !1;
  }, p = function($, oe) {
    var se = oe.addToList, ge = se.has($);
    !ge && $.grabbable() && !$.locked() && (se.merge($), o($));
  }, g = function($, oe) {
    if ($.cy().hasCompoundNodes() && !(oe.inDragLayer == null && oe.addToList == null)) {
      var se = $.descendants();
      oe.inDragLayer && (se.forEach(u), se.connectedEdges().forEach(u)), oe.addToList && p(se, oe);
    }
  }, m = function($, oe) {
    oe = oe || {};
    var se = $.cy().hasCompoundNodes();
    oe.inDragLayer && ($.forEach(u), $.neighborhood().stdFilter(function(ge) {
      return !se || ge.isEdge();
    }).forEach(u)), oe.addToList && $.forEach(function(ge) {
      p(ge, oe);
    }), g($, oe), b($, {
      inDragLayer: oe.inDragLayer
    }), t.updateCachedGrabbedEles();
  }, v = m, y = function($) {
    $ && (t.getCachedZSortedEles().forEach(function(oe) {
      l(oe), h(oe), f(oe);
    }), t.updateCachedGrabbedEles());
  }, b = function($, oe) {
    if (!(oe.inDragLayer == null && oe.addToList == null) && $.cy().hasCompoundNodes()) {
      var se = $.ancestors().orphans();
      if (!se.same($)) {
        var ge = se.descendants().spawnSelf().merge(se).unmerge($).unmerge($.descendants()), he = ge.connectedEdges();
        oe.inDragLayer && (he.forEach(u), ge.forEach(u)), oe.addToList && ge.forEach(function(be) {
          p(be, oe);
        });
      }
    }
  }, w = function() {
    document.activeElement != null && document.activeElement.blur != null && document.activeElement.blur();
  }, T = typeof MutationObserver < "u", E = typeof ResizeObserver < "u";
  T ? (t.removeObserver = new MutationObserver(function(ce) {
    for (var $ = 0; $ < ce.length; $++) {
      var oe = ce[$], se = oe.removedNodes;
      if (se)
        for (var ge = 0; ge < se.length; ge++) {
          var he = se[ge];
          if (he === t.container) {
            t.destroy();
            break;
          }
        }
    }
  }), t.container.parentNode && t.removeObserver.observe(t.container.parentNode, {
    childList: !0
  })) : t.registerBinding(t.container, "DOMNodeRemoved", function(ce) {
    t.destroy();
  });
  var L = Ag(function() {
    t.cy.resize();
  }, 100);
  T && (t.styleObserver = new MutationObserver(L), t.styleObserver.observe(t.container, {
    attributes: !0
  })), t.registerBinding(e, "resize", L), E && (t.resizeObserver = new ResizeObserver(L), t.resizeObserver.observe(t.container));
  var k = function($, oe) {
    for (; $ != null; )
      oe($), $ = $.parentNode;
  }, C = function() {
    t.invalidateContainerClientCoordsCache();
  };
  k(t.container, function(ce) {
    t.registerBinding(ce, "transitionend", C), t.registerBinding(ce, "animationend", C), t.registerBinding(ce, "scroll", C);
  }), t.registerBinding(t.container, "contextmenu", function(ce) {
    ce.preventDefault();
  });
  var A = function() {
    return t.selection[4] !== 0;
  }, R = function($) {
    for (var oe = t.findContainerClientCoords(), se = oe[0], ge = oe[1], he = oe[2], be = oe[3], Ce = $.touches ? $.touches : [$], Te = !1, Me = 0; Me < Ce.length; Me++) {
      var Xe = Ce[Me];
      if (se <= Xe.clientX && Xe.clientX <= se + he && ge <= Xe.clientY && Xe.clientY <= ge + be) {
        Te = !0;
        break;
      }
    }
    if (!Te)
      return !1;
    for (var We = t.container, Ke = $.target, Ze = Ke.parentNode, Pe = !1; Ze; ) {
      if (Ze === We) {
        Pe = !0;
        break;
      }
      Ze = Ze.parentNode;
    }
    return !!Pe;
  };
  t.registerBinding(t.container, "mousedown", function($) {
    if (R($) && !(t.hoverData.which === 1 && $.which !== 1)) {
      $.preventDefault(), w(), t.hoverData.capture = !0, t.hoverData.which = $.which;
      var oe = t.cy, se = [$.clientX, $.clientY], ge = t.projectIntoViewport(se[0], se[1]), he = t.selection, be = t.findNearestElements(ge[0], ge[1], !0, !1), Ce = be[0], Te = t.dragData.possibleDragElements;
      t.hoverData.mdownPos = ge, t.hoverData.mdownGPos = se;
      var Me = function(He) {
        return {
          originalEvent: $,
          type: He,
          position: {
            x: ge[0],
            y: ge[1]
          }
        };
      }, Xe = function() {
        t.hoverData.tapholdCancelled = !1, clearTimeout(t.hoverData.tapholdTimeout), t.hoverData.tapholdTimeout = setTimeout(function() {
          if (!t.hoverData.tapholdCancelled) {
            var He = t.hoverData.down;
            He ? He.emit(Me("taphold")) : oe.emit(Me("taphold"));
          }
        }, t.tapholdDuration);
      };
      if ($.which == 3) {
        t.hoverData.cxtStarted = !0;
        var We = {
          originalEvent: $,
          type: "cxttapstart",
          position: {
            x: ge[0],
            y: ge[1]
          }
        };
        Ce ? (Ce.activate(), Ce.emit(We), t.hoverData.down = Ce) : oe.emit(We), t.hoverData.downTime = (/* @__PURE__ */ new Date()).getTime(), t.hoverData.cxtDragged = !1;
      } else if ($.which == 1) {
        Ce && Ce.activate();
        {
          if (Ce != null && t.nodeIsGrabbable(Ce)) {
            var Ke = function(He) {
              He.emit(Me("grab"));
            };
            if (d(Ce), !Ce.selected())
              Te = t.dragData.possibleDragElements = oe.collection(), v(Ce, {
                addToList: Te
              }), Ce.emit(Me("grabon")).emit(Me("grab"));
            else {
              Te = t.dragData.possibleDragElements = oe.collection();
              var Ze = oe.$(function(Pe) {
                return Pe.isNode() && Pe.selected() && t.nodeIsGrabbable(Pe);
              });
              m(Ze, {
                addToList: Te
              }), Ce.emit(Me("grabon")), Ze.forEach(Ke);
            }
            t.redrawHint("eles", !0), t.redrawHint("drag", !0);
          }
          t.hoverData.down = Ce, t.hoverData.downs = be, t.hoverData.downTime = (/* @__PURE__ */ new Date()).getTime();
        }
        i(Ce, ["mousedown", "tapstart", "vmousedown"], $, {
          x: ge[0],
          y: ge[1]
        }), Ce == null ? (he[4] = 1, t.data.bgActivePosistion = {
          x: ge[0],
          y: ge[1]
        }, t.redrawHint("select", !0), t.redraw()) : Ce.pannable() && (he[4] = 1), Xe();
      }
      he[0] = he[2] = ge[0], he[1] = he[3] = ge[1];
    }
  }, !1);
  var _ = n(t.container);
  t.registerBinding([e, _], "mousemove", function($) {
    var oe = t.hoverData.capture;
    if (!(!oe && !R($))) {
      var se = !1, ge = t.cy, he = ge.zoom(), be = [$.clientX, $.clientY], Ce = t.projectIntoViewport(be[0], be[1]), Te = t.hoverData.mdownPos, Me = t.hoverData.mdownGPos, Xe = t.selection, We = null;
      !t.hoverData.draggingEles && !t.hoverData.dragging && !t.hoverData.selecting && (We = t.findNearestElement(Ce[0], Ce[1], !0, !1));
      var Ke = t.hoverData.last, Ze = t.hoverData.down, Pe = [Ce[0] - Xe[2], Ce[1] - Xe[3]], He = t.dragData.possibleDragElements, ht;
      if (Me) {
        var st = be[0] - Me[0], Ue = st * st, Et = be[1] - Me[1], qe = Et * Et, rt = Ue + qe;
        t.hoverData.isOverThresholdDrag = ht = rt >= t.desktopTapThreshold2;
      }
      var ct = a($);
      ht && (t.hoverData.tapholdCancelled = !0);
      var ut = function() {
        var dt = t.hoverData.dragDelta = t.hoverData.dragDelta || [];
        dt.length === 0 ? (dt.push(Pe[0]), dt.push(Pe[1])) : (dt[0] += Pe[0], dt[1] += Pe[1]);
      };
      se = !0, i(We, ["mousemove", "vmousemove", "tapdrag"], $, {
        x: Ce[0],
        y: Ce[1]
      });
      var nt = function(dt) {
        return {
          originalEvent: $,
          type: dt,
          position: {
            x: Ce[0],
            y: Ce[1]
          }
        };
      }, xt = function() {
        t.data.bgActivePosistion = void 0, t.hoverData.selecting || ge.emit(nt("boxstart")), Xe[4] = 1, t.hoverData.selecting = !0, t.redrawHint("select", !0), t.redraw();
      };
      if (t.hoverData.which === 3) {
        if (ht) {
          var Qt = nt("cxtdrag");
          Ze ? Ze.emit(Qt) : ge.emit(Qt), t.hoverData.cxtDragged = !0, (!t.hoverData.cxtOver || We !== t.hoverData.cxtOver) && (t.hoverData.cxtOver && t.hoverData.cxtOver.emit(nt("cxtdragout")), t.hoverData.cxtOver = We, We && We.emit(nt("cxtdragover")));
        }
      } else if (t.hoverData.dragging) {
        if (se = !0, ge.panningEnabled() && ge.userPanningEnabled()) {
          var Dt;
          if (t.hoverData.justStartedPan) {
            var rr = t.hoverData.mdownPos;
            Dt = {
              x: (Ce[0] - rr[0]) * he,
              y: (Ce[1] - rr[1]) * he
            }, t.hoverData.justStartedPan = !1;
          } else
            Dt = {
              x: Pe[0] * he,
              y: Pe[1] * he
            };
          ge.panBy(Dt), ge.emit(nt("dragpan")), t.hoverData.dragged = !0;
        }
        Ce = t.projectIntoViewport($.clientX, $.clientY);
      } else if (Xe[4] == 1 && (Ze == null || Ze.pannable())) {
        if (ht) {
          if (!t.hoverData.dragging && ge.boxSelectionEnabled() && (ct || !ge.panningEnabled() || !ge.userPanningEnabled()))
            xt();
          else if (!t.hoverData.selecting && ge.panningEnabled() && ge.userPanningEnabled()) {
            var xr = s(Ze, t.hoverData.downs);
            xr && (t.hoverData.dragging = !0, t.hoverData.justStartedPan = !0, Xe[4] = 0, t.data.bgActivePosistion = Gh(Te), t.redrawHint("select", !0), t.redraw());
          }
          Ze && Ze.pannable() && Ze.active() && Ze.unactivate();
        }
      } else {
        if (Ze && Ze.pannable() && Ze.active() && Ze.unactivate(), (!Ze || !Ze.grabbed()) && We != Ke && (Ke && i(Ke, ["mouseout", "tapdragout"], $, {
          x: Ce[0],
          y: Ce[1]
        }), We && i(We, ["mouseover", "tapdragover"], $, {
          x: Ce[0],
          y: Ce[1]
        }), t.hoverData.last = We), Ze)
          if (ht) {
            if (ge.boxSelectionEnabled() && ct)
              Ze && Ze.grabbed() && (y(He), Ze.emit(nt("freeon")), He.emit(nt("free")), t.dragData.didDrag && (Ze.emit(nt("dragfreeon")), He.emit(nt("dragfree")))), xt();
            else if (Ze && Ze.grabbed() && t.nodeIsDraggable(Ze)) {
              var nr = !t.dragData.didDrag;
              nr && t.redrawHint("eles", !0), t.dragData.didDrag = !0, t.hoverData.draggingEles || m(He, {
                inDragLayer: !0
              });
              var Ht = {
                x: 0,
                y: 0
              };
              if (mt(Pe[0]) && mt(Pe[1]) && (Ht.x += Pe[0], Ht.y += Pe[1], nr)) {
                var lr = t.hoverData.dragDelta;
                lr && mt(lr[0]) && mt(lr[1]) && (Ht.x += lr[0], Ht.y += lr[1]);
              }
              t.hoverData.draggingEles = !0, He.silentShift(Ht).emit(nt("position")).emit(nt("drag")), t.redrawHint("drag", !0), t.redraw();
            }
          } else
            ut();
        se = !0;
      }
      if (Xe[2] = Ce[0], Xe[3] = Ce[1], se)
        return $.stopPropagation && $.stopPropagation(), $.preventDefault && $.preventDefault(), !1;
    }
  }, !1);
  var O, P, S;
  t.registerBinding(e, "mouseup", function($) {
    if (!(t.hoverData.which === 1 && $.which !== 1 && t.hoverData.capture)) {
      var oe = t.hoverData.capture;
      if (oe) {
        t.hoverData.capture = !1;
        var se = t.cy, ge = t.projectIntoViewport($.clientX, $.clientY), he = t.selection, be = t.findNearestElement(ge[0], ge[1], !0, !1), Ce = t.dragData.possibleDragElements, Te = t.hoverData.down, Me = a($);
        t.data.bgActivePosistion && (t.redrawHint("select", !0), t.redraw()), t.hoverData.tapholdCancelled = !0, t.data.bgActivePosistion = void 0, Te && Te.unactivate();
        var Xe = function(st) {
          return {
            originalEvent: $,
            type: st,
            position: {
              x: ge[0],
              y: ge[1]
            }
          };
        };
        if (t.hoverData.which === 3) {
          var We = Xe("cxttapend");
          if (Te ? Te.emit(We) : se.emit(We), !t.hoverData.cxtDragged) {
            var Ke = Xe("cxttap");
            Te ? Te.emit(Ke) : se.emit(Ke);
          }
          t.hoverData.cxtDragged = !1, t.hoverData.which = null;
        } else if (t.hoverData.which === 1) {
          if (i(be, ["mouseup", "tapend", "vmouseup"], $, {
            x: ge[0],
            y: ge[1]
          }), !t.dragData.didDrag && // didn't move a node around
          !t.hoverData.dragged && // didn't pan
          !t.hoverData.selecting && // not box selection
          !t.hoverData.isOverThresholdDrag && (i(Te, ["click", "tap", "vclick"], $, {
            x: ge[0],
            y: ge[1]
          }), P = !1, $.timeStamp - S <= se.multiClickDebounceTime() ? (O && clearTimeout(O), P = !0, S = null, i(Te, ["dblclick", "dbltap", "vdblclick"], $, {
            x: ge[0],
            y: ge[1]
          })) : (O = setTimeout(function() {
            P || i(Te, ["oneclick", "onetap", "voneclick"], $, {
              x: ge[0],
              y: ge[1]
            });
          }, se.multiClickDebounceTime()), S = $.timeStamp)), Te == null && !t.dragData.didDrag && !t.hoverData.selecting && !t.hoverData.dragged && !a($) && (se.$(r).unselect(["tapunselect"]), Ce.length > 0 && t.redrawHint("eles", !0), t.dragData.possibleDragElements = Ce = se.collection()), be == Te && !t.dragData.didDrag && !t.hoverData.selecting && be != null && be._private.selectable && (t.hoverData.dragging || (se.selectionType() === "additive" || Me ? be.selected() ? be.unselect(["tapunselect"]) : be.select(["tapselect"]) : Me || (se.$(r).unmerge(be).unselect(["tapunselect"]), be.select(["tapselect"]))), t.redrawHint("eles", !0)), t.hoverData.selecting) {
            var Ze = se.collection(t.getAllInBox(he[0], he[1], he[2], he[3]));
            t.redrawHint("select", !0), Ze.length > 0 && t.redrawHint("eles", !0), se.emit(Xe("boxend"));
            var Pe = function(st) {
              return st.selectable() && !st.selected();
            };
            se.selectionType() === "additive" || Me || se.$(r).unmerge(Ze).unselect(), Ze.emit(Xe("box")).stdFilter(Pe).select().emit(Xe("boxselect")), t.redraw();
          }
          if (t.hoverData.dragging && (t.hoverData.dragging = !1, t.redrawHint("select", !0), t.redrawHint("eles", !0), t.redraw()), !he[4]) {
            t.redrawHint("drag", !0), t.redrawHint("eles", !0);
            var He = Te && Te.grabbed();
            y(Ce), He && (Te.emit(Xe("freeon")), Ce.emit(Xe("free")), t.dragData.didDrag && (Te.emit(Xe("dragfreeon")), Ce.emit(Xe("dragfree"))));
          }
        }
        he[4] = 0, t.hoverData.down = null, t.hoverData.cxtStarted = !1, t.hoverData.draggingEles = !1, t.hoverData.selecting = !1, t.hoverData.isOverThresholdDrag = !1, t.dragData.didDrag = !1, t.hoverData.dragged = !1, t.hoverData.dragDelta = [], t.hoverData.mdownPos = null, t.hoverData.mdownGPos = null, t.hoverData.which = null;
      }
    }
  }, !1);
  var M = [], N = 4, D, I = 1e5, B = function($, oe) {
    for (var se = 0; se < $.length; se++)
      if ($[se] % oe !== 0)
        return !1;
    return !0;
  }, z = function($) {
    for (var oe = Math.abs($[0]), se = 1; se < $.length; se++)
      if (Math.abs($[se]) !== oe)
        return !1;
    return !0;
  }, F = function($) {
    var oe = !1, se = $.deltaY;
    if (se == null && ($.wheelDeltaY != null ? se = $.wheelDeltaY / 4 : $.wheelDelta != null && (se = $.wheelDelta / 4)), se !== 0) {
      if (D == null)
        if (M.length >= N) {
          var ge = M;
          if (D = B(ge, 5), !D) {
            var he = Math.abs(ge[0]);
            D = z(ge) && he > 5;
          }
          if (D)
            for (var be = 0; be < ge.length; be++)
              I = Math.min(Math.abs(ge[be]), I);
        } else
          M.push(se), oe = !0;
      else D && (I = Math.min(Math.abs(se), I));
      if (!t.scrollingPage) {
        var Ce = t.cy, Te = Ce.zoom(), Me = Ce.pan(), Xe = t.projectIntoViewport($.clientX, $.clientY), We = [Xe[0] * Te + Me.x, Xe[1] * Te + Me.y];
        if (t.hoverData.draggingEles || t.hoverData.dragging || t.hoverData.cxtStarted || A()) {
          $.preventDefault();
          return;
        }
        if (Ce.panningEnabled() && Ce.userPanningEnabled() && Ce.zoomingEnabled() && Ce.userZoomingEnabled()) {
          $.preventDefault(), t.data.wheelZooming = !0, clearTimeout(t.data.wheelTimeout), t.data.wheelTimeout = setTimeout(function() {
            t.data.wheelZooming = !1, t.redrawHint("eles", !0), t.redraw();
          }, 150);
          var Ke;
          oe && Math.abs(se) > 5 && (se = eS(se) * 5), Ke = se / -250, D && (Ke /= I, Ke *= 3), Ke = Ke * t.wheelSensitivity;
          var Ze = $.deltaMode === 1;
          Ze && (Ke *= 33);
          var Pe = Ce.zoom() * Math.pow(10, Ke);
          $.type === "gesturechange" && (Pe = t.gestureStartZoom * $.scale), Ce.zoom({
            level: Pe,
            renderedPosition: {
              x: We[0],
              y: We[1]
            }
          }), Ce.emit({
            type: $.type === "gesturechange" ? "pinchzoom" : "scrollzoom",
            originalEvent: $,
            position: {
              x: Xe[0],
              y: Xe[1]
            }
          });
        }
      }
    }
  };
  t.registerBinding(t.container, "wheel", F, !0), t.registerBinding(e, "scroll", function($) {
    t.scrollingPage = !0, clearTimeout(t.scrollingPageTimeout), t.scrollingPageTimeout = setTimeout(function() {
      t.scrollingPage = !1;
    }, 250);
  }, !0), t.registerBinding(t.container, "gesturestart", function($) {
    t.gestureStartZoom = t.cy.zoom(), t.hasTouchStarted || $.preventDefault();
  }, !0), t.registerBinding(t.container, "gesturechange", function(ce) {
    t.hasTouchStarted || F(ce);
  }, !0), t.registerBinding(t.container, "mouseout", function($) {
    var oe = t.projectIntoViewport($.clientX, $.clientY);
    t.cy.emit({
      originalEvent: $,
      type: "mouseout",
      position: {
        x: oe[0],
        y: oe[1]
      }
    });
  }, !1), t.registerBinding(t.container, "mouseover", function($) {
    var oe = t.projectIntoViewport($.clientX, $.clientY);
    t.cy.emit({
      originalEvent: $,
      type: "mouseover",
      position: {
        x: oe[0],
        y: oe[1]
      }
    });
  }, !1);
  var V, H, J, q, ae, re, pe, K, Z, X, Y, ee, j, fe = function($, oe, se, ge) {
    return Math.sqrt((se - $) * (se - $) + (ge - oe) * (ge - oe));
  }, te = function($, oe, se, ge) {
    return (se - $) * (se - $) + (ge - oe) * (ge - oe);
  }, Ae;
  t.registerBinding(t.container, "touchstart", Ae = function($) {
    if (t.hasTouchStarted = !0, !!R($)) {
      w(), t.touchData.capture = !0, t.data.bgActivePosistion = void 0;
      var oe = t.cy, se = t.touchData.now, ge = t.touchData.earlier;
      if ($.touches[0]) {
        var he = t.projectIntoViewport($.touches[0].clientX, $.touches[0].clientY);
        se[0] = he[0], se[1] = he[1];
      }
      if ($.touches[1]) {
        var he = t.projectIntoViewport($.touches[1].clientX, $.touches[1].clientY);
        se[2] = he[0], se[3] = he[1];
      }
      if ($.touches[2]) {
        var he = t.projectIntoViewport($.touches[2].clientX, $.touches[2].clientY);
        se[4] = he[0], se[5] = he[1];
      }
      var be = function(ct) {
        return {
          originalEvent: $,
          type: ct,
          position: {
            x: se[0],
            y: se[1]
          }
        };
      };
      if ($.touches[1]) {
        t.touchData.singleTouchMoved = !0, y(t.dragData.touchDragEles);
        var Ce = t.findContainerClientCoords();
        Z = Ce[0], X = Ce[1], Y = Ce[2], ee = Ce[3], V = $.touches[0].clientX - Z, H = $.touches[0].clientY - X, J = $.touches[1].clientX - Z, q = $.touches[1].clientY - X, j = 0 <= V && V <= Y && 0 <= J && J <= Y && 0 <= H && H <= ee && 0 <= q && q <= ee;
        var Te = oe.pan(), Me = oe.zoom();
        ae = fe(V, H, J, q), re = te(V, H, J, q), pe = [(V + J) / 2, (H + q) / 2], K = [(pe[0] - Te.x) / Me, (pe[1] - Te.y) / Me];
        var Xe = 200, We = Xe * Xe;
        if (re < We && !$.touches[2]) {
          var Ke = t.findNearestElement(se[0], se[1], !0, !0), Ze = t.findNearestElement(se[2], se[3], !0, !0);
          Ke && Ke.isNode() ? (Ke.activate().emit(be("cxttapstart")), t.touchData.start = Ke) : Ze && Ze.isNode() ? (Ze.activate().emit(be("cxttapstart")), t.touchData.start = Ze) : oe.emit(be("cxttapstart")), t.touchData.start && (t.touchData.start._private.grabbed = !1), t.touchData.cxt = !0, t.touchData.cxtDragged = !1, t.data.bgActivePosistion = void 0, t.redraw();
          return;
        }
      }
      if ($.touches[2])
        oe.boxSelectionEnabled() && $.preventDefault();
      else if (!$.touches[1]) {
        if ($.touches[0]) {
          var Pe = t.findNearestElements(se[0], se[1], !0, !0), He = Pe[0];
          if (He != null && (He.activate(), t.touchData.start = He, t.touchData.starts = Pe, t.nodeIsGrabbable(He))) {
            var ht = t.dragData.touchDragEles = oe.collection(), st = null;
            t.redrawHint("eles", !0), t.redrawHint("drag", !0), He.selected() ? (st = oe.$(function(rt) {
              return rt.selected() && t.nodeIsGrabbable(rt);
            }), m(st, {
              addToList: ht
            })) : v(He, {
              addToList: ht
            }), d(He), He.emit(be("grabon")), st ? st.forEach(function(rt) {
              rt.emit(be("grab"));
            }) : He.emit(be("grab"));
          }
          i(He, ["touchstart", "tapstart", "vmousedown"], $, {
            x: se[0],
            y: se[1]
          }), He == null && (t.data.bgActivePosistion = {
            x: he[0],
            y: he[1]
          }, t.redrawHint("select", !0), t.redraw()), t.touchData.singleTouchMoved = !1, t.touchData.singleTouchStartTime = +/* @__PURE__ */ new Date(), clearTimeout(t.touchData.tapholdTimeout), t.touchData.tapholdTimeout = setTimeout(function() {
            t.touchData.singleTouchMoved === !1 && !t.pinching && !t.touchData.selecting && i(t.touchData.start, ["taphold"], $, {
              x: se[0],
              y: se[1]
            });
          }, t.tapholdDuration);
        }
      }
      if ($.touches.length >= 1) {
        for (var Ue = t.touchData.startPosition = [null, null, null, null, null, null], Et = 0; Et < se.length; Et++)
          Ue[Et] = ge[Et] = se[Et];
        var qe = $.touches[0];
        t.touchData.startGPosition = [qe.clientX, qe.clientY];
      }
    }
  }, !1);
  var W;
  t.registerBinding(e, "touchmove", W = function($) {
    var oe = t.touchData.capture;
    if (!(!oe && !R($))) {
      var se = t.selection, ge = t.cy, he = t.touchData.now, be = t.touchData.earlier, Ce = ge.zoom();
      if ($.touches[0]) {
        var Te = t.projectIntoViewport($.touches[0].clientX, $.touches[0].clientY);
        he[0] = Te[0], he[1] = Te[1];
      }
      if ($.touches[1]) {
        var Te = t.projectIntoViewport($.touches[1].clientX, $.touches[1].clientY);
        he[2] = Te[0], he[3] = Te[1];
      }
      if ($.touches[2]) {
        var Te = t.projectIntoViewport($.touches[2].clientX, $.touches[2].clientY);
        he[4] = Te[0], he[5] = Te[1];
      }
      var Me = function(Qg) {
        return {
          originalEvent: $,
          type: Qg,
          position: {
            x: he[0],
            y: he[1]
          }
        };
      }, Xe = t.touchData.startGPosition, We;
      if (oe && $.touches[0] && Xe) {
        for (var Ke = [], Ze = 0; Ze < he.length; Ze++)
          Ke[Ze] = he[Ze] - be[Ze];
        var Pe = $.touches[0].clientX - Xe[0], He = Pe * Pe, ht = $.touches[0].clientY - Xe[1], st = ht * ht, Ue = He + st;
        We = Ue >= t.touchTapThreshold2;
      }
      if (oe && t.touchData.cxt) {
        $.preventDefault();
        var Et = $.touches[0].clientX - Z, qe = $.touches[0].clientY - X, rt = $.touches[1].clientX - Z, ct = $.touches[1].clientY - X, ut = te(Et, qe, rt, ct), nt = ut / re, xt = 150, Qt = xt * xt, Dt = 1.5, rr = Dt * Dt;
        if (nt >= rr || ut >= Qt) {
          t.touchData.cxt = !1, t.data.bgActivePosistion = void 0, t.redrawHint("select", !0);
          var xr = Me("cxttapend");
          t.touchData.start ? (t.touchData.start.unactivate().emit(xr), t.touchData.start = null) : ge.emit(xr);
        }
      }
      if (oe && t.touchData.cxt) {
        var xr = Me("cxtdrag");
        t.data.bgActivePosistion = void 0, t.redrawHint("select", !0), t.touchData.start ? t.touchData.start.emit(xr) : ge.emit(xr), t.touchData.start && (t.touchData.start._private.grabbed = !1), t.touchData.cxtDragged = !0;
        var nr = t.findNearestElement(he[0], he[1], !0, !0);
        (!t.touchData.cxtOver || nr !== t.touchData.cxtOver) && (t.touchData.cxtOver && t.touchData.cxtOver.emit(Me("cxtdragout")), t.touchData.cxtOver = nr, nr && nr.emit(Me("cxtdragover")));
      } else if (oe && $.touches[2] && ge.boxSelectionEnabled())
        $.preventDefault(), t.data.bgActivePosistion = void 0, this.lastThreeTouch = +/* @__PURE__ */ new Date(), t.touchData.selecting || ge.emit(Me("boxstart")), t.touchData.selecting = !0, t.touchData.didSelect = !0, se[4] = 1, !se || se.length === 0 || se[0] === void 0 ? (se[0] = (he[0] + he[2] + he[4]) / 3, se[1] = (he[1] + he[3] + he[5]) / 3, se[2] = (he[0] + he[2] + he[4]) / 3 + 1, se[3] = (he[1] + he[3] + he[5]) / 3 + 1) : (se[2] = (he[0] + he[2] + he[4]) / 3, se[3] = (he[1] + he[3] + he[5]) / 3), t.redrawHint("select", !0), t.redraw();
      else if (oe && $.touches[1] && !t.touchData.didSelect && ge.zoomingEnabled() && ge.panningEnabled() && ge.userZoomingEnabled() && ge.userPanningEnabled()) {
        $.preventDefault(), t.data.bgActivePosistion = void 0, t.redrawHint("select", !0);
        var Ht = t.dragData.touchDragEles;
        if (Ht) {
          t.redrawHint("drag", !0);
          for (var lr = 0; lr < Ht.length; lr++) {
            var sn = Ht[lr]._private;
            sn.grabbed = !1, sn.rscratch.inDragLayer = !1;
          }
        }
        var dt = t.touchData.start, Et = $.touches[0].clientX - Z, qe = $.touches[0].clientY - X, rt = $.touches[1].clientX - Z, ct = $.touches[1].clientY - X, Ee = fe(Et, qe, rt, ct), Je = Ee / ae;
        if (j) {
          var bt = Et - V, sr = qe - H, Ur = rt - J, cr = ct - q, Xr = (bt + Ur) / 2, gi = (sr + cr) / 2, bn = ge.zoom(), wn = bn * Je, ft = ge.pan(), wt = K[0] * bn + ft.x, lt = K[1] * bn + ft.y, je = {
            x: -wn / bn * (wt - ft.x - Xr) + wt,
            y: -wn / bn * (lt - ft.y - gi) + lt
          };
          if (dt && dt.active()) {
            var Ht = t.dragData.touchDragEles;
            y(Ht), t.redrawHint("drag", !0), t.redrawHint("eles", !0), dt.unactivate().emit(Me("freeon")), Ht.emit(Me("free")), t.dragData.didDrag && (dt.emit(Me("dragfreeon")), Ht.emit(Me("dragfree")));
          }
          ge.viewport({
            zoom: wn,
            pan: je,
            cancelOnFailedZoom: !0
          }), ge.emit(Me("pinchzoom")), ae = Ee, V = Et, H = qe, J = rt, q = ct, t.pinching = !0;
        }
        if ($.touches[0]) {
          var Te = t.projectIntoViewport($.touches[0].clientX, $.touches[0].clientY);
          he[0] = Te[0], he[1] = Te[1];
        }
        if ($.touches[1]) {
          var Te = t.projectIntoViewport($.touches[1].clientX, $.touches[1].clientY);
          he[2] = Te[0], he[3] = Te[1];
        }
        if ($.touches[2]) {
          var Te = t.projectIntoViewport($.touches[2].clientX, $.touches[2].clientY);
          he[4] = Te[0], he[5] = Te[1];
        }
      } else if ($.touches[0] && !t.touchData.didSelect) {
        var Kt = t.touchData.start, de = t.touchData.last, nr;
        if (!t.hoverData.draggingEles && !t.swipePanning && (nr = t.findNearestElement(he[0], he[1], !0, !0)), oe && Kt != null && $.preventDefault(), oe && Kt != null && t.nodeIsDraggable(Kt))
          if (We) {
            var Ht = t.dragData.touchDragEles, xl = !t.dragData.didDrag;
            xl && m(Ht, {
              inDragLayer: !0
            }), t.dragData.didDrag = !0;
            var ve = {
              x: 0,
              y: 0
            };
            if (mt(Ke[0]) && mt(Ke[1]) && (ve.x += Ke[0], ve.y += Ke[1], xl)) {
              t.redrawHint("eles", !0);
              var br = t.touchData.dragDelta;
              br && mt(br[0]) && mt(br[1]) && (ve.x += br[0], ve.y += br[1]);
            }
            t.hoverData.draggingEles = !0, Ht.silentShift(ve).emit(Me("position")).emit(Me("drag")), t.redrawHint("drag", !0), t.touchData.startPosition[0] == be[0] && t.touchData.startPosition[1] == be[1] && t.redrawHint("eles", !0), t.redraw();
          } else {
            var br = t.touchData.dragDelta = t.touchData.dragDelta || [];
            br.length === 0 ? (br.push(Ke[0]), br.push(Ke[1])) : (br[0] += Ke[0], br[1] += Ke[1]);
          }
        if (i(Kt || nr, ["touchmove", "tapdrag", "vmousemove"], $, {
          x: he[0],
          y: he[1]
        }), (!Kt || !Kt.grabbed()) && nr != de && (de && de.emit(Me("tapdragout")), nr && nr.emit(Me("tapdragover"))), t.touchData.last = nr, oe)
          for (var lr = 0; lr < he.length; lr++)
            he[lr] && t.touchData.startPosition[lr] && We && (t.touchData.singleTouchMoved = !0);
        if (oe && (Kt == null || Kt.pannable()) && ge.panningEnabled() && ge.userPanningEnabled()) {
          var Zg = s(Kt, t.touchData.starts);
          Zg && ($.preventDefault(), t.data.bgActivePosistion || (t.data.bgActivePosistion = Gh(t.touchData.startPosition)), t.swipePanning ? (ge.panBy({
            x: Ke[0] * Ce,
            y: Ke[1] * Ce
          }), ge.emit(Me("dragpan"))) : We && (t.swipePanning = !0, ge.panBy({
            x: Pe * Ce,
            y: ht * Ce
          }), ge.emit(Me("dragpan")), Kt && (Kt.unactivate(), t.redrawHint("select", !0), t.touchData.start = null)));
          var Te = t.projectIntoViewport($.touches[0].clientX, $.touches[0].clientY);
          he[0] = Te[0], he[1] = Te[1];
        }
      }
      for (var Ze = 0; Ze < he.length; Ze++)
        be[Ze] = he[Ze];
      oe && $.touches.length > 0 && !t.hoverData.draggingEles && !t.swipePanning && t.data.bgActivePosistion != null && (t.data.bgActivePosistion = void 0, t.redrawHint("select", !0), t.redraw());
    }
  }, !1);
  var De;
  t.registerBinding(e, "touchcancel", De = function($) {
    var oe = t.touchData.start;
    t.touchData.capture = !1, oe && oe.unactivate();
  });
  var ue, ze, Ge, Ve;
  if (t.registerBinding(e, "touchend", ue = function($) {
    var oe = t.touchData.start, se = t.touchData.capture;
    if (se)
      $.touches.length === 0 && (t.touchData.capture = !1), $.preventDefault();
    else
      return;
    var ge = t.selection;
    t.swipePanning = !1, t.hoverData.draggingEles = !1;
    var he = t.cy, be = he.zoom(), Ce = t.touchData.now, Te = t.touchData.earlier;
    if ($.touches[0]) {
      var Me = t.projectIntoViewport($.touches[0].clientX, $.touches[0].clientY);
      Ce[0] = Me[0], Ce[1] = Me[1];
    }
    if ($.touches[1]) {
      var Me = t.projectIntoViewport($.touches[1].clientX, $.touches[1].clientY);
      Ce[2] = Me[0], Ce[3] = Me[1];
    }
    if ($.touches[2]) {
      var Me = t.projectIntoViewport($.touches[2].clientX, $.touches[2].clientY);
      Ce[4] = Me[0], Ce[5] = Me[1];
    }
    var Xe = function(Qt) {
      return {
        originalEvent: $,
        type: Qt,
        position: {
          x: Ce[0],
          y: Ce[1]
        }
      };
    };
    oe && oe.unactivate();
    var We;
    if (t.touchData.cxt) {
      if (We = Xe("cxttapend"), oe ? oe.emit(We) : he.emit(We), !t.touchData.cxtDragged) {
        var Ke = Xe("cxttap");
        oe ? oe.emit(Ke) : he.emit(Ke);
      }
      t.touchData.start && (t.touchData.start._private.grabbed = !1), t.touchData.cxt = !1, t.touchData.start = null, t.redraw();
      return;
    }
    if (!$.touches[2] && he.boxSelectionEnabled() && t.touchData.selecting) {
      t.touchData.selecting = !1;
      var Ze = he.collection(t.getAllInBox(ge[0], ge[1], ge[2], ge[3]));
      ge[0] = void 0, ge[1] = void 0, ge[2] = void 0, ge[3] = void 0, ge[4] = 0, t.redrawHint("select", !0), he.emit(Xe("boxend"));
      var Pe = function(Qt) {
        return Qt.selectable() && !Qt.selected();
      };
      Ze.emit(Xe("box")).stdFilter(Pe).select().emit(Xe("boxselect")), Ze.nonempty() && t.redrawHint("eles", !0), t.redraw();
    }
    if (oe?.unactivate(), $.touches[2])
      t.data.bgActivePosistion = void 0, t.redrawHint("select", !0);
    else if (!$.touches[1]) {
      if (!$.touches[0]) {
        if (!$.touches[0]) {
          t.data.bgActivePosistion = void 0, t.redrawHint("select", !0);
          var He = t.dragData.touchDragEles;
          if (oe != null) {
            var ht = oe._private.grabbed;
            y(He), t.redrawHint("drag", !0), t.redrawHint("eles", !0), ht && (oe.emit(Xe("freeon")), He.emit(Xe("free")), t.dragData.didDrag && (oe.emit(Xe("dragfreeon")), He.emit(Xe("dragfree")))), i(oe, ["touchend", "tapend", "vmouseup", "tapdragout"], $, {
              x: Ce[0],
              y: Ce[1]
            }), oe.unactivate(), t.touchData.start = null;
          } else {
            var st = t.findNearestElement(Ce[0], Ce[1], !0, !0);
            i(st, ["touchend", "tapend", "vmouseup", "tapdragout"], $, {
              x: Ce[0],
              y: Ce[1]
            });
          }
          var Ue = t.touchData.startPosition[0] - Ce[0], Et = Ue * Ue, qe = t.touchData.startPosition[1] - Ce[1], rt = qe * qe, ct = Et + rt, ut = ct * be * be;
          t.touchData.singleTouchMoved || (oe || he.$(":selected").unselect(["tapunselect"]), i(oe, ["tap", "vclick"], $, {
            x: Ce[0],
            y: Ce[1]
          }), ze = !1, $.timeStamp - Ve <= he.multiClickDebounceTime() ? (Ge && clearTimeout(Ge), ze = !0, Ve = null, i(oe, ["dbltap", "vdblclick"], $, {
            x: Ce[0],
            y: Ce[1]
          })) : (Ge = setTimeout(function() {
            ze || i(oe, ["onetap", "voneclick"], $, {
              x: Ce[0],
              y: Ce[1]
            });
          }, he.multiClickDebounceTime()), Ve = $.timeStamp)), oe != null && !t.dragData.didDrag && oe._private.selectable && ut < t.touchTapThreshold2 && !t.pinching && (he.selectionType() === "single" ? (he.$(r).unmerge(oe).unselect(["tapunselect"]), oe.select(["tapselect"])) : oe.selected() ? oe.unselect(["tapunselect"]) : oe.select(["tapselect"]), t.redrawHint("eles", !0)), t.touchData.singleTouchMoved = !0;
        }
      }
    }
    for (var nt = 0; nt < Ce.length; nt++)
      Te[nt] = Ce[nt];
    t.dragData.didDrag = !1, $.touches.length === 0 && (t.touchData.dragDelta = [], t.touchData.startPosition = [null, null, null, null, null, null], t.touchData.startGPosition = null, t.touchData.didSelect = !1), $.touches.length < 2 && ($.touches.length === 1 && (t.touchData.startGPosition = [$.touches[0].clientX, $.touches[0].clientY]), t.pinching = !1, t.redrawHint("eles", !0), t.redraw());
  }, !1), typeof TouchEvent > "u") {
    var ke = [], Oe = function($) {
      return {
        clientX: $.clientX,
        clientY: $.clientY,
        force: 1,
        identifier: $.pointerId,
        pageX: $.pageX,
        pageY: $.pageY,
        radiusX: $.width / 2,
        radiusY: $.height / 2,
        screenX: $.screenX,
        screenY: $.screenY,
        target: $.target
      };
    }, Se = function($) {
      return {
        event: $,
        touch: Oe($)
      };
    }, _e = function($) {
      ke.push(Se($));
    }, $e = function($) {
      for (var oe = 0; oe < ke.length; oe++) {
        var se = ke[oe];
        if (se.event.pointerId === $.pointerId) {
          ke.splice(oe, 1);
          return;
        }
      }
    }, me = function($) {
      var oe = ke.filter(function(se) {
        return se.event.pointerId === $.pointerId;
      })[0];
      oe.event = $, oe.touch = Oe($);
    }, Ne = function($) {
      $.touches = ke.map(function(oe) {
        return oe.touch;
      });
    }, Q = function($) {
      return $.pointerType === "mouse" || $.pointerType === 4;
    };
    t.registerBinding(t.container, "pointerdown", function(ce) {
      Q(ce) || (ce.preventDefault(), _e(ce), Ne(ce), Ae(ce));
    }), t.registerBinding(t.container, "pointerup", function(ce) {
      Q(ce) || ($e(ce), Ne(ce), ue(ce));
    }), t.registerBinding(t.container, "pointercancel", function(ce) {
      Q(ce) || ($e(ce), Ne(ce), De(ce));
    }), t.registerBinding(t.container, "pointermove", function(ce) {
      Q(ce) || (ce.preventDefault(), me(ce), Ne(ce), W(ce));
    });
  }
};
var fl = {};
fl.generatePolygon = function(t, e) {
  return this.nodeShapes[t] = {
    renderer: this,
    name: t,
    points: e,
    draw: function(n, i, a, s, o, l) {
      this.renderer.nodeShapeImpl("polygon", n, i, a, s, o, this.points);
    },
    intersectLine: function(n, i, a, s, o, l, u, h) {
      return Bp(o, l, this.points, n, i, a / 2, s / 2, u);
    },
    checkPoint: function(n, i, a, s, o, l, u, h) {
      return il(n, i, this.points, l, u, s, o, [0, -1], a);
    },
    hasMiterBounds: t !== "rectangle",
    miterBounds: function(n, i, a, s, o, l) {
      return N2e(this.points, n, i, a, s, o);
    }
  };
};
fl.generateEllipse = function() {
  return this.nodeShapes.ellipse = {
    renderer: this,
    name: "ellipse",
    draw: function(e, r, n, i, a, s) {
      this.renderer.nodeShapeImpl(this.name, e, r, n, i, a);
    },
    intersectLine: function(e, r, n, i, a, s, o, l) {
      return z2e(a, s, e, r, n / 2 + o, i / 2 + o);
    },
    checkPoint: function(e, r, n, i, a, s, o, l) {
      return ou(e, r, i, a, s, o, n);
    }
  };
};
fl.generateRoundPolygon = function(t, e) {
  return this.nodeShapes[t] = {
    renderer: this,
    name: t,
    points: e,
    getOrCreateCorners: function(n, i, a, s, o, l, u) {
      if (l[u] !== void 0 && l[u + "-cx"] === n && l[u + "-cy"] === i)
        return l[u];
      l[u] = new Array(e.length / 2), l[u + "-cx"] = n, l[u + "-cy"] = i;
      var h = a / 2, d = s / 2;
      o = o === "auto" ? DV(a, s) : o;
      for (var f = new Array(e.length / 2), p = 0; p < e.length / 2; p++)
        f[p] = {
          x: n + h * e[p * 2],
          y: i + d * e[p * 2 + 1]
        };
      var g, m, v, y, b = f.length;
      for (m = f[b - 1], g = 0; g < b; g++)
        v = f[g % b], y = f[(g + 1) % b], l[u][g] = fS(m, v, y, o), m = v, v = y;
      return l[u];
    },
    draw: function(n, i, a, s, o, l, u) {
      this.renderer.nodeShapeImpl("round-polygon", n, i, a, s, o, this.points, this.getOrCreateCorners(i, a, s, o, l, u, "drawCorners"));
    },
    intersectLine: function(n, i, a, s, o, l, u, h, d) {
      return V2e(o, l, this.points, n, i, a, s, u, this.getOrCreateCorners(n, i, a, s, h, d, "corners"));
    },
    checkPoint: function(n, i, a, s, o, l, u, h, d) {
      return $2e(n, i, this.points, l, u, s, o, this.getOrCreateCorners(l, u, s, o, h, d, "corners"));
    }
  };
};
fl.generateRoundRectangle = function() {
  return this.nodeShapes["round-rectangle"] = this.nodeShapes.roundrectangle = {
    renderer: this,
    name: "round-rectangle",
    points: Di(4, 0),
    draw: function(e, r, n, i, a, s) {
      this.renderer.nodeShapeImpl(this.name, e, r, n, i, a, this.points, s);
    },
    intersectLine: function(e, r, n, i, a, s, o, l) {
      return NV(a, s, e, r, n, i, o, l);
    },
    checkPoint: function(e, r, n, i, a, s, o, l) {
      var u = i / 2, h = a / 2;
      l = l === "auto" ? Jl(i, a) : l, l = Math.min(u, h, l);
      var d = l * 2;
      return !!(il(e, r, this.points, s, o, i, a - d, [0, -1], n) || il(e, r, this.points, s, o, i - d, a, [0, -1], n) || ou(e, r, d, d, s - u + l, o - h + l, n) || ou(e, r, d, d, s + u - l, o - h + l, n) || ou(e, r, d, d, s + u - l, o + h - l, n) || ou(e, r, d, d, s - u + l, o + h - l, n));
    }
  };
};
fl.generateCutRectangle = function() {
  return this.nodeShapes["cut-rectangle"] = this.nodeShapes.cutrectangle = {
    renderer: this,
    name: "cut-rectangle",
    cornerLength: rS(),
    points: Di(4, 0),
    draw: function(e, r, n, i, a, s) {
      this.renderer.nodeShapeImpl(this.name, e, r, n, i, a, null, s);
    },
    generateCutTrianglePts: function(e, r, n, i, a) {
      var s = a === "auto" ? this.cornerLength : a, o = r / 2, l = e / 2, u = n - l, h = n + l, d = i - o, f = i + o;
      return {
        topLeft: [u, d + s, u + s, d, u + s, d + s],
        topRight: [h - s, d, h, d + s, h - s, d + s],
        bottomRight: [h, f - s, h - s, f, h - s, f - s],
        bottomLeft: [u + s, f, u, f - s, u + s, f - s]
      };
    },
    intersectLine: function(e, r, n, i, a, s, o, l) {
      var u = this.generateCutTrianglePts(n + 2 * o, i + 2 * o, e, r, l), h = [].concat.apply([], [u.topLeft.splice(0, 4), u.topRight.splice(0, 4), u.bottomRight.splice(0, 4), u.bottomLeft.splice(0, 4)]);
      return Bp(a, s, h, e, r);
    },
    checkPoint: function(e, r, n, i, a, s, o, l) {
      var u = l === "auto" ? this.cornerLength : l;
      if (il(e, r, this.points, s, o, i, a - 2 * u, [0, -1], n) || il(e, r, this.points, s, o, i - 2 * u, a, [0, -1], n))
        return !0;
      var h = this.generateCutTrianglePts(i, a, s, o);
      return ia(e, r, h.topLeft) || ia(e, r, h.topRight) || ia(e, r, h.bottomRight) || ia(e, r, h.bottomLeft);
    }
  };
};
fl.generateBarrel = function() {
  return this.nodeShapes.barrel = {
    renderer: this,
    name: "barrel",
    points: Di(4, 0),
    draw: function(e, r, n, i, a, s) {
      this.renderer.nodeShapeImpl(this.name, e, r, n, i, a);
    },
    intersectLine: function(e, r, n, i, a, s, o, l) {
      var u = 0.15, h = 0.5, d = 0.85, f = this.generateBarrelBezierPts(n + 2 * o, i + 2 * o, e, r), p = function(v) {
        var y = td({
          x: v[0],
          y: v[1]
        }, {
          x: v[2],
          y: v[3]
        }, {
          x: v[4],
          y: v[5]
        }, u), b = td({
          x: v[0],
          y: v[1]
        }, {
          x: v[2],
          y: v[3]
        }, {
          x: v[4],
          y: v[5]
        }, h), w = td({
          x: v[0],
          y: v[1]
        }, {
          x: v[2],
          y: v[3]
        }, {
          x: v[4],
          y: v[5]
        }, d);
        return [v[0], v[1], y.x, y.y, b.x, b.y, w.x, w.y, v[4], v[5]];
      }, g = [].concat(p(f.topLeft), p(f.topRight), p(f.bottomRight), p(f.bottomLeft));
      return Bp(a, s, g, e, r);
    },
    generateBarrelBezierPts: function(e, r, n, i) {
      var a = r / 2, s = e / 2, o = n - s, l = n + s, u = i - a, h = i + a, d = pT(e, r), f = d.heightOffset, p = d.widthOffset, g = d.ctrlPtOffsetPct * e, m = {
        topLeft: [o, u + f, o + g, u, o + p, u],
        topRight: [l - p, u, l - g, u, l, u + f],
        bottomRight: [l, h - f, l - g, h, l - p, h],
        bottomLeft: [o + p, h, o + g, h, o, h - f]
      };
      return m.topLeft.isTop = !0, m.topRight.isTop = !0, m.bottomLeft.isBottom = !0, m.bottomRight.isBottom = !0, m;
    },
    checkPoint: function(e, r, n, i, a, s, o, l) {
      var u = pT(i, a), h = u.heightOffset, d = u.widthOffset;
      if (il(e, r, this.points, s, o, i, a - 2 * h, [0, -1], n) || il(e, r, this.points, s, o, i - 2 * d, a, [0, -1], n))
        return !0;
      for (var f = this.generateBarrelBezierPts(i, a, s, o), p = function(C, A, R) {
        var _ = R[4], O = R[2], P = R[0], S = R[5], M = R[1], N = Math.min(_, P), D = Math.max(_, P), I = Math.min(S, M), B = Math.max(S, M);
        if (N <= C && C <= D && I <= A && A <= B) {
          var z = U2e(_, O, P), F = O2e(z[0], z[1], z[2], C), V = F.filter(function(H) {
            return 0 <= H && H <= 1;
          });
          if (V.length > 0)
            return V[0];
        }
        return null;
      }, g = Object.keys(f), m = 0; m < g.length; m++) {
        var v = g[m], y = f[v], b = p(e, r, y);
        if (b != null) {
          var w = y[5], T = y[3], E = y[1], L = Yn(w, T, E, b);
          if (y.isTop && L <= r || y.isBottom && r <= L)
            return !0;
        }
      }
      return !1;
    }
  };
};
fl.generateBottomRoundrectangle = function() {
  return this.nodeShapes["bottom-round-rectangle"] = this.nodeShapes.bottomroundrectangle = {
    renderer: this,
    name: "bottom-round-rectangle",
    points: Di(4, 0),
    draw: function(e, r, n, i, a, s) {
      this.renderer.nodeShapeImpl(this.name, e, r, n, i, a, this.points, s);
    },
    intersectLine: function(e, r, n, i, a, s, o, l) {
      var u = e - (n / 2 + o), h = r - (i / 2 + o), d = h, f = e + (n / 2 + o), p = Ol(a, s, e, r, u, h, f, d, !1);
      return p.length > 0 ? p : NV(a, s, e, r, n, i, o, l);
    },
    checkPoint: function(e, r, n, i, a, s, o, l) {
      l = l === "auto" ? Jl(i, a) : l;
      var u = 2 * l;
      if (il(e, r, this.points, s, o, i, a - u, [0, -1], n) || il(e, r, this.points, s, o, i - u, a, [0, -1], n))
        return !0;
      var h = i / 2 + 2 * n, d = a / 2 + 2 * n, f = [s - h, o - d, s - h, o, s + h, o, s + h, o - d];
      return !!(ia(e, r, f) || ou(e, r, u, u, s + i / 2 - l, o + a / 2 - l, n) || ou(e, r, u, u, s - i / 2 + l, o + a / 2 - l, n));
    }
  };
};
fl.registerNodeShapes = function() {
  var t = this.nodeShapes = {}, e = this;
  this.generateEllipse(), this.generatePolygon("triangle", Di(3, 0)), this.generateRoundPolygon("round-triangle", Di(3, 0)), this.generatePolygon("rectangle", Di(4, 0)), t.square = t.rectangle, this.generateRoundRectangle(), this.generateCutRectangle(), this.generateBarrel(), this.generateBottomRoundrectangle();
  {
    var r = [0, 1, 1, 0, 0, -1, -1, 0];
    this.generatePolygon("diamond", r), this.generateRoundPolygon("round-diamond", r);
  }
  this.generatePolygon("pentagon", Di(5, 0)), this.generateRoundPolygon("round-pentagon", Di(5, 0)), this.generatePolygon("hexagon", Di(6, 0)), this.generateRoundPolygon("round-hexagon", Di(6, 0)), this.generatePolygon("heptagon", Di(7, 0)), this.generateRoundPolygon("round-heptagon", Di(7, 0)), this.generatePolygon("octagon", Di(8, 0)), this.generateRoundPolygon("round-octagon", Di(8, 0));
  var n = new Array(20);
  {
    var i = fT(5, 0), a = fT(5, Math.PI / 5), s = 0.5 * (3 - Math.sqrt(5));
    s *= 1.57;
    for (var o = 0; o < a.length / 2; o++)
      a[o * 2] *= s, a[o * 2 + 1] *= s;
    for (var o = 0; o < 20 / 4; o++)
      n[o * 4] = i[o * 2], n[o * 4 + 1] = i[o * 2 + 1], n[o * 4 + 2] = a[o * 2], n[o * 4 + 3] = a[o * 2 + 1];
  }
  n = IV(n), this.generatePolygon("star", n), this.generatePolygon("vee", [-1, -1, 0, -0.333, 1, -1, 0, 1]), this.generatePolygon("rhomboid", [-1, -1, 0.333, -1, 1, 1, -0.333, 1]), this.generatePolygon("right-rhomboid", [-0.333, -1, 1, -1, 0.333, 1, -1, 1]), this.nodeShapes.concavehexagon = this.generatePolygon("concave-hexagon", [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);
  {
    var l = [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1];
    this.generatePolygon("tag", l), this.generateRoundPolygon("round-tag", l);
  }
  t.makePolygon = function(u) {
    var h = u.join("$"), d = "polygon-" + h, f;
    return (f = this[d]) ? f : e.generatePolygon(d, u);
  };
};
var Ng = {};
Ng.timeToRender = function() {
  return this.redrawTotalTime / this.redrawCount;
};
Ng.redraw = function(t) {
  t = t || _V();
  var e = this;
  e.averageRedrawTime === void 0 && (e.averageRedrawTime = 0), e.lastRedrawTime === void 0 && (e.lastRedrawTime = 0), e.lastDrawTime === void 0 && (e.lastDrawTime = 0), e.requestedFrame = !0, e.renderOptions = t;
};
Ng.beforeRender = function(t, e) {
  if (!this.destroyed) {
    e == null && Zr("Priority is not optional for beforeRender");
    var r = this.beforeRenderCallbacks;
    r.push({
      fn: t,
      priority: e
    }), r.sort(function(n, i) {
      return i.priority - n.priority;
    });
  }
};
var pL = function(e, r, n) {
  for (var i = e.beforeRenderCallbacks, a = 0; a < i.length; a++)
    i[a].fn(r, n);
};
Ng.startRenderLoop = function() {
  var t = this, e = t.cy;
  if (!t.renderLoopStarted) {
    t.renderLoopStarted = !0;
    var r = function(i) {
      if (!t.destroyed) {
        if (!e.batching()) if (t.requestedFrame && !t.skipFrame) {
          pL(t, !0, i);
          var a = nl();
          t.render(t.renderOptions);
          var s = t.lastDrawTime = nl();
          t.averageRedrawTime === void 0 && (t.averageRedrawTime = s - a), t.redrawCount === void 0 && (t.redrawCount = 0), t.redrawCount++, t.redrawTotalTime === void 0 && (t.redrawTotalTime = 0);
          var o = s - a;
          t.redrawTotalTime += o, t.lastRedrawTime = o, t.averageRedrawTime = t.averageRedrawTime / 2 + o / 2, t.requestedFrame = !1;
        } else
          pL(t, !1, i);
        t.skipFrame = !1, Sy(r);
      }
    };
    Sy(r);
  }
};
var a3e = function(e) {
  this.init(e);
}, DU = a3e, of = DU.prototype;
of.clientFunctions = ["redrawHint", "render", "renderTo", "matchCanvasSize", "nodeShapeImpl", "arrowShapeImpl"];
of.init = function(t) {
  var e = this;
  e.options = t, e.cy = t.cy;
  var r = e.container = t.cy.container(), n = e.cy.window();
  if (n) {
    var i = n.document, a = i.head, s = "__________cytoscape_stylesheet", o = "__________cytoscape_container", l = i.getElementById(s) != null;
    if (r.className.indexOf(o) < 0 && (r.className = (r.className || "") + " " + o), !l) {
      var u = i.createElement("style");
      u.id = s, u.textContent = "." + o + " { position: relative; }", a.insertBefore(u, a.children[0]);
    }
    var h = n.getComputedStyle(r), d = h.getPropertyValue("position");
    d === "static" && Lr("A Cytoscape container has style position:static and so can not use UI extensions properly");
  }
  e.selection = [void 0, void 0, void 0, void 0, 0], e.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95], e.hoverData = {
    down: null,
    last: null,
    downTime: null,
    triggerMode: null,
    dragging: !1,
    initialPan: [null, null],
    capture: !1
  }, e.dragData = {
    possibleDragElements: []
  }, e.touchData = {
    start: null,
    capture: !1,
    // These 3 fields related to tap, taphold events
    startPosition: [null, null, null, null, null, null],
    singleTouchStartTime: null,
    singleTouchMoved: !0,
    now: [null, null, null, null, null, null],
    earlier: [null, null, null, null, null, null]
  }, e.redraws = 0, e.showFps = t.showFps, e.debug = t.debug, e.webgl = t.webgl, e.hideEdgesOnViewport = t.hideEdgesOnViewport, e.textureOnViewport = t.textureOnViewport, e.wheelSensitivity = t.wheelSensitivity, e.motionBlurEnabled = t.motionBlur, e.forcedPixelRatio = mt(t.pixelRatio) ? t.pixelRatio : null, e.motionBlur = t.motionBlur, e.motionBlurOpacity = t.motionBlurOpacity, e.motionBlurTransparency = 1 - e.motionBlurOpacity, e.motionBlurPxRatio = 1, e.mbPxRBlurry = 1, e.minMbLowQualFrames = 4, e.fullQualityMb = !1, e.clearedForMotionBlur = [], e.desktopTapThreshold = t.desktopTapThreshold, e.desktopTapThreshold2 = t.desktopTapThreshold * t.desktopTapThreshold, e.touchTapThreshold = t.touchTapThreshold, e.touchTapThreshold2 = t.touchTapThreshold * t.touchTapThreshold, e.tapholdDuration = 500, e.bindings = [], e.beforeRenderCallbacks = [], e.beforeRenderPriorities = {
    // higher priority execs before lower one
    animations: 400,
    eleCalcs: 300,
    eleTxrDeq: 200,
    lyrTxrDeq: 150,
    lyrTxrSkip: 100
  }, e.registerNodeShapes(), e.registerArrowShapes(), e.registerCalculationListeners();
};
of.notify = function(t, e) {
  var r = this, n = r.cy;
  if (!this.destroyed) {
    if (t === "init") {
      r.load();
      return;
    }
    if (t === "destroy") {
      r.destroy();
      return;
    }
    (t === "add" || t === "remove" || t === "move" && n.hasCompoundNodes() || t === "load" || t === "zorder" || t === "mount") && r.invalidateCachedZSortedEles(), t === "viewport" && r.redrawHint("select", !0), t === "gc" && r.redrawHint("gc", !0), (t === "load" || t === "resize" || t === "mount") && (r.invalidateContainerClientCoordsCache(), r.matchCanvasSize(r.container)), r.redrawHint("eles", !0), r.redrawHint("drag", !0), this.startRenderLoop(), this.redraw();
  }
};
of.destroy = function() {
  var t = this;
  t.destroyed = !0, t.cy.stopAnimationLoop();
  for (var e = 0; e < t.bindings.length; e++) {
    var r = t.bindings[e], n = r, i = n.target;
    (i.off || i.removeEventListener).apply(i, n.args);
  }
  if (t.bindings = [], t.beforeRenderCallbacks = [], t.onUpdateEleCalcsFns = [], t.removeObserver && t.removeObserver.disconnect(), t.styleObserver && t.styleObserver.disconnect(), t.resizeObserver && t.resizeObserver.disconnect(), t.labelCalcDiv)
    try {
      document.body.removeChild(t.labelCalcDiv);
    } catch {
    }
};
of.isHeadless = function() {
  return !1;
};
[dS, NU, IU, sf, fl, Ng].forEach(function(t) {
  Gt(of, t);
});
var t5 = 1e3 / 60, OU = {
  setupDequeueing: function(e) {
    return function() {
      var n = this, i = this.renderer;
      if (!n.dequeueingSetup) {
        n.dequeueingSetup = !0;
        var a = Ag(function() {
          i.redrawHint("eles", !0), i.redrawHint("drag", !0), i.redraw();
        }, e.deqRedrawThreshold), s = function(u, h) {
          var d = nl(), f = i.averageRedrawTime, p = i.lastRedrawTime, g = [], m = i.cy.extent(), v = i.getPixelRatio();
          for (u || i.flushRenderedStyleQueue(); ; ) {
            var y = nl(), b = y - d, w = y - h;
            if (p < t5) {
              var T = t5 - (u ? f : 0);
              if (w >= e.deqFastCost * T)
                break;
            } else if (u) {
              if (b >= e.deqCost * p || b >= e.deqAvgCost * f)
                break;
            } else if (w >= e.deqNoDrawCost * t5)
              break;
            var E = e.deq(n, v, m);
            if (E.length > 0)
              for (var L = 0; L < E.length; L++)
                g.push(E[L]);
            else
              break;
          }
          g.length > 0 && (e.onDeqd(n, g), !u && e.shouldRedraw(n, g, v, m) && a());
        }, o = e.priority || Zk;
        i.beforeRender(s, o(n));
      }
    };
  }
}, s3e = /* @__PURE__ */ (function() {
  function t(e) {
    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Cy;
    mc(this, t), this.idsByKey = new Go(), this.keyForId = new Go(), this.cachesByLvl = new Go(), this.lvls = [], this.getKey = e, this.doesEleInvalidateKey = r;
  }
  return vc(t, [{
    key: "getIdsFor",
    value: function(r) {
      r == null && Zr("Can not get id list for null key");
      var n = this.idsByKey, i = this.idsByKey.get(r);
      return i || (i = new tf(), n.set(r, i)), i;
    }
  }, {
    key: "addIdForKey",
    value: function(r, n) {
      r != null && this.getIdsFor(r).add(n);
    }
  }, {
    key: "deleteIdForKey",
    value: function(r, n) {
      r != null && this.getIdsFor(r).delete(n);
    }
  }, {
    key: "getNumberOfIdsForKey",
    value: function(r) {
      return r == null ? 0 : this.getIdsFor(r).size;
    }
  }, {
    key: "updateKeyMappingFor",
    value: function(r) {
      var n = r.id(), i = this.keyForId.get(n), a = this.getKey(r);
      this.deleteIdForKey(i, n), this.addIdForKey(a, n), this.keyForId.set(n, a);
    }
  }, {
    key: "deleteKeyMappingFor",
    value: function(r) {
      var n = r.id(), i = this.keyForId.get(n);
      this.deleteIdForKey(i, n), this.keyForId.delete(n);
    }
  }, {
    key: "keyHasChangedFor",
    value: function(r) {
      var n = r.id(), i = this.keyForId.get(n), a = this.getKey(r);
      return i !== a;
    }
  }, {
    key: "isInvalid",
    value: function(r) {
      return this.keyHasChangedFor(r) || this.doesEleInvalidateKey(r);
    }
  }, {
    key: "getCachesAt",
    value: function(r) {
      var n = this.cachesByLvl, i = this.lvls, a = n.get(r);
      return a || (a = new Go(), n.set(r, a), i.push(r)), a;
    }
  }, {
    key: "getCache",
    value: function(r, n) {
      return this.getCachesAt(n).get(r);
    }
  }, {
    key: "get",
    value: function(r, n) {
      var i = this.getKey(r), a = this.getCache(i, n);
      return a != null && this.updateKeyMappingFor(r), a;
    }
  }, {
    key: "getForCachedKey",
    value: function(r, n) {
      var i = this.keyForId.get(r.id()), a = this.getCache(i, n);
      return a;
    }
  }, {
    key: "hasCache",
    value: function(r, n) {
      return this.getCachesAt(n).has(r);
    }
  }, {
    key: "has",
    value: function(r, n) {
      var i = this.getKey(r);
      return this.hasCache(i, n);
    }
  }, {
    key: "setCache",
    value: function(r, n, i) {
      i.key = r, this.getCachesAt(n).set(r, i);
    }
  }, {
    key: "set",
    value: function(r, n, i) {
      var a = this.getKey(r);
      this.setCache(a, n, i), this.updateKeyMappingFor(r);
    }
  }, {
    key: "deleteCache",
    value: function(r, n) {
      this.getCachesAt(n).delete(r);
    }
  }, {
    key: "delete",
    value: function(r, n) {
      var i = this.getKey(r);
      this.deleteCache(i, n);
    }
  }, {
    key: "invalidateKey",
    value: function(r) {
      var n = this;
      this.lvls.forEach(function(i) {
        return n.deleteCache(r, i);
      });
    }
    // returns true if no other eles reference the invalidated cache (n.b. other eles may need the cache with the same key)
  }, {
    key: "invalidate",
    value: function(r) {
      var n = r.id(), i = this.keyForId.get(n);
      this.deleteKeyMappingFor(r);
      var a = this.doesEleInvalidateKey(r);
      return a && this.invalidateKey(i), a || this.getNumberOfIdsForKey(i) === 0;
    }
  }]);
})(), gL = 25, B1 = 50, Um = -4, AT = 3, PU = 7.99, o3e = 8, l3e = 1024, c3e = 1024, u3e = 1024, h3e = 0.2, d3e = 0.8, f3e = 10, p3e = 0.15, g3e = 0.1, m3e = 0.9, v3e = 0.9, y3e = 100, x3e = 1, Uh = {
  dequeue: "dequeue",
  downscale: "downscale",
  highQuality: "highQuality"
}, b3e = fi({
  getKey: null,
  doesEleInvalidateKey: Cy,
  drawElement: null,
  getBoundingBox: null,
  getRotationPoint: null,
  getRotationOffset: null,
  isVisible: SV,
  allowEdgeTxrCaching: !0,
  allowParentTxrCaching: !0
}), r0 = function(e, r) {
  var n = this;
  n.renderer = e, n.onDequeues = [];
  var i = b3e(r);
  Gt(n, i), n.lookup = new s3e(i.getKey, i.doesEleInvalidateKey), n.setupDequeueing();
}, qn = r0.prototype;
qn.reasons = Uh;
qn.getTextureQueue = function(t) {
  var e = this;
  return e.eleImgCaches = e.eleImgCaches || {}, e.eleImgCaches[t] = e.eleImgCaches[t] || [];
};
qn.getRetiredTextureQueue = function(t) {
  var e = this, r = e.eleImgCaches.retired = e.eleImgCaches.retired || {}, n = r[t] = r[t] || [];
  return n;
};
qn.getElementQueue = function() {
  var t = this, e = t.eleCacheQueue = t.eleCacheQueue || new _g(function(r, n) {
    return n.reqs - r.reqs;
  });
  return e;
};
qn.getElementKeyToQueue = function() {
  var t = this, e = t.eleKeyToCacheQueue = t.eleKeyToCacheQueue || {};
  return e;
};
qn.getElement = function(t, e, r, n, i) {
  var a = this, s = this.renderer, o = s.cy.zoom(), l = this.lookup;
  if (!e || e.w === 0 || e.h === 0 || isNaN(e.w) || isNaN(e.h) || !t.visible() || t.removed() || !a.allowEdgeTxrCaching && t.isEdge() || !a.allowParentTxrCaching && t.isParent())
    return null;
  if (n == null && (n = Math.ceil(Jk(o * r))), n < Um)
    n = Um;
  else if (o >= PU || n > AT)
    return null;
  var u = Math.pow(2, n), h = e.h * u, d = e.w * u, f = s.eleTextBiggerThanMin(t, u);
  if (!this.isVisible(t, f))
    return null;
  var p = l.get(t, n);
  if (p && p.invalidated && (p.invalidated = !1, p.texture.invalidatedWidth -= p.width), p)
    return p;
  var g;
  if (h <= gL ? g = gL : h <= B1 ? g = B1 : g = Math.ceil(h / B1) * B1, h > u3e || d > c3e)
    return null;
  var m = a.getTextureQueue(g), v = m[m.length - 2], y = function() {
    return a.recycleTexture(g, d) || a.addTexture(g, d);
  };
  v || (v = m[m.length - 1]), v || (v = y()), v.width - v.usedWidth < d && (v = y());
  for (var b = function(N) {
    return N && N.scaledLabelShown === f;
  }, w = i && i === Uh.dequeue, T = i && i === Uh.highQuality, E = i && i === Uh.downscale, L, k = n + 1; k <= AT; k++) {
    var C = l.get(t, k);
    if (C) {
      L = C;
      break;
    }
  }
  var A = L && L.level === n + 1 ? L : null, R = function() {
    v.context.drawImage(A.texture.canvas, A.x, 0, A.width, A.height, v.usedWidth, 0, d, h);
  };
  if (v.context.setTransform(1, 0, 0, 1, 0, 0), v.context.clearRect(v.usedWidth, 0, d, g), b(A))
    R();
  else if (b(L))
    if (T) {
      for (var _ = L.level; _ > n; _--)
        A = a.getElement(t, e, r, _, Uh.downscale);
      R();
    } else
      return a.queueElement(t, L.level - 1), L;
  else {
    var O;
    if (!w && !T && !E)
      for (var P = n - 1; P >= Um; P--) {
        var S = l.get(t, P);
        if (S) {
          O = S;
          break;
        }
      }
    if (b(O))
      return a.queueElement(t, n), O;
    v.context.translate(v.usedWidth, 0), v.context.scale(u, u), this.drawElement(v.context, t, e, f, !1), v.context.scale(1 / u, 1 / u), v.context.translate(-v.usedWidth, 0);
  }
  return p = {
    x: v.usedWidth,
    texture: v,
    level: n,
    scale: u,
    width: d,
    height: h,
    scaledLabelShown: f
  }, v.usedWidth += Math.ceil(d + o3e), v.eleCaches.push(p), l.set(t, n, p), a.checkTextureFullness(v), p;
};
qn.invalidateElements = function(t) {
  for (var e = 0; e < t.length; e++)
    this.invalidateElement(t[e]);
};
qn.invalidateElement = function(t) {
  var e = this, r = e.lookup, n = [], i = r.isInvalid(t);
  if (i) {
    for (var a = Um; a <= AT; a++) {
      var s = r.getForCachedKey(t, a);
      s && n.push(s);
    }
    var o = r.invalidate(t);
    if (o)
      for (var l = 0; l < n.length; l++) {
        var u = n[l], h = u.texture;
        h.invalidatedWidth += u.width, u.invalidated = !0, e.checkTextureUtility(h);
      }
    e.removeFromQueue(t);
  }
};
qn.checkTextureUtility = function(t) {
  t.invalidatedWidth >= h3e * t.width && this.retireTexture(t);
};
qn.checkTextureFullness = function(t) {
  var e = this, r = e.getTextureQueue(t.height);
  t.usedWidth / t.width > d3e && t.fullnessChecks >= f3e ? Ql(r, t) : t.fullnessChecks++;
};
qn.retireTexture = function(t) {
  var e = this, r = t.height, n = e.getTextureQueue(r), i = this.lookup;
  Ql(n, t), t.retired = !0;
  for (var a = t.eleCaches, s = 0; s < a.length; s++) {
    var o = a[s];
    i.deleteCache(o.key, o.level);
  }
  Qk(a);
  var l = e.getRetiredTextureQueue(r);
  l.push(t);
};
qn.addTexture = function(t, e) {
  var r = this, n = r.getTextureQueue(t), i = {};
  return n.push(i), i.eleCaches = [], i.height = t, i.width = Math.max(l3e, e), i.usedWidth = 0, i.invalidatedWidth = 0, i.fullnessChecks = 0, i.canvas = r.renderer.makeOffscreenCanvas(i.width, i.height), i.context = i.canvas.getContext("2d"), i;
};
qn.recycleTexture = function(t, e) {
  for (var r = this, n = r.getTextureQueue(t), i = r.getRetiredTextureQueue(t), a = 0; a < i.length; a++) {
    var s = i[a];
    if (s.width >= e)
      return s.retired = !1, s.usedWidth = 0, s.invalidatedWidth = 0, s.fullnessChecks = 0, Qk(s.eleCaches), s.context.setTransform(1, 0, 0, 1, 0, 0), s.context.clearRect(0, 0, s.width, s.height), Ql(i, s), n.push(s), s;
  }
};
qn.queueElement = function(t, e) {
  var r = this, n = r.getElementQueue(), i = r.getElementKeyToQueue(), a = this.getKey(t), s = i[a];
  if (s)
    s.level = Math.max(s.level, e), s.eles.merge(t), s.reqs++, n.updateItem(s);
  else {
    var o = {
      eles: t.spawn().merge(t),
      level: e,
      reqs: 1,
      key: a
    };
    n.push(o), i[a] = o;
  }
};
qn.dequeue = function(t) {
  for (var e = this, r = e.getElementQueue(), n = e.getElementKeyToQueue(), i = [], a = e.lookup, s = 0; s < x3e && r.size() > 0; s++) {
    var o = r.pop(), l = o.key, u = o.eles[0], h = a.hasCache(u, o.level);
    if (n[l] = null, h)
      continue;
    i.push(o);
    var d = e.getBoundingBox(u);
    e.getElement(u, d, t, o.level, Uh.dequeue);
  }
  return i;
};
qn.removeFromQueue = function(t) {
  var e = this, r = e.getElementQueue(), n = e.getElementKeyToQueue(), i = this.getKey(t), a = n[i];
  a != null && (a.eles.length === 1 ? (a.reqs = Kk, r.updateItem(a), r.pop(), n[i] = null) : a.eles.unmerge(t));
};
qn.onDequeue = function(t) {
  this.onDequeues.push(t);
};
qn.offDequeue = function(t) {
  Ql(this.onDequeues, t);
};
qn.setupDequeueing = OU.setupDequeueing({
  deqRedrawThreshold: y3e,
  deqCost: p3e,
  deqAvgCost: g3e,
  deqNoDrawCost: m3e,
  deqFastCost: v3e,
  deq: function(e, r, n) {
    return e.dequeue(r, n);
  },
  onDeqd: function(e, r) {
    for (var n = 0; n < e.onDequeues.length; n++) {
      var i = e.onDequeues[n];
      i(r);
    }
  },
  shouldRedraw: function(e, r, n, i) {
    for (var a = 0; a < r.length; a++)
      for (var s = r[a].eles, o = 0; o < s.length; o++) {
        var l = s[o].boundingBox();
        if (tS(l, i))
          return !0;
      }
    return !1;
  },
  priority: function(e) {
    return e.renderer.beforeRenderPriorities.eleTxrDeq;
  }
});
var w3e = 1, tp = -4, Dy = 2, T3e = 3.99, E3e = 50, k3e = 50, S3e = 0.15, C3e = 0.1, A3e = 0.9, _3e = 0.9, L3e = 1, mL = 250, R3e = 4e3 * 4e3, vL = 32767, M3e = !0, BU = function(e) {
  var r = this, n = r.renderer = e, i = n.cy;
  r.layersByLevel = {}, r.firstGet = !0, r.lastInvalidationTime = nl() - 2 * mL, r.skipping = !1, r.eleTxrDeqs = i.collection(), r.scheduleElementRefinement = Ag(function() {
    r.refineElementTextures(r.eleTxrDeqs), r.eleTxrDeqs.unmerge(r.eleTxrDeqs);
  }, k3e), n.beforeRender(function(s, o) {
    o - r.lastInvalidationTime <= mL ? r.skipping = !0 : r.skipping = !1;
  }, n.beforeRenderPriorities.lyrTxrSkip);
  var a = function(o, l) {
    return l.reqs - o.reqs;
  };
  r.layersQueue = new _g(a), r.setupDequeueing();
}, pi = BU.prototype, yL = 0, N3e = Math.pow(2, 53) - 1;
pi.makeLayer = function(t, e) {
  var r = Math.pow(2, e), n = Math.ceil(t.w * r), i = Math.ceil(t.h * r), a = this.renderer.makeOffscreenCanvas(n, i), s = {
    id: yL = ++yL % N3e,
    bb: t,
    level: e,
    width: n,
    height: i,
    canvas: a,
    context: a.getContext("2d"),
    eles: [],
    elesQueue: [],
    reqs: 0
  }, o = s.context, l = -s.bb.x1, u = -s.bb.y1;
  return o.scale(r, r), o.translate(l, u), s;
};
pi.getLayers = function(t, e, r) {
  var n = this, i = n.renderer, a = i.cy, s = a.zoom(), o = n.firstGet;
  if (n.firstGet = !1, r == null) {
    if (r = Math.ceil(Jk(s * e)), r < tp)
      r = tp;
    else if (s >= T3e || r > Dy)
      return null;
  }
  n.validateLayersElesOrdering(r, t);
  var l = n.layersByLevel, u = Math.pow(2, r), h = l[r] = l[r] || [], d, f = n.levelIsComplete(r, t), p, g = function() {
    var R = function(M) {
      if (n.validateLayersElesOrdering(M, t), n.levelIsComplete(M, t))
        return p = l[M], !0;
    }, _ = function(M) {
      if (!p)
        for (var N = r + M; tp <= N && N <= Dy && !R(N); N += M)
          ;
    };
    _(1), _(-1);
    for (var O = h.length - 1; O >= 0; O--) {
      var P = h[O];
      P.invalid && Ql(h, P);
    }
  };
  if (!f)
    g();
  else
    return h;
  var m = function() {
    if (!d) {
      d = qi();
      for (var R = 0; R < t.length; R++)
        L2e(d, t[R].boundingBox());
    }
    return d;
  }, v = function(R) {
    R = R || {};
    var _ = R.after;
    m();
    var O = Math.ceil(d.w * u), P = Math.ceil(d.h * u);
    if (O > vL || P > vL)
      return null;
    var S = O * P;
    if (S > R3e)
      return null;
    var M = n.makeLayer(d, r);
    if (_ != null) {
      var N = h.indexOf(_) + 1;
      h.splice(N, 0, M);
    } else (R.insert === void 0 || R.insert) && h.unshift(M);
    return M;
  };
  if (n.skipping && !o)
    return null;
  for (var y = null, b = t.length / w3e, w = !o, T = 0; T < t.length; T++) {
    var E = t[T], L = E._private.rscratch, k = L.imgLayerCaches = L.imgLayerCaches || {}, C = k[r];
    if (C) {
      y = C;
      continue;
    }
    if ((!y || y.eles.length >= b || !MV(y.bb, E.boundingBox())) && (y = v({
      insert: !0,
      after: y
    }), !y))
      return null;
    p || w ? n.queueLayer(y, E) : n.drawEleInLayer(y, E, r, e), y.eles.push(E), k[r] = y;
  }
  return p || (w ? null : h);
};
pi.getEleLevelForLayerLevel = function(t, e) {
  return t;
};
pi.drawEleInLayer = function(t, e, r, n) {
  var i = this, a = this.renderer, s = t.context, o = e.boundingBox();
  o.w === 0 || o.h === 0 || !e.visible() || (r = i.getEleLevelForLayerLevel(r, n), a.setImgSmoothing(s, !1), a.drawCachedElement(s, e, null, null, r, M3e), a.setImgSmoothing(s, !0));
};
pi.levelIsComplete = function(t, e) {
  var r = this, n = r.layersByLevel[t];
  if (!n || n.length === 0)
    return !1;
  for (var i = 0, a = 0; a < n.length; a++) {
    var s = n[a];
    if (s.reqs > 0 || s.invalid)
      return !1;
    i += s.eles.length;
  }
  return i === e.length;
};
pi.validateLayersElesOrdering = function(t, e) {
  var r = this.layersByLevel[t];
  if (r)
    for (var n = 0; n < r.length; n++) {
      for (var i = r[n], a = -1, s = 0; s < e.length; s++)
        if (i.eles[0] === e[s]) {
          a = s;
          break;
        }
      if (a < 0) {
        this.invalidateLayer(i);
        continue;
      }
      for (var o = a, s = 0; s < i.eles.length; s++)
        if (i.eles[s] !== e[o + s]) {
          this.invalidateLayer(i);
          break;
        }
    }
};
pi.updateElementsInLayers = function(t, e) {
  for (var r = this, n = Eg(t[0]), i = 0; i < t.length; i++)
    for (var a = n ? null : t[i], s = n ? t[i] : t[i].ele, o = s._private.rscratch, l = o.imgLayerCaches = o.imgLayerCaches || {}, u = tp; u <= Dy; u++) {
      var h = l[u];
      h && (a && r.getEleLevelForLayerLevel(h.level) !== a.level || e(h, s, a));
    }
};
pi.haveLayers = function() {
  for (var t = this, e = !1, r = tp; r <= Dy; r++) {
    var n = t.layersByLevel[r];
    if (n && n.length > 0) {
      e = !0;
      break;
    }
  }
  return e;
};
pi.invalidateElements = function(t) {
  var e = this;
  t.length !== 0 && (e.lastInvalidationTime = nl(), !(t.length === 0 || !e.haveLayers()) && e.updateElementsInLayers(t, function(n, i, a) {
    e.invalidateLayer(n);
  }));
};
pi.invalidateLayer = function(t) {
  if (this.lastInvalidationTime = nl(), !t.invalid) {
    var e = t.level, r = t.eles, n = this.layersByLevel[e];
    Ql(n, t), t.elesQueue = [], t.invalid = !0, t.replacement && (t.replacement.invalid = !0);
    for (var i = 0; i < r.length; i++) {
      var a = r[i]._private.rscratch.imgLayerCaches;
      a && (a[e] = null);
    }
  }
};
pi.refineElementTextures = function(t) {
  var e = this;
  e.updateElementsInLayers(t, function(n, i, a) {
    var s = n.replacement;
    if (s || (s = n.replacement = e.makeLayer(n.bb, n.level), s.replaces = n, s.eles = n.eles), !s.reqs)
      for (var o = 0; o < s.eles.length; o++)
        e.queueLayer(s, s.eles[o]);
  });
};
pi.enqueueElementRefinement = function(t) {
  this.eleTxrDeqs.merge(t), this.scheduleElementRefinement();
};
pi.queueLayer = function(t, e) {
  var r = this, n = r.layersQueue, i = t.elesQueue, a = i.hasId = i.hasId || {};
  if (!t.replacement) {
    if (e) {
      if (a[e.id()])
        return;
      i.push(e), a[e.id()] = !0;
    }
    t.reqs ? (t.reqs++, n.updateItem(t)) : (t.reqs = 1, n.push(t));
  }
};
pi.dequeue = function(t) {
  for (var e = this, r = e.layersQueue, n = [], i = 0; i < L3e && r.size() !== 0; ) {
    var a = r.peek();
    if (a.replacement) {
      r.pop();
      continue;
    }
    if (a.replaces && a !== a.replaces.replacement) {
      r.pop();
      continue;
    }
    if (a.invalid) {
      r.pop();
      continue;
    }
    var s = a.elesQueue.shift();
    s && (e.drawEleInLayer(a, s, a.level, t), i++), n.length === 0 && n.push(!0), a.elesQueue.length === 0 && (r.pop(), a.reqs = 0, a.replaces && e.applyLayerReplacement(a), e.requestRedraw());
  }
  return n;
};
pi.applyLayerReplacement = function(t) {
  var e = this, r = e.layersByLevel[t.level], n = t.replaces, i = r.indexOf(n);
  if (!(i < 0 || n.invalid)) {
    r[i] = t;
    for (var a = 0; a < t.eles.length; a++) {
      var s = t.eles[a]._private, o = s.imgLayerCaches = s.imgLayerCaches || {};
      o && (o[t.level] = t);
    }
    e.requestRedraw();
  }
};
pi.requestRedraw = Ag(function() {
  var t = this.renderer;
  t.redrawHint("eles", !0), t.redrawHint("drag", !0), t.redraw();
}, 100);
pi.setupDequeueing = OU.setupDequeueing({
  deqRedrawThreshold: E3e,
  deqCost: S3e,
  deqAvgCost: C3e,
  deqNoDrawCost: A3e,
  deqFastCost: _3e,
  deq: function(e, r) {
    return e.dequeue(r);
  },
  onDeqd: Zk,
  shouldRedraw: SV,
  priority: function(e) {
    return e.renderer.beforeRenderPriorities.lyrTxrDeq;
  }
});
var FU = {}, xL;
function I3e(t, e) {
  for (var r = 0; r < e.length; r++) {
    var n = e[r];
    t.lineTo(n.x, n.y);
  }
}
function D3e(t, e, r) {
  for (var n, i = 0; i < e.length; i++) {
    var a = e[i];
    i === 0 && (n = a), t.lineTo(a.x, a.y);
  }
  t.quadraticCurveTo(r.x, r.y, n.x, n.y);
}
function bL(t, e, r) {
  t.beginPath && t.beginPath();
  for (var n = e, i = 0; i < n.length; i++) {
    var a = n[i];
    t.lineTo(a.x, a.y);
  }
  var s = r, o = r[0];
  t.moveTo(o.x, o.y);
  for (var i = 1; i < s.length; i++) {
    var a = s[i];
    t.lineTo(a.x, a.y);
  }
  t.closePath && t.closePath();
}
function O3e(t, e, r, n, i) {
  t.beginPath && t.beginPath(), t.arc(r, n, i, 0, Math.PI * 2, !1);
  var a = e, s = a[0];
  t.moveTo(s.x, s.y);
  for (var o = 0; o < a.length; o++) {
    var l = a[o];
    t.lineTo(l.x, l.y);
  }
  t.closePath && t.closePath();
}
function P3e(t, e, r, n) {
  t.arc(e, r, n, 0, Math.PI * 2, !1);
}
FU.arrowShapeImpl = function(t) {
  return (xL || (xL = {
    polygon: I3e,
    "triangle-backcurve": D3e,
    "triangle-tee": bL,
    "circle-triangle": O3e,
    "triangle-cross": bL,
    circle: P3e
  }))[t];
};
var mo = {};
mo.drawElement = function(t, e, r, n, i, a) {
  var s = this;
  e.isNode() ? s.drawNode(t, e, r, n, i, a) : s.drawEdge(t, e, r, n, i, a);
};
mo.drawElementOverlay = function(t, e) {
  var r = this;
  e.isNode() ? r.drawNodeOverlay(t, e) : r.drawEdgeOverlay(t, e);
};
mo.drawElementUnderlay = function(t, e) {
  var r = this;
  e.isNode() ? r.drawNodeUnderlay(t, e) : r.drawEdgeUnderlay(t, e);
};
mo.drawCachedElementPortion = function(t, e, r, n, i, a, s, o) {
  var l = this, u = r.getBoundingBox(e);
  if (!(u.w === 0 || u.h === 0)) {
    var h = r.getElement(e, u, n, i, a);
    if (h != null) {
      var d = o(l, e);
      if (d === 0)
        return;
      var f = s(l, e), p = u.x1, g = u.y1, m = u.w, v = u.h, y, b, w, T, E;
      if (f !== 0) {
        var L = r.getRotationPoint(e);
        w = L.x, T = L.y, t.translate(w, T), t.rotate(f), E = l.getImgSmoothing(t), E || l.setImgSmoothing(t, !0);
        var k = r.getRotationOffset(e);
        y = k.x, b = k.y;
      } else
        y = p, b = g;
      var C;
      d !== 1 && (C = t.globalAlpha, t.globalAlpha = C * d), t.drawImage(h.texture.canvas, h.x, 0, h.width, h.height, y, b, m, v), d !== 1 && (t.globalAlpha = C), f !== 0 && (t.rotate(-f), t.translate(-w, -T), E || l.setImgSmoothing(t, !1));
    } else
      r.drawElement(t, e);
  }
};
var B3e = function() {
  return 0;
}, F3e = function(e, r) {
  return e.getTextAngle(r, null);
}, $3e = function(e, r) {
  return e.getTextAngle(r, "source");
}, z3e = function(e, r) {
  return e.getTextAngle(r, "target");
}, G3e = function(e, r) {
  return r.effectiveOpacity();
}, r5 = function(e, r) {
  return r.pstyle("text-opacity").pfValue * r.effectiveOpacity();
};
mo.drawCachedElement = function(t, e, r, n, i, a) {
  var s = this, o = s.data, l = o.eleTxrCache, u = o.lblTxrCache, h = o.slbTxrCache, d = o.tlbTxrCache, f = e.boundingBox(), p = a === !0 ? l.reasons.highQuality : null;
  if (!(f.w === 0 || f.h === 0 || !e.visible()) && (!n || tS(f, n))) {
    var g = e.isEdge(), m = e.element()._private.rscratch.badLine;
    s.drawElementUnderlay(t, e), s.drawCachedElementPortion(t, e, l, r, i, p, B3e, G3e), (!g || !m) && s.drawCachedElementPortion(t, e, u, r, i, p, F3e, r5), g && !m && (s.drawCachedElementPortion(t, e, h, r, i, p, $3e, r5), s.drawCachedElementPortion(t, e, d, r, i, p, z3e, r5)), s.drawElementOverlay(t, e);
  }
};
mo.drawElements = function(t, e) {
  for (var r = this, n = 0; n < e.length; n++) {
    var i = e[n];
    r.drawElement(t, i);
  }
};
mo.drawCachedElements = function(t, e, r, n) {
  for (var i = this, a = 0; a < e.length; a++) {
    var s = e[a];
    i.drawCachedElement(t, s, r, n);
  }
};
mo.drawCachedNodes = function(t, e, r, n) {
  for (var i = this, a = 0; a < e.length; a++) {
    var s = e[a];
    s.isNode() && i.drawCachedElement(t, s, r, n);
  }
};
mo.drawLayeredElements = function(t, e, r, n) {
  var i = this, a = i.data.lyrTxrCache.getLayers(e, r);
  if (a)
    for (var s = 0; s < a.length; s++) {
      var o = a[s], l = o.bb;
      l.w === 0 || l.h === 0 || t.drawImage(o.canvas, l.x1, l.y1, l.w, l.h);
    }
  else
    i.drawCachedElements(t, e, r, n);
};
var pl = {};
pl.drawEdge = function(t, e, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, a = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !0, s = this, o = e._private.rscratch;
  if (!(a && !e.visible()) && !(o.badLine || o.allpts == null || isNaN(o.allpts[0]))) {
    var l;
    r && (l = r, t.translate(-l.x1, -l.y1));
    var u = a ? e.pstyle("opacity").value : 1, h = a ? e.pstyle("line-opacity").value : 1, d = e.pstyle("curve-style").value, f = e.pstyle("line-style").value, p = e.pstyle("width").pfValue, g = e.pstyle("line-cap").value, m = e.pstyle("line-outline-width").value, v = e.pstyle("line-outline-color").value, y = u * h, b = u * h, w = function() {
      var M = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : y;
      d === "straight-triangle" ? (s.eleStrokeStyle(t, e, M), s.drawEdgeTrianglePath(e, t, o.allpts)) : (t.lineWidth = p, t.lineCap = g, s.eleStrokeStyle(t, e, M), s.drawEdgePath(e, t, o.allpts, f), t.lineCap = "butt");
    }, T = function() {
      var M = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : y;
      if (t.lineWidth = p + m, t.lineCap = g, m > 0)
        s.colorStrokeStyle(t, v[0], v[1], v[2], M);
      else {
        t.lineCap = "butt";
        return;
      }
      d === "straight-triangle" ? s.drawEdgeTrianglePath(e, t, o.allpts) : (s.drawEdgePath(e, t, o.allpts, f), t.lineCap = "butt");
    }, E = function() {
      i && s.drawEdgeOverlay(t, e);
    }, L = function() {
      i && s.drawEdgeUnderlay(t, e);
    }, k = function() {
      var M = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : b;
      s.drawArrowheads(t, e, M);
    }, C = function() {
      s.drawElementText(t, e, null, n);
    };
    t.lineJoin = "round";
    var A = e.pstyle("ghost").value === "yes";
    if (A) {
      var R = e.pstyle("ghost-offset-x").pfValue, _ = e.pstyle("ghost-offset-y").pfValue, O = e.pstyle("ghost-opacity").value, P = y * O;
      t.translate(R, _), w(P), k(P), t.translate(-R, -_);
    } else
      T();
    L(), w(), k(), E(), C(), r && t.translate(l.x1, l.y1);
  }
};
var $U = function(e) {
  if (!["overlay", "underlay"].includes(e))
    throw new Error("Invalid state");
  return function(r, n) {
    if (n.visible()) {
      var i = n.pstyle("".concat(e, "-opacity")).value;
      if (i !== 0) {
        var a = this, s = a.usePaths(), o = n._private.rscratch, l = n.pstyle("".concat(e, "-padding")).pfValue, u = 2 * l, h = n.pstyle("".concat(e, "-color")).value;
        r.lineWidth = u, o.edgeType === "self" && !s ? r.lineCap = "butt" : r.lineCap = "round", a.colorStrokeStyle(r, h[0], h[1], h[2], i), a.drawEdgePath(n, r, o.allpts, "solid");
      }
    }
  };
};
pl.drawEdgeOverlay = $U("overlay");
pl.drawEdgeUnderlay = $U("underlay");
pl.drawEdgePath = function(t, e, r, n) {
  var i = t._private.rscratch, a = e, s, o = !1, l = this.usePaths(), u = t.pstyle("line-dash-pattern").pfValue, h = t.pstyle("line-dash-offset").pfValue;
  if (l) {
    var d = r.join("$"), f = i.pathCacheKey && i.pathCacheKey === d;
    f ? (s = e = i.pathCache, o = !0) : (s = e = new Path2D(), i.pathCacheKey = d, i.pathCache = s);
  }
  if (a.setLineDash)
    switch (n) {
      case "dotted":
        a.setLineDash([1, 1]);
        break;
      case "dashed":
        a.setLineDash(u), a.lineDashOffset = h;
        break;
      case "solid":
        a.setLineDash([]);
        break;
    }
  if (!o && !i.badLine)
    switch (e.beginPath && e.beginPath(), e.moveTo(r[0], r[1]), i.edgeType) {
      case "bezier":
      case "self":
      case "compound":
      case "multibezier":
        for (var p = 2; p + 3 < r.length; p += 4)
          e.quadraticCurveTo(r[p], r[p + 1], r[p + 2], r[p + 3]);
        break;
      case "straight":
      case "haystack":
        for (var g = 2; g + 1 < r.length; g += 2)
          e.lineTo(r[g], r[g + 1]);
        break;
      case "segments":
        if (i.isRound) {
          var m = oa(i.roundCorners), v;
          try {
            for (m.s(); !(v = m.n()).done; ) {
              var y = v.value;
              AU(e, y);
            }
          } catch (w) {
            m.e(w);
          } finally {
            m.f();
          }
          e.lineTo(r[r.length - 2], r[r.length - 1]);
        } else
          for (var b = 2; b + 1 < r.length; b += 2)
            e.lineTo(r[b], r[b + 1]);
        break;
    }
  e = a, l ? e.stroke(s) : e.stroke(), e.setLineDash && e.setLineDash([]);
};
pl.drawEdgeTrianglePath = function(t, e, r) {
  e.fillStyle = e.strokeStyle;
  for (var n = t.pstyle("width").pfValue, i = 0; i + 1 < r.length; i += 2) {
    var a = [r[i + 2] - r[i], r[i + 3] - r[i + 1]], s = Math.sqrt(a[0] * a[0] + a[1] * a[1]), o = [a[1] / s, -a[0] / s], l = [o[0] * n / 2, o[1] * n / 2];
    e.beginPath(), e.moveTo(r[i] - l[0], r[i + 1] - l[1]), e.lineTo(r[i] + l[0], r[i + 1] + l[1]), e.lineTo(r[i + 2], r[i + 3]), e.closePath(), e.fill();
  }
};
pl.drawArrowheads = function(t, e, r) {
  var n = e._private.rscratch, i = n.edgeType === "haystack";
  i || this.drawArrowhead(t, e, "source", n.arrowStartX, n.arrowStartY, n.srcArrowAngle, r), this.drawArrowhead(t, e, "mid-target", n.midX, n.midY, n.midtgtArrowAngle, r), this.drawArrowhead(t, e, "mid-source", n.midX, n.midY, n.midsrcArrowAngle, r), i || this.drawArrowhead(t, e, "target", n.arrowEndX, n.arrowEndY, n.tgtArrowAngle, r);
};
pl.drawArrowhead = function(t, e, r, n, i, a, s) {
  if (!(isNaN(n) || n == null || isNaN(i) || i == null || isNaN(a) || a == null)) {
    var o = this, l = e.pstyle(r + "-arrow-shape").value;
    if (l !== "none") {
      var u = e.pstyle(r + "-arrow-fill").value === "hollow" ? "both" : "filled", h = e.pstyle(r + "-arrow-fill").value, d = e.pstyle("width").pfValue, f = e.pstyle(r + "-arrow-width"), p = f.value === "match-line" ? d : f.pfValue;
      f.units === "%" && (p *= d);
      var g = e.pstyle("opacity").value;
      s === void 0 && (s = g);
      var m = t.globalCompositeOperation;
      (s !== 1 || h === "hollow") && (t.globalCompositeOperation = "destination-out", o.colorFillStyle(t, 255, 255, 255, 1), o.colorStrokeStyle(t, 255, 255, 255, 1), o.drawArrowShape(e, t, u, d, l, p, n, i, a), t.globalCompositeOperation = m);
      var v = e.pstyle(r + "-arrow-color").value;
      o.colorFillStyle(t, v[0], v[1], v[2], s), o.colorStrokeStyle(t, v[0], v[1], v[2], s), o.drawArrowShape(e, t, h, d, l, p, n, i, a);
    }
  }
};
pl.drawArrowShape = function(t, e, r, n, i, a, s, o, l) {
  var u = this, h = this.usePaths() && i !== "triangle-cross", d = !1, f, p = e, g = {
    x: s,
    y: o
  }, m = t.pstyle("arrow-scale").value, v = this.getArrowWidth(n, m), y = u.arrowShapes[i];
  if (h) {
    var b = u.arrowPathCache = u.arrowPathCache || [], w = Cu(i), T = b[w];
    T != null ? (f = e = T, d = !0) : (f = e = new Path2D(), b[w] = f);
  }
  d || (e.beginPath && e.beginPath(), h ? y.draw(e, 1, 0, {
    x: 0,
    y: 0
  }, 1) : y.draw(e, v, l, g, n), e.closePath && e.closePath()), e = p, h && (e.translate(s, o), e.rotate(l), e.scale(v, v)), (r === "filled" || r === "both") && (h ? e.fill(f) : e.fill()), (r === "hollow" || r === "both") && (e.lineWidth = a / (h ? v : 1), e.lineJoin = "miter", h ? e.stroke(f) : e.stroke()), h && (e.scale(1 / v, 1 / v), e.rotate(-l), e.translate(-s, -o));
};
var gS = {};
gS.safeDrawImage = function(t, e, r, n, i, a, s, o, l, u) {
  if (!(i <= 0 || a <= 0 || l <= 0 || u <= 0))
    try {
      t.drawImage(e, r, n, i, a, s, o, l, u);
    } catch (h) {
      Lr(h);
    }
};
gS.drawInscribedImage = function(t, e, r, n, i) {
  var a = this, s = r.position(), o = s.x, l = s.y, u = r.cy().style(), h = u.getIndexedStyle.bind(u), d = h(r, "background-fit", "value", n), f = h(r, "background-repeat", "value", n), p = r.width(), g = r.height(), m = r.padding() * 2, v = p + (h(r, "background-width-relative-to", "value", n) === "inner" ? 0 : m), y = g + (h(r, "background-height-relative-to", "value", n) === "inner" ? 0 : m), b = r._private.rscratch, w = h(r, "background-clip", "value", n), T = w === "node", E = h(r, "background-image-opacity", "value", n) * i, L = h(r, "background-image-smoothing", "value", n), k = r.pstyle("corner-radius").value;
  k !== "auto" && (k = r.pstyle("corner-radius").pfValue);
  var C = e.width || e.cachedW, A = e.height || e.cachedH;
  (C == null || A == null) && (document.body.appendChild(e), C = e.cachedW = e.width || e.offsetWidth, A = e.cachedH = e.height || e.offsetHeight, document.body.removeChild(e));
  var R = C, _ = A;
  if (h(r, "background-width", "value", n) !== "auto" && (h(r, "background-width", "units", n) === "%" ? R = h(r, "background-width", "pfValue", n) * v : R = h(r, "background-width", "pfValue", n)), h(r, "background-height", "value", n) !== "auto" && (h(r, "background-height", "units", n) === "%" ? _ = h(r, "background-height", "pfValue", n) * y : _ = h(r, "background-height", "pfValue", n)), !(R === 0 || _ === 0)) {
    if (d === "contain") {
      var O = Math.min(v / R, y / _);
      R *= O, _ *= O;
    } else if (d === "cover") {
      var O = Math.max(v / R, y / _);
      R *= O, _ *= O;
    }
    var P = o - v / 2, S = h(r, "background-position-x", "units", n), M = h(r, "background-position-x", "pfValue", n);
    S === "%" ? P += (v - R) * M : P += M;
    var N = h(r, "background-offset-x", "units", n), D = h(r, "background-offset-x", "pfValue", n);
    N === "%" ? P += (v - R) * D : P += D;
    var I = l - y / 2, B = h(r, "background-position-y", "units", n), z = h(r, "background-position-y", "pfValue", n);
    B === "%" ? I += (y - _) * z : I += z;
    var F = h(r, "background-offset-y", "units", n), V = h(r, "background-offset-y", "pfValue", n);
    F === "%" ? I += (y - _) * V : I += V, b.pathCache && (P -= o, I -= l, o = 0, l = 0);
    var H = t.globalAlpha;
    t.globalAlpha = E;
    var J = a.getImgSmoothing(t), q = !1;
    if (L === "no" && J ? (a.setImgSmoothing(t, !1), q = !0) : L === "yes" && !J && (a.setImgSmoothing(t, !0), q = !0), f === "no-repeat")
      T && (t.save(), b.pathCache ? t.clip(b.pathCache) : (a.nodeShapes[a.getNodeShape(r)].draw(t, o, l, v, y, k, b), t.clip())), a.safeDrawImage(t, e, 0, 0, C, A, P, I, R, _), T && t.restore();
    else {
      var ae = t.createPattern(e, f);
      t.fillStyle = ae, a.nodeShapes[a.getNodeShape(r)].draw(t, o, l, v, y, k, b), t.translate(P, I), t.fill(), t.translate(-P, -I);
    }
    t.globalAlpha = H, q && a.setImgSmoothing(t, J);
  }
};
var th = {};
th.eleTextBiggerThanMin = function(t, e) {
  if (!e) {
    var r = t.cy().zoom(), n = this.getPixelRatio(), i = Math.ceil(Jk(r * n));
    e = Math.pow(2, i);
  }
  var a = t.pstyle("font-size").pfValue * e, s = t.pstyle("min-zoomed-font-size").pfValue;
  return !(a < s);
};
th.drawElementText = function(t, e, r, n, i) {
  var a = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !0, s = this;
  if (n == null) {
    if (a && !s.eleTextBiggerThanMin(e))
      return;
  } else if (n === !1)
    return;
  if (e.isNode()) {
    var o = e.pstyle("label");
    if (!o || !o.value)
      return;
    var l = s.getLabelJustification(e);
    t.textAlign = l, t.textBaseline = "bottom";
  } else {
    var u = e.element()._private.rscratch.badLine, h = e.pstyle("label"), d = e.pstyle("source-label"), f = e.pstyle("target-label");
    if (u || (!h || !h.value) && (!d || !d.value) && (!f || !f.value))
      return;
    t.textAlign = "center", t.textBaseline = "bottom";
  }
  var p = !r, g;
  r && (g = r, t.translate(-g.x1, -g.y1)), i == null ? (s.drawText(t, e, null, p, a), e.isEdge() && (s.drawText(t, e, "source", p, a), s.drawText(t, e, "target", p, a))) : s.drawText(t, e, i, p, a), r && t.translate(g.x1, g.y1);
};
th.getFontCache = function(t) {
  var e;
  this.fontCaches = this.fontCaches || [];
  for (var r = 0; r < this.fontCaches.length; r++)
    if (e = this.fontCaches[r], e.context === t)
      return e;
  return e = {
    context: t
  }, this.fontCaches.push(e), e;
};
th.setupTextStyle = function(t, e) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, n = e.pstyle("font-style").strValue, i = e.pstyle("font-size").pfValue + "px", a = e.pstyle("font-family").strValue, s = e.pstyle("font-weight").strValue, o = r ? e.effectiveOpacity() * e.pstyle("text-opacity").value : 1, l = e.pstyle("text-outline-opacity").value * o, u = e.pstyle("color").value, h = e.pstyle("text-outline-color").value;
  t.font = n + " " + s + " " + i + " " + a, t.lineJoin = "round", this.colorFillStyle(t, u[0], u[1], u[2], o), this.colorStrokeStyle(t, h[0], h[1], h[2], l);
};
function V3e(t, e, r, n, i) {
  var a = Math.min(n, i), s = a / 2, o = e + n / 2, l = r + i / 2;
  t.beginPath(), t.arc(o, l, s, 0, Math.PI * 2), t.closePath();
}
function wL(t, e, r, n, i) {
  var a = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 5, s = Math.min(a, n / 2, i / 2);
  t.beginPath(), t.moveTo(e + s, r), t.lineTo(e + n - s, r), t.quadraticCurveTo(e + n, r, e + n, r + s), t.lineTo(e + n, r + i - s), t.quadraticCurveTo(e + n, r + i, e + n - s, r + i), t.lineTo(e + s, r + i), t.quadraticCurveTo(e, r + i, e, r + i - s), t.lineTo(e, r + s), t.quadraticCurveTo(e, r, e + s, r), t.closePath();
}
th.getTextAngle = function(t, e) {
  var r, n = t._private, i = n.rscratch, a = e ? e + "-" : "", s = t.pstyle(a + "text-rotation");
  if (s.strValue === "autorotate") {
    var o = na(i, "labelAngle", e);
    r = t.isEdge() ? o : 0;
  } else s.strValue === "none" ? r = 0 : r = s.pfValue;
  return r;
};
th.drawText = function(t, e, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, a = e._private, s = a.rscratch, o = i ? e.effectiveOpacity() : 1;
  if (!(i && (o === 0 || e.pstyle("text-opacity").value === 0))) {
    r === "main" && (r = null);
    var l = na(s, "labelX", r), u = na(s, "labelY", r), h, d, f = this.getLabelText(e, r);
    if (f != null && f !== "" && !isNaN(l) && !isNaN(u)) {
      this.setupTextStyle(t, e, i);
      var p = r ? r + "-" : "", g = na(s, "labelWidth", r), m = na(s, "labelHeight", r), v = e.pstyle(p + "text-margin-x").pfValue, y = e.pstyle(p + "text-margin-y").pfValue, b = e.isEdge(), w = e.pstyle("text-halign").value, T = e.pstyle("text-valign").value;
      b && (w = "center", T = "center"), l += v, u += y;
      var E;
      switch (n ? E = this.getTextAngle(e, r) : E = 0, E !== 0 && (h = l, d = u, t.translate(h, d), t.rotate(E), l = 0, u = 0), T) {
        case "top":
          break;
        case "center":
          u += m / 2;
          break;
        case "bottom":
          u += m;
          break;
      }
      var L = e.pstyle("text-background-opacity").value, k = e.pstyle("text-border-opacity").value, C = e.pstyle("text-border-width").pfValue, A = e.pstyle("text-background-padding").pfValue, R = e.pstyle("text-background-shape").strValue, _ = R === "round-rectangle" || R === "roundrectangle", O = R === "circle", P = 2;
      if (L > 0 || C > 0 && k > 0) {
        var S = t.fillStyle, M = t.strokeStyle, N = t.lineWidth, D = e.pstyle("text-background-color").value, I = e.pstyle("text-border-color").value, B = e.pstyle("text-border-style").value, z = L > 0, F = C > 0 && k > 0, V = l - A;
        switch (w) {
          case "left":
            V -= g;
            break;
          case "center":
            V -= g / 2;
            break;
        }
        var H = u - m - A, J = g + 2 * A, q = m + 2 * A;
        if (z && (t.fillStyle = "rgba(".concat(D[0], ",").concat(D[1], ",").concat(D[2], ",").concat(L * o, ")")), F && (t.strokeStyle = "rgba(".concat(I[0], ",").concat(I[1], ",").concat(I[2], ",").concat(k * o, ")"), t.lineWidth = C, t.setLineDash))
          switch (B) {
            case "dotted":
              t.setLineDash([1, 1]);
              break;
            case "dashed":
              t.setLineDash([4, 2]);
              break;
            case "double":
              t.lineWidth = C / 4, t.setLineDash([]);
              break;
            default:
              t.setLineDash([]);
              break;
          }
        if (_ ? (t.beginPath(), wL(t, V, H, J, q, P)) : O ? (t.beginPath(), V3e(t, V, H, J, q)) : (t.beginPath(), t.rect(V, H, J, q)), z && t.fill(), F && t.stroke(), F && B === "double") {
          var ae = C / 2;
          t.beginPath(), _ ? wL(t, V + ae, H + ae, J - 2 * ae, q - 2 * ae, P) : t.rect(V + ae, H + ae, J - 2 * ae, q - 2 * ae), t.stroke();
        }
        t.fillStyle = S, t.strokeStyle = M, t.lineWidth = N, t.setLineDash && t.setLineDash([]);
      }
      var re = 2 * e.pstyle("text-outline-width").pfValue;
      if (re > 0 && (t.lineWidth = re), e.pstyle("text-wrap").value === "wrap") {
        var pe = na(s, "labelWrapCachedLines", r), K = na(s, "labelLineHeight", r), Z = g / 2, X = this.getLabelJustification(e);
        switch (X === "auto" || (w === "left" ? X === "left" ? l += -g : X === "center" && (l += -Z) : w === "center" ? X === "left" ? l += -Z : X === "right" && (l += Z) : w === "right" && (X === "center" ? l += Z : X === "right" && (l += g))), T) {
          case "top":
            u -= (pe.length - 1) * K;
            break;
          case "center":
          case "bottom":
            u -= (pe.length - 1) * K;
            break;
        }
        for (var Y = 0; Y < pe.length; Y++)
          re > 0 && t.strokeText(pe[Y], l, u), t.fillText(pe[Y], l, u), u += K;
      } else
        re > 0 && t.strokeText(f, l, u), t.fillText(f, l, u);
      E !== 0 && (t.rotate(-E), t.translate(-h, -d));
    }
  }
};
var xc = {};
xc.drawNode = function(t, e, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, a = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !0, s = this, o, l, u = e._private, h = u.rscratch, d = e.position();
  if (!(!mt(d.x) || !mt(d.y)) && !(a && !e.visible())) {
    var f = a ? e.effectiveOpacity() : 1, p = s.usePaths(), g, m = !1, v = e.padding();
    o = e.width() + 2 * v, l = e.height() + 2 * v;
    var y;
    r && (y = r, t.translate(-y.x1, -y.y1));
    for (var b = e.pstyle("background-image"), w = b.value, T = new Array(w.length), E = new Array(w.length), L = 0, k = 0; k < w.length; k++) {
      var C = w[k], A = T[k] = C != null && C !== "none";
      if (A) {
        var R = e.cy().style().getIndexedStyle(e, "background-image-crossorigin", "value", k);
        L++, E[k] = s.getCachedImage(C, R, function() {
          u.backgroundTimestamp = Date.now(), e.emitAndNotify("background");
        });
      }
    }
    var _ = e.pstyle("background-blacken").value, O = e.pstyle("border-width").pfValue, P = e.pstyle("background-opacity").value * f, S = e.pstyle("border-color").value, M = e.pstyle("border-style").value, N = e.pstyle("border-join").value, D = e.pstyle("border-cap").value, I = e.pstyle("border-position").value, B = e.pstyle("border-dash-pattern").pfValue, z = e.pstyle("border-dash-offset").pfValue, F = e.pstyle("border-opacity").value * f, V = e.pstyle("outline-width").pfValue, H = e.pstyle("outline-color").value, J = e.pstyle("outline-style").value, q = e.pstyle("outline-opacity").value * f, ae = e.pstyle("outline-offset").value, re = e.pstyle("corner-radius").value;
    re !== "auto" && (re = e.pstyle("corner-radius").pfValue);
    var pe = function() {
      var Q = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : P;
      s.eleFillStyle(t, e, Q);
    }, K = function() {
      var Q = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : F;
      s.colorStrokeStyle(t, S[0], S[1], S[2], Q);
    }, Z = function() {
      var Q = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : q;
      s.colorStrokeStyle(t, H[0], H[1], H[2], Q);
    }, X = function(Q, ce, $, oe) {
      var se = s.nodePathCache = s.nodePathCache || [], ge = kV($ === "polygon" ? $ + "," + oe.join(",") : $, "" + ce, "" + Q, "" + re), he = se[ge], be, Ce = !1;
      return he != null ? (be = he, Ce = !0, h.pathCache = be) : (be = new Path2D(), se[ge] = h.pathCache = be), {
        path: be,
        cacheHit: Ce
      };
    }, Y = e.pstyle("shape").strValue, ee = e.pstyle("shape-polygon-points").pfValue;
    if (p) {
      t.translate(d.x, d.y);
      var j = X(o, l, Y, ee);
      g = j.path, m = j.cacheHit;
    }
    var fe = function() {
      if (!m) {
        var Q = d;
        p && (Q = {
          x: 0,
          y: 0
        }), s.nodeShapes[s.getNodeShape(e)].draw(g || t, Q.x, Q.y, o, l, re, h);
      }
      p ? t.fill(g) : t.fill();
    }, te = function() {
      for (var Q = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : f, ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, $ = u.backgrounding, oe = 0, se = 0; se < E.length; se++) {
        var ge = e.cy().style().getIndexedStyle(e, "background-image-containment", "value", se);
        if (ce && ge === "over" || !ce && ge === "inside") {
          oe++;
          continue;
        }
        T[se] && E[se].complete && !E[se].error && (oe++, s.drawInscribedImage(t, E[se], e, se, Q));
      }
      u.backgrounding = oe !== L, $ !== u.backgrounding && e.updateStyle(!1);
    }, Ae = function() {
      var Q = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : f;
      s.hasPie(e) && (s.drawPie(t, e, ce), Q && (p || s.nodeShapes[s.getNodeShape(e)].draw(t, d.x, d.y, o, l, re, h)));
    }, W = function() {
      var Q = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : f;
      s.hasStripe(e) && (t.save(), p ? t.clip(h.pathCache) : (s.nodeShapes[s.getNodeShape(e)].draw(t, d.x, d.y, o, l, re, h), t.clip()), s.drawStripe(t, e, ce), t.restore(), Q && (p || s.nodeShapes[s.getNodeShape(e)].draw(t, d.x, d.y, o, l, re, h)));
    }, De = function() {
      var Q = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : f, ce = (_ > 0 ? _ : -_) * Q, $ = _ > 0 ? 0 : 255;
      _ !== 0 && (s.colorFillStyle(t, $, $, $, ce), p ? t.fill(g) : t.fill());
    }, ue = function() {
      if (O > 0) {
        if (t.lineWidth = O, t.lineCap = D, t.lineJoin = N, t.setLineDash)
          switch (M) {
            case "dotted":
              t.setLineDash([1, 1]);
              break;
            case "dashed":
              t.setLineDash(B), t.lineDashOffset = z;
              break;
            case "solid":
            case "double":
              t.setLineDash([]);
              break;
          }
        if (I !== "center") {
          if (t.save(), t.lineWidth *= 2, I === "inside")
            p ? t.clip(g) : t.clip();
          else {
            var Q = new Path2D();
            Q.rect(-o / 2 - O, -l / 2 - O, o + 2 * O, l + 2 * O), Q.addPath(g), t.clip(Q, "evenodd");
          }
          p ? t.stroke(g) : t.stroke(), t.restore();
        } else
          p ? t.stroke(g) : t.stroke();
        if (M === "double") {
          t.lineWidth = O / 3;
          var ce = t.globalCompositeOperation;
          t.globalCompositeOperation = "destination-out", p ? t.stroke(g) : t.stroke(), t.globalCompositeOperation = ce;
        }
        t.setLineDash && t.setLineDash([]);
      }
    }, ze = function() {
      if (V > 0) {
        if (t.lineWidth = V, t.lineCap = "butt", t.setLineDash)
          switch (J) {
            case "dotted":
              t.setLineDash([1, 1]);
              break;
            case "dashed":
              t.setLineDash([4, 2]);
              break;
            case "solid":
            case "double":
              t.setLineDash([]);
              break;
          }
        var Q = d;
        p && (Q = {
          x: 0,
          y: 0
        });
        var ce = s.getNodeShape(e), $ = O;
        I === "inside" && ($ = 0), I === "outside" && ($ *= 2);
        var oe = (o + $ + (V + ae)) / o, se = (l + $ + (V + ae)) / l, ge = o * oe, he = l * se, be = s.nodeShapes[ce].points, Ce;
        if (p) {
          var Te = X(ge, he, ce, be);
          Ce = Te.path;
        }
        if (ce === "ellipse")
          s.drawEllipsePath(Ce || t, Q.x, Q.y, ge, he);
        else if (["round-diamond", "round-heptagon", "round-hexagon", "round-octagon", "round-pentagon", "round-polygon", "round-triangle", "round-tag"].includes(ce)) {
          var Me = 0, Xe = 0, We = 0;
          ce === "round-diamond" ? Me = ($ + ae + V) * 1.4 : ce === "round-heptagon" ? (Me = ($ + ae + V) * 1.075, We = -($ / 2 + ae + V) / 35) : ce === "round-hexagon" ? Me = ($ + ae + V) * 1.12 : ce === "round-pentagon" ? (Me = ($ + ae + V) * 1.13, We = -($ / 2 + ae + V) / 15) : ce === "round-tag" ? (Me = ($ + ae + V) * 1.12, Xe = ($ / 2 + V + ae) * 0.07) : ce === "round-triangle" && (Me = ($ + ae + V) * (Math.PI / 2), We = -($ + ae / 2 + V) / Math.PI), Me !== 0 && (oe = (o + Me) / o, ge = o * oe, ["round-hexagon", "round-tag"].includes(ce) || (se = (l + Me) / l, he = l * se)), re = re === "auto" ? DV(ge, he) : re;
          for (var Ke = ge / 2, Ze = he / 2, Pe = re + ($ + V + ae) / 2, He = new Array(be.length / 2), ht = new Array(be.length / 2), st = 0; st < be.length / 2; st++)
            He[st] = {
              x: Q.x + Xe + Ke * be[st * 2],
              y: Q.y + We + Ze * be[st * 2 + 1]
            };
          var Ue, Et, qe, rt, ct = He.length;
          for (Et = He[ct - 1], Ue = 0; Ue < ct; Ue++)
            qe = He[Ue % ct], rt = He[(Ue + 1) % ct], ht[Ue] = fS(Et, qe, rt, Pe), Et = qe, qe = rt;
          s.drawRoundPolygonPath(Ce || t, Q.x + Xe, Q.y + We, o * oe, l * se, be, ht);
        } else if (["roundrectangle", "round-rectangle"].includes(ce))
          re = re === "auto" ? Jl(ge, he) : re, s.drawRoundRectanglePath(Ce || t, Q.x, Q.y, ge, he, re + ($ + V + ae) / 2);
        else if (["cutrectangle", "cut-rectangle"].includes(ce))
          re = re === "auto" ? rS() : re, s.drawCutRectanglePath(Ce || t, Q.x, Q.y, ge, he, null, re + ($ + V + ae) / 4);
        else if (["bottomroundrectangle", "bottom-round-rectangle"].includes(ce))
          re = re === "auto" ? Jl(ge, he) : re, s.drawBottomRoundRectanglePath(Ce || t, Q.x, Q.y, ge, he, re + ($ + V + ae) / 2);
        else if (ce === "barrel")
          s.drawBarrelPath(Ce || t, Q.x, Q.y, ge, he);
        else if (ce.startsWith("polygon") || ["rhomboid", "right-rhomboid", "round-tag", "tag", "vee"].includes(ce)) {
          var ut = ($ + V + ae) / o;
          be = Ay(_y(be, ut)), s.drawPolygonPath(Ce || t, Q.x, Q.y, o, l, be);
        } else {
          var nt = ($ + V + ae) / o;
          be = Ay(_y(be, -nt)), s.drawPolygonPath(Ce || t, Q.x, Q.y, o, l, be);
        }
        if (p ? t.stroke(Ce) : t.stroke(), J === "double") {
          t.lineWidth = $ / 3;
          var xt = t.globalCompositeOperation;
          t.globalCompositeOperation = "destination-out", p ? t.stroke(Ce) : t.stroke(), t.globalCompositeOperation = xt;
        }
        t.setLineDash && t.setLineDash([]);
      }
    }, Ge = function() {
      i && s.drawNodeOverlay(t, e, d, o, l);
    }, Ve = function() {
      i && s.drawNodeUnderlay(t, e, d, o, l);
    }, ke = function() {
      s.drawElementText(t, e, null, n);
    }, Oe = e.pstyle("ghost").value === "yes";
    if (Oe) {
      var Se = e.pstyle("ghost-offset-x").pfValue, _e = e.pstyle("ghost-offset-y").pfValue, $e = e.pstyle("ghost-opacity").value, me = $e * f;
      t.translate(Se, _e), Z(), ze(), pe($e * P), fe(), te(me, !0), K($e * F), ue(), Ae(_ !== 0 || O !== 0), W(_ !== 0 || O !== 0), te(me, !1), De(me), t.translate(-Se, -_e);
    }
    p && t.translate(-d.x, -d.y), Ve(), p && t.translate(d.x, d.y), Z(), ze(), pe(), fe(), te(f, !0), K(), ue(), Ae(_ !== 0 || O !== 0), W(_ !== 0 || O !== 0), te(f, !1), De(), p && t.translate(-d.x, -d.y), ke(), Ge(), r && t.translate(y.x1, y.y1);
  }
};
var zU = function(e) {
  if (!["overlay", "underlay"].includes(e))
    throw new Error("Invalid state");
  return function(r, n, i, a, s) {
    var o = this;
    if (n.visible()) {
      var l = n.pstyle("".concat(e, "-padding")).pfValue, u = n.pstyle("".concat(e, "-opacity")).value, h = n.pstyle("".concat(e, "-color")).value, d = n.pstyle("".concat(e, "-shape")).value, f = n.pstyle("".concat(e, "-corner-radius")).value;
      if (u > 0) {
        if (i = i || n.position(), a == null || s == null) {
          var p = n.padding();
          a = n.width() + 2 * p, s = n.height() + 2 * p;
        }
        o.colorFillStyle(r, h[0], h[1], h[2], u), o.nodeShapes[d].draw(r, i.x, i.y, a + l * 2, s + l * 2, f), r.fill();
      }
    }
  };
};
xc.drawNodeOverlay = zU("overlay");
xc.drawNodeUnderlay = zU("underlay");
xc.hasPie = function(t) {
  return t = t[0], t._private.hasPie;
};
xc.hasStripe = function(t) {
  return t = t[0], t._private.hasStripe;
};
xc.drawPie = function(t, e, r, n) {
  e = e[0], n = n || e.position();
  var i = e.cy().style(), a = e.pstyle("pie-size"), s = e.pstyle("pie-hole"), o = e.pstyle("pie-start-angle").pfValue, l = n.x, u = n.y, h = e.width(), d = e.height(), f = Math.min(h, d) / 2, p, g = 0, m = this.usePaths();
  if (m && (l = 0, u = 0), a.units === "%" ? f = f * a.pfValue : a.pfValue !== void 0 && (f = a.pfValue / 2), s.units === "%" ? p = f * s.pfValue : s.pfValue !== void 0 && (p = s.pfValue / 2), !(p >= f))
    for (var v = 1; v <= i.pieBackgroundN; v++) {
      var y = e.pstyle("pie-" + v + "-background-size").value, b = e.pstyle("pie-" + v + "-background-color").value, w = e.pstyle("pie-" + v + "-background-opacity").value * r, T = y / 100;
      T + g > 1 && (T = 1 - g);
      var E = 1.5 * Math.PI + 2 * Math.PI * g;
      E += o;
      var L = 2 * Math.PI * T, k = E + L;
      y === 0 || g >= 1 || g + T > 1 || (p === 0 ? (t.beginPath(), t.moveTo(l, u), t.arc(l, u, f, E, k), t.closePath()) : (t.beginPath(), t.arc(l, u, f, E, k), t.arc(l, u, p, k, E, !0), t.closePath()), this.colorFillStyle(t, b[0], b[1], b[2], w), t.fill(), g += T);
    }
};
xc.drawStripe = function(t, e, r, n) {
  e = e[0], n = n || e.position();
  var i = e.cy().style(), a = n.x, s = n.y, o = e.width(), l = e.height(), u = 0, h = this.usePaths();
  t.save();
  var d = e.pstyle("stripe-direction").value, f = e.pstyle("stripe-size");
  switch (d) {
    case "vertical":
      break;
    // default
    case "righward":
      t.rotate(-Math.PI / 2);
      break;
  }
  var p = o, g = l;
  f.units === "%" ? (p = p * f.pfValue, g = g * f.pfValue) : f.pfValue !== void 0 && (p = f.pfValue, g = f.pfValue), h && (a = 0, s = 0), s -= p / 2, a -= g / 2;
  for (var m = 1; m <= i.stripeBackgroundN; m++) {
    var v = e.pstyle("stripe-" + m + "-background-size").value, y = e.pstyle("stripe-" + m + "-background-color").value, b = e.pstyle("stripe-" + m + "-background-opacity").value * r, w = v / 100;
    w + u > 1 && (w = 1 - u), !(v === 0 || u >= 1 || u + w > 1) && (t.beginPath(), t.rect(a, s + g * u, p, g * w), t.closePath(), this.colorFillStyle(t, y[0], y[1], y[2], b), t.fill(), u += w);
  }
  t.restore();
};
var Ki = {}, U3e = 100;
Ki.getPixelRatio = function() {
  var t = this.data.contexts[0];
  if (this.forcedPixelRatio != null)
    return this.forcedPixelRatio;
  var e = this.cy.window(), r = t.backingStorePixelRatio || t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1;
  return (e.devicePixelRatio || 1) / r;
};
Ki.paintCache = function(t) {
  for (var e = this.paintCaches = this.paintCaches || [], r = !0, n, i = 0; i < e.length; i++)
    if (n = e[i], n.context === t) {
      r = !1;
      break;
    }
  return r && (n = {
    context: t
  }, e.push(n)), n;
};
Ki.createGradientStyleFor = function(t, e, r, n, i) {
  var a, s = this.usePaths(), o = r.pstyle(e + "-gradient-stop-colors").value, l = r.pstyle(e + "-gradient-stop-positions").pfValue;
  if (n === "radial-gradient")
    if (r.isEdge()) {
      var u = r.sourceEndpoint(), h = r.targetEndpoint(), d = r.midpoint(), f = Au(u, d), p = Au(h, d);
      a = t.createRadialGradient(d.x, d.y, 0, d.x, d.y, Math.max(f, p));
    } else {
      var g = s ? {
        x: 0,
        y: 0
      } : r.position(), m = r.paddedWidth(), v = r.paddedHeight();
      a = t.createRadialGradient(g.x, g.y, 0, g.x, g.y, Math.max(m, v));
    }
  else if (r.isEdge()) {
    var y = r.sourceEndpoint(), b = r.targetEndpoint();
    a = t.createLinearGradient(y.x, y.y, b.x, b.y);
  } else {
    var w = s ? {
      x: 0,
      y: 0
    } : r.position(), T = r.paddedWidth(), E = r.paddedHeight(), L = T / 2, k = E / 2, C = r.pstyle("background-gradient-direction").value;
    switch (C) {
      case "to-bottom":
        a = t.createLinearGradient(w.x, w.y - k, w.x, w.y + k);
        break;
      case "to-top":
        a = t.createLinearGradient(w.x, w.y + k, w.x, w.y - k);
        break;
      case "to-left":
        a = t.createLinearGradient(w.x + L, w.y, w.x - L, w.y);
        break;
      case "to-right":
        a = t.createLinearGradient(w.x - L, w.y, w.x + L, w.y);
        break;
      case "to-bottom-right":
      case "to-right-bottom":
        a = t.createLinearGradient(w.x - L, w.y - k, w.x + L, w.y + k);
        break;
      case "to-top-right":
      case "to-right-top":
        a = t.createLinearGradient(w.x - L, w.y + k, w.x + L, w.y - k);
        break;
      case "to-bottom-left":
      case "to-left-bottom":
        a = t.createLinearGradient(w.x + L, w.y - k, w.x - L, w.y + k);
        break;
      case "to-top-left":
      case "to-left-top":
        a = t.createLinearGradient(w.x + L, w.y + k, w.x - L, w.y - k);
        break;
    }
  }
  if (!a) return null;
  for (var A = l.length === o.length, R = o.length, _ = 0; _ < R; _++)
    a.addColorStop(A ? l[_] : _ / (R - 1), "rgba(" + o[_][0] + "," + o[_][1] + "," + o[_][2] + "," + i + ")");
  return a;
};
Ki.gradientFillStyle = function(t, e, r, n) {
  var i = this.createGradientStyleFor(t, "background", e, r, n);
  if (!i) return null;
  t.fillStyle = i;
};
Ki.colorFillStyle = function(t, e, r, n, i) {
  t.fillStyle = "rgba(" + e + "," + r + "," + n + "," + i + ")";
};
Ki.eleFillStyle = function(t, e, r) {
  var n = e.pstyle("background-fill").value;
  if (n === "linear-gradient" || n === "radial-gradient")
    this.gradientFillStyle(t, e, n, r);
  else {
    var i = e.pstyle("background-color").value;
    this.colorFillStyle(t, i[0], i[1], i[2], r);
  }
};
Ki.gradientStrokeStyle = function(t, e, r, n) {
  var i = this.createGradientStyleFor(t, "line", e, r, n);
  if (!i) return null;
  t.strokeStyle = i;
};
Ki.colorStrokeStyle = function(t, e, r, n, i) {
  t.strokeStyle = "rgba(" + e + "," + r + "," + n + "," + i + ")";
};
Ki.eleStrokeStyle = function(t, e, r) {
  var n = e.pstyle("line-fill").value;
  if (n === "linear-gradient" || n === "radial-gradient")
    this.gradientStrokeStyle(t, e, n, r);
  else {
    var i = e.pstyle("line-color").value;
    this.colorStrokeStyle(t, i[0], i[1], i[2], r);
  }
};
Ki.matchCanvasSize = function(t) {
  var e = this, r = e.data, n = e.findContainerClientCoords(), i = n[2], a = n[3], s = e.getPixelRatio(), o = e.motionBlurPxRatio;
  (t === e.data.bufferCanvases[e.MOTIONBLUR_BUFFER_NODE] || t === e.data.bufferCanvases[e.MOTIONBLUR_BUFFER_DRAG]) && (s = o);
  var l = i * s, u = a * s, h;
  if (!(l === e.canvasWidth && u === e.canvasHeight)) {
    e.fontCaches = null;
    var d = r.canvasContainer;
    d.style.width = i + "px", d.style.height = a + "px";
    for (var f = 0; f < e.CANVAS_LAYERS; f++)
      h = r.canvases[f], h.width = l, h.height = u, h.style.width = i + "px", h.style.height = a + "px";
    for (var f = 0; f < e.BUFFER_COUNT; f++)
      h = r.bufferCanvases[f], h.width = l, h.height = u, h.style.width = i + "px", h.style.height = a + "px";
    e.textureMult = 1, s <= 1 && (h = r.bufferCanvases[e.TEXTURE_BUFFER], e.textureMult = 2, h.width = l * e.textureMult, h.height = u * e.textureMult), e.canvasWidth = l, e.canvasHeight = u, e.pixelRatio = s;
  }
};
Ki.renderTo = function(t, e, r, n) {
  this.render({
    forcedContext: t,
    forcedZoom: e,
    forcedPan: r,
    drawAllLayers: !0,
    forcedPxRatio: n
  });
};
Ki.clearCanvas = function() {
  var t = this, e = t.data;
  function r(n) {
    n.clearRect(0, 0, t.canvasWidth, t.canvasHeight);
  }
  r(e.contexts[t.NODE]), r(e.contexts[t.DRAG]);
};
Ki.render = function(t) {
  var e = this;
  t = t || _V();
  var r = e.cy, n = t.forcedContext, i = t.drawAllLayers, a = t.drawOnlyNodeLayer, s = t.forcedZoom, o = t.forcedPan, l = t.forcedPxRatio === void 0 ? this.getPixelRatio() : t.forcedPxRatio, u = e.data, h = u.canvasNeedsRedraw, d = e.textureOnViewport && !n && (e.pinching || e.hoverData.dragging || e.swipePanning || e.data.wheelZooming), f = t.motionBlur !== void 0 ? t.motionBlur : e.motionBlur, p = e.motionBlurPxRatio, g = r.hasCompoundNodes(), m = e.hoverData.draggingEles, v = !!(e.hoverData.selecting || e.touchData.selecting);
  f = f && !n && e.motionBlurEnabled && !v;
  var y = f;
  n || (e.prevPxRatio !== l && (e.invalidateContainerClientCoordsCache(), e.matchCanvasSize(e.container), e.redrawHint("eles", !0), e.redrawHint("drag", !0)), e.prevPxRatio = l), !n && e.motionBlurTimeout && clearTimeout(e.motionBlurTimeout), f && (e.mbFrames == null && (e.mbFrames = 0), e.mbFrames++, e.mbFrames < 3 && (y = !1), e.mbFrames > e.minMbLowQualFrames && (e.motionBlurPxRatio = e.mbPxRBlurry)), e.clearingMotionBlur && (e.motionBlurPxRatio = 1), e.textureDrawLastFrame && !d && (h[e.NODE] = !0, h[e.SELECT_BOX] = !0);
  var b = r.style(), w = r.zoom(), T = s !== void 0 ? s : w, E = r.pan(), L = {
    x: E.x,
    y: E.y
  }, k = {
    zoom: w,
    pan: {
      x: E.x,
      y: E.y
    }
  }, C = e.prevViewport, A = C === void 0 || k.zoom !== C.zoom || k.pan.x !== C.pan.x || k.pan.y !== C.pan.y;
  !A && !(m && !g) && (e.motionBlurPxRatio = 1), o && (L = o), T *= l, L.x *= l, L.y *= l;
  var R = e.getCachedZSortedEles();
  function _(K, Z, X, Y, ee) {
    var j = K.globalCompositeOperation;
    K.globalCompositeOperation = "destination-out", e.colorFillStyle(K, 255, 255, 255, e.motionBlurTransparency), K.fillRect(Z, X, Y, ee), K.globalCompositeOperation = j;
  }
  function O(K, Z) {
    var X, Y, ee, j;
    !e.clearingMotionBlur && (K === u.bufferContexts[e.MOTIONBLUR_BUFFER_NODE] || K === u.bufferContexts[e.MOTIONBLUR_BUFFER_DRAG]) ? (X = {
      x: E.x * p,
      y: E.y * p
    }, Y = w * p, ee = e.canvasWidth * p, j = e.canvasHeight * p) : (X = L, Y = T, ee = e.canvasWidth, j = e.canvasHeight), K.setTransform(1, 0, 0, 1, 0, 0), Z === "motionBlur" ? _(K, 0, 0, ee, j) : !n && (Z === void 0 || Z) && K.clearRect(0, 0, ee, j), i || (K.translate(X.x, X.y), K.scale(Y, Y)), o && K.translate(o.x, o.y), s && K.scale(s, s);
  }
  if (d || (e.textureDrawLastFrame = !1), d) {
    if (e.textureDrawLastFrame = !0, !e.textureCache) {
      e.textureCache = {}, e.textureCache.bb = r.mutableElements().boundingBox(), e.textureCache.texture = e.data.bufferCanvases[e.TEXTURE_BUFFER];
      var P = e.data.bufferContexts[e.TEXTURE_BUFFER];
      P.setTransform(1, 0, 0, 1, 0, 0), P.clearRect(0, 0, e.canvasWidth * e.textureMult, e.canvasHeight * e.textureMult), e.render({
        forcedContext: P,
        drawOnlyNodeLayer: !0,
        forcedPxRatio: l * e.textureMult
      });
      var k = e.textureCache.viewport = {
        zoom: r.zoom(),
        pan: r.pan(),
        width: e.canvasWidth,
        height: e.canvasHeight
      };
      k.mpan = {
        x: (0 - k.pan.x) / k.zoom,
        y: (0 - k.pan.y) / k.zoom
      };
    }
    h[e.DRAG] = !1, h[e.NODE] = !1;
    var S = u.contexts[e.NODE], M = e.textureCache.texture, k = e.textureCache.viewport;
    S.setTransform(1, 0, 0, 1, 0, 0), f ? _(S, 0, 0, k.width, k.height) : S.clearRect(0, 0, k.width, k.height);
    var N = b.core("outside-texture-bg-color").value, D = b.core("outside-texture-bg-opacity").value;
    e.colorFillStyle(S, N[0], N[1], N[2], D), S.fillRect(0, 0, k.width, k.height);
    var w = r.zoom();
    O(S, !1), S.clearRect(k.mpan.x, k.mpan.y, k.width / k.zoom / l, k.height / k.zoom / l), S.drawImage(M, k.mpan.x, k.mpan.y, k.width / k.zoom / l, k.height / k.zoom / l);
  } else e.textureOnViewport && !n && (e.textureCache = null);
  var I = r.extent(), B = e.pinching || e.hoverData.dragging || e.swipePanning || e.data.wheelZooming || e.hoverData.draggingEles || e.cy.animated(), z = e.hideEdgesOnViewport && B, F = [];
  if (F[e.NODE] = !h[e.NODE] && f && !e.clearedForMotionBlur[e.NODE] || e.clearingMotionBlur, F[e.NODE] && (e.clearedForMotionBlur[e.NODE] = !0), F[e.DRAG] = !h[e.DRAG] && f && !e.clearedForMotionBlur[e.DRAG] || e.clearingMotionBlur, F[e.DRAG] && (e.clearedForMotionBlur[e.DRAG] = !0), h[e.NODE] || i || a || F[e.NODE]) {
    var V = f && !F[e.NODE] && p !== 1, S = n || (V ? e.data.bufferContexts[e.MOTIONBLUR_BUFFER_NODE] : u.contexts[e.NODE]), H = f && !V ? "motionBlur" : void 0;
    O(S, H), z ? e.drawCachedNodes(S, R.nondrag, l, I) : e.drawLayeredElements(S, R.nondrag, l, I), e.debug && e.drawDebugPoints(S, R.nondrag), !i && !f && (h[e.NODE] = !1);
  }
  if (!a && (h[e.DRAG] || i || F[e.DRAG])) {
    var V = f && !F[e.DRAG] && p !== 1, S = n || (V ? e.data.bufferContexts[e.MOTIONBLUR_BUFFER_DRAG] : u.contexts[e.DRAG]);
    O(S, f && !V ? "motionBlur" : void 0), z ? e.drawCachedNodes(S, R.drag, l, I) : e.drawCachedElements(S, R.drag, l, I), e.debug && e.drawDebugPoints(S, R.drag), !i && !f && (h[e.DRAG] = !1);
  }
  if (this.drawSelectionRectangle(t, O), f && p !== 1) {
    var J = u.contexts[e.NODE], q = e.data.bufferCanvases[e.MOTIONBLUR_BUFFER_NODE], ae = u.contexts[e.DRAG], re = e.data.bufferCanvases[e.MOTIONBLUR_BUFFER_DRAG], pe = function(Z, X, Y) {
      Z.setTransform(1, 0, 0, 1, 0, 0), Y || !y ? Z.clearRect(0, 0, e.canvasWidth, e.canvasHeight) : _(Z, 0, 0, e.canvasWidth, e.canvasHeight);
      var ee = p;
      Z.drawImage(
        X,
        // img
        0,
        0,
        // sx, sy
        e.canvasWidth * ee,
        e.canvasHeight * ee,
        // sw, sh
        0,
        0,
        // x, y
        e.canvasWidth,
        e.canvasHeight
        // w, h
      );
    };
    (h[e.NODE] || F[e.NODE]) && (pe(J, q, F[e.NODE]), h[e.NODE] = !1), (h[e.DRAG] || F[e.DRAG]) && (pe(ae, re, F[e.DRAG]), h[e.DRAG] = !1);
  }
  e.prevViewport = k, e.clearingMotionBlur && (e.clearingMotionBlur = !1, e.motionBlurCleared = !0, e.motionBlur = !0), f && (e.motionBlurTimeout = setTimeout(function() {
    e.motionBlurTimeout = null, e.clearedForMotionBlur[e.NODE] = !1, e.clearedForMotionBlur[e.DRAG] = !1, e.motionBlur = !1, e.clearingMotionBlur = !d, e.mbFrames = 0, h[e.NODE] = !0, h[e.DRAG] = !0, e.redraw();
  }, U3e)), n || r.emit("render");
};
var Df;
Ki.drawSelectionRectangle = function(t, e) {
  var r = this, n = r.cy, i = r.data, a = n.style(), s = t.drawOnlyNodeLayer, o = t.drawAllLayers, l = i.canvasNeedsRedraw, u = t.forcedContext;
  if (r.showFps || !s && l[r.SELECT_BOX] && !o) {
    var h = u || i.contexts[r.SELECT_BOX];
    if (e(h), r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {
      var d = r.cy.zoom(), f = a.core("selection-box-border-width").value / d;
      h.lineWidth = f, h.fillStyle = "rgba(" + a.core("selection-box-color").value[0] + "," + a.core("selection-box-color").value[1] + "," + a.core("selection-box-color").value[2] + "," + a.core("selection-box-opacity").value + ")", h.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]), f > 0 && (h.strokeStyle = "rgba(" + a.core("selection-box-border-color").value[0] + "," + a.core("selection-box-border-color").value[1] + "," + a.core("selection-box-border-color").value[2] + "," + a.core("selection-box-opacity").value + ")", h.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]));
    }
    if (i.bgActivePosistion && !r.hoverData.selecting) {
      var d = r.cy.zoom(), p = i.bgActivePosistion;
      h.fillStyle = "rgba(" + a.core("active-bg-color").value[0] + "," + a.core("active-bg-color").value[1] + "," + a.core("active-bg-color").value[2] + "," + a.core("active-bg-opacity").value + ")", h.beginPath(), h.arc(p.x, p.y, a.core("active-bg-size").pfValue / d, 0, 2 * Math.PI), h.fill();
    }
    var g = r.lastRedrawTime;
    if (r.showFps && g) {
      g = Math.round(g);
      var m = Math.round(1e3 / g), v = "1 frame = " + g + " ms = " + m + " fps";
      if (h.setTransform(1, 0, 0, 1, 0, 0), h.fillStyle = "rgba(255, 0, 0, 0.75)", h.strokeStyle = "rgba(255, 0, 0, 0.75)", h.font = "30px Arial", !Df) {
        var y = h.measureText(v);
        Df = y.actualBoundingBoxAscent;
      }
      h.fillText(v, 0, Df);
      var b = 60;
      h.strokeRect(0, Df + 10, 250, 20), h.fillRect(0, Df + 10, 250 * Math.min(m / b, 1), 20);
    }
    o || (l[r.SELECT_BOX] = !1);
  }
};
function TL(t, e, r) {
  var n = t.createShader(e);
  if (t.shaderSource(n, r), t.compileShader(n), !t.getShaderParameter(n, t.COMPILE_STATUS))
    throw new Error(t.getShaderInfoLog(n));
  return n;
}
function H3e(t, e, r) {
  var n = TL(t, t.VERTEX_SHADER, e), i = TL(t, t.FRAGMENT_SHADER, r), a = t.createProgram();
  if (t.attachShader(a, n), t.attachShader(a, i), t.linkProgram(a), !t.getProgramParameter(a, t.LINK_STATUS))
    throw new Error("Could not initialize shaders");
  return a;
}
function q3e(t, e, r) {
  r === void 0 && (r = e);
  var n = t.makeOffscreenCanvas(e, r), i = n.context = n.getContext("2d");
  return n.clear = function() {
    return i.clearRect(0, 0, n.width, n.height);
  }, n.clear(), n;
}
function mS(t) {
  var e = t.pixelRatio, r = t.cy.zoom(), n = t.cy.pan();
  return {
    zoom: r * e,
    pan: {
      x: n.x * e,
      y: n.y * e
    }
  };
}
function W3e(t) {
  var e = t.pixelRatio, r = t.cy.zoom();
  return r * e;
}
function Y3e(t, e, r, n, i) {
  var a = n * r + e.x, s = i * r + e.y;
  return s = Math.round(t.canvasHeight - s), [a, s];
}
function X3e(t) {
  return t.pstyle("background-fill").value !== "solid" || t.pstyle("background-image").strValue !== "none" ? !1 : t.pstyle("border-width").value === 0 || t.pstyle("border-opacity").value === 0 ? !0 : t.pstyle("border-style").value === "solid";
}
function j3e(t, e) {
  if (t.length !== e.length)
    return !1;
  for (var r = 0; r < t.length; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
function zc(t, e, r) {
  var n = t[0] / 255, i = t[1] / 255, a = t[2] / 255, s = e, o = r || new Array(4);
  return o[0] = n * s, o[1] = i * s, o[2] = a * s, o[3] = s, o;
}
function Eh(t, e) {
  var r = e || new Array(4);
  return r[0] = (t >> 0 & 255) / 255, r[1] = (t >> 8 & 255) / 255, r[2] = (t >> 16 & 255) / 255, r[3] = (t >> 24 & 255) / 255, r;
}
function K3e(t) {
  return t[0] + (t[1] << 8) + (t[2] << 16) + (t[3] << 24);
}
function Z3e(t, e) {
  var r = t.createTexture();
  return r.buffer = function(n) {
    t.bindTexture(t.TEXTURE_2D, r), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR_MIPMAP_NEAREST), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, n), t.generateMipmap(t.TEXTURE_2D), t.bindTexture(t.TEXTURE_2D, null);
  }, r.deleteTexture = function() {
    t.deleteTexture(r);
  }, r;
}
function GU(t, e) {
  switch (e) {
    case "float":
      return [1, t.FLOAT, 4];
    case "vec2":
      return [2, t.FLOAT, 4];
    case "vec3":
      return [3, t.FLOAT, 4];
    case "vec4":
      return [4, t.FLOAT, 4];
    case "int":
      return [1, t.INT, 4];
    case "ivec2":
      return [2, t.INT, 4];
  }
}
function VU(t, e, r) {
  switch (e) {
    case t.FLOAT:
      return new Float32Array(r);
    case t.INT:
      return new Int32Array(r);
  }
}
function Q3e(t, e, r, n, i, a) {
  switch (e) {
    case t.FLOAT:
      return new Float32Array(r.buffer, a * n, i);
    case t.INT:
      return new Int32Array(r.buffer, a * n, i);
  }
}
function J3e(t, e, r, n) {
  var i = GU(t, e), a = En(i, 2), s = a[0], o = a[1], l = VU(t, o, n), u = t.createBuffer();
  return t.bindBuffer(t.ARRAY_BUFFER, u), t.bufferData(t.ARRAY_BUFFER, l, t.STATIC_DRAW), o === t.FLOAT ? t.vertexAttribPointer(r, s, o, !1, 0, 0) : o === t.INT && t.vertexAttribIPointer(r, s, o, 0, 0), t.enableVertexAttribArray(r), t.bindBuffer(t.ARRAY_BUFFER, null), u;
}
function Bs(t, e, r, n) {
  var i = GU(t, r), a = En(i, 3), s = a[0], o = a[1], l = a[2], u = VU(t, o, e * s), h = s * l, d = t.createBuffer();
  t.bindBuffer(t.ARRAY_BUFFER, d), t.bufferData(t.ARRAY_BUFFER, e * h, t.DYNAMIC_DRAW), t.enableVertexAttribArray(n), o === t.FLOAT ? t.vertexAttribPointer(n, s, o, !1, h, 0) : o === t.INT && t.vertexAttribIPointer(n, s, o, h, 0), t.vertexAttribDivisor(n, 1), t.bindBuffer(t.ARRAY_BUFFER, null);
  for (var f = new Array(e), p = 0; p < e; p++)
    f[p] = Q3e(t, o, u, h, s, p);
  return d.dataArray = u, d.stride = h, d.size = s, d.getView = function(g) {
    return f[g];
  }, d.setPoint = function(g, m, v) {
    var y = f[g];
    y[0] = m, y[1] = v;
  }, d.bufferSubData = function(g) {
    t.bindBuffer(t.ARRAY_BUFFER, d), g ? t.bufferSubData(t.ARRAY_BUFFER, 0, u, 0, g * s) : t.bufferSubData(t.ARRAY_BUFFER, 0, u);
  }, d;
}
function e5e(t, e, r) {
  for (var n = 9, i = new Float32Array(e * n), a = new Array(e), s = 0; s < e; s++) {
    var o = s * n * 4;
    a[s] = new Float32Array(i.buffer, o, n);
  }
  var l = t.createBuffer();
  t.bindBuffer(t.ARRAY_BUFFER, l), t.bufferData(t.ARRAY_BUFFER, i.byteLength, t.DYNAMIC_DRAW);
  for (var u = 0; u < 3; u++) {
    var h = r + u;
    t.enableVertexAttribArray(h), t.vertexAttribPointer(h, 3, t.FLOAT, !1, 36, u * 12), t.vertexAttribDivisor(h, 1);
  }
  return t.bindBuffer(t.ARRAY_BUFFER, null), l.getMatrixView = function(d) {
    return a[d];
  }, l.setData = function(d, f) {
    a[f].set(d, 0);
  }, l.bufferSubData = function() {
    t.bindBuffer(t.ARRAY_BUFFER, l), t.bufferSubData(t.ARRAY_BUFFER, 0, i);
  }, l;
}
function t5e(t) {
  var e = t.createFramebuffer();
  t.bindFramebuffer(t.FRAMEBUFFER, e);
  var r = t.createTexture();
  return t.bindTexture(t.TEXTURE_2D, r), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0), t.bindFramebuffer(t.FRAMEBUFFER, null), e.setFramebufferAttachmentSizes = function(n, i) {
    t.bindTexture(t.TEXTURE_2D, r), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, n, i, 0, t.RGBA, t.UNSIGNED_BYTE, null);
  }, e;
}
var EL = typeof Float32Array < "u" ? Float32Array : Array;
Math.hypot || (Math.hypot = function() {
  for (var t = 0, e = arguments.length; e--; )
    t += arguments[e] * arguments[e];
  return Math.sqrt(t);
});
function n5() {
  var t = new EL(9);
  return EL != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;
}
function kL(t) {
  return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
}
function r5e(t, e, r) {
  var n = e[0], i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], u = e[6], h = e[7], d = e[8], f = r[0], p = r[1], g = r[2], m = r[3], v = r[4], y = r[5], b = r[6], w = r[7], T = r[8];
  return t[0] = f * n + p * s + g * u, t[1] = f * i + p * o + g * h, t[2] = f * a + p * l + g * d, t[3] = m * n + v * s + y * u, t[4] = m * i + v * o + y * h, t[5] = m * a + v * l + y * d, t[6] = b * n + w * s + T * u, t[7] = b * i + w * o + T * h, t[8] = b * a + w * l + T * d, t;
}
function Hm(t, e, r) {
  var n = e[0], i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], u = e[6], h = e[7], d = e[8], f = r[0], p = r[1];
  return t[0] = n, t[1] = i, t[2] = a, t[3] = s, t[4] = o, t[5] = l, t[6] = f * n + p * s + u, t[7] = f * i + p * o + h, t[8] = f * a + p * l + d, t;
}
function SL(t, e, r) {
  var n = e[0], i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], u = e[6], h = e[7], d = e[8], f = Math.sin(r), p = Math.cos(r);
  return t[0] = p * n + f * s, t[1] = p * i + f * o, t[2] = p * a + f * l, t[3] = p * s - f * n, t[4] = p * o - f * i, t[5] = p * l - f * a, t[6] = u, t[7] = h, t[8] = d, t;
}
function _T(t, e, r) {
  var n = r[0], i = r[1];
  return t[0] = n * e[0], t[1] = n * e[1], t[2] = n * e[2], t[3] = i * e[3], t[4] = i * e[4], t[5] = i * e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;
}
function n5e(t, e, r) {
  return t[0] = 2 / e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / r, t[5] = 0, t[6] = -1, t[7] = 1, t[8] = 1, t;
}
var i5e = /* @__PURE__ */ (function() {
  function t(e, r, n, i) {
    mc(this, t), this.debugID = Math.floor(Math.random() * 1e4), this.r = e, this.texSize = r, this.texRows = n, this.texHeight = Math.floor(r / n), this.enableWrapping = !0, this.locked = !1, this.texture = null, this.needsBuffer = !0, this.freePointer = {
      x: 0,
      row: 0
    }, this.keyToLocation = /* @__PURE__ */ new Map(), this.canvas = i(e, r, r), this.scratch = i(e, r, this.texHeight, "scratch");
  }
  return vc(t, [{
    key: "lock",
    value: function() {
      this.locked = !0;
    }
  }, {
    key: "getKeys",
    value: function() {
      return new Set(this.keyToLocation.keys());
    }
  }, {
    key: "getScale",
    value: function(r) {
      var n = r.w, i = r.h, a = this.texHeight, s = this.texSize, o = a / i, l = n * o, u = i * o;
      return l > s && (o = s / n, l = n * o, u = i * o), {
        scale: o,
        texW: l,
        texH: u
      };
    }
  }, {
    key: "draw",
    value: function(r, n, i) {
      var a = this;
      if (this.locked) throw new Error("can't draw, atlas is locked");
      var s = this.texSize, o = this.texRows, l = this.texHeight, u = this.getScale(n), h = u.scale, d = u.texW, f = u.texH, p = function(w, T) {
        if (i && T) {
          var E = T.context, L = w.x, k = w.row, C = L, A = l * k;
          E.save(), E.translate(C, A), E.scale(h, h), i(E, n), E.restore();
        }
      }, g = [null, null], m = function() {
        p(a.freePointer, a.canvas), g[0] = {
          x: a.freePointer.x,
          y: a.freePointer.row * l,
          w: d,
          h: f
        }, g[1] = {
          // create a second location with a width of 0, for convenience
          x: a.freePointer.x + d,
          y: a.freePointer.row * l,
          w: 0,
          h: f
        }, a.freePointer.x += d, a.freePointer.x == s && (a.freePointer.x = 0, a.freePointer.row++);
      }, v = function() {
        var w = a.scratch, T = a.canvas;
        w.clear(), p({
          x: 0,
          row: 0
        }, w);
        var E = s - a.freePointer.x, L = d - E, k = l;
        {
          var C = a.freePointer.x, A = a.freePointer.row * l, R = E;
          T.context.drawImage(w, 0, 0, R, k, C, A, R, k), g[0] = {
            x: C,
            y: A,
            w: R,
            h: f
          };
        }
        {
          var _ = E, O = (a.freePointer.row + 1) * l, P = L;
          T && T.context.drawImage(w, _, 0, P, k, 0, O, P, k), g[1] = {
            x: 0,
            y: O,
            w: P,
            h: f
          };
        }
        a.freePointer.x = L, a.freePointer.row++;
      }, y = function() {
        a.freePointer.x = 0, a.freePointer.row++;
      };
      if (this.freePointer.x + d <= s)
        m();
      else {
        if (this.freePointer.row >= o - 1)
          return !1;
        this.freePointer.x === s ? (y(), m()) : this.enableWrapping ? v() : (y(), m());
      }
      return this.keyToLocation.set(r, g), this.needsBuffer = !0, g;
    }
  }, {
    key: "getOffsets",
    value: function(r) {
      return this.keyToLocation.get(r);
    }
  }, {
    key: "isEmpty",
    value: function() {
      return this.freePointer.x === 0 && this.freePointer.row === 0;
    }
  }, {
    key: "canFit",
    value: function(r) {
      if (this.locked) return !1;
      var n = this.texSize, i = this.texRows, a = this.getScale(r), s = a.texW;
      return this.freePointer.x + s > n ? this.freePointer.row < i - 1 : !0;
    }
    // called on every frame
  }, {
    key: "bufferIfNeeded",
    value: function(r) {
      this.texture || (this.texture = Z3e(r, this.debugID)), this.needsBuffer && (this.texture.buffer(this.canvas), this.needsBuffer = !1, this.locked && (this.canvas = null, this.scratch = null));
    }
  }, {
    key: "dispose",
    value: function() {
      this.texture && (this.texture.deleteTexture(), this.texture = null), this.canvas = null, this.scratch = null, this.locked = !0;
    }
  }]);
})(), a5e = /* @__PURE__ */ (function() {
  function t(e, r, n, i) {
    mc(this, t), this.r = e, this.texSize = r, this.texRows = n, this.createTextureCanvas = i, this.atlases = [], this.styleKeyToAtlas = /* @__PURE__ */ new Map(), this.markedKeys = /* @__PURE__ */ new Set();
  }
  return vc(t, [{
    key: "getKeys",
    value: function() {
      return new Set(this.styleKeyToAtlas.keys());
    }
  }, {
    key: "_createAtlas",
    value: function() {
      var r = this.r, n = this.texSize, i = this.texRows, a = this.createTextureCanvas;
      return new i5e(r, n, i, a);
    }
  }, {
    key: "_getScratchCanvas",
    value: function() {
      if (!this.scratch) {
        var r = this.r, n = this.texSize, i = this.texRows, a = this.createTextureCanvas, s = Math.floor(n / i);
        this.scratch = a(r, n, s, "scratch");
      }
      return this.scratch;
    }
  }, {
    key: "draw",
    value: function(r, n, i) {
      var a = this.styleKeyToAtlas.get(r);
      return a || (a = this.atlases[this.atlases.length - 1], (!a || !a.canFit(n)) && (a && a.lock(), a = this._createAtlas(), this.atlases.push(a)), a.draw(r, n, i), this.styleKeyToAtlas.set(r, a)), a;
    }
  }, {
    key: "getAtlas",
    value: function(r) {
      return this.styleKeyToAtlas.get(r);
    }
  }, {
    key: "hasAtlas",
    value: function(r) {
      return this.styleKeyToAtlas.has(r);
    }
  }, {
    key: "markKeyForGC",
    value: function(r) {
      this.markedKeys.add(r);
    }
  }, {
    key: "gc",
    value: function() {
      var r = this, n = this.markedKeys;
      if (n.size === 0) {
        console.log("nothing to garbage collect");
        return;
      }
      var i = [], a = /* @__PURE__ */ new Map(), s = null, o = oa(this.atlases), l;
      try {
        var u = function() {
          var d = l.value, f = d.getKeys(), p = s5e(n, f);
          if (p.size === 0)
            return i.push(d), f.forEach(function(E) {
              return a.set(E, d);
            }), 1;
          s || (s = r._createAtlas(), i.push(s));
          var g = oa(f), m;
          try {
            for (g.s(); !(m = g.n()).done; ) {
              var v = m.value;
              if (!p.has(v)) {
                var y = d.getOffsets(v), b = En(y, 2), w = b[0], T = b[1];
                s.canFit({
                  w: w.w + T.w,
                  h: w.h
                }) || (s.lock(), s = r._createAtlas(), i.push(s)), d.canvas && (r._copyTextureToNewAtlas(v, d, s), a.set(v, s));
              }
            }
          } catch (E) {
            g.e(E);
          } finally {
            g.f();
          }
          d.dispose();
        };
        for (o.s(); !(l = o.n()).done; )
          u();
      } catch (h) {
        o.e(h);
      } finally {
        o.f();
      }
      this.atlases = i, this.styleKeyToAtlas = a, this.markedKeys = /* @__PURE__ */ new Set();
    }
  }, {
    key: "_copyTextureToNewAtlas",
    value: function(r, n, i) {
      var a = n.getOffsets(r), s = En(a, 2), o = s[0], l = s[1];
      if (l.w === 0)
        i.draw(r, o, function(f) {
          f.drawImage(n.canvas, o.x, o.y, o.w, o.h, 0, 0, o.w, o.h);
        });
      else {
        var u = this._getScratchCanvas();
        u.clear(), u.context.drawImage(n.canvas, o.x, o.y, o.w, o.h, 0, 0, o.w, o.h), u.context.drawImage(n.canvas, l.x, l.y, l.w, l.h, o.w, 0, l.w, l.h);
        var h = o.w + l.w, d = o.h;
        i.draw(r, {
          w: h,
          h: d
        }, function(f) {
          f.drawImage(
            u,
            0,
            0,
            h,
            d,
            0,
            0,
            h,
            d
            // the destination context has already been translated to the correct position
          );
        });
      }
    }
  }, {
    key: "getCounts",
    value: function() {
      return {
        keyCount: this.styleKeyToAtlas.size,
        atlasCount: new Set(this.styleKeyToAtlas.values()).size
      };
    }
  }]);
})();
function s5e(t, e) {
  return t.intersection ? t.intersection(e) : new Set(Ey(t).filter(function(r) {
    return e.has(r);
  }));
}
var o5e = /* @__PURE__ */ (function() {
  function t(e, r) {
    mc(this, t), this.r = e, this.globalOptions = r, this.atlasSize = r.webglTexSize, this.maxAtlasesPerBatch = r.webglTexPerBatch, this.renderTypes = /* @__PURE__ */ new Map(), this.collections = /* @__PURE__ */ new Map(), this.typeAndIdToKey = /* @__PURE__ */ new Map();
  }
  return vc(t, [{
    key: "getAtlasSize",
    value: function() {
      return this.atlasSize;
    }
  }, {
    key: "addAtlasCollection",
    value: function(r, n) {
      var i = this.globalOptions, a = i.webglTexSize, s = i.createTextureCanvas, o = n.texRows, l = this._cacheScratchCanvas(s), u = new a5e(this.r, a, o, l);
      this.collections.set(r, u);
    }
  }, {
    key: "addRenderType",
    value: function(r, n) {
      var i = n.collection;
      if (!this.collections.has(i)) throw new Error("invalid atlas collection name '".concat(i, "'"));
      var a = this.collections.get(i), s = Gt({
        type: r,
        atlasCollection: a
      }, n);
      this.renderTypes.set(r, s);
    }
  }, {
    key: "getRenderTypeOpts",
    value: function(r) {
      return this.renderTypes.get(r);
    }
  }, {
    key: "getAtlasCollection",
    value: function(r) {
      return this.collections.get(r);
    }
  }, {
    key: "_cacheScratchCanvas",
    value: function(r) {
      var n = -1, i = -1, a = null;
      return function(s, o, l, u) {
        return u ? ((!a || o != n || l != i) && (n = o, i = l, a = r(s, o, l)), a) : r(s, o, l);
      };
    }
  }, {
    key: "_key",
    value: function(r, n) {
      return "".concat(r, "-").concat(n);
    }
    /** Marks textues associated with the element for garbage collection. */
  }, {
    key: "invalidate",
    value: function(r) {
      var n = this, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = i.forceRedraw, s = a === void 0 ? !1 : a, o = i.filterEle, l = o === void 0 ? function() {
        return !0;
      } : o, u = i.filterType, h = u === void 0 ? function() {
        return !0;
      } : u, d = !1, f = !1, p = oa(r), g;
      try {
        for (p.s(); !(g = p.n()).done; ) {
          var m = g.value;
          if (l(m)) {
            var v = oa(this.renderTypes.values()), y;
            try {
              var b = function() {
                var T = y.value, E = T.type;
                if (h(E)) {
                  var L = n.collections.get(T.collection), k = T.getKey(m), C = Array.isArray(k) ? k : [k];
                  if (s)
                    C.forEach(function(O) {
                      return L.markKeyForGC(O);
                    }), f = !0;
                  else {
                    var A = T.getID ? T.getID(m) : m.id(), R = n._key(E, A), _ = n.typeAndIdToKey.get(R);
                    _ !== void 0 && !j3e(C, _) && (d = !0, n.typeAndIdToKey.delete(R), _.forEach(function(O) {
                      return L.markKeyForGC(O);
                    }));
                  }
                }
              };
              for (v.s(); !(y = v.n()).done; )
                b();
            } catch (w) {
              v.e(w);
            } finally {
              v.f();
            }
          }
        }
      } catch (w) {
        p.e(w);
      } finally {
        p.f();
      }
      return f && (this.gc(), d = !1), d;
    }
    /** Garbage collect */
  }, {
    key: "gc",
    value: function() {
      var r = oa(this.collections.values()), n;
      try {
        for (r.s(); !(n = r.n()).done; ) {
          var i = n.value;
          i.gc();
        }
      } catch (a) {
        r.e(a);
      } finally {
        r.f();
      }
    }
  }, {
    key: "getOrCreateAtlas",
    value: function(r, n, i, a) {
      var s = this.renderTypes.get(n), o = this.collections.get(s.collection), l = !1, u = o.draw(a, i, function(f) {
        s.drawClipped ? (f.save(), f.beginPath(), f.rect(0, 0, i.w, i.h), f.clip(), s.drawElement(f, r, i, !0, !0), f.restore()) : s.drawElement(f, r, i, !0, !0), l = !0;
      });
      if (l) {
        var h = s.getID ? s.getID(r) : r.id(), d = this._key(n, h);
        this.typeAndIdToKey.has(d) ? this.typeAndIdToKey.get(d).push(a) : this.typeAndIdToKey.set(d, [a]);
      }
      return u;
    }
  }, {
    key: "getAtlasInfo",
    value: function(r, n) {
      var i = this, a = this.renderTypes.get(n), s = a.getKey(r), o = Array.isArray(s) ? s : [s];
      return o.map(function(l) {
        var u = a.getBoundingBox(r, l), h = i.getOrCreateAtlas(r, n, u, l), d = h.getOffsets(l), f = En(d, 2), p = f[0], g = f[1];
        return {
          atlas: h,
          tex: p,
          tex1: p,
          tex2: g,
          bb: u
        };
      });
    }
  }, {
    key: "getDebugInfo",
    value: function() {
      var r = [], n = oa(this.collections), i;
      try {
        for (n.s(); !(i = n.n()).done; ) {
          var a = En(i.value, 2), s = a[0], o = a[1], l = o.getCounts(), u = l.keyCount, h = l.atlasCount;
          r.push({
            type: s,
            keyCount: u,
            atlasCount: h
          });
        }
      } catch (d) {
        n.e(d);
      } finally {
        n.f();
      }
      return r;
    }
  }]);
})(), l5e = /* @__PURE__ */ (function() {
  function t(e) {
    mc(this, t), this.globalOptions = e, this.atlasSize = e.webglTexSize, this.maxAtlasesPerBatch = e.webglTexPerBatch, this.batchAtlases = [];
  }
  return vc(t, [{
    key: "getMaxAtlasesPerBatch",
    value: function() {
      return this.maxAtlasesPerBatch;
    }
  }, {
    key: "getAtlasSize",
    value: function() {
      return this.atlasSize;
    }
  }, {
    key: "getIndexArray",
    value: function() {
      return Array.from({
        length: this.maxAtlasesPerBatch
      }, function(r, n) {
        return n;
      });
    }
  }, {
    key: "startBatch",
    value: function() {
      this.batchAtlases = [];
    }
  }, {
    key: "getAtlasCount",
    value: function() {
      return this.batchAtlases.length;
    }
  }, {
    key: "getAtlases",
    value: function() {
      return this.batchAtlases;
    }
  }, {
    key: "canAddToCurrentBatch",
    value: function(r) {
      return this.batchAtlases.length === this.maxAtlasesPerBatch ? this.batchAtlases.includes(r) : !0;
    }
  }, {
    key: "getAtlasIndexForBatch",
    value: function(r) {
      var n = this.batchAtlases.indexOf(r);
      if (n < 0) {
        if (this.batchAtlases.length === this.maxAtlasesPerBatch)
          throw new Error("cannot add more atlases to batch");
        this.batchAtlases.push(r), n = this.batchAtlases.length - 1;
      }
      return n;
    }
  }]);
})(), c5e = `
  float circleSD(vec2 p, float r) {
    return distance(vec2(0), p) - r; // signed distance
  }
`, u5e = `
  float rectangleSD(vec2 p, vec2 b) {
    vec2 d = abs(p)-b;
    return distance(vec2(0),max(d,0.0)) + min(max(d.x,d.y),0.0);
  }
`, h5e = `
  float roundRectangleSD(vec2 p, vec2 b, vec4 cr) {
    cr.xy = (p.x > 0.0) ? cr.xy : cr.zw;
    cr.x  = (p.y > 0.0) ? cr.x  : cr.y;
    vec2 q = abs(p) - b + cr.x;
    return min(max(q.x, q.y), 0.0) + distance(vec2(0), max(q, 0.0)) - cr.x;
  }
`, d5e = `
  float ellipseSD(vec2 p, vec2 ab) {
    p = abs( p ); // symmetry

    // find root with Newton solver
    vec2 q = ab*(p-ab);
    float w = (q.x<q.y)? 1.570796327 : 0.0;
    for( int i=0; i<5; i++ ) {
      vec2 cs = vec2(cos(w),sin(w));
      vec2 u = ab*vec2( cs.x,cs.y);
      vec2 v = ab*vec2(-cs.y,cs.x);
      w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));
    }
    
    // compute final point and distance
    float d = length(p-ab*vec2(cos(w),sin(w)));
    
    // return signed distance
    return (dot(p/ab,p/ab)>1.0) ? d : -d;
  }
`, rp = {
  SCREEN: {
    name: "screen",
    screen: !0
  },
  PICKING: {
    name: "picking",
    picking: !0
  }
}, Oy = {
  // render the texture just like in RENDER_TARGET.SCREEN mode
  IGNORE: 1,
  // don't render the texture at all
  USE_BB: 2
  // render the bounding box as an opaque rectangle
}, i5 = 0, CL = 1, AL = 2, a5 = 3, kh = 4, F1 = 5, Of = 6, Pf = 7, f5e = /* @__PURE__ */ (function() {
  function t(e, r, n) {
    mc(this, t), this.r = e, this.gl = r, this.maxInstances = n.webglBatchSize, this.atlasSize = n.webglTexSize, this.bgColor = n.bgColor, this.debug = n.webglDebug, this.batchDebugInfo = [], n.enableWrapping = !0, n.createTextureCanvas = q3e, this.atlasManager = new o5e(e, n), this.batchManager = new l5e(n), this.simpleShapeOptions = /* @__PURE__ */ new Map(), this.program = this._createShaderProgram(rp.SCREEN), this.pickingProgram = this._createShaderProgram(rp.PICKING), this.vao = this._createVAO();
  }
  return vc(t, [{
    key: "addAtlasCollection",
    value: function(r, n) {
      this.atlasManager.addAtlasCollection(r, n);
    }
    /**
     * @typedef { Object } TextureRenderTypeOpts
     * @property { string } collection - name of atlas collection to render textures to
     * @property { function } getKey - returns the "style key" for an element, may be a single value or an array for multi-line lables
     * @property { function } drawElement - uses a canvas renderer to draw the element to the texture atlas
     * @property { boolean  } drawClipped - if true the context will be clipped to the bounding box before drawElement() is called, may affect performance
     * @property { function } getBoundingBox - returns the bounding box for an element
     * @property { function } getRotation
     * @property { function } getRotationPoint
     * @property { function } getRotationOffset
     * @property { function } isVisible - an extra check for visibility in addition to ele.visible()
     * @property { function } getTexPickingMode - returns a value from the TEX_PICKING_MODE enum
     */
    /**
     * @param { string } typeName
     * @param { TextureRenderTypeOpts } opts
     */
  }, {
    key: "addTextureAtlasRenderType",
    value: function(r, n) {
      this.atlasManager.addRenderType(r, n);
    }
    /**
     * @typedef { Object } SimpleShapeRenderTypeOpts
     * @property { function } getBoundingBox - returns the bounding box for an element
     * @property { function } isVisible - this is an extra check for visibility in addition to ele.visible()
     * @property { function } isSimple - check if element is a simple shape, or if it needs to fall back to texture rendering
     * @property { ShapeVisualProperties } shapeProps
     */
    /**
     * @typedef { Object } ShapeVisualProperties
     * @property { string } shape
     * @property { string } color
     * @property { string } opacity
     * @property { string } padding
     * @property { string } radius
     * @property { boolean } border
    */
    /**
     * @param { string } typeName
     * @param { SimpleShapeRenderTypeOpts } opts
     */
  }, {
    key: "addSimpleShapeRenderType",
    value: function(r, n) {
      this.simpleShapeOptions.set(r, n);
    }
    /**
     * Inform the atlasManager when element style keys may have changed.
     * The atlasManager can then mark unused textures for "garbage collection".
     */
  }, {
    key: "invalidate",
    value: function(r) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = n.type, a = this.atlasManager;
      return i ? a.invalidate(r, {
        filterType: function(o) {
          return o === i;
        },
        forceRedraw: !0
      }) : a.invalidate(r);
    }
    /**
     * Run texture garbage collection.
     */
  }, {
    key: "gc",
    value: function() {
      this.atlasManager.gc();
    }
  }, {
    key: "_createShaderProgram",
    value: function(r) {
      var n = this.gl, i = `#version 300 es
      precision highp float;

      uniform mat3 uPanZoomMatrix;
      uniform int  uAtlasSize;
      
      // instanced
      in vec2 aPosition; // a vertex from the unit square
      
      in mat3 aTransform; // used to transform verticies, eg into a bounding box
      in int aVertType; // the type of thing we are rendering

      // the z-index that is output when using picking mode
      in vec4 aIndex;
      
      // For textures
      in int aAtlasId; // which shader unit/atlas to use
      in vec4 aTex; // x/y/w/h of texture in atlas

      // for edges
      in vec4 aPointAPointB;
      in vec4 aPointCPointD;
      in vec2 aLineWidth; // also used for node border width

      // simple shapes
      in vec4 aCornerRadius; // for round-rectangle [top-right, bottom-right, top-left, bottom-left]
      in vec4 aColor; // also used for edges
      in vec4 aBorderColor; // aLineWidth is used for border width

      // output values passed to the fragment shader
      out vec2 vTexCoord;
      out vec4 vColor;
      out vec2 vPosition;
      // flat values are not interpolated
      flat out int vAtlasId; 
      flat out int vVertType;
      flat out vec2 vTopRight;
      flat out vec2 vBotLeft;
      flat out vec4 vCornerRadius;
      flat out vec4 vBorderColor;
      flat out vec2 vBorderWidth;
      flat out vec4 vIndex;
      
      void main(void) {
        int vid = gl_VertexID;
        vec2 position = aPosition; // TODO make this a vec3, simplifies some code below

        if(aVertType == `.concat(i5, `) {
          float texX = aTex.x; // texture coordinates
          float texY = aTex.y;
          float texW = aTex.z;
          float texH = aTex.w;

          if(vid == 1 || vid == 2 || vid == 4) {
            texX += texW;
          }
          if(vid == 2 || vid == 4 || vid == 5) {
            texY += texH;
          }

          float d = float(uAtlasSize);
          vTexCoord = vec2(texX / d, texY / d); // tex coords must be between 0 and 1

          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);
        }
        else if(aVertType == `).concat(kh, " || aVertType == ").concat(Pf, ` 
             || aVertType == `).concat(F1, " || aVertType == ").concat(Of, `) { // simple shapes

          // the bounding box is needed by the fragment shader
          vBotLeft  = (aTransform * vec3(0, 0, 1)).xy; // flat
          vTopRight = (aTransform * vec3(1, 1, 1)).xy; // flat
          vPosition = (aTransform * vec3(position, 1)).xy; // will be interpolated

          // calculations are done in the fragment shader, just pass these along
          vColor = aColor;
          vCornerRadius = aCornerRadius;
          vBorderColor = aBorderColor;
          vBorderWidth = aLineWidth;

          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);
        }
        else if(aVertType == `).concat(CL, `) {
          vec2 source = aPointAPointB.xy;
          vec2 target = aPointAPointB.zw;

          // adjust the geometry so that the line is centered on the edge
          position.y = position.y - 0.5;

          // stretch the unit square into a long skinny rectangle
          vec2 xBasis = target - source;
          vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));
          vec2 point = source + xBasis * position.x + yBasis * aLineWidth[0] * position.y;

          gl_Position = vec4(uPanZoomMatrix * vec3(point, 1.0), 1.0);
          vColor = aColor;
        } 
        else if(aVertType == `).concat(AL, `) {
          vec2 pointA = aPointAPointB.xy;
          vec2 pointB = aPointAPointB.zw;
          vec2 pointC = aPointCPointD.xy;
          vec2 pointD = aPointCPointD.zw;

          // adjust the geometry so that the line is centered on the edge
          position.y = position.y - 0.5;

          vec2 p0, p1, p2, pos;
          if(position.x == 0.0) { // The left side of the unit square
            p0 = pointA;
            p1 = pointB;
            p2 = pointC;
            pos = position;
          } else { // The right side of the unit square, use same approach but flip the geometry upside down
            p0 = pointD;
            p1 = pointC;
            p2 = pointB;
            pos = vec2(0.0, -position.y);
          }

          vec2 p01 = p1 - p0;
          vec2 p12 = p2 - p1;
          vec2 p21 = p1 - p2;

          // Find the normal vector.
          vec2 tangent = normalize(normalize(p12) + normalize(p01));
          vec2 normal = vec2(-tangent.y, tangent.x);

          // Find the vector perpendicular to p0 -> p1.
          vec2 p01Norm = normalize(vec2(-p01.y, p01.x));

          // Determine the bend direction.
          float sigma = sign(dot(p01 + p21, normal));
          float width = aLineWidth[0];

          if(sign(pos.y) == -sigma) {
            // This is an intersecting vertex. Adjust the position so that there's no overlap.
            vec2 point = 0.5 * width * normal * -sigma / dot(normal, p01Norm);
            gl_Position = vec4(uPanZoomMatrix * vec3(p1 + point, 1.0), 1.0);
          } else {
            // This is a non-intersecting vertex. Treat it like a mitre join.
            vec2 point = 0.5 * width * normal * sigma * dot(normal, p01Norm);
            gl_Position = vec4(uPanZoomMatrix * vec3(p1 + point, 1.0), 1.0);
          }

          vColor = aColor;
        } 
        else if(aVertType == `).concat(a5, ` && vid < 3) {
          // massage the first triangle into an edge arrow
          if(vid == 0)
            position = vec2(-0.15, -0.3);
          if(vid == 1)
            position = vec2(  0.0,  0.0);
          if(vid == 2)
            position = vec2( 0.15, -0.3);

          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);
          vColor = aColor;
        }
        else {
          gl_Position = vec4(2.0, 0.0, 0.0, 1.0); // discard vertex by putting it outside webgl clip space
        }

        vAtlasId = aAtlasId;
        vVertType = aVertType;
        vIndex = aIndex;
      }
    `), a = this.batchManager.getIndexArray(), s = `#version 300 es
      precision highp float;

      // declare texture unit for each texture atlas in the batch
      `.concat(a.map(function(u) {
        return "uniform sampler2D uTexture".concat(u, ";");
      }).join(`
	`), `

      uniform vec4 uBGColor;
      uniform float uZoom;

      in vec2 vTexCoord;
      in vec4 vColor;
      in vec2 vPosition; // model coordinates

      flat in int vAtlasId;
      flat in vec4 vIndex;
      flat in int vVertType;
      flat in vec2 vTopRight;
      flat in vec2 vBotLeft;
      flat in vec4 vCornerRadius;
      flat in vec4 vBorderColor;
      flat in vec2 vBorderWidth;

      out vec4 outColor;

      `).concat(c5e, `
      `).concat(u5e, `
      `).concat(h5e, `
      `).concat(d5e, `

      vec4 blend(vec4 top, vec4 bot) { // blend colors with premultiplied alpha
        return vec4( 
          top.rgb + (bot.rgb * (1.0 - top.a)),
          top.a   + (bot.a   * (1.0 - top.a)) 
        );
      }

      vec4 distInterp(vec4 cA, vec4 cB, float d) { // interpolate color using Signed Distance
        // scale to the zoom level so that borders don't look blurry when zoomed in
        // note 1.5 is an aribitrary value chosen because it looks good
        return mix(cA, cB, 1.0 - smoothstep(0.0, 1.5 / uZoom, abs(d))); 
      }

      void main(void) {
        if(vVertType == `).concat(i5, `) {
          // look up the texel from the texture unit
          `).concat(a.map(function(u) {
        return "if(vAtlasId == ".concat(u, ") outColor = texture(uTexture").concat(u, ", vTexCoord);");
      }).join(`
	else `), `
        } 
        else if(vVertType == `).concat(a5, `) {
          // mimics how canvas renderer uses context.globalCompositeOperation = 'destination-out';
          outColor = blend(vColor, uBGColor);
          outColor.a = 1.0; // make opaque, masks out line under arrow
        }
        else if(vVertType == `).concat(kh, ` && vBorderWidth == vec2(0.0)) { // simple rectangle with no border
          outColor = vColor; // unit square is already transformed to the rectangle, nothing else needs to be done
        }
        else if(vVertType == `).concat(kh, " || vVertType == ").concat(Pf, ` 
          || vVertType == `).concat(F1, " || vVertType == ").concat(Of, `) { // use SDF

          float outerBorder = vBorderWidth[0];
          float innerBorder = vBorderWidth[1];
          float borderPadding = outerBorder * 2.0;
          float w = vTopRight.x - vBotLeft.x - borderPadding;
          float h = vTopRight.y - vBotLeft.y - borderPadding;
          vec2 b = vec2(w/2.0, h/2.0); // half width, half height
          vec2 p = vPosition - vec2(vTopRight.x - b[0] - outerBorder, vTopRight.y - b[1] - outerBorder); // translate to center

          float d; // signed distance
          if(vVertType == `).concat(kh, `) {
            d = rectangleSD(p, b);
          } else if(vVertType == `).concat(Pf, ` && w == h) {
            d = circleSD(p, b.x); // faster than ellipse
          } else if(vVertType == `).concat(Pf, `) {
            d = ellipseSD(p, b);
          } else {
            d = roundRectangleSD(p, b, vCornerRadius.wzyx);
          }

          // use the distance to interpolate a color to smooth the edges of the shape, doesn't need multisampling
          // we must smooth colors inwards, because we can't change pixels outside the shape's bounding box
          if(d > 0.0) {
            if(d > outerBorder) {
              discard;
            } else {
              outColor = distInterp(vBorderColor, vec4(0), d - outerBorder);
            }
          } else {
            if(d > innerBorder) {
              vec4 outerColor = outerBorder == 0.0 ? vec4(0) : vBorderColor;
              vec4 innerBorderColor = blend(vBorderColor, vColor);
              outColor = distInterp(innerBorderColor, outerColor, d);
            } 
            else {
              vec4 outerColor;
              if(innerBorder == 0.0 && outerBorder == 0.0) {
                outerColor = vec4(0);
              } else if(innerBorder == 0.0) {
                outerColor = vBorderColor;
              } else {
                outerColor = blend(vBorderColor, vColor);
              }
              outColor = distInterp(vColor, outerColor, d - innerBorder);
            }
          }
        }
        else {
          outColor = vColor;
        }

        `).concat(r.picking ? `if(outColor.a == 0.0) discard;
             else outColor = vIndex;` : "", `
      }
    `), o = H3e(n, i, s);
      o.aPosition = n.getAttribLocation(o, "aPosition"), o.aIndex = n.getAttribLocation(o, "aIndex"), o.aVertType = n.getAttribLocation(o, "aVertType"), o.aTransform = n.getAttribLocation(o, "aTransform"), o.aAtlasId = n.getAttribLocation(o, "aAtlasId"), o.aTex = n.getAttribLocation(o, "aTex"), o.aPointAPointB = n.getAttribLocation(o, "aPointAPointB"), o.aPointCPointD = n.getAttribLocation(o, "aPointCPointD"), o.aLineWidth = n.getAttribLocation(o, "aLineWidth"), o.aColor = n.getAttribLocation(o, "aColor"), o.aCornerRadius = n.getAttribLocation(o, "aCornerRadius"), o.aBorderColor = n.getAttribLocation(o, "aBorderColor"), o.uPanZoomMatrix = n.getUniformLocation(o, "uPanZoomMatrix"), o.uAtlasSize = n.getUniformLocation(o, "uAtlasSize"), o.uBGColor = n.getUniformLocation(o, "uBGColor"), o.uZoom = n.getUniformLocation(o, "uZoom"), o.uTextures = [];
      for (var l = 0; l < this.batchManager.getMaxAtlasesPerBatch(); l++)
        o.uTextures.push(n.getUniformLocation(o, "uTexture".concat(l)));
      return o;
    }
  }, {
    key: "_createVAO",
    value: function() {
      var r = [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1];
      this.vertexCount = r.length / 2;
      var n = this.maxInstances, i = this.gl, a = this.program, s = i.createVertexArray();
      return i.bindVertexArray(s), J3e(i, "vec2", a.aPosition, r), this.transformBuffer = e5e(i, n, a.aTransform), this.indexBuffer = Bs(i, n, "vec4", a.aIndex), this.vertTypeBuffer = Bs(i, n, "int", a.aVertType), this.atlasIdBuffer = Bs(i, n, "int", a.aAtlasId), this.texBuffer = Bs(i, n, "vec4", a.aTex), this.pointAPointBBuffer = Bs(i, n, "vec4", a.aPointAPointB), this.pointCPointDBuffer = Bs(i, n, "vec4", a.aPointCPointD), this.lineWidthBuffer = Bs(i, n, "vec2", a.aLineWidth), this.colorBuffer = Bs(i, n, "vec4", a.aColor), this.cornerRadiusBuffer = Bs(i, n, "vec4", a.aCornerRadius), this.borderColorBuffer = Bs(i, n, "vec4", a.aBorderColor), i.bindVertexArray(null), s;
    }
  }, {
    key: "buffers",
    get: function() {
      var r = this;
      return this._buffers || (this._buffers = Object.keys(this).filter(function(n) {
        return Il(n, "Buffer");
      }).map(function(n) {
        return r[n];
      })), this._buffers;
    }
  }, {
    key: "startFrame",
    value: function(r) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : rp.SCREEN;
      this.panZoomMatrix = r, this.renderTarget = n, this.batchDebugInfo = [], this.wrappedCount = 0, this.simpleCount = 0, this.startBatch();
    }
  }, {
    key: "startBatch",
    value: function() {
      this.instanceCount = 0, this.batchManager.startBatch();
    }
  }, {
    key: "endFrame",
    value: function() {
      this.endBatch();
    }
  }, {
    key: "_isVisible",
    value: function(r, n) {
      return r.visible() ? n && n.isVisible ? n.isVisible(r) : !0 : !1;
    }
    /**
     * Draws a texture using the texture atlas.
     */
  }, {
    key: "drawTexture",
    value: function(r, n, i) {
      var a = this.atlasManager, s = this.batchManager, o = a.getRenderTypeOpts(i);
      if (this._isVisible(r, o) && !(r.isEdge() && !this._isValidEdge(r))) {
        if (this.renderTarget.picking && o.getTexPickingMode) {
          var l = o.getTexPickingMode(r);
          if (l === Oy.IGNORE)
            return;
          if (l == Oy.USE_BB) {
            this.drawPickingRectangle(r, n, i);
            return;
          }
        }
        var u = a.getAtlasInfo(r, i), h = oa(u), d;
        try {
          for (h.s(); !(d = h.n()).done; ) {
            var f = d.value, p = f.atlas, g = f.tex1, m = f.tex2;
            s.canAddToCurrentBatch(p) || this.endBatch();
            for (var v = s.getAtlasIndexForBatch(p), y = 0, b = [[g, !0], [m, !1]]; y < b.length; y++) {
              var w = En(b[y], 2), T = w[0], E = w[1];
              if (T.w != 0) {
                var L = this.instanceCount;
                this.vertTypeBuffer.getView(L)[0] = i5;
                var k = this.indexBuffer.getView(L);
                Eh(n, k);
                var C = this.atlasIdBuffer.getView(L);
                C[0] = v;
                var A = this.texBuffer.getView(L);
                A[0] = T.x, A[1] = T.y, A[2] = T.w, A[3] = T.h;
                var R = this.transformBuffer.getMatrixView(L);
                this.setTransformMatrix(r, R, o, f, E), this.instanceCount++, E || this.wrappedCount++, this.instanceCount >= this.maxInstances && this.endBatch();
              }
            }
          }
        } catch (_) {
          h.e(_);
        } finally {
          h.f();
        }
      }
    }
    /**
     * matrix is expected to be a 9 element array
     * this function follows same pattern as CRp.drawCachedElementPortion(...)
     */
  }, {
    key: "setTransformMatrix",
    value: function(r, n, i, a) {
      var s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, o = 0;
      if (i.shapeProps && i.shapeProps.padding && (o = r.pstyle(i.shapeProps.padding).pfValue), a) {
        var l = a.bb, u = a.tex1, h = a.tex2, d = u.w / (u.w + h.w);
        s || (d = 1 - d);
        var f = this._getAdjustedBB(l, o, s, d);
        this._applyTransformMatrix(n, f, i, r);
      } else {
        var p = i.getBoundingBox(r), g = this._getAdjustedBB(p, o, !0, 1);
        this._applyTransformMatrix(n, g, i, r);
      }
    }
  }, {
    key: "_applyTransformMatrix",
    value: function(r, n, i, a) {
      var s, o;
      kL(r);
      var l = i.getRotation ? i.getRotation(a) : 0;
      if (l !== 0) {
        var u = i.getRotationPoint(a), h = u.x, d = u.y;
        Hm(r, r, [h, d]), SL(r, r, l);
        var f = i.getRotationOffset(a);
        s = f.x + (n.xOffset || 0), o = f.y + (n.yOffset || 0);
      } else
        s = n.x1, o = n.y1;
      Hm(r, r, [s, o]), _T(r, r, [n.w, n.h]);
    }
    /**
     * Adjusts a node or label BB to accomodate padding and split for wrapped textures.
     * @param bb - the original bounding box
     * @param padding - the padding to add to the bounding box
     * @param first - whether this is the first part of a wrapped texture
     * @param ratio - the ratio of the texture width of part of the text to the entire texture
     */
  }, {
    key: "_getAdjustedBB",
    value: function(r, n, i, a) {
      var s = r.x1, o = r.y1, l = r.w, u = r.h, h = r.yOffset;
      n && (s -= n, o -= n, l += 2 * n, u += 2 * n);
      var d = 0, f = l * a;
      return i && a < 1 ? l = f : !i && a < 1 && (d = l - f, s += d, l = f), {
        x1: s,
        y1: o,
        w: l,
        h: u,
        xOffset: d,
        yOffset: h
      };
    }
    /**
     * Draw a solid opaque rectangle matching the element's Bounding Box.
     * Used by the PICKING mode to make the entire BB of a label clickable.
     */
  }, {
    key: "drawPickingRectangle",
    value: function(r, n, i) {
      var a = this.atlasManager.getRenderTypeOpts(i), s = this.instanceCount;
      this.vertTypeBuffer.getView(s)[0] = kh;
      var o = this.indexBuffer.getView(s);
      Eh(n, o);
      var l = this.colorBuffer.getView(s);
      zc([0, 0, 0], 1, l);
      var u = this.transformBuffer.getMatrixView(s);
      this.setTransformMatrix(r, u, a), this.simpleCount++, this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
    }
    /**
     * Draw a node using either a texture or a "simple shape".
     */
  }, {
    key: "drawNode",
    value: function(r, n, i) {
      var a = this.simpleShapeOptions.get(i);
      if (this._isVisible(r, a)) {
        var s = a.shapeProps, o = this._getVertTypeForShape(r, s.shape);
        if (o === void 0 || a.isSimple && !a.isSimple(r)) {
          this.drawTexture(r, n, i);
          return;
        }
        var l = this.instanceCount;
        if (this.vertTypeBuffer.getView(l)[0] = o, o === F1 || o === Of) {
          var u = a.getBoundingBox(r), h = this._getCornerRadius(r, s.radius, u), d = this.cornerRadiusBuffer.getView(l);
          d[0] = h, d[1] = h, d[2] = h, d[3] = h, o === Of && (d[0] = 0, d[2] = 0);
        }
        var f = this.indexBuffer.getView(l);
        Eh(n, f);
        var p = r.pstyle(s.color).value, g = r.pstyle(s.opacity).value, m = this.colorBuffer.getView(l);
        zc(p, g, m);
        var v = this.lineWidthBuffer.getView(l);
        if (v[0] = 0, v[1] = 0, s.border) {
          var y = r.pstyle("border-width").value;
          if (y > 0) {
            var b = r.pstyle("border-color").value, w = r.pstyle("border-opacity").value, T = this.borderColorBuffer.getView(l);
            zc(b, w, T);
            var E = r.pstyle("border-position").value;
            if (E === "inside")
              v[0] = 0, v[1] = -y;
            else if (E === "outside")
              v[0] = y, v[1] = 0;
            else {
              var L = y / 2;
              v[0] = L, v[1] = -L;
            }
          }
        }
        var k = this.transformBuffer.getMatrixView(l);
        this.setTransformMatrix(r, k, a), this.simpleCount++, this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
      }
    }
  }, {
    key: "_getVertTypeForShape",
    value: function(r, n) {
      var i = r.pstyle(n).value;
      switch (i) {
        case "rectangle":
          return kh;
        case "ellipse":
          return Pf;
        case "roundrectangle":
        case "round-rectangle":
          return F1;
        case "bottom-round-rectangle":
          return Of;
        default:
          return;
      }
    }
  }, {
    key: "_getCornerRadius",
    value: function(r, n, i) {
      var a = i.w, s = i.h;
      if (r.pstyle(n).value === "auto")
        return Jl(a, s);
      var o = r.pstyle(n).pfValue, l = a / 2, u = s / 2;
      return Math.min(o, u, l);
    }
    /**
     * Only supports drawing triangles at the moment.
     */
  }, {
    key: "drawEdgeArrow",
    value: function(r, n, i) {
      if (r.visible()) {
        var a = r._private.rscratch, s, o, l;
        if (i === "source" ? (s = a.arrowStartX, o = a.arrowStartY, l = a.srcArrowAngle) : (s = a.arrowEndX, o = a.arrowEndY, l = a.tgtArrowAngle), !(isNaN(s) || s == null || isNaN(o) || o == null || isNaN(l) || l == null)) {
          var u = r.pstyle(i + "-arrow-shape").value;
          if (u !== "none") {
            var h = r.pstyle(i + "-arrow-color").value, d = r.pstyle("opacity").value, f = r.pstyle("line-opacity").value, p = d * f, g = r.pstyle("width").pfValue, m = r.pstyle("arrow-scale").value, v = this.r.getArrowWidth(g, m), y = this.instanceCount, b = this.transformBuffer.getMatrixView(y);
            kL(b), Hm(b, b, [s, o]), _T(b, b, [v, v]), SL(b, b, l), this.vertTypeBuffer.getView(y)[0] = a5;
            var w = this.indexBuffer.getView(y);
            Eh(n, w);
            var T = this.colorBuffer.getView(y);
            zc(h, p, T), this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
          }
        }
      }
    }
    /**
     * Draw straight-line or bezier curve edges.
     */
  }, {
    key: "drawEdgeLine",
    value: function(r, n) {
      if (r.visible()) {
        var i = this._getEdgePoints(r);
        if (i) {
          var a = r.pstyle("opacity").value, s = r.pstyle("line-opacity").value, o = r.pstyle("width").pfValue, l = r.pstyle("line-color").value, u = a * s;
          if (i.length / 2 + this.instanceCount > this.maxInstances && this.endBatch(), i.length == 4) {
            var h = this.instanceCount;
            this.vertTypeBuffer.getView(h)[0] = CL;
            var d = this.indexBuffer.getView(h);
            Eh(n, d);
            var f = this.colorBuffer.getView(h);
            zc(l, u, f);
            var p = this.lineWidthBuffer.getView(h);
            p[0] = o;
            var g = this.pointAPointBBuffer.getView(h);
            g[0] = i[0], g[1] = i[1], g[2] = i[2], g[3] = i[3], this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
          } else
            for (var m = 0; m < i.length - 2; m += 2) {
              var v = this.instanceCount;
              this.vertTypeBuffer.getView(v)[0] = AL;
              var y = this.indexBuffer.getView(v);
              Eh(n, y);
              var b = this.colorBuffer.getView(v);
              zc(l, u, b);
              var w = this.lineWidthBuffer.getView(v);
              w[0] = o;
              var T = i[m - 2], E = i[m - 1], L = i[m], k = i[m + 1], C = i[m + 2], A = i[m + 3], R = i[m + 4], _ = i[m + 5];
              m == 0 && (T = 2 * L - C + 1e-3, E = 2 * k - A + 1e-3), m == i.length - 4 && (R = 2 * C - L + 1e-3, _ = 2 * A - k + 1e-3);
              var O = this.pointAPointBBuffer.getView(v);
              O[0] = T, O[1] = E, O[2] = L, O[3] = k;
              var P = this.pointCPointDBuffer.getView(v);
              P[0] = C, P[1] = A, P[2] = R, P[3] = _, this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
            }
        }
      }
    }
  }, {
    key: "_isValidEdge",
    value: function(r) {
      var n = r._private.rscratch;
      return !(n.badLine || n.allpts == null || isNaN(n.allpts[0]));
    }
  }, {
    key: "_getEdgePoints",
    value: function(r) {
      var n = r._private.rscratch;
      if (this._isValidEdge(r)) {
        var i = n.allpts;
        if (i.length == 4)
          return i;
        var a = this._getNumSegments(r);
        return this._getCurveSegmentPoints(i, a);
      }
    }
  }, {
    key: "_getNumSegments",
    value: function(r) {
      var n = 15;
      return Math.min(Math.max(n, 5), this.maxInstances);
    }
  }, {
    key: "_getCurveSegmentPoints",
    value: function(r, n) {
      if (r.length == 4)
        return r;
      for (var i = Array((n + 1) * 2), a = 0; a <= n; a++)
        if (a == 0)
          i[0] = r[0], i[1] = r[1];
        else if (a == n)
          i[a * 2] = r[r.length - 2], i[a * 2 + 1] = r[r.length - 1];
        else {
          var s = a / n;
          this._setCurvePoint(r, s, i, a * 2);
        }
      return i;
    }
  }, {
    key: "_setCurvePoint",
    value: function(r, n, i, a) {
      if (r.length <= 2)
        i[a] = r[0], i[a + 1] = r[1];
      else {
        for (var s = Array(r.length - 2), o = 0; o < s.length; o += 2) {
          var l = (1 - n) * r[o] + n * r[o + 2], u = (1 - n) * r[o + 1] + n * r[o + 3];
          s[o] = l, s[o + 1] = u;
        }
        return this._setCurvePoint(s, n, i, a);
      }
    }
  }, {
    key: "endBatch",
    value: function() {
      var r = this.gl, n = this.vao, i = this.vertexCount, a = this.instanceCount;
      if (a !== 0) {
        var s = this.renderTarget.picking ? this.pickingProgram : this.program;
        r.useProgram(s), r.bindVertexArray(n);
        var o = oa(this.buffers), l;
        try {
          for (o.s(); !(l = o.n()).done; ) {
            var u = l.value;
            u.bufferSubData(a);
          }
        } catch (g) {
          o.e(g);
        } finally {
          o.f();
        }
        for (var h = this.batchManager.getAtlases(), d = 0; d < h.length; d++)
          h[d].bufferIfNeeded(r);
        for (var f = 0; f < h.length; f++)
          r.activeTexture(r.TEXTURE0 + f), r.bindTexture(r.TEXTURE_2D, h[f].texture), r.uniform1i(s.uTextures[f], f);
        r.uniform1f(s.uZoom, W3e(this.r)), r.uniformMatrix3fv(s.uPanZoomMatrix, !1, this.panZoomMatrix), r.uniform1i(s.uAtlasSize, this.batchManager.getAtlasSize());
        var p = zc(this.bgColor, 1);
        r.uniform4fv(s.uBGColor, p), r.drawArraysInstanced(r.TRIANGLES, 0, i, a), r.bindVertexArray(null), r.bindTexture(r.TEXTURE_2D, null), this.debug && this.batchDebugInfo.push({
          count: a,
          // instance count
          atlasCount: h.length
        }), this.startBatch();
      }
    }
  }, {
    key: "getDebugInfo",
    value: function() {
      var r = this.atlasManager.getDebugInfo(), n = r.reduce(function(s, o) {
        return s + o.atlasCount;
      }, 0), i = this.batchDebugInfo, a = i.reduce(function(s, o) {
        return s + o.count;
      }, 0);
      return {
        atlasInfo: r,
        totalAtlases: n,
        wrappedCount: this.wrappedCount,
        simpleCount: this.simpleCount,
        batchCount: i.length,
        batchInfo: i,
        totalInstances: a
      };
    }
  }]);
})(), UU = {};
UU.initWebgl = function(t, e) {
  var r = this, n = r.data.contexts[r.WEBGL];
  t.bgColor = p5e(r), t.webglTexSize = Math.min(t.webglTexSize, n.getParameter(n.MAX_TEXTURE_SIZE)), t.webglTexRows = Math.min(t.webglTexRows, 54), t.webglTexRowsNodes = Math.min(t.webglTexRowsNodes, 54), t.webglBatchSize = Math.min(t.webglBatchSize, 16384), t.webglTexPerBatch = Math.min(t.webglTexPerBatch, n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)), r.webglDebug = t.webglDebug, r.webglDebugShowAtlases = t.webglDebugShowAtlases, r.pickingFrameBuffer = t5e(n), r.pickingFrameBuffer.needsDraw = !0, r.drawing = new f5e(r, n, t);
  var i = function(d) {
    return function(f) {
      return r.getTextAngle(f, d);
    };
  }, a = function(d) {
    return function(f) {
      var p = f.pstyle(d);
      return p && p.value;
    };
  }, s = function(d) {
    return function(f) {
      return f.pstyle("".concat(d, "-opacity")).value > 0;
    };
  }, o = function(d) {
    var f = d.pstyle("text-events").strValue === "yes";
    return f ? Oy.USE_BB : Oy.IGNORE;
  }, l = function(d) {
    var f = d.position(), p = f.x, g = f.y, m = d.outerWidth(), v = d.outerHeight();
    return {
      w: m,
      h: v,
      x1: p - m / 2,
      y1: g - v / 2
    };
  };
  r.drawing.addAtlasCollection("node", {
    texRows: t.webglTexRowsNodes
  }), r.drawing.addAtlasCollection("label", {
    texRows: t.webglTexRows
  }), r.drawing.addTextureAtlasRenderType("node-body", {
    collection: "node",
    getKey: e.getStyleKey,
    getBoundingBox: e.getElementBox,
    drawElement: e.drawElement
  }), r.drawing.addSimpleShapeRenderType("node-body", {
    getBoundingBox: l,
    isSimple: X3e,
    shapeProps: {
      shape: "shape",
      color: "background-color",
      opacity: "background-opacity",
      radius: "corner-radius",
      border: !0
    }
  }), r.drawing.addSimpleShapeRenderType("node-overlay", {
    getBoundingBox: l,
    isVisible: s("overlay"),
    shapeProps: {
      shape: "overlay-shape",
      color: "overlay-color",
      opacity: "overlay-opacity",
      padding: "overlay-padding",
      radius: "overlay-corner-radius"
    }
  }), r.drawing.addSimpleShapeRenderType("node-underlay", {
    getBoundingBox: l,
    isVisible: s("underlay"),
    shapeProps: {
      shape: "underlay-shape",
      color: "underlay-color",
      opacity: "underlay-opacity",
      padding: "underlay-padding",
      radius: "underlay-corner-radius"
    }
  }), r.drawing.addTextureAtlasRenderType("label", {
    // node label or edge mid label
    collection: "label",
    getTexPickingMode: o,
    getKey: s5(e.getLabelKey, null),
    getBoundingBox: o5(e.getLabelBox, null),
    drawClipped: !0,
    drawElement: e.drawLabel,
    getRotation: i(null),
    getRotationPoint: e.getLabelRotationPoint,
    getRotationOffset: e.getLabelRotationOffset,
    isVisible: a("label")
  }), r.drawing.addTextureAtlasRenderType("edge-source-label", {
    collection: "label",
    getTexPickingMode: o,
    getKey: s5(e.getSourceLabelKey, "source"),
    getBoundingBox: o5(e.getSourceLabelBox, "source"),
    drawClipped: !0,
    drawElement: e.drawSourceLabel,
    getRotation: i("source"),
    getRotationPoint: e.getSourceLabelRotationPoint,
    getRotationOffset: e.getSourceLabelRotationOffset,
    isVisible: a("source-label")
  }), r.drawing.addTextureAtlasRenderType("edge-target-label", {
    collection: "label",
    getTexPickingMode: o,
    getKey: s5(e.getTargetLabelKey, "target"),
    getBoundingBox: o5(e.getTargetLabelBox, "target"),
    drawClipped: !0,
    drawElement: e.drawTargetLabel,
    getRotation: i("target"),
    getRotationPoint: e.getTargetLabelRotationPoint,
    getRotationOffset: e.getTargetLabelRotationOffset,
    isVisible: a("target-label")
  });
  var u = Ag(function() {
    console.log("garbage collect flag set"), r.data.gc = !0;
  }, 1e4);
  r.onUpdateEleCalcs(function(h, d) {
    var f = !1;
    d && d.length > 0 && (f |= r.drawing.invalidate(d)), f && u();
  }), g5e(r);
};
function p5e(t) {
  var e = t.cy.container(), r = e && e.style && e.style.backgroundColor || "white";
  return vV(r);
}
function HU(t, e) {
  var r = t._private.rscratch;
  return na(r, "labelWrapCachedLines", e) || [];
}
var s5 = function(e, r) {
  return function(n) {
    var i = e(n), a = HU(n, r);
    return a.length > 1 ? a.map(function(s, o) {
      return "".concat(i, "_").concat(o);
    }) : i;
  };
}, o5 = function(e, r) {
  return function(n, i) {
    var a = e(n);
    if (typeof i == "string") {
      var s = i.indexOf("_");
      if (s > 0) {
        var o = Number(i.substring(s + 1)), l = HU(n, r), u = a.h / l.length, h = u * o, d = a.y1 + h;
        return {
          x1: a.x1,
          w: a.w,
          y1: d,
          h: u,
          yOffset: h
        };
      }
    }
    return a;
  };
};
function g5e(t) {
  {
    var e = t.render;
    t.render = function(a) {
      a = a || {};
      var s = t.cy;
      t.webgl && (s.zoom() > PU ? (m5e(t), e.call(t, a)) : (v5e(t), WU(t, a, rp.SCREEN)));
    };
  }
  {
    var r = t.matchCanvasSize;
    t.matchCanvasSize = function(a) {
      r.call(t, a), t.pickingFrameBuffer.setFramebufferAttachmentSizes(t.canvasWidth, t.canvasHeight), t.pickingFrameBuffer.needsDraw = !0;
    };
  }
  t.findNearestElements = function(a, s, o, l) {
    return E5e(t, a, s);
  };
  {
    var n = t.invalidateCachedZSortedEles;
    t.invalidateCachedZSortedEles = function() {
      n.call(t), t.pickingFrameBuffer.needsDraw = !0;
    };
  }
  {
    var i = t.notify;
    t.notify = function(a, s) {
      i.call(t, a, s), a === "viewport" || a === "bounds" ? t.pickingFrameBuffer.needsDraw = !0 : a === "background" && t.drawing.invalidate(s, {
        type: "node-body"
      });
    };
  }
}
function m5e(t) {
  var e = t.data.contexts[t.WEBGL];
  e.clear(e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT);
}
function v5e(t) {
  var e = function(n) {
    n.save(), n.setTransform(1, 0, 0, 1, 0, 0), n.clearRect(0, 0, t.canvasWidth, t.canvasHeight), n.restore();
  };
  e(t.data.contexts[t.NODE]), e(t.data.contexts[t.DRAG]);
}
function y5e(t) {
  var e = t.canvasWidth, r = t.canvasHeight, n = mS(t), i = n.pan, a = n.zoom, s = n5();
  Hm(s, s, [i.x, i.y]), _T(s, s, [a, a]);
  var o = n5();
  n5e(o, e, r);
  var l = n5();
  return r5e(l, o, s), l;
}
function qU(t, e) {
  var r = t.canvasWidth, n = t.canvasHeight, i = mS(t), a = i.pan, s = i.zoom;
  e.setTransform(1, 0, 0, 1, 0, 0), e.clearRect(0, 0, r, n), e.translate(a.x, a.y), e.scale(s, s);
}
function x5e(t, e) {
  t.drawSelectionRectangle(e, function(r) {
    return qU(t, r);
  });
}
function b5e(t) {
  var e = t.data.contexts[t.NODE];
  e.save(), qU(t, e), e.strokeStyle = "rgba(0, 0, 0, 0.3)", e.beginPath(), e.moveTo(-1e3, 0), e.lineTo(1e3, 0), e.stroke(), e.beginPath(), e.moveTo(0, -1e3), e.lineTo(0, 1e3), e.stroke(), e.restore();
}
function w5e(t) {
  var e = function(i, a, s) {
    for (var o = i.atlasManager.getAtlasCollection(a), l = t.data.contexts[t.NODE], u = o.atlases, h = 0; h < u.length; h++) {
      var d = u[h], f = d.canvas;
      if (f) {
        var p = f.width, g = f.height, m = p * h, v = f.height * s, y = 0.4;
        l.save(), l.scale(y, y), l.drawImage(f, m, v), l.strokeStyle = "black", l.rect(m, v, p, g), l.stroke(), l.restore();
      }
    }
  }, r = 0;
  e(t.drawing, "node", r++), e(t.drawing, "label", r++);
}
function T5e(t, e, r, n, i) {
  var a, s, o, l, u = mS(t), h = u.pan, d = u.zoom;
  {
    var f = Y3e(t, h, d, e, r), p = En(f, 2), g = p[0], m = p[1], v = 6;
    a = g - v / 2, s = m - v / 2, o = v, l = v;
  }
  if (o === 0 || l === 0)
    return [];
  var y = t.data.contexts[t.WEBGL];
  y.bindFramebuffer(y.FRAMEBUFFER, t.pickingFrameBuffer), t.pickingFrameBuffer.needsDraw && (y.viewport(0, 0, y.canvas.width, y.canvas.height), WU(t, null, rp.PICKING), t.pickingFrameBuffer.needsDraw = !1);
  var b = o * l, w = new Uint8Array(b * 4);
  y.readPixels(a, s, o, l, y.RGBA, y.UNSIGNED_BYTE, w), y.bindFramebuffer(y.FRAMEBUFFER, null);
  for (var T = /* @__PURE__ */ new Set(), E = 0; E < b; E++) {
    var L = w.slice(E * 4, E * 4 + 4), k = K3e(L) - 1;
    k >= 0 && T.add(k);
  }
  return T;
}
function E5e(t, e, r) {
  var n = T5e(t, e, r), i = t.getCachedZSortedEles(), a, s, o = oa(n), l;
  try {
    for (o.s(); !(l = o.n()).done; ) {
      var u = l.value, h = i[u];
      if (!a && h.isNode() && (a = h), !s && h.isEdge() && (s = h), a && s)
        break;
    }
  } catch (d) {
    o.e(d);
  } finally {
    o.f();
  }
  return [a, s].filter(Boolean);
}
function l5(t, e, r) {
  var n = t.drawing;
  e += 1, r.isNode() ? (n.drawNode(r, e, "node-underlay"), n.drawNode(r, e, "node-body"), n.drawTexture(r, e, "label"), n.drawNode(r, e, "node-overlay")) : (n.drawEdgeLine(r, e), n.drawEdgeArrow(r, e, "source"), n.drawEdgeArrow(r, e, "target"), n.drawTexture(r, e, "label"), n.drawTexture(r, e, "edge-source-label"), n.drawTexture(r, e, "edge-target-label"));
}
function WU(t, e, r) {
  var n;
  t.webglDebug && (n = performance.now());
  var i = t.drawing, a = 0;
  if (r.screen && t.data.canvasNeedsRedraw[t.SELECT_BOX] && x5e(t, e), t.data.canvasNeedsRedraw[t.NODE] || r.picking) {
    var s = t.data.contexts[t.WEBGL];
    r.screen ? (s.clearColor(0, 0, 0, 0), s.enable(s.BLEND), s.blendFunc(s.ONE, s.ONE_MINUS_SRC_ALPHA)) : s.disable(s.BLEND), s.clear(s.COLOR_BUFFER_BIT | s.DEPTH_BUFFER_BIT), s.viewport(0, 0, s.canvas.width, s.canvas.height);
    var o = y5e(t), l = t.getCachedZSortedEles();
    if (a = l.length, i.startFrame(o, r), r.screen) {
      for (var u = 0; u < l.nondrag.length; u++)
        l5(t, u, l.nondrag[u]);
      for (var h = 0; h < l.drag.length; h++)
        l5(t, h, l.drag[h]);
    } else if (r.picking)
      for (var d = 0; d < l.length; d++)
        l5(t, d, l[d]);
    i.endFrame(), r.screen && t.webglDebugShowAtlases && (b5e(t), w5e(t)), t.data.canvasNeedsRedraw[t.NODE] = !1, t.data.canvasNeedsRedraw[t.DRAG] = !1;
  }
  if (t.webglDebug) {
    var f = performance.now(), p = !1, g = Math.ceil(f - n), m = i.getDebugInfo(), v = ["".concat(a, " elements"), "".concat(m.totalInstances, " instances"), "".concat(m.batchCount, " batches"), "".concat(m.totalAtlases, " atlases"), "".concat(m.wrappedCount, " wrapped textures"), "".concat(m.simpleCount, " simple shapes")].join(", ");
    if (p)
      console.log("WebGL (".concat(r.name, ") - time ").concat(g, "ms, ").concat(v));
    else {
      console.log("WebGL (".concat(r.name, ") - frame time ").concat(g, "ms")), console.log("Totals:"), console.log("  ".concat(v)), console.log("Texture Atlases Used:");
      var y = m.atlasInfo, b = oa(y), w;
      try {
        for (b.s(); !(w = b.n()).done; ) {
          var T = w.value;
          console.log("  ".concat(T.type, ": ").concat(T.keyCount, " keys, ").concat(T.atlasCount, " atlases"));
        }
      } catch (E) {
        b.e(E);
      } finally {
        b.f();
      }
      console.log("");
    }
  }
  t.data.gc && (console.log("Garbage Collect!"), t.data.gc = !1, i.gc());
}
var bc = {};
bc.drawPolygonPath = function(t, e, r, n, i, a) {
  var s = n / 2, o = i / 2;
  t.beginPath && t.beginPath(), t.moveTo(e + s * a[0], r + o * a[1]);
  for (var l = 1; l < a.length / 2; l++)
    t.lineTo(e + s * a[l * 2], r + o * a[l * 2 + 1]);
  t.closePath();
};
bc.drawRoundPolygonPath = function(t, e, r, n, i, a, s) {
  s.forEach(function(o) {
    return AU(t, o);
  }), t.closePath();
};
bc.drawRoundRectanglePath = function(t, e, r, n, i, a) {
  var s = n / 2, o = i / 2, l = a === "auto" ? Jl(n, i) : Math.min(a, o, s);
  t.beginPath && t.beginPath(), t.moveTo(e, r - o), t.arcTo(e + s, r - o, e + s, r, l), t.arcTo(e + s, r + o, e, r + o, l), t.arcTo(e - s, r + o, e - s, r, l), t.arcTo(e - s, r - o, e, r - o, l), t.lineTo(e, r - o), t.closePath();
};
bc.drawBottomRoundRectanglePath = function(t, e, r, n, i, a) {
  var s = n / 2, o = i / 2, l = a === "auto" ? Jl(n, i) : a;
  t.beginPath && t.beginPath(), t.moveTo(e, r - o), t.lineTo(e + s, r - o), t.lineTo(e + s, r), t.arcTo(e + s, r + o, e, r + o, l), t.arcTo(e - s, r + o, e - s, r, l), t.lineTo(e - s, r - o), t.lineTo(e, r - o), t.closePath();
};
bc.drawCutRectanglePath = function(t, e, r, n, i, a, s) {
  var o = n / 2, l = i / 2, u = s === "auto" ? rS() : s;
  t.beginPath && t.beginPath(), t.moveTo(e - o + u, r - l), t.lineTo(e + o - u, r - l), t.lineTo(e + o, r - l + u), t.lineTo(e + o, r + l - u), t.lineTo(e + o - u, r + l), t.lineTo(e - o + u, r + l), t.lineTo(e - o, r + l - u), t.lineTo(e - o, r - l + u), t.closePath();
};
bc.drawBarrelPath = function(t, e, r, n, i) {
  var a = n / 2, s = i / 2, o = e - a, l = e + a, u = r - s, h = r + s, d = pT(n, i), f = d.widthOffset, p = d.heightOffset, g = d.ctrlPtOffsetPct * f;
  t.beginPath && t.beginPath(), t.moveTo(o, u + p), t.lineTo(o, h - p), t.quadraticCurveTo(o + g, h, o + f, h), t.lineTo(l - f, h), t.quadraticCurveTo(l - g, h, l, h - p), t.lineTo(l, u + p), t.quadraticCurveTo(l - g, u, l - f, u), t.lineTo(o + f, u), t.quadraticCurveTo(o + g, u, o, u + p), t.closePath();
};
var _L = Math.sin(0), LL = Math.cos(0), LT = {}, RT = {}, YU = Math.PI / 40;
for (var Sh = 0 * Math.PI; Sh < 2 * Math.PI; Sh += YU)
  LT[Sh] = Math.sin(Sh), RT[Sh] = Math.cos(Sh);
bc.drawEllipsePath = function(t, e, r, n, i) {
  if (t.beginPath && t.beginPath(), t.ellipse)
    t.ellipse(e, r, n / 2, i / 2, 0, 0, 2 * Math.PI);
  else
    for (var a, s, o = n / 2, l = i / 2, u = 0 * Math.PI; u < 2 * Math.PI; u += YU)
      a = e - o * LT[u] * _L + o * RT[u] * LL, s = r + l * RT[u] * _L + l * LT[u] * LL, u === 0 ? t.moveTo(a, s) : t.lineTo(a, s);
  t.closePath();
};
var Ig = {};
Ig.createBuffer = function(t, e) {
  var r = document.createElement("canvas");
  return r.width = t, r.height = e, [r, r.getContext("2d")];
};
Ig.bufferCanvasImage = function(t) {
  var e = this.cy, r = e.mutableElements(), n = r.boundingBox(), i = this.findContainerClientCoords(), a = t.full ? Math.ceil(n.w) : i[2], s = t.full ? Math.ceil(n.h) : i[3], o = mt(t.maxWidth) || mt(t.maxHeight), l = this.getPixelRatio(), u = 1;
  if (t.scale !== void 0)
    a *= t.scale, s *= t.scale, u = t.scale;
  else if (o) {
    var h = 1 / 0, d = 1 / 0;
    mt(t.maxWidth) && (h = u * t.maxWidth / a), mt(t.maxHeight) && (d = u * t.maxHeight / s), u = Math.min(h, d), a *= u, s *= u;
  }
  o || (a *= l, s *= l, u *= l);
  var f = document.createElement("canvas");
  f.width = a, f.height = s, f.style.width = a + "px", f.style.height = s + "px";
  var p = f.getContext("2d");
  if (a > 0 && s > 0) {
    p.clearRect(0, 0, a, s), p.globalCompositeOperation = "source-over";
    var g = this.getCachedZSortedEles();
    if (t.full)
      p.translate(-n.x1 * u, -n.y1 * u), p.scale(u, u), this.drawElements(p, g), p.scale(1 / u, 1 / u), p.translate(n.x1 * u, n.y1 * u);
    else {
      var m = e.pan(), v = {
        x: m.x * u,
        y: m.y * u
      };
      u *= e.zoom(), p.translate(v.x, v.y), p.scale(u, u), this.drawElements(p, g), p.scale(1 / u, 1 / u), p.translate(-v.x, -v.y);
    }
    t.bg && (p.globalCompositeOperation = "destination-over", p.fillStyle = t.bg, p.rect(0, 0, a, s), p.fill());
  }
  return f;
};
function k5e(t, e) {
  for (var r = atob(t), n = new ArrayBuffer(r.length), i = new Uint8Array(n), a = 0; a < r.length; a++)
    i[a] = r.charCodeAt(a);
  return new Blob([n], {
    type: e
  });
}
function RL(t) {
  var e = t.indexOf(",");
  return t.substr(e + 1);
}
function XU(t, e, r) {
  var n = function() {
    return e.toDataURL(r, t.quality);
  };
  switch (t.output) {
    case "blob-promise":
      return new rf(function(i, a) {
        try {
          e.toBlob(function(s) {
            s != null ? i(s) : a(new Error("`canvas.toBlob()` sent a null value in its callback"));
          }, r, t.quality);
        } catch (s) {
          a(s);
        }
      });
    case "blob":
      return k5e(RL(n()), r);
    case "base64":
      return RL(n());
    default:
      return n();
  }
}
Ig.png = function(t) {
  return XU(t, this.bufferCanvasImage(t), "image/png");
};
Ig.jpg = function(t) {
  return XU(t, this.bufferCanvasImage(t), "image/jpeg");
};
var jU = {};
jU.nodeShapeImpl = function(t, e, r, n, i, a, s, o) {
  switch (t) {
    case "ellipse":
      return this.drawEllipsePath(e, r, n, i, a);
    case "polygon":
      return this.drawPolygonPath(e, r, n, i, a, s);
    case "round-polygon":
      return this.drawRoundPolygonPath(e, r, n, i, a, s, o);
    case "roundrectangle":
    case "round-rectangle":
      return this.drawRoundRectanglePath(e, r, n, i, a, o);
    case "cutrectangle":
    case "cut-rectangle":
      return this.drawCutRectanglePath(e, r, n, i, a, s, o);
    case "bottomroundrectangle":
    case "bottom-round-rectangle":
      return this.drawBottomRoundRectanglePath(e, r, n, i, a, o);
    case "barrel":
      return this.drawBarrelPath(e, r, n, i, a);
  }
};
var S5e = KU, er = KU.prototype;
er.CANVAS_LAYERS = 3;
er.SELECT_BOX = 0;
er.DRAG = 1;
er.NODE = 2;
er.WEBGL = 3;
er.CANVAS_TYPES = ["2d", "2d", "2d", "webgl2"];
er.BUFFER_COUNT = 3;
er.TEXTURE_BUFFER = 0;
er.MOTIONBLUR_BUFFER_NODE = 1;
er.MOTIONBLUR_BUFFER_DRAG = 2;
function KU(t) {
  var e = this, r = e.cy.window(), n = r.document;
  t.webgl && (er.CANVAS_LAYERS = e.CANVAS_LAYERS = 4, console.log("webgl rendering enabled")), e.data = {
    canvases: new Array(er.CANVAS_LAYERS),
    contexts: new Array(er.CANVAS_LAYERS),
    canvasNeedsRedraw: new Array(er.CANVAS_LAYERS),
    bufferCanvases: new Array(er.BUFFER_COUNT),
    bufferContexts: new Array(er.CANVAS_LAYERS)
  };
  var i = "-webkit-tap-highlight-color", a = "rgba(0,0,0,0)";
  e.data.canvasContainer = n.createElement("div");
  var s = e.data.canvasContainer.style;
  e.data.canvasContainer.style[i] = a, s.position = "relative", s.zIndex = "0", s.overflow = "hidden";
  var o = t.cy.container();
  o.appendChild(e.data.canvasContainer), o.style[i] = a;
  var l = {
    "-webkit-user-select": "none",
    "-moz-user-select": "-moz-none",
    "user-select": "none",
    "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
    "outline-style": "none"
  };
  xye() && (l["-ms-touch-action"] = "none", l["touch-action"] = "none");
  for (var u = 0; u < er.CANVAS_LAYERS; u++) {
    var h = e.data.canvases[u] = n.createElement("canvas"), d = er.CANVAS_TYPES[u];
    e.data.contexts[u] = h.getContext(d), e.data.contexts[u] || Zr("Could not create canvas of type " + d), Object.keys(l).forEach(function(K) {
      h.style[K] = l[K];
    }), h.style.position = "absolute", h.setAttribute("data-id", "layer" + u), h.style.zIndex = String(er.CANVAS_LAYERS - u), e.data.canvasContainer.appendChild(h), e.data.canvasNeedsRedraw[u] = !1;
  }
  e.data.topCanvas = e.data.canvases[0], e.data.canvases[er.NODE].setAttribute("data-id", "layer" + er.NODE + "-node"), e.data.canvases[er.SELECT_BOX].setAttribute("data-id", "layer" + er.SELECT_BOX + "-selectbox"), e.data.canvases[er.DRAG].setAttribute("data-id", "layer" + er.DRAG + "-drag"), e.data.canvases[er.WEBGL] && e.data.canvases[er.WEBGL].setAttribute("data-id", "layer" + er.WEBGL + "-webgl");
  for (var u = 0; u < er.BUFFER_COUNT; u++)
    e.data.bufferCanvases[u] = n.createElement("canvas"), e.data.bufferContexts[u] = e.data.bufferCanvases[u].getContext("2d"), e.data.bufferCanvases[u].style.position = "absolute", e.data.bufferCanvases[u].setAttribute("data-id", "buffer" + u), e.data.bufferCanvases[u].style.zIndex = String(-u - 1), e.data.bufferCanvases[u].style.visibility = "hidden";
  e.pathsEnabled = !0;
  var f = qi(), p = function(Z) {
    return {
      x: (Z.x1 + Z.x2) / 2,
      y: (Z.y1 + Z.y2) / 2
    };
  }, g = function(Z) {
    return {
      x: -Z.w / 2,
      y: -Z.h / 2
    };
  }, m = function(Z) {
    var X = Z[0]._private, Y = X.oldBackgroundTimestamp === X.backgroundTimestamp;
    return !Y;
  }, v = function(Z) {
    return Z[0]._private.nodeKey;
  }, y = function(Z) {
    return Z[0]._private.labelStyleKey;
  }, b = function(Z) {
    return Z[0]._private.sourceLabelStyleKey;
  }, w = function(Z) {
    return Z[0]._private.targetLabelStyleKey;
  }, T = function(Z, X, Y, ee, j) {
    return e.drawElement(Z, X, Y, !1, !1, j);
  }, E = function(Z, X, Y, ee, j) {
    return e.drawElementText(Z, X, Y, ee, "main", j);
  }, L = function(Z, X, Y, ee, j) {
    return e.drawElementText(Z, X, Y, ee, "source", j);
  }, k = function(Z, X, Y, ee, j) {
    return e.drawElementText(Z, X, Y, ee, "target", j);
  }, C = function(Z) {
    return Z.boundingBox(), Z[0]._private.bodyBounds;
  }, A = function(Z) {
    return Z.boundingBox(), Z[0]._private.labelBounds.main || f;
  }, R = function(Z) {
    return Z.boundingBox(), Z[0]._private.labelBounds.source || f;
  }, _ = function(Z) {
    return Z.boundingBox(), Z[0]._private.labelBounds.target || f;
  }, O = function(Z, X) {
    return X;
  }, P = function(Z) {
    return p(C(Z));
  }, S = function(Z, X, Y) {
    var ee = Z ? Z + "-" : "";
    return {
      x: X.x + Y.pstyle(ee + "text-margin-x").pfValue,
      y: X.y + Y.pstyle(ee + "text-margin-y").pfValue
    };
  }, M = function(Z, X, Y) {
    var ee = Z[0]._private.rscratch;
    return {
      x: ee[X],
      y: ee[Y]
    };
  }, N = function(Z) {
    return S("", M(Z, "labelX", "labelY"), Z);
  }, D = function(Z) {
    return S("source", M(Z, "sourceLabelX", "sourceLabelY"), Z);
  }, I = function(Z) {
    return S("target", M(Z, "targetLabelX", "targetLabelY"), Z);
  }, B = function(Z) {
    return g(C(Z));
  }, z = function(Z) {
    return g(R(Z));
  }, F = function(Z) {
    return g(_(Z));
  }, V = function(Z) {
    var X = A(Z), Y = g(A(Z));
    if (Z.isNode()) {
      switch (Z.pstyle("text-halign").value) {
        case "left":
          Y.x = -X.w - (X.leftPad || 0);
          break;
        case "right":
          Y.x = -(X.rightPad || 0);
          break;
      }
      switch (Z.pstyle("text-valign").value) {
        case "top":
          Y.y = -X.h - (X.topPad || 0);
          break;
        case "bottom":
          Y.y = -(X.botPad || 0);
          break;
      }
    }
    return Y;
  }, H = e.data.eleTxrCache = new r0(e, {
    getKey: v,
    doesEleInvalidateKey: m,
    drawElement: T,
    getBoundingBox: C,
    getRotationPoint: P,
    getRotationOffset: B,
    allowEdgeTxrCaching: !1,
    allowParentTxrCaching: !1
  }), J = e.data.lblTxrCache = new r0(e, {
    getKey: y,
    drawElement: E,
    getBoundingBox: A,
    getRotationPoint: N,
    getRotationOffset: V,
    isVisible: O
  }), q = e.data.slbTxrCache = new r0(e, {
    getKey: b,
    drawElement: L,
    getBoundingBox: R,
    getRotationPoint: D,
    getRotationOffset: z,
    isVisible: O
  }), ae = e.data.tlbTxrCache = new r0(e, {
    getKey: w,
    drawElement: k,
    getBoundingBox: _,
    getRotationPoint: I,
    getRotationOffset: F,
    isVisible: O
  }), re = e.data.lyrTxrCache = new BU(e);
  e.onUpdateEleCalcs(function(Z, X) {
    H.invalidateElements(X), J.invalidateElements(X), q.invalidateElements(X), ae.invalidateElements(X), re.invalidateElements(X);
    for (var Y = 0; Y < X.length; Y++) {
      var ee = X[Y]._private;
      ee.oldBackgroundTimestamp = ee.backgroundTimestamp;
    }
  });
  var pe = function(Z) {
    for (var X = 0; X < Z.length; X++)
      re.enqueueElementRefinement(Z[X].ele);
  };
  H.onDequeue(pe), J.onDequeue(pe), q.onDequeue(pe), ae.onDequeue(pe), t.webgl && e.initWebgl(t, {
    getStyleKey: v,
    getLabelKey: y,
    getSourceLabelKey: b,
    getTargetLabelKey: w,
    drawElement: T,
    drawLabel: E,
    drawSourceLabel: L,
    drawTargetLabel: k,
    getElementBox: C,
    getLabelBox: A,
    getSourceLabelBox: R,
    getTargetLabelBox: _,
    getElementRotationPoint: P,
    getElementRotationOffset: B,
    getLabelRotationPoint: N,
    getSourceLabelRotationPoint: D,
    getTargetLabelRotationPoint: I,
    getLabelRotationOffset: V,
    getSourceLabelRotationOffset: z,
    getTargetLabelRotationOffset: F
  });
}
er.redrawHint = function(t, e) {
  var r = this;
  switch (t) {
    case "eles":
      r.data.canvasNeedsRedraw[er.NODE] = e;
      break;
    case "drag":
      r.data.canvasNeedsRedraw[er.DRAG] = e;
      break;
    case "select":
      r.data.canvasNeedsRedraw[er.SELECT_BOX] = e;
      break;
    case "gc":
      r.data.gc = !0;
      break;
  }
};
var C5e = typeof Path2D < "u";
er.path2dEnabled = function(t) {
  if (t === void 0)
    return this.pathsEnabled;
  this.pathsEnabled = !!t;
};
er.usePaths = function() {
  return C5e && this.pathsEnabled;
};
er.setImgSmoothing = function(t, e) {
  t.imageSmoothingEnabled != null ? t.imageSmoothingEnabled = e : (t.webkitImageSmoothingEnabled = e, t.mozImageSmoothingEnabled = e, t.msImageSmoothingEnabled = e);
};
er.getImgSmoothing = function(t) {
  return t.imageSmoothingEnabled != null ? t.imageSmoothingEnabled : t.webkitImageSmoothingEnabled || t.mozImageSmoothingEnabled || t.msImageSmoothingEnabled;
};
er.makeOffscreenCanvas = function(t, e) {
  var r;
  if ((typeof OffscreenCanvas > "u" ? "undefined" : zn(OffscreenCanvas)) !== "undefined")
    r = new OffscreenCanvas(t, e);
  else {
    var n = this.cy.window(), i = n.document;
    r = i.createElement("canvas"), r.width = t, r.height = e;
  }
  return r;
};
[FU, mo, pl, gS, th, xc, Ki, UU, bc, Ig, jU].forEach(function(t) {
  Gt(er, t);
});
var A5e = [{
  name: "null",
  impl: kU
}, {
  name: "base",
  impl: DU
}, {
  name: "canvas",
  impl: S5e
}], _5e = [{
  type: "layout",
  extensions: J4e
}, {
  type: "renderer",
  extensions: A5e
}], ZU = {}, QU = {};
function JU(t, e, r) {
  var n = r, i = function(C) {
    Lr("Can not register `" + e + "` for `" + t + "` since `" + C + "` already exists in the prototype and can not be overridden");
  };
  if (t === "core") {
    if (Gp.prototype[e])
      return i(e);
    Gp.prototype[e] = r;
  } else if (t === "collection") {
    if (ui.prototype[e])
      return i(e);
    ui.prototype[e] = r;
  } else if (t === "layout") {
    for (var a = function(C) {
      this.options = C, r.call(this, C), mr(this._private) || (this._private = {}), this._private.cy = C.cy, this._private.listeners = [], this.createEmitter();
    }, s = a.prototype = Object.create(r.prototype), o = [], l = 0; l < o.length; l++) {
      var u = o[l];
      s[u] = s[u] || function() {
        return this;
      };
    }
    s.start && !s.run ? s.run = function() {
      return this.start(), this;
    } : !s.start && s.run && (s.start = function() {
      return this.run(), this;
    });
    var h = r.prototype.stop;
    s.stop = function() {
      var k = this.options;
      if (k && k.animate) {
        var C = this.animations;
        if (C)
          for (var A = 0; A < C.length; A++)
            C[A].stop();
      }
      return h ? h.call(this) : this.emit("layoutstop"), this;
    }, s.destroy || (s.destroy = function() {
      return this;
    }), s.cy = function() {
      return this._private.cy;
    };
    var d = function(C) {
      return C._private.cy;
    }, f = {
      addEventFields: function(C, A) {
        A.layout = C, A.cy = d(C), A.target = C;
      },
      bubble: function() {
        return !0;
      },
      parent: function(C) {
        return d(C);
      }
    };
    Gt(s, {
      createEmitter: function() {
        return this._private.emitter = new Ox(f, this), this;
      },
      emitter: function() {
        return this._private.emitter;
      },
      on: function(C, A) {
        return this.emitter().on(C, A), this;
      },
      one: function(C, A) {
        return this.emitter().one(C, A), this;
      },
      once: function(C, A) {
        return this.emitter().one(C, A), this;
      },
      removeListener: function(C, A) {
        return this.emitter().removeListener(C, A), this;
      },
      removeAllListeners: function() {
        return this.emitter().removeAllListeners(), this;
      },
      emit: function(C, A) {
        return this.emitter().emit(C, A), this;
      }
    }), Ar.eventAliasesOn(s), n = a;
  } else if (t === "renderer" && e !== "null" && e !== "base") {
    var p = eH("renderer", "base"), g = p.prototype, m = r, v = r.prototype, y = function() {
      p.apply(this, arguments), m.apply(this, arguments);
    }, b = y.prototype;
    for (var w in g) {
      var T = g[w], E = v[w] != null;
      if (E)
        return i(w);
      b[w] = T;
    }
    for (var L in v)
      b[L] = v[L];
    g.clientFunctions.forEach(function(k) {
      b[k] = b[k] || function() {
        Zr("Renderer does not implement `renderer." + k + "()` on its prototype");
      };
    }), n = y;
  } else if (t === "__proto__" || t === "constructor" || t === "prototype")
    return Zr(t + " is an illegal type to be registered, possibly lead to prototype pollutions");
  return yV({
    map: ZU,
    keys: [t, e],
    value: n
  });
}
function eH(t, e) {
  return xV({
    map: ZU,
    keys: [t, e]
  });
}
function L5e(t, e, r, n, i) {
  return yV({
    map: QU,
    keys: [t, e, r, n],
    value: i
  });
}
function R5e(t, e, r, n) {
  return xV({
    map: QU,
    keys: [t, e, r, n]
  });
}
var MT = function() {
  if (arguments.length === 2)
    return eH.apply(null, arguments);
  if (arguments.length === 3)
    return JU.apply(null, arguments);
  if (arguments.length === 4)
    return R5e.apply(null, arguments);
  if (arguments.length === 5)
    return L5e.apply(null, arguments);
  Zr("Invalid extension access syntax");
};
Gp.prototype.extension = MT;
_5e.forEach(function(t) {
  t.extensions.forEach(function(e) {
    JU(t.type, e.name, e.impl);
  });
});
var Py = function() {
  if (!(this instanceof Py))
    return new Py();
  this.length = 0;
}, Ru = Py.prototype;
Ru.instanceString = function() {
  return "stylesheet";
};
Ru.selector = function(t) {
  var e = this.length++;
  return this[e] = {
    selector: t,
    properties: []
  }, this;
};
Ru.css = function(t, e) {
  var r = this.length - 1;
  if (Bt(t))
    this[r].properties.push({
      name: t,
      value: e
    });
  else if (mr(t))
    for (var n = t, i = Object.keys(n), a = 0; a < i.length; a++) {
      var s = i[a], o = n[s];
      if (o != null) {
        var l = jn.properties[s] || jn.properties[Sx(s)];
        if (l != null) {
          var u = l.name, h = o;
          this[r].properties.push({
            name: u,
            value: h
          });
        }
      }
    }
  return this;
};
Ru.style = Ru.css;
Ru.generateStyle = function(t) {
  var e = new jn(t);
  return this.appendToStyle(e);
};
Ru.appendToStyle = function(t) {
  for (var e = 0; e < this.length; e++) {
    var r = this[e], n = r.selector, i = r.properties;
    t.selector(n);
    for (var a = 0; a < i.length; a++) {
      var s = i[a];
      t.css(s.name, s.value);
    }
  }
  return t;
};
var M5e = "3.33.1", oo = function(e) {
  if (e === void 0 && (e = {}), mr(e))
    return new Gp(e);
  if (Bt(e))
    return MT.apply(MT, arguments);
};
oo.use = function(t) {
  var e = Array.prototype.slice.call(arguments, 1);
  return e.unshift(oo), t.apply(null, e), this;
};
oo.warnings = function(t) {
  return CV(t);
};
oo.version = M5e;
oo.stylesheet = oo.Stylesheet = Py;
var qm = { exports: {} }, Wm = { exports: {} }, Ym = { exports: {} }, N5e = Ym.exports, ML;
function I5e() {
  return ML || (ML = 1, (function(t, e) {
    (function(n, i) {
      t.exports = i();
    })(N5e, function() {
      return (
        /******/
        (function(r) {
          var n = {};
          function i(a) {
            if (n[a])
              return n[a].exports;
            var s = n[a] = {
              /******/
              i: a,
              /******/
              l: !1,
              /******/
              exports: {}
              /******/
            };
            return r[a].call(s.exports, s, s.exports, i), s.l = !0, s.exports;
          }
          return i.m = r, i.c = n, i.i = function(a) {
            return a;
          }, i.d = function(a, s, o) {
            i.o(a, s) || Object.defineProperty(a, s, {
              /******/
              configurable: !1,
              /******/
              enumerable: !0,
              /******/
              get: o
              /******/
            });
          }, i.n = function(a) {
            var s = a && a.__esModule ? (
              /******/
              function() {
                return a.default;
              }
            ) : (
              /******/
              function() {
                return a;
              }
            );
            return i.d(s, "a", s), s;
          }, i.o = function(a, s) {
            return Object.prototype.hasOwnProperty.call(a, s);
          }, i.p = "", i(i.s = 26);
        })([
          /* 0 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.QUALITY = 1, a.DEFAULT_CREATE_BENDS_AS_NEEDED = !1, a.DEFAULT_INCREMENTAL = !1, a.DEFAULT_ANIMATION_ON_LAYOUT = !0, a.DEFAULT_ANIMATION_DURING_LAYOUT = !1, a.DEFAULT_ANIMATION_PERIOD = 50, a.DEFAULT_UNIFORM_LEAF_NODE_SIZES = !1, a.DEFAULT_GRAPH_MARGIN = 15, a.NODE_DIMENSIONS_INCLUDE_LABELS = !1, a.SIMPLE_NODE_SIZE = 40, a.SIMPLE_NODE_HALF_SIZE = a.SIMPLE_NODE_SIZE / 2, a.EMPTY_COMPOUND_NODE_SIZE = 40, a.MIN_EDGE_LENGTH = 1, a.WORLD_BOUNDARY = 1e6, a.INITIAL_WORLD_BOUNDARY = a.WORLD_BOUNDARY / 1e3, a.WORLD_CENTER_X = 1200, a.WORLD_CENTER_Y = 900, r.exports = a;
          }),
          /* 1 */
          /***/
          (function(r, n, i) {
            var a = i(2), s = i(8), o = i(9);
            function l(h, d, f) {
              a.call(this, f), this.isOverlapingSourceAndTarget = !1, this.vGraphObject = f, this.bendpoints = [], this.source = h, this.target = d;
            }
            l.prototype = Object.create(a.prototype);
            for (var u in a)
              l[u] = a[u];
            l.prototype.getSource = function() {
              return this.source;
            }, l.prototype.getTarget = function() {
              return this.target;
            }, l.prototype.isInterGraph = function() {
              return this.isInterGraph;
            }, l.prototype.getLength = function() {
              return this.length;
            }, l.prototype.isOverlapingSourceAndTarget = function() {
              return this.isOverlapingSourceAndTarget;
            }, l.prototype.getBendpoints = function() {
              return this.bendpoints;
            }, l.prototype.getLca = function() {
              return this.lca;
            }, l.prototype.getSourceInLca = function() {
              return this.sourceInLca;
            }, l.prototype.getTargetInLca = function() {
              return this.targetInLca;
            }, l.prototype.getOtherEnd = function(h) {
              if (this.source === h)
                return this.target;
              if (this.target === h)
                return this.source;
              throw "Node is not incident with this edge";
            }, l.prototype.getOtherEndInGraph = function(h, d) {
              for (var f = this.getOtherEnd(h), p = d.getGraphManager().getRoot(); ; ) {
                if (f.getOwner() == d)
                  return f;
                if (f.getOwner() == p)
                  break;
                f = f.getOwner().getParent();
              }
              return null;
            }, l.prototype.updateLength = function() {
              var h = new Array(4);
              this.isOverlapingSourceAndTarget = s.getIntersection(this.target.getRect(), this.source.getRect(), h), this.isOverlapingSourceAndTarget || (this.lengthX = h[0] - h[2], this.lengthY = h[1] - h[3], Math.abs(this.lengthX) < 1 && (this.lengthX = o.sign(this.lengthX)), Math.abs(this.lengthY) < 1 && (this.lengthY = o.sign(this.lengthY)), this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY));
            }, l.prototype.updateLengthSimple = function() {
              this.lengthX = this.target.getCenterX() - this.source.getCenterX(), this.lengthY = this.target.getCenterY() - this.source.getCenterY(), Math.abs(this.lengthX) < 1 && (this.lengthX = o.sign(this.lengthX)), Math.abs(this.lengthY) < 1 && (this.lengthY = o.sign(this.lengthY)), this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);
            }, r.exports = l;
          }),
          /* 2 */
          /***/
          (function(r, n, i) {
            function a(s) {
              this.vGraphObject = s;
            }
            r.exports = a;
          }),
          /* 3 */
          /***/
          (function(r, n, i) {
            var a = i(2), s = i(10), o = i(13), l = i(0), u = i(16), h = i(4);
            function d(p, g, m, v) {
              m == null && v == null && (v = g), a.call(this, v), p.graphManager != null && (p = p.graphManager), this.estimatedSize = s.MIN_VALUE, this.inclusionTreeDepth = s.MAX_VALUE, this.vGraphObject = v, this.edges = [], this.graphManager = p, m != null && g != null ? this.rect = new o(g.x, g.y, m.width, m.height) : this.rect = new o();
            }
            d.prototype = Object.create(a.prototype);
            for (var f in a)
              d[f] = a[f];
            d.prototype.getEdges = function() {
              return this.edges;
            }, d.prototype.getChild = function() {
              return this.child;
            }, d.prototype.getOwner = function() {
              return this.owner;
            }, d.prototype.getWidth = function() {
              return this.rect.width;
            }, d.prototype.setWidth = function(p) {
              this.rect.width = p;
            }, d.prototype.getHeight = function() {
              return this.rect.height;
            }, d.prototype.setHeight = function(p) {
              this.rect.height = p;
            }, d.prototype.getCenterX = function() {
              return this.rect.x + this.rect.width / 2;
            }, d.prototype.getCenterY = function() {
              return this.rect.y + this.rect.height / 2;
            }, d.prototype.getCenter = function() {
              return new h(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);
            }, d.prototype.getLocation = function() {
              return new h(this.rect.x, this.rect.y);
            }, d.prototype.getRect = function() {
              return this.rect;
            }, d.prototype.getDiagonal = function() {
              return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);
            }, d.prototype.getHalfTheDiagonal = function() {
              return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;
            }, d.prototype.setRect = function(p, g) {
              this.rect.x = p.x, this.rect.y = p.y, this.rect.width = g.width, this.rect.height = g.height;
            }, d.prototype.setCenter = function(p, g) {
              this.rect.x = p - this.rect.width / 2, this.rect.y = g - this.rect.height / 2;
            }, d.prototype.setLocation = function(p, g) {
              this.rect.x = p, this.rect.y = g;
            }, d.prototype.moveBy = function(p, g) {
              this.rect.x += p, this.rect.y += g;
            }, d.prototype.getEdgeListToNode = function(p) {
              var g = [], m = this;
              return m.edges.forEach(function(v) {
                if (v.target == p) {
                  if (v.source != m) throw "Incorrect edge source!";
                  g.push(v);
                }
              }), g;
            }, d.prototype.getEdgesBetween = function(p) {
              var g = [], m = this;
              return m.edges.forEach(function(v) {
                if (!(v.source == m || v.target == m)) throw "Incorrect edge source and/or target";
                (v.target == p || v.source == p) && g.push(v);
              }), g;
            }, d.prototype.getNeighborsList = function() {
              var p = /* @__PURE__ */ new Set(), g = this;
              return g.edges.forEach(function(m) {
                if (m.source == g)
                  p.add(m.target);
                else {
                  if (m.target != g)
                    throw "Incorrect incidency!";
                  p.add(m.source);
                }
              }), p;
            }, d.prototype.withChildren = function() {
              var p = /* @__PURE__ */ new Set(), g, m;
              if (p.add(this), this.child != null)
                for (var v = this.child.getNodes(), y = 0; y < v.length; y++)
                  g = v[y], m = g.withChildren(), m.forEach(function(b) {
                    p.add(b);
                  });
              return p;
            }, d.prototype.getNoOfChildren = function() {
              var p = 0, g;
              if (this.child == null)
                p = 1;
              else
                for (var m = this.child.getNodes(), v = 0; v < m.length; v++)
                  g = m[v], p += g.getNoOfChildren();
              return p == 0 && (p = 1), p;
            }, d.prototype.getEstimatedSize = function() {
              if (this.estimatedSize == s.MIN_VALUE)
                throw "assert failed";
              return this.estimatedSize;
            }, d.prototype.calcEstimatedSize = function() {
              return this.child == null ? this.estimatedSize = (this.rect.width + this.rect.height) / 2 : (this.estimatedSize = this.child.calcEstimatedSize(), this.rect.width = this.estimatedSize, this.rect.height = this.estimatedSize, this.estimatedSize);
            }, d.prototype.scatter = function() {
              var p, g, m = -l.INITIAL_WORLD_BOUNDARY, v = l.INITIAL_WORLD_BOUNDARY;
              p = l.WORLD_CENTER_X + u.nextDouble() * (v - m) + m;
              var y = -l.INITIAL_WORLD_BOUNDARY, b = l.INITIAL_WORLD_BOUNDARY;
              g = l.WORLD_CENTER_Y + u.nextDouble() * (b - y) + y, this.rect.x = p, this.rect.y = g;
            }, d.prototype.updateBounds = function() {
              if (this.getChild() == null)
                throw "assert failed";
              if (this.getChild().getNodes().length != 0) {
                var p = this.getChild();
                if (p.updateBounds(!0), this.rect.x = p.getLeft(), this.rect.y = p.getTop(), this.setWidth(p.getRight() - p.getLeft()), this.setHeight(p.getBottom() - p.getTop()), l.NODE_DIMENSIONS_INCLUDE_LABELS) {
                  var g = p.getRight() - p.getLeft(), m = p.getBottom() - p.getTop();
                  this.labelWidth > g && (this.rect.x -= (this.labelWidth - g) / 2, this.setWidth(this.labelWidth)), this.labelHeight > m && (this.labelPos == "center" ? this.rect.y -= (this.labelHeight - m) / 2 : this.labelPos == "top" && (this.rect.y -= this.labelHeight - m), this.setHeight(this.labelHeight));
                }
              }
            }, d.prototype.getInclusionTreeDepth = function() {
              if (this.inclusionTreeDepth == s.MAX_VALUE)
                throw "assert failed";
              return this.inclusionTreeDepth;
            }, d.prototype.transform = function(p) {
              var g = this.rect.x;
              g > l.WORLD_BOUNDARY ? g = l.WORLD_BOUNDARY : g < -l.WORLD_BOUNDARY && (g = -l.WORLD_BOUNDARY);
              var m = this.rect.y;
              m > l.WORLD_BOUNDARY ? m = l.WORLD_BOUNDARY : m < -l.WORLD_BOUNDARY && (m = -l.WORLD_BOUNDARY);
              var v = new h(g, m), y = p.inverseTransformPoint(v);
              this.setLocation(y.x, y.y);
            }, d.prototype.getLeft = function() {
              return this.rect.x;
            }, d.prototype.getRight = function() {
              return this.rect.x + this.rect.width;
            }, d.prototype.getTop = function() {
              return this.rect.y;
            }, d.prototype.getBottom = function() {
              return this.rect.y + this.rect.height;
            }, d.prototype.getParent = function() {
              return this.owner == null ? null : this.owner.getParent();
            }, r.exports = d;
          }),
          /* 4 */
          /***/
          (function(r, n, i) {
            function a(s, o) {
              s == null && o == null ? (this.x = 0, this.y = 0) : (this.x = s, this.y = o);
            }
            a.prototype.getX = function() {
              return this.x;
            }, a.prototype.getY = function() {
              return this.y;
            }, a.prototype.setX = function(s) {
              this.x = s;
            }, a.prototype.setY = function(s) {
              this.y = s;
            }, a.prototype.getDifference = function(s) {
              return new DimensionD(this.x - s.x, this.y - s.y);
            }, a.prototype.getCopy = function() {
              return new a(this.x, this.y);
            }, a.prototype.translate = function(s) {
              return this.x += s.width, this.y += s.height, this;
            }, r.exports = a;
          }),
          /* 5 */
          /***/
          (function(r, n, i) {
            var a = i(2), s = i(10), o = i(0), l = i(6), u = i(3), h = i(1), d = i(13), f = i(12), p = i(11);
            function g(v, y, b) {
              a.call(this, b), this.estimatedSize = s.MIN_VALUE, this.margin = o.DEFAULT_GRAPH_MARGIN, this.edges = [], this.nodes = [], this.isConnected = !1, this.parent = v, y != null && y instanceof l ? this.graphManager = y : y != null && y instanceof Layout && (this.graphManager = y.graphManager);
            }
            g.prototype = Object.create(a.prototype);
            for (var m in a)
              g[m] = a[m];
            g.prototype.getNodes = function() {
              return this.nodes;
            }, g.prototype.getEdges = function() {
              return this.edges;
            }, g.prototype.getGraphManager = function() {
              return this.graphManager;
            }, g.prototype.getParent = function() {
              return this.parent;
            }, g.prototype.getLeft = function() {
              return this.left;
            }, g.prototype.getRight = function() {
              return this.right;
            }, g.prototype.getTop = function() {
              return this.top;
            }, g.prototype.getBottom = function() {
              return this.bottom;
            }, g.prototype.isConnected = function() {
              return this.isConnected;
            }, g.prototype.add = function(v, y, b) {
              if (y == null && b == null) {
                var w = v;
                if (this.graphManager == null)
                  throw "Graph has no graph mgr!";
                if (this.getNodes().indexOf(w) > -1)
                  throw "Node already in graph!";
                return w.owner = this, this.getNodes().push(w), w;
              } else {
                var T = v;
                if (!(this.getNodes().indexOf(y) > -1 && this.getNodes().indexOf(b) > -1))
                  throw "Source or target not in graph!";
                if (!(y.owner == b.owner && y.owner == this))
                  throw "Both owners must be this graph!";
                return y.owner != b.owner ? null : (T.source = y, T.target = b, T.isInterGraph = !1, this.getEdges().push(T), y.edges.push(T), b != y && b.edges.push(T), T);
              }
            }, g.prototype.remove = function(v) {
              var y = v;
              if (v instanceof u) {
                if (y == null)
                  throw "Node is null!";
                if (!(y.owner != null && y.owner == this))
                  throw "Owner graph is invalid!";
                if (this.graphManager == null)
                  throw "Owner graph manager is invalid!";
                for (var b = y.edges.slice(), w, T = b.length, E = 0; E < T; E++)
                  w = b[E], w.isInterGraph ? this.graphManager.remove(w) : w.source.owner.remove(w);
                var L = this.nodes.indexOf(y);
                if (L == -1)
                  throw "Node not in owner node list!";
                this.nodes.splice(L, 1);
              } else if (v instanceof h) {
                var w = v;
                if (w == null)
                  throw "Edge is null!";
                if (!(w.source != null && w.target != null))
                  throw "Source and/or target is null!";
                if (!(w.source.owner != null && w.target.owner != null && w.source.owner == this && w.target.owner == this))
                  throw "Source and/or target owner is invalid!";
                var k = w.source.edges.indexOf(w), C = w.target.edges.indexOf(w);
                if (!(k > -1 && C > -1))
                  throw "Source and/or target doesn't know this edge!";
                w.source.edges.splice(k, 1), w.target != w.source && w.target.edges.splice(C, 1);
                var L = w.source.owner.getEdges().indexOf(w);
                if (L == -1)
                  throw "Not in owner's edge list!";
                w.source.owner.getEdges().splice(L, 1);
              }
            }, g.prototype.updateLeftTop = function() {
              for (var v = s.MAX_VALUE, y = s.MAX_VALUE, b, w, T, E = this.getNodes(), L = E.length, k = 0; k < L; k++) {
                var C = E[k];
                b = C.getTop(), w = C.getLeft(), v > b && (v = b), y > w && (y = w);
              }
              return v == s.MAX_VALUE ? null : (E[0].getParent().paddingLeft != null ? T = E[0].getParent().paddingLeft : T = this.margin, this.left = y - T, this.top = v - T, new f(this.left, this.top));
            }, g.prototype.updateBounds = function(v) {
              for (var y = s.MAX_VALUE, b = -s.MAX_VALUE, w = s.MAX_VALUE, T = -s.MAX_VALUE, E, L, k, C, A, R = this.nodes, _ = R.length, O = 0; O < _; O++) {
                var P = R[O];
                v && P.child != null && P.updateBounds(), E = P.getLeft(), L = P.getRight(), k = P.getTop(), C = P.getBottom(), y > E && (y = E), b < L && (b = L), w > k && (w = k), T < C && (T = C);
              }
              var S = new d(y, w, b - y, T - w);
              y == s.MAX_VALUE && (this.left = this.parent.getLeft(), this.right = this.parent.getRight(), this.top = this.parent.getTop(), this.bottom = this.parent.getBottom()), R[0].getParent().paddingLeft != null ? A = R[0].getParent().paddingLeft : A = this.margin, this.left = S.x - A, this.right = S.x + S.width + A, this.top = S.y - A, this.bottom = S.y + S.height + A;
            }, g.calculateBounds = function(v) {
              for (var y = s.MAX_VALUE, b = -s.MAX_VALUE, w = s.MAX_VALUE, T = -s.MAX_VALUE, E, L, k, C, A = v.length, R = 0; R < A; R++) {
                var _ = v[R];
                E = _.getLeft(), L = _.getRight(), k = _.getTop(), C = _.getBottom(), y > E && (y = E), b < L && (b = L), w > k && (w = k), T < C && (T = C);
              }
              var O = new d(y, w, b - y, T - w);
              return O;
            }, g.prototype.getInclusionTreeDepth = function() {
              return this == this.graphManager.getRoot() ? 1 : this.parent.getInclusionTreeDepth();
            }, g.prototype.getEstimatedSize = function() {
              if (this.estimatedSize == s.MIN_VALUE)
                throw "assert failed";
              return this.estimatedSize;
            }, g.prototype.calcEstimatedSize = function() {
              for (var v = 0, y = this.nodes, b = y.length, w = 0; w < b; w++) {
                var T = y[w];
                v += T.calcEstimatedSize();
              }
              return v == 0 ? this.estimatedSize = o.EMPTY_COMPOUND_NODE_SIZE : this.estimatedSize = v / Math.sqrt(this.nodes.length), this.estimatedSize;
            }, g.prototype.updateConnected = function() {
              var v = this;
              if (this.nodes.length == 0) {
                this.isConnected = !0;
                return;
              }
              var y = new p(), b = /* @__PURE__ */ new Set(), w = this.nodes[0], T, E, L = w.withChildren();
              for (L.forEach(function(O) {
                y.push(O), b.add(O);
              }); y.length !== 0; ) {
                w = y.shift(), T = w.getEdges();
                for (var k = T.length, C = 0; C < k; C++) {
                  var A = T[C];
                  if (E = A.getOtherEndInGraph(w, this), E != null && !b.has(E)) {
                    var R = E.withChildren();
                    R.forEach(function(O) {
                      y.push(O), b.add(O);
                    });
                  }
                }
              }
              if (this.isConnected = !1, b.size >= this.nodes.length) {
                var _ = 0;
                b.forEach(function(O) {
                  O.owner == v && _++;
                }), _ == this.nodes.length && (this.isConnected = !0);
              }
            }, r.exports = g;
          }),
          /* 6 */
          /***/
          (function(r, n, i) {
            var a, s = i(1);
            function o(l) {
              a = i(5), this.layout = l, this.graphs = [], this.edges = [];
            }
            o.prototype.addRoot = function() {
              var l = this.layout.newGraph(), u = this.layout.newNode(null), h = this.add(l, u);
              return this.setRootGraph(h), this.rootGraph;
            }, o.prototype.add = function(l, u, h, d, f) {
              if (h == null && d == null && f == null) {
                if (l == null)
                  throw "Graph is null!";
                if (u == null)
                  throw "Parent node is null!";
                if (this.graphs.indexOf(l) > -1)
                  throw "Graph already in this graph mgr!";
                if (this.graphs.push(l), l.parent != null)
                  throw "Already has a parent!";
                if (u.child != null)
                  throw "Already has a child!";
                return l.parent = u, u.child = l, l;
              } else {
                f = h, d = u, h = l;
                var p = d.getOwner(), g = f.getOwner();
                if (!(p != null && p.getGraphManager() == this))
                  throw "Source not in this graph mgr!";
                if (!(g != null && g.getGraphManager() == this))
                  throw "Target not in this graph mgr!";
                if (p == g)
                  return h.isInterGraph = !1, p.add(h, d, f);
                if (h.isInterGraph = !0, h.source = d, h.target = f, this.edges.indexOf(h) > -1)
                  throw "Edge already in inter-graph edge list!";
                if (this.edges.push(h), !(h.source != null && h.target != null))
                  throw "Edge source and/or target is null!";
                if (!(h.source.edges.indexOf(h) == -1 && h.target.edges.indexOf(h) == -1))
                  throw "Edge already in source and/or target incidency list!";
                return h.source.edges.push(h), h.target.edges.push(h), h;
              }
            }, o.prototype.remove = function(l) {
              if (l instanceof a) {
                var u = l;
                if (u.getGraphManager() != this)
                  throw "Graph not in this graph mgr";
                if (!(u == this.rootGraph || u.parent != null && u.parent.graphManager == this))
                  throw "Invalid parent node!";
                var h = [];
                h = h.concat(u.getEdges());
                for (var d, f = h.length, p = 0; p < f; p++)
                  d = h[p], u.remove(d);
                var g = [];
                g = g.concat(u.getNodes());
                var m;
                f = g.length;
                for (var p = 0; p < f; p++)
                  m = g[p], u.remove(m);
                u == this.rootGraph && this.setRootGraph(null);
                var v = this.graphs.indexOf(u);
                this.graphs.splice(v, 1), u.parent = null;
              } else if (l instanceof s) {
                if (d = l, d == null)
                  throw "Edge is null!";
                if (!d.isInterGraph)
                  throw "Not an inter-graph edge!";
                if (!(d.source != null && d.target != null))
                  throw "Source and/or target is null!";
                if (!(d.source.edges.indexOf(d) != -1 && d.target.edges.indexOf(d) != -1))
                  throw "Source and/or target doesn't know this edge!";
                var v = d.source.edges.indexOf(d);
                if (d.source.edges.splice(v, 1), v = d.target.edges.indexOf(d), d.target.edges.splice(v, 1), !(d.source.owner != null && d.source.owner.getGraphManager() != null))
                  throw "Edge owner graph or owner graph manager is null!";
                if (d.source.owner.getGraphManager().edges.indexOf(d) == -1)
                  throw "Not in owner graph manager's edge list!";
                var v = d.source.owner.getGraphManager().edges.indexOf(d);
                d.source.owner.getGraphManager().edges.splice(v, 1);
              }
            }, o.prototype.updateBounds = function() {
              this.rootGraph.updateBounds(!0);
            }, o.prototype.getGraphs = function() {
              return this.graphs;
            }, o.prototype.getAllNodes = function() {
              if (this.allNodes == null) {
                for (var l = [], u = this.getGraphs(), h = u.length, d = 0; d < h; d++)
                  l = l.concat(u[d].getNodes());
                this.allNodes = l;
              }
              return this.allNodes;
            }, o.prototype.resetAllNodes = function() {
              this.allNodes = null;
            }, o.prototype.resetAllEdges = function() {
              this.allEdges = null;
            }, o.prototype.resetAllNodesToApplyGravitation = function() {
              this.allNodesToApplyGravitation = null;
            }, o.prototype.getAllEdges = function() {
              if (this.allEdges == null) {
                var l = [], u = this.getGraphs();
                u.length;
                for (var h = 0; h < u.length; h++)
                  l = l.concat(u[h].getEdges());
                l = l.concat(this.edges), this.allEdges = l;
              }
              return this.allEdges;
            }, o.prototype.getAllNodesToApplyGravitation = function() {
              return this.allNodesToApplyGravitation;
            }, o.prototype.setAllNodesToApplyGravitation = function(l) {
              if (this.allNodesToApplyGravitation != null)
                throw "assert failed";
              this.allNodesToApplyGravitation = l;
            }, o.prototype.getRoot = function() {
              return this.rootGraph;
            }, o.prototype.setRootGraph = function(l) {
              if (l.getGraphManager() != this)
                throw "Root not in this graph mgr!";
              this.rootGraph = l, l.parent == null && (l.parent = this.layout.newNode("Root node"));
            }, o.prototype.getLayout = function() {
              return this.layout;
            }, o.prototype.isOneAncestorOfOther = function(l, u) {
              if (!(l != null && u != null))
                throw "assert failed";
              if (l == u)
                return !0;
              var h = l.getOwner(), d;
              do {
                if (d = h.getParent(), d == null)
                  break;
                if (d == u)
                  return !0;
                if (h = d.getOwner(), h == null)
                  break;
              } while (!0);
              h = u.getOwner();
              do {
                if (d = h.getParent(), d == null)
                  break;
                if (d == l)
                  return !0;
                if (h = d.getOwner(), h == null)
                  break;
              } while (!0);
              return !1;
            }, o.prototype.calcLowestCommonAncestors = function() {
              for (var l, u, h, d, f, p = this.getAllEdges(), g = p.length, m = 0; m < g; m++) {
                if (l = p[m], u = l.source, h = l.target, l.lca = null, l.sourceInLca = u, l.targetInLca = h, u == h) {
                  l.lca = u.getOwner();
                  continue;
                }
                for (d = u.getOwner(); l.lca == null; ) {
                  for (l.targetInLca = h, f = h.getOwner(); l.lca == null; ) {
                    if (f == d) {
                      l.lca = f;
                      break;
                    }
                    if (f == this.rootGraph)
                      break;
                    if (l.lca != null)
                      throw "assert failed";
                    l.targetInLca = f.getParent(), f = l.targetInLca.getOwner();
                  }
                  if (d == this.rootGraph)
                    break;
                  l.lca == null && (l.sourceInLca = d.getParent(), d = l.sourceInLca.getOwner());
                }
                if (l.lca == null)
                  throw "assert failed";
              }
            }, o.prototype.calcLowestCommonAncestor = function(l, u) {
              if (l == u)
                return l.getOwner();
              var h = l.getOwner();
              do {
                if (h == null)
                  break;
                var d = u.getOwner();
                do {
                  if (d == null)
                    break;
                  if (d == h)
                    return d;
                  d = d.getParent().getOwner();
                } while (!0);
                h = h.getParent().getOwner();
              } while (!0);
              return h;
            }, o.prototype.calcInclusionTreeDepths = function(l, u) {
              l == null && u == null && (l = this.rootGraph, u = 1);
              for (var h, d = l.getNodes(), f = d.length, p = 0; p < f; p++)
                h = d[p], h.inclusionTreeDepth = u, h.child != null && this.calcInclusionTreeDepths(h.child, u + 1);
            }, o.prototype.includesInvalidEdge = function() {
              for (var l, u = this.edges.length, h = 0; h < u; h++)
                if (l = this.edges[h], this.isOneAncestorOfOther(l.source, l.target))
                  return !0;
              return !1;
            }, r.exports = o;
          }),
          /* 7 */
          /***/
          (function(r, n, i) {
            var a = i(0);
            function s() {
            }
            for (var o in a)
              s[o] = a[o];
            s.MAX_ITERATIONS = 2500, s.DEFAULT_EDGE_LENGTH = 50, s.DEFAULT_SPRING_STRENGTH = 0.45, s.DEFAULT_REPULSION_STRENGTH = 4500, s.DEFAULT_GRAVITY_STRENGTH = 0.4, s.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1, s.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8, s.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5, s.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = !0, s.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = !0, s.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3, s.COOLING_ADAPTATION_FACTOR = 0.33, s.ADAPTATION_LOWER_NODE_LIMIT = 1e3, s.ADAPTATION_UPPER_NODE_LIMIT = 5e3, s.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100, s.MAX_NODE_DISPLACEMENT = s.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3, s.MIN_REPULSION_DIST = s.DEFAULT_EDGE_LENGTH / 10, s.CONVERGENCE_CHECK_PERIOD = 100, s.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1, s.MIN_EDGE_LENGTH = 1, s.GRID_CALCULATION_CHECK_PERIOD = 10, r.exports = s;
          }),
          /* 8 */
          /***/
          (function(r, n, i) {
            var a = i(12);
            function s() {
            }
            s.calcSeparationAmount = function(o, l, u, h) {
              if (!o.intersects(l))
                throw "assert failed";
              var d = new Array(2);
              this.decideDirectionsForOverlappingNodes(o, l, d), u[0] = Math.min(o.getRight(), l.getRight()) - Math.max(o.x, l.x), u[1] = Math.min(o.getBottom(), l.getBottom()) - Math.max(o.y, l.y), o.getX() <= l.getX() && o.getRight() >= l.getRight() ? u[0] += Math.min(l.getX() - o.getX(), o.getRight() - l.getRight()) : l.getX() <= o.getX() && l.getRight() >= o.getRight() && (u[0] += Math.min(o.getX() - l.getX(), l.getRight() - o.getRight())), o.getY() <= l.getY() && o.getBottom() >= l.getBottom() ? u[1] += Math.min(l.getY() - o.getY(), o.getBottom() - l.getBottom()) : l.getY() <= o.getY() && l.getBottom() >= o.getBottom() && (u[1] += Math.min(o.getY() - l.getY(), l.getBottom() - o.getBottom()));
              var f = Math.abs((l.getCenterY() - o.getCenterY()) / (l.getCenterX() - o.getCenterX()));
              l.getCenterY() === o.getCenterY() && l.getCenterX() === o.getCenterX() && (f = 1);
              var p = f * u[0], g = u[1] / f;
              u[0] < g ? g = u[0] : p = u[1], u[0] = -1 * d[0] * (g / 2 + h), u[1] = -1 * d[1] * (p / 2 + h);
            }, s.decideDirectionsForOverlappingNodes = function(o, l, u) {
              o.getCenterX() < l.getCenterX() ? u[0] = -1 : u[0] = 1, o.getCenterY() < l.getCenterY() ? u[1] = -1 : u[1] = 1;
            }, s.getIntersection2 = function(o, l, u) {
              var h = o.getCenterX(), d = o.getCenterY(), f = l.getCenterX(), p = l.getCenterY();
              if (o.intersects(l))
                return u[0] = h, u[1] = d, u[2] = f, u[3] = p, !0;
              var g = o.getX(), m = o.getY(), v = o.getRight(), y = o.getX(), b = o.getBottom(), w = o.getRight(), T = o.getWidthHalf(), E = o.getHeightHalf(), L = l.getX(), k = l.getY(), C = l.getRight(), A = l.getX(), R = l.getBottom(), _ = l.getRight(), O = l.getWidthHalf(), P = l.getHeightHalf(), S = !1, M = !1;
              if (h === f) {
                if (d > p)
                  return u[0] = h, u[1] = m, u[2] = f, u[3] = R, !1;
                if (d < p)
                  return u[0] = h, u[1] = b, u[2] = f, u[3] = k, !1;
              } else if (d === p) {
                if (h > f)
                  return u[0] = g, u[1] = d, u[2] = C, u[3] = p, !1;
                if (h < f)
                  return u[0] = v, u[1] = d, u[2] = L, u[3] = p, !1;
              } else {
                var N = o.height / o.width, D = l.height / l.width, I = (p - d) / (f - h), B = void 0, z = void 0, F = void 0, V = void 0, H = void 0, J = void 0;
                if (-N === I ? h > f ? (u[0] = y, u[1] = b, S = !0) : (u[0] = v, u[1] = m, S = !0) : N === I && (h > f ? (u[0] = g, u[1] = m, S = !0) : (u[0] = w, u[1] = b, S = !0)), -D === I ? f > h ? (u[2] = A, u[3] = R, M = !0) : (u[2] = C, u[3] = k, M = !0) : D === I && (f > h ? (u[2] = L, u[3] = k, M = !0) : (u[2] = _, u[3] = R, M = !0)), S && M)
                  return !1;
                if (h > f ? d > p ? (B = this.getCardinalDirection(N, I, 4), z = this.getCardinalDirection(D, I, 2)) : (B = this.getCardinalDirection(-N, I, 3), z = this.getCardinalDirection(-D, I, 1)) : d > p ? (B = this.getCardinalDirection(-N, I, 1), z = this.getCardinalDirection(-D, I, 3)) : (B = this.getCardinalDirection(N, I, 2), z = this.getCardinalDirection(D, I, 4)), !S)
                  switch (B) {
                    case 1:
                      V = m, F = h + -E / I, u[0] = F, u[1] = V;
                      break;
                    case 2:
                      F = w, V = d + T * I, u[0] = F, u[1] = V;
                      break;
                    case 3:
                      V = b, F = h + E / I, u[0] = F, u[1] = V;
                      break;
                    case 4:
                      F = y, V = d + -T * I, u[0] = F, u[1] = V;
                      break;
                  }
                if (!M)
                  switch (z) {
                    case 1:
                      J = k, H = f + -P / I, u[2] = H, u[3] = J;
                      break;
                    case 2:
                      H = _, J = p + O * I, u[2] = H, u[3] = J;
                      break;
                    case 3:
                      J = R, H = f + P / I, u[2] = H, u[3] = J;
                      break;
                    case 4:
                      H = A, J = p + -O * I, u[2] = H, u[3] = J;
                      break;
                  }
              }
              return !1;
            }, s.getCardinalDirection = function(o, l, u) {
              return o > l ? u : 1 + u % 4;
            }, s.getIntersection = function(o, l, u, h) {
              if (h == null)
                return this.getIntersection2(o, l, u);
              var d = o.x, f = o.y, p = l.x, g = l.y, m = u.x, v = u.y, y = h.x, b = h.y, w = void 0, T = void 0, E = void 0, L = void 0, k = void 0, C = void 0, A = void 0, R = void 0, _ = void 0;
              return E = g - f, k = d - p, A = p * f - d * g, L = b - v, C = m - y, R = y * v - m * b, _ = E * C - L * k, _ === 0 ? null : (w = (k * R - C * A) / _, T = (L * A - E * R) / _, new a(w, T));
            }, s.angleOfVector = function(o, l, u, h) {
              var d = void 0;
              return o !== u ? (d = Math.atan((h - l) / (u - o)), u < o ? d += Math.PI : h < l && (d += this.TWO_PI)) : h < l ? d = this.ONE_AND_HALF_PI : d = this.HALF_PI, d;
            }, s.doIntersect = function(o, l, u, h) {
              var d = o.x, f = o.y, p = l.x, g = l.y, m = u.x, v = u.y, y = h.x, b = h.y, w = (p - d) * (b - v) - (y - m) * (g - f);
              if (w === 0)
                return !1;
              var T = ((b - v) * (y - d) + (m - y) * (b - f)) / w, E = ((f - g) * (y - d) + (p - d) * (b - f)) / w;
              return 0 < T && T < 1 && 0 < E && E < 1;
            }, s.HALF_PI = 0.5 * Math.PI, s.ONE_AND_HALF_PI = 1.5 * Math.PI, s.TWO_PI = 2 * Math.PI, s.THREE_PI = 3 * Math.PI, r.exports = s;
          }),
          /* 9 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.sign = function(s) {
              return s > 0 ? 1 : s < 0 ? -1 : 0;
            }, a.floor = function(s) {
              return s < 0 ? Math.ceil(s) : Math.floor(s);
            }, a.ceil = function(s) {
              return s < 0 ? Math.floor(s) : Math.ceil(s);
            }, r.exports = a;
          }),
          /* 10 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.MAX_VALUE = 2147483647, a.MIN_VALUE = -2147483648, r.exports = a;
          }),
          /* 11 */
          /***/
          (function(r, n, i) {
            var a = /* @__PURE__ */ (function() {
              function d(f, p) {
                for (var g = 0; g < p.length; g++) {
                  var m = p[g];
                  m.enumerable = m.enumerable || !1, m.configurable = !0, "value" in m && (m.writable = !0), Object.defineProperty(f, m.key, m);
                }
              }
              return function(f, p, g) {
                return p && d(f.prototype, p), g && d(f, g), f;
              };
            })();
            function s(d, f) {
              if (!(d instanceof f))
                throw new TypeError("Cannot call a class as a function");
            }
            var o = function(f) {
              return { value: f, next: null, prev: null };
            }, l = function(f, p, g, m) {
              return f !== null ? f.next = p : m.head = p, g !== null ? g.prev = p : m.tail = p, p.prev = f, p.next = g, m.length++, p;
            }, u = function(f, p) {
              var g = f.prev, m = f.next;
              return g !== null ? g.next = m : p.head = m, m !== null ? m.prev = g : p.tail = g, f.prev = f.next = null, p.length--, f;
            }, h = (function() {
              function d(f) {
                var p = this;
                s(this, d), this.length = 0, this.head = null, this.tail = null, f?.forEach(function(g) {
                  return p.push(g);
                });
              }
              return a(d, [{
                key: "size",
                value: function() {
                  return this.length;
                }
              }, {
                key: "insertBefore",
                value: function(p, g) {
                  return l(g.prev, o(p), g, this);
                }
              }, {
                key: "insertAfter",
                value: function(p, g) {
                  return l(g, o(p), g.next, this);
                }
              }, {
                key: "insertNodeBefore",
                value: function(p, g) {
                  return l(g.prev, p, g, this);
                }
              }, {
                key: "insertNodeAfter",
                value: function(p, g) {
                  return l(g, p, g.next, this);
                }
              }, {
                key: "push",
                value: function(p) {
                  return l(this.tail, o(p), null, this);
                }
              }, {
                key: "unshift",
                value: function(p) {
                  return l(null, o(p), this.head, this);
                }
              }, {
                key: "remove",
                value: function(p) {
                  return u(p, this);
                }
              }, {
                key: "pop",
                value: function() {
                  return u(this.tail, this).value;
                }
              }, {
                key: "popNode",
                value: function() {
                  return u(this.tail, this);
                }
              }, {
                key: "shift",
                value: function() {
                  return u(this.head, this).value;
                }
              }, {
                key: "shiftNode",
                value: function() {
                  return u(this.head, this);
                }
              }, {
                key: "get_object_at",
                value: function(p) {
                  if (p <= this.length()) {
                    for (var g = 1, m = this.head; g < p; )
                      m = m.next, g++;
                    return m.value;
                  }
                }
              }, {
                key: "set_object_at",
                value: function(p, g) {
                  if (p <= this.length()) {
                    for (var m = 1, v = this.head; m < p; )
                      v = v.next, m++;
                    v.value = g;
                  }
                }
              }]), d;
            })();
            r.exports = h;
          }),
          /* 12 */
          /***/
          (function(r, n, i) {
            function a(s, o, l) {
              this.x = null, this.y = null, s == null && o == null && l == null ? (this.x = 0, this.y = 0) : typeof s == "number" && typeof o == "number" && l == null ? (this.x = s, this.y = o) : s.constructor.name == "Point" && o == null && l == null && (l = s, this.x = l.x, this.y = l.y);
            }
            a.prototype.getX = function() {
              return this.x;
            }, a.prototype.getY = function() {
              return this.y;
            }, a.prototype.getLocation = function() {
              return new a(this.x, this.y);
            }, a.prototype.setLocation = function(s, o, l) {
              s.constructor.name == "Point" && o == null && l == null ? (l = s, this.setLocation(l.x, l.y)) : typeof s == "number" && typeof o == "number" && l == null && (parseInt(s) == s && parseInt(o) == o ? this.move(s, o) : (this.x = Math.floor(s + 0.5), this.y = Math.floor(o + 0.5)));
            }, a.prototype.move = function(s, o) {
              this.x = s, this.y = o;
            }, a.prototype.translate = function(s, o) {
              this.x += s, this.y += o;
            }, a.prototype.equals = function(s) {
              if (s.constructor.name == "Point") {
                var o = s;
                return this.x == o.x && this.y == o.y;
              }
              return this == s;
            }, a.prototype.toString = function() {
              return new a().constructor.name + "[x=" + this.x + ",y=" + this.y + "]";
            }, r.exports = a;
          }),
          /* 13 */
          /***/
          (function(r, n, i) {
            function a(s, o, l, u) {
              this.x = 0, this.y = 0, this.width = 0, this.height = 0, s != null && o != null && l != null && u != null && (this.x = s, this.y = o, this.width = l, this.height = u);
            }
            a.prototype.getX = function() {
              return this.x;
            }, a.prototype.setX = function(s) {
              this.x = s;
            }, a.prototype.getY = function() {
              return this.y;
            }, a.prototype.setY = function(s) {
              this.y = s;
            }, a.prototype.getWidth = function() {
              return this.width;
            }, a.prototype.setWidth = function(s) {
              this.width = s;
            }, a.prototype.getHeight = function() {
              return this.height;
            }, a.prototype.setHeight = function(s) {
              this.height = s;
            }, a.prototype.getRight = function() {
              return this.x + this.width;
            }, a.prototype.getBottom = function() {
              return this.y + this.height;
            }, a.prototype.intersects = function(s) {
              return !(this.getRight() < s.x || this.getBottom() < s.y || s.getRight() < this.x || s.getBottom() < this.y);
            }, a.prototype.getCenterX = function() {
              return this.x + this.width / 2;
            }, a.prototype.getMinX = function() {
              return this.getX();
            }, a.prototype.getMaxX = function() {
              return this.getX() + this.width;
            }, a.prototype.getCenterY = function() {
              return this.y + this.height / 2;
            }, a.prototype.getMinY = function() {
              return this.getY();
            }, a.prototype.getMaxY = function() {
              return this.getY() + this.height;
            }, a.prototype.getWidthHalf = function() {
              return this.width / 2;
            }, a.prototype.getHeightHalf = function() {
              return this.height / 2;
            }, r.exports = a;
          }),
          /* 14 */
          /***/
          (function(r, n, i) {
            var a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
              return typeof o;
            } : function(o) {
              return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
            };
            function s() {
            }
            s.lastID = 0, s.createID = function(o) {
              return s.isPrimitive(o) ? o : (o.uniqueID != null || (o.uniqueID = s.getString(), s.lastID++), o.uniqueID);
            }, s.getString = function(o) {
              return o == null && (o = s.lastID), "Object#" + o;
            }, s.isPrimitive = function(o) {
              var l = typeof o > "u" ? "undefined" : a(o);
              return o == null || l != "object" && l != "function";
            }, r.exports = s;
          }),
          /* 15 */
          /***/
          (function(r, n, i) {
            function a(m) {
              if (Array.isArray(m)) {
                for (var v = 0, y = Array(m.length); v < m.length; v++)
                  y[v] = m[v];
                return y;
              } else
                return Array.from(m);
            }
            var s = i(0), o = i(6), l = i(3), u = i(1), h = i(5), d = i(4), f = i(17), p = i(27);
            function g(m) {
              p.call(this), this.layoutQuality = s.QUALITY, this.createBendsAsNeeded = s.DEFAULT_CREATE_BENDS_AS_NEEDED, this.incremental = s.DEFAULT_INCREMENTAL, this.animationOnLayout = s.DEFAULT_ANIMATION_ON_LAYOUT, this.animationDuringLayout = s.DEFAULT_ANIMATION_DURING_LAYOUT, this.animationPeriod = s.DEFAULT_ANIMATION_PERIOD, this.uniformLeafNodeSizes = s.DEFAULT_UNIFORM_LEAF_NODE_SIZES, this.edgeToDummyNodes = /* @__PURE__ */ new Map(), this.graphManager = new o(this), this.isLayoutFinished = !1, this.isSubLayout = !1, this.isRemoteUse = !1, m != null && (this.isRemoteUse = m);
            }
            g.RANDOM_SEED = 1, g.prototype = Object.create(p.prototype), g.prototype.getGraphManager = function() {
              return this.graphManager;
            }, g.prototype.getAllNodes = function() {
              return this.graphManager.getAllNodes();
            }, g.prototype.getAllEdges = function() {
              return this.graphManager.getAllEdges();
            }, g.prototype.getAllNodesToApplyGravitation = function() {
              return this.graphManager.getAllNodesToApplyGravitation();
            }, g.prototype.newGraphManager = function() {
              var m = new o(this);
              return this.graphManager = m, m;
            }, g.prototype.newGraph = function(m) {
              return new h(null, this.graphManager, m);
            }, g.prototype.newNode = function(m) {
              return new l(this.graphManager, m);
            }, g.prototype.newEdge = function(m) {
              return new u(null, null, m);
            }, g.prototype.checkLayoutSuccess = function() {
              return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();
            }, g.prototype.runLayout = function() {
              this.isLayoutFinished = !1, this.tilingPreLayout && this.tilingPreLayout(), this.initParameters();
              var m;
              return this.checkLayoutSuccess() ? m = !1 : m = this.layout(), s.ANIMATE === "during" ? !1 : (m && (this.isSubLayout || this.doPostLayout()), this.tilingPostLayout && this.tilingPostLayout(), this.isLayoutFinished = !0, m);
            }, g.prototype.doPostLayout = function() {
              this.incremental || this.transform(), this.update();
            }, g.prototype.update2 = function() {
              if (this.createBendsAsNeeded && (this.createBendpointsFromDummyNodes(), this.graphManager.resetAllEdges()), !this.isRemoteUse) {
                for (var m = this.graphManager.getAllEdges(), v = 0; v < m.length; v++)
                  m[v];
                for (var y = this.graphManager.getRoot().getNodes(), v = 0; v < y.length; v++)
                  y[v];
                this.update(this.graphManager.getRoot());
              }
            }, g.prototype.update = function(m) {
              if (m == null)
                this.update2();
              else if (m instanceof l) {
                var v = m;
                if (v.getChild() != null)
                  for (var y = v.getChild().getNodes(), b = 0; b < y.length; b++)
                    update(y[b]);
                if (v.vGraphObject != null) {
                  var w = v.vGraphObject;
                  w.update(v);
                }
              } else if (m instanceof u) {
                var T = m;
                if (T.vGraphObject != null) {
                  var E = T.vGraphObject;
                  E.update(T);
                }
              } else if (m instanceof h) {
                var L = m;
                if (L.vGraphObject != null) {
                  var k = L.vGraphObject;
                  k.update(L);
                }
              }
            }, g.prototype.initParameters = function() {
              this.isSubLayout || (this.layoutQuality = s.QUALITY, this.animationDuringLayout = s.DEFAULT_ANIMATION_DURING_LAYOUT, this.animationPeriod = s.DEFAULT_ANIMATION_PERIOD, this.animationOnLayout = s.DEFAULT_ANIMATION_ON_LAYOUT, this.incremental = s.DEFAULT_INCREMENTAL, this.createBendsAsNeeded = s.DEFAULT_CREATE_BENDS_AS_NEEDED, this.uniformLeafNodeSizes = s.DEFAULT_UNIFORM_LEAF_NODE_SIZES), this.animationDuringLayout && (this.animationOnLayout = !1);
            }, g.prototype.transform = function(m) {
              if (m == null)
                this.transform(new d(0, 0));
              else {
                var v = new f(), y = this.graphManager.getRoot().updateLeftTop();
                if (y != null) {
                  v.setWorldOrgX(m.x), v.setWorldOrgY(m.y), v.setDeviceOrgX(y.x), v.setDeviceOrgY(y.y);
                  for (var b = this.getAllNodes(), w, T = 0; T < b.length; T++)
                    w = b[T], w.transform(v);
                }
              }
            }, g.prototype.positionNodesRandomly = function(m) {
              if (m == null)
                this.positionNodesRandomly(this.getGraphManager().getRoot()), this.getGraphManager().getRoot().updateBounds(!0);
              else
                for (var v, y, b = m.getNodes(), w = 0; w < b.length; w++)
                  v = b[w], y = v.getChild(), y == null || y.getNodes().length == 0 ? v.scatter() : (this.positionNodesRandomly(y), v.updateBounds());
            }, g.prototype.getFlatForest = function() {
              for (var m = [], v = !0, y = this.graphManager.getRoot().getNodes(), b = !0, w = 0; w < y.length; w++)
                y[w].getChild() != null && (b = !1);
              if (!b)
                return m;
              var T = /* @__PURE__ */ new Set(), E = [], L = /* @__PURE__ */ new Map(), k = [];
              for (k = k.concat(y); k.length > 0 && v; ) {
                for (E.push(k[0]); E.length > 0 && v; ) {
                  var C = E[0];
                  E.splice(0, 1), T.add(C);
                  for (var A = C.getEdges(), w = 0; w < A.length; w++) {
                    var R = A[w].getOtherEnd(C);
                    if (L.get(C) != R)
                      if (!T.has(R))
                        E.push(R), L.set(R, C);
                      else {
                        v = !1;
                        break;
                      }
                  }
                }
                if (!v)
                  m = [];
                else {
                  var _ = [].concat(a(T));
                  m.push(_);
                  for (var w = 0; w < _.length; w++) {
                    var O = _[w], P = k.indexOf(O);
                    P > -1 && k.splice(P, 1);
                  }
                  T = /* @__PURE__ */ new Set(), L = /* @__PURE__ */ new Map();
                }
              }
              return m;
            }, g.prototype.createDummyNodesForBendpoints = function(m) {
              for (var v = [], y = m.source, b = this.graphManager.calcLowestCommonAncestor(m.source, m.target), w = 0; w < m.bendpoints.length; w++) {
                var T = this.newNode(null);
                T.setRect(new Point(0, 0), new Dimension(1, 1)), b.add(T);
                var E = this.newEdge(null);
                this.graphManager.add(E, y, T), v.add(T), y = T;
              }
              var E = this.newEdge(null);
              return this.graphManager.add(E, y, m.target), this.edgeToDummyNodes.set(m, v), m.isInterGraph() ? this.graphManager.remove(m) : b.remove(m), v;
            }, g.prototype.createBendpointsFromDummyNodes = function() {
              var m = [];
              m = m.concat(this.graphManager.getAllEdges()), m = [].concat(a(this.edgeToDummyNodes.keys())).concat(m);
              for (var v = 0; v < m.length; v++) {
                var y = m[v];
                if (y.bendpoints.length > 0) {
                  for (var b = this.edgeToDummyNodes.get(y), w = 0; w < b.length; w++) {
                    var T = b[w], E = new d(T.getCenterX(), T.getCenterY()), L = y.bendpoints.get(w);
                    L.x = E.x, L.y = E.y, T.getOwner().remove(T);
                  }
                  this.graphManager.add(y, y.source, y.target);
                }
              }
            }, g.transform = function(m, v, y, b) {
              if (y != null && b != null) {
                var w = v;
                if (m <= 50) {
                  var T = v / y;
                  w -= (v - T) / 50 * (50 - m);
                } else {
                  var E = v * b;
                  w += (E - v) / 50 * (m - 50);
                }
                return w;
              } else {
                var L, k;
                return m <= 50 ? (L = 9 * v / 500, k = v / 10) : (L = 9 * v / 50, k = -8 * v), L * m + k;
              }
            }, g.findCenterOfTree = function(m) {
              var v = [];
              v = v.concat(m);
              var y = [], b = /* @__PURE__ */ new Map(), w = !1, T = null;
              (v.length == 1 || v.length == 2) && (w = !0, T = v[0]);
              for (var E = 0; E < v.length; E++) {
                var L = v[E], k = L.getNeighborsList().size;
                b.set(L, L.getNeighborsList().size), k == 1 && y.push(L);
              }
              var C = [];
              for (C = C.concat(y); !w; ) {
                var A = [];
                A = A.concat(C), C = [];
                for (var E = 0; E < v.length; E++) {
                  var L = v[E], R = v.indexOf(L);
                  R >= 0 && v.splice(R, 1);
                  var _ = L.getNeighborsList();
                  _.forEach(function(S) {
                    if (y.indexOf(S) < 0) {
                      var M = b.get(S), N = M - 1;
                      N == 1 && C.push(S), b.set(S, N);
                    }
                  });
                }
                y = y.concat(C), (v.length == 1 || v.length == 2) && (w = !0, T = v[0]);
              }
              return T;
            }, g.prototype.setGraphManager = function(m) {
              this.graphManager = m;
            }, r.exports = g;
          }),
          /* 16 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.seed = 1, a.x = 0, a.nextDouble = function() {
              return a.x = Math.sin(a.seed++) * 1e4, a.x - Math.floor(a.x);
            }, r.exports = a;
          }),
          /* 17 */
          /***/
          (function(r, n, i) {
            var a = i(4);
            function s(o, l) {
              this.lworldOrgX = 0, this.lworldOrgY = 0, this.ldeviceOrgX = 0, this.ldeviceOrgY = 0, this.lworldExtX = 1, this.lworldExtY = 1, this.ldeviceExtX = 1, this.ldeviceExtY = 1;
            }
            s.prototype.getWorldOrgX = function() {
              return this.lworldOrgX;
            }, s.prototype.setWorldOrgX = function(o) {
              this.lworldOrgX = o;
            }, s.prototype.getWorldOrgY = function() {
              return this.lworldOrgY;
            }, s.prototype.setWorldOrgY = function(o) {
              this.lworldOrgY = o;
            }, s.prototype.getWorldExtX = function() {
              return this.lworldExtX;
            }, s.prototype.setWorldExtX = function(o) {
              this.lworldExtX = o;
            }, s.prototype.getWorldExtY = function() {
              return this.lworldExtY;
            }, s.prototype.setWorldExtY = function(o) {
              this.lworldExtY = o;
            }, s.prototype.getDeviceOrgX = function() {
              return this.ldeviceOrgX;
            }, s.prototype.setDeviceOrgX = function(o) {
              this.ldeviceOrgX = o;
            }, s.prototype.getDeviceOrgY = function() {
              return this.ldeviceOrgY;
            }, s.prototype.setDeviceOrgY = function(o) {
              this.ldeviceOrgY = o;
            }, s.prototype.getDeviceExtX = function() {
              return this.ldeviceExtX;
            }, s.prototype.setDeviceExtX = function(o) {
              this.ldeviceExtX = o;
            }, s.prototype.getDeviceExtY = function() {
              return this.ldeviceExtY;
            }, s.prototype.setDeviceExtY = function(o) {
              this.ldeviceExtY = o;
            }, s.prototype.transformX = function(o) {
              var l = 0, u = this.lworldExtX;
              return u != 0 && (l = this.ldeviceOrgX + (o - this.lworldOrgX) * this.ldeviceExtX / u), l;
            }, s.prototype.transformY = function(o) {
              var l = 0, u = this.lworldExtY;
              return u != 0 && (l = this.ldeviceOrgY + (o - this.lworldOrgY) * this.ldeviceExtY / u), l;
            }, s.prototype.inverseTransformX = function(o) {
              var l = 0, u = this.ldeviceExtX;
              return u != 0 && (l = this.lworldOrgX + (o - this.ldeviceOrgX) * this.lworldExtX / u), l;
            }, s.prototype.inverseTransformY = function(o) {
              var l = 0, u = this.ldeviceExtY;
              return u != 0 && (l = this.lworldOrgY + (o - this.ldeviceOrgY) * this.lworldExtY / u), l;
            }, s.prototype.inverseTransformPoint = function(o) {
              var l = new a(this.inverseTransformX(o.x), this.inverseTransformY(o.y));
              return l;
            }, r.exports = s;
          }),
          /* 18 */
          /***/
          (function(r, n, i) {
            function a(p) {
              if (Array.isArray(p)) {
                for (var g = 0, m = Array(p.length); g < p.length; g++)
                  m[g] = p[g];
                return m;
              } else
                return Array.from(p);
            }
            var s = i(15), o = i(7), l = i(0), u = i(8), h = i(9);
            function d() {
              s.call(this), this.useSmartIdealEdgeLengthCalculation = o.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION, this.idealEdgeLength = o.DEFAULT_EDGE_LENGTH, this.springConstant = o.DEFAULT_SPRING_STRENGTH, this.repulsionConstant = o.DEFAULT_REPULSION_STRENGTH, this.gravityConstant = o.DEFAULT_GRAVITY_STRENGTH, this.compoundGravityConstant = o.DEFAULT_COMPOUND_GRAVITY_STRENGTH, this.gravityRangeFactor = o.DEFAULT_GRAVITY_RANGE_FACTOR, this.compoundGravityRangeFactor = o.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR, this.displacementThresholdPerNode = 3 * o.DEFAULT_EDGE_LENGTH / 100, this.coolingFactor = o.DEFAULT_COOLING_FACTOR_INCREMENTAL, this.initialCoolingFactor = o.DEFAULT_COOLING_FACTOR_INCREMENTAL, this.totalDisplacement = 0, this.oldTotalDisplacement = 0, this.maxIterations = o.MAX_ITERATIONS;
            }
            d.prototype = Object.create(s.prototype);
            for (var f in s)
              d[f] = s[f];
            d.prototype.initParameters = function() {
              s.prototype.initParameters.call(this, arguments), this.totalIterations = 0, this.notAnimatedIterations = 0, this.useFRGridVariant = o.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION, this.grid = [];
            }, d.prototype.calcIdealEdgeLengths = function() {
              for (var p, g, m, v, y, b, w = this.getGraphManager().getAllEdges(), T = 0; T < w.length; T++)
                p = w[T], p.idealLength = this.idealEdgeLength, p.isInterGraph && (m = p.getSource(), v = p.getTarget(), y = p.getSourceInLca().getEstimatedSize(), b = p.getTargetInLca().getEstimatedSize(), this.useSmartIdealEdgeLengthCalculation && (p.idealLength += y + b - 2 * l.SIMPLE_NODE_SIZE), g = p.getLca().getInclusionTreeDepth(), p.idealLength += o.DEFAULT_EDGE_LENGTH * o.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (m.getInclusionTreeDepth() + v.getInclusionTreeDepth() - 2 * g));
            }, d.prototype.initSpringEmbedder = function() {
              var p = this.getAllNodes().length;
              this.incremental ? (p > o.ADAPTATION_LOWER_NODE_LIMIT && (this.coolingFactor = Math.max(this.coolingFactor * o.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (p - o.ADAPTATION_LOWER_NODE_LIMIT) / (o.ADAPTATION_UPPER_NODE_LIMIT - o.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - o.COOLING_ADAPTATION_FACTOR))), this.maxNodeDisplacement = o.MAX_NODE_DISPLACEMENT_INCREMENTAL) : (p > o.ADAPTATION_LOWER_NODE_LIMIT ? this.coolingFactor = Math.max(o.COOLING_ADAPTATION_FACTOR, 1 - (p - o.ADAPTATION_LOWER_NODE_LIMIT) / (o.ADAPTATION_UPPER_NODE_LIMIT - o.ADAPTATION_LOWER_NODE_LIMIT) * (1 - o.COOLING_ADAPTATION_FACTOR)) : this.coolingFactor = 1, this.initialCoolingFactor = this.coolingFactor, this.maxNodeDisplacement = o.MAX_NODE_DISPLACEMENT), this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations), this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length, this.repulsionRange = this.calcRepulsionRange();
            }, d.prototype.calcSpringForces = function() {
              for (var p = this.getAllEdges(), g, m = 0; m < p.length; m++)
                g = p[m], this.calcSpringForce(g, g.idealLength);
            }, d.prototype.calcRepulsionForces = function() {
              var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, m, v, y, b, w = this.getAllNodes(), T;
              if (this.useFRGridVariant)
                for (this.totalIterations % o.GRID_CALCULATION_CHECK_PERIOD == 1 && p && this.updateGrid(), T = /* @__PURE__ */ new Set(), m = 0; m < w.length; m++)
                  y = w[m], this.calculateRepulsionForceOfANode(y, T, p, g), T.add(y);
              else
                for (m = 0; m < w.length; m++)
                  for (y = w[m], v = m + 1; v < w.length; v++)
                    b = w[v], y.getOwner() == b.getOwner() && this.calcRepulsionForce(y, b);
            }, d.prototype.calcGravitationalForces = function() {
              for (var p, g = this.getAllNodesToApplyGravitation(), m = 0; m < g.length; m++)
                p = g[m], this.calcGravitationalForce(p);
            }, d.prototype.moveNodes = function() {
              for (var p = this.getAllNodes(), g, m = 0; m < p.length; m++)
                g = p[m], g.move();
            }, d.prototype.calcSpringForce = function(p, g) {
              var m = p.getSource(), v = p.getTarget(), y, b, w, T;
              if (this.uniformLeafNodeSizes && m.getChild() == null && v.getChild() == null)
                p.updateLengthSimple();
              else if (p.updateLength(), p.isOverlapingSourceAndTarget)
                return;
              y = p.getLength(), y != 0 && (b = this.springConstant * (y - g), w = b * (p.lengthX / y), T = b * (p.lengthY / y), m.springForceX += w, m.springForceY += T, v.springForceX -= w, v.springForceY -= T);
            }, d.prototype.calcRepulsionForce = function(p, g) {
              var m = p.getRect(), v = g.getRect(), y = new Array(2), b = new Array(4), w, T, E, L, k, C, A;
              if (m.intersects(v)) {
                u.calcSeparationAmount(m, v, y, o.DEFAULT_EDGE_LENGTH / 2), C = 2 * y[0], A = 2 * y[1];
                var R = p.noOfChildren * g.noOfChildren / (p.noOfChildren + g.noOfChildren);
                p.repulsionForceX -= R * C, p.repulsionForceY -= R * A, g.repulsionForceX += R * C, g.repulsionForceY += R * A;
              } else
                this.uniformLeafNodeSizes && p.getChild() == null && g.getChild() == null ? (w = v.getCenterX() - m.getCenterX(), T = v.getCenterY() - m.getCenterY()) : (u.getIntersection(m, v, b), w = b[2] - b[0], T = b[3] - b[1]), Math.abs(w) < o.MIN_REPULSION_DIST && (w = h.sign(w) * o.MIN_REPULSION_DIST), Math.abs(T) < o.MIN_REPULSION_DIST && (T = h.sign(T) * o.MIN_REPULSION_DIST), E = w * w + T * T, L = Math.sqrt(E), k = this.repulsionConstant * p.noOfChildren * g.noOfChildren / E, C = k * w / L, A = k * T / L, p.repulsionForceX -= C, p.repulsionForceY -= A, g.repulsionForceX += C, g.repulsionForceY += A;
            }, d.prototype.calcGravitationalForce = function(p) {
              var g, m, v, y, b, w, T, E;
              g = p.getOwner(), m = (g.getRight() + g.getLeft()) / 2, v = (g.getTop() + g.getBottom()) / 2, y = p.getCenterX() - m, b = p.getCenterY() - v, w = Math.abs(y) + p.getWidth() / 2, T = Math.abs(b) + p.getHeight() / 2, p.getOwner() == this.graphManager.getRoot() ? (E = g.getEstimatedSize() * this.gravityRangeFactor, (w > E || T > E) && (p.gravitationForceX = -this.gravityConstant * y, p.gravitationForceY = -this.gravityConstant * b)) : (E = g.getEstimatedSize() * this.compoundGravityRangeFactor, (w > E || T > E) && (p.gravitationForceX = -this.gravityConstant * y * this.compoundGravityConstant, p.gravitationForceY = -this.gravityConstant * b * this.compoundGravityConstant));
            }, d.prototype.isConverged = function() {
              var p, g = !1;
              return this.totalIterations > this.maxIterations / 3 && (g = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2), p = this.totalDisplacement < this.totalDisplacementThreshold, this.oldTotalDisplacement = this.totalDisplacement, p || g;
            }, d.prototype.animate = function() {
              this.animationDuringLayout && !this.isSubLayout && (this.notAnimatedIterations == this.animationPeriod ? (this.update(), this.notAnimatedIterations = 0) : this.notAnimatedIterations++);
            }, d.prototype.calcNoOfChildrenForAllNodes = function() {
              for (var p, g = this.graphManager.getAllNodes(), m = 0; m < g.length; m++)
                p = g[m], p.noOfChildren = p.getNoOfChildren();
            }, d.prototype.calcGrid = function(p) {
              var g = 0, m = 0;
              g = parseInt(Math.ceil((p.getRight() - p.getLeft()) / this.repulsionRange)), m = parseInt(Math.ceil((p.getBottom() - p.getTop()) / this.repulsionRange));
              for (var v = new Array(g), y = 0; y < g; y++)
                v[y] = new Array(m);
              for (var y = 0; y < g; y++)
                for (var b = 0; b < m; b++)
                  v[y][b] = new Array();
              return v;
            }, d.prototype.addNodeToGrid = function(p, g, m) {
              var v = 0, y = 0, b = 0, w = 0;
              v = parseInt(Math.floor((p.getRect().x - g) / this.repulsionRange)), y = parseInt(Math.floor((p.getRect().width + p.getRect().x - g) / this.repulsionRange)), b = parseInt(Math.floor((p.getRect().y - m) / this.repulsionRange)), w = parseInt(Math.floor((p.getRect().height + p.getRect().y - m) / this.repulsionRange));
              for (var T = v; T <= y; T++)
                for (var E = b; E <= w; E++)
                  this.grid[T][E].push(p), p.setGridCoordinates(v, y, b, w);
            }, d.prototype.updateGrid = function() {
              var p, g, m = this.getAllNodes();
              for (this.grid = this.calcGrid(this.graphManager.getRoot()), p = 0; p < m.length; p++)
                g = m[p], this.addNodeToGrid(g, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());
            }, d.prototype.calculateRepulsionForceOfANode = function(p, g, m, v) {
              if (this.totalIterations % o.GRID_CALCULATION_CHECK_PERIOD == 1 && m || v) {
                var y = /* @__PURE__ */ new Set();
                p.surrounding = new Array();
                for (var b, w = this.grid, T = p.startX - 1; T < p.finishX + 2; T++)
                  for (var E = p.startY - 1; E < p.finishY + 2; E++)
                    if (!(T < 0 || E < 0 || T >= w.length || E >= w[0].length)) {
                      for (var L = 0; L < w[T][E].length; L++)
                        if (b = w[T][E][L], !(p.getOwner() != b.getOwner() || p == b) && !g.has(b) && !y.has(b)) {
                          var k = Math.abs(p.getCenterX() - b.getCenterX()) - (p.getWidth() / 2 + b.getWidth() / 2), C = Math.abs(p.getCenterY() - b.getCenterY()) - (p.getHeight() / 2 + b.getHeight() / 2);
                          k <= this.repulsionRange && C <= this.repulsionRange && y.add(b);
                        }
                    }
                p.surrounding = [].concat(a(y));
              }
              for (T = 0; T < p.surrounding.length; T++)
                this.calcRepulsionForce(p, p.surrounding[T]);
            }, d.prototype.calcRepulsionRange = function() {
              return 0;
            }, r.exports = d;
          }),
          /* 19 */
          /***/
          (function(r, n, i) {
            var a = i(1), s = i(7);
            function o(u, h, d) {
              a.call(this, u, h, d), this.idealLength = s.DEFAULT_EDGE_LENGTH;
            }
            o.prototype = Object.create(a.prototype);
            for (var l in a)
              o[l] = a[l];
            r.exports = o;
          }),
          /* 20 */
          /***/
          (function(r, n, i) {
            var a = i(3);
            function s(l, u, h, d) {
              a.call(this, l, u, h, d), this.springForceX = 0, this.springForceY = 0, this.repulsionForceX = 0, this.repulsionForceY = 0, this.gravitationForceX = 0, this.gravitationForceY = 0, this.displacementX = 0, this.displacementY = 0, this.startX = 0, this.finishX = 0, this.startY = 0, this.finishY = 0, this.surrounding = [];
            }
            s.prototype = Object.create(a.prototype);
            for (var o in a)
              s[o] = a[o];
            s.prototype.setGridCoordinates = function(l, u, h, d) {
              this.startX = l, this.finishX = u, this.startY = h, this.finishY = d;
            }, r.exports = s;
          }),
          /* 21 */
          /***/
          (function(r, n, i) {
            function a(s, o) {
              this.width = 0, this.height = 0, s !== null && o !== null && (this.height = o, this.width = s);
            }
            a.prototype.getWidth = function() {
              return this.width;
            }, a.prototype.setWidth = function(s) {
              this.width = s;
            }, a.prototype.getHeight = function() {
              return this.height;
            }, a.prototype.setHeight = function(s) {
              this.height = s;
            }, r.exports = a;
          }),
          /* 22 */
          /***/
          (function(r, n, i) {
            var a = i(14);
            function s() {
              this.map = {}, this.keys = [];
            }
            s.prototype.put = function(o, l) {
              var u = a.createID(o);
              this.contains(u) || (this.map[u] = l, this.keys.push(o));
            }, s.prototype.contains = function(o) {
              return a.createID(o), this.map[o] != null;
            }, s.prototype.get = function(o) {
              var l = a.createID(o);
              return this.map[l];
            }, s.prototype.keySet = function() {
              return this.keys;
            }, r.exports = s;
          }),
          /* 23 */
          /***/
          (function(r, n, i) {
            var a = i(14);
            function s() {
              this.set = {};
            }
            s.prototype.add = function(o) {
              var l = a.createID(o);
              this.contains(l) || (this.set[l] = o);
            }, s.prototype.remove = function(o) {
              delete this.set[a.createID(o)];
            }, s.prototype.clear = function() {
              this.set = {};
            }, s.prototype.contains = function(o) {
              return this.set[a.createID(o)] == o;
            }, s.prototype.isEmpty = function() {
              return this.size() === 0;
            }, s.prototype.size = function() {
              return Object.keys(this.set).length;
            }, s.prototype.addAllTo = function(o) {
              for (var l = Object.keys(this.set), u = l.length, h = 0; h < u; h++)
                o.push(this.set[l[h]]);
            }, s.prototype.size = function() {
              return Object.keys(this.set).length;
            }, s.prototype.addAll = function(o) {
              for (var l = o.length, u = 0; u < l; u++) {
                var h = o[u];
                this.add(h);
              }
            }, r.exports = s;
          }),
          /* 24 */
          /***/
          (function(r, n, i) {
            var a = /* @__PURE__ */ (function() {
              function u(h, d) {
                for (var f = 0; f < d.length; f++) {
                  var p = d[f];
                  p.enumerable = p.enumerable || !1, p.configurable = !0, "value" in p && (p.writable = !0), Object.defineProperty(h, p.key, p);
                }
              }
              return function(h, d, f) {
                return d && u(h.prototype, d), f && u(h, f), h;
              };
            })();
            function s(u, h) {
              if (!(u instanceof h))
                throw new TypeError("Cannot call a class as a function");
            }
            var o = i(11), l = (function() {
              function u(h, d) {
                s(this, u), (d !== null || d !== void 0) && (this.compareFunction = this._defaultCompareFunction);
                var f = void 0;
                h instanceof o ? f = h.size() : f = h.length, this._quicksort(h, 0, f - 1);
              }
              return a(u, [{
                key: "_quicksort",
                value: function(d, f, p) {
                  if (f < p) {
                    var g = this._partition(d, f, p);
                    this._quicksort(d, f, g), this._quicksort(d, g + 1, p);
                  }
                }
              }, {
                key: "_partition",
                value: function(d, f, p) {
                  for (var g = this._get(d, f), m = f, v = p; ; ) {
                    for (; this.compareFunction(g, this._get(d, v)); )
                      v--;
                    for (; this.compareFunction(this._get(d, m), g); )
                      m++;
                    if (m < v)
                      this._swap(d, m, v), m++, v--;
                    else return v;
                  }
                }
              }, {
                key: "_get",
                value: function(d, f) {
                  return d instanceof o ? d.get_object_at(f) : d[f];
                }
              }, {
                key: "_set",
                value: function(d, f, p) {
                  d instanceof o ? d.set_object_at(f, p) : d[f] = p;
                }
              }, {
                key: "_swap",
                value: function(d, f, p) {
                  var g = this._get(d, f);
                  this._set(d, f, this._get(d, p)), this._set(d, p, g);
                }
              }, {
                key: "_defaultCompareFunction",
                value: function(d, f) {
                  return f > d;
                }
              }]), u;
            })();
            r.exports = l;
          }),
          /* 25 */
          /***/
          (function(r, n, i) {
            var a = /* @__PURE__ */ (function() {
              function l(u, h) {
                for (var d = 0; d < h.length; d++) {
                  var f = h[d];
                  f.enumerable = f.enumerable || !1, f.configurable = !0, "value" in f && (f.writable = !0), Object.defineProperty(u, f.key, f);
                }
              }
              return function(u, h, d) {
                return h && l(u.prototype, h), d && l(u, d), u;
              };
            })();
            function s(l, u) {
              if (!(l instanceof u))
                throw new TypeError("Cannot call a class as a function");
            }
            var o = (function() {
              function l(u, h) {
                var d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, f = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1, p = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1;
                s(this, l), this.sequence1 = u, this.sequence2 = h, this.match_score = d, this.mismatch_penalty = f, this.gap_penalty = p, this.iMax = u.length + 1, this.jMax = h.length + 1, this.grid = new Array(this.iMax);
                for (var g = 0; g < this.iMax; g++) {
                  this.grid[g] = new Array(this.jMax);
                  for (var m = 0; m < this.jMax; m++)
                    this.grid[g][m] = 0;
                }
                this.tracebackGrid = new Array(this.iMax);
                for (var v = 0; v < this.iMax; v++) {
                  this.tracebackGrid[v] = new Array(this.jMax);
                  for (var y = 0; y < this.jMax; y++)
                    this.tracebackGrid[v][y] = [null, null, null];
                }
                this.alignments = [], this.score = -1, this.computeGrids();
              }
              return a(l, [{
                key: "getScore",
                value: function() {
                  return this.score;
                }
              }, {
                key: "getAlignments",
                value: function() {
                  return this.alignments;
                }
                // Main dynamic programming procedure
              }, {
                key: "computeGrids",
                value: function() {
                  for (var h = 1; h < this.jMax; h++)
                    this.grid[0][h] = this.grid[0][h - 1] + this.gap_penalty, this.tracebackGrid[0][h] = [!1, !1, !0];
                  for (var d = 1; d < this.iMax; d++)
                    this.grid[d][0] = this.grid[d - 1][0] + this.gap_penalty, this.tracebackGrid[d][0] = [!1, !0, !1];
                  for (var f = 1; f < this.iMax; f++)
                    for (var p = 1; p < this.jMax; p++) {
                      var g = void 0;
                      this.sequence1[f - 1] === this.sequence2[p - 1] ? g = this.grid[f - 1][p - 1] + this.match_score : g = this.grid[f - 1][p - 1] + this.mismatch_penalty;
                      var m = this.grid[f - 1][p] + this.gap_penalty, v = this.grid[f][p - 1] + this.gap_penalty, y = [g, m, v], b = this.arrayAllMaxIndexes(y);
                      this.grid[f][p] = y[b[0]], this.tracebackGrid[f][p] = [b.includes(0), b.includes(1), b.includes(2)];
                    }
                  this.score = this.grid[this.iMax - 1][this.jMax - 1];
                }
                // Gets all possible valid sequence combinations
              }, {
                key: "alignmentTraceback",
                value: function() {
                  var h = [];
                  for (h.push({
                    pos: [this.sequence1.length, this.sequence2.length],
                    seq1: "",
                    seq2: ""
                  }); h[0]; ) {
                    var d = h[0], f = this.tracebackGrid[d.pos[0]][d.pos[1]];
                    f[0] && h.push({
                      pos: [d.pos[0] - 1, d.pos[1] - 1],
                      seq1: this.sequence1[d.pos[0] - 1] + d.seq1,
                      seq2: this.sequence2[d.pos[1] - 1] + d.seq2
                    }), f[1] && h.push({
                      pos: [d.pos[0] - 1, d.pos[1]],
                      seq1: this.sequence1[d.pos[0] - 1] + d.seq1,
                      seq2: "-" + d.seq2
                    }), f[2] && h.push({
                      pos: [d.pos[0], d.pos[1] - 1],
                      seq1: "-" + d.seq1,
                      seq2: this.sequence2[d.pos[1] - 1] + d.seq2
                    }), d.pos[0] === 0 && d.pos[1] === 0 && this.alignments.push({
                      sequence1: d.seq1,
                      sequence2: d.seq2
                    }), h.shift();
                  }
                  return this.alignments;
                }
                // Helper Functions
              }, {
                key: "getAllIndexes",
                value: function(h, d) {
                  for (var f = [], p = -1; (p = h.indexOf(d, p + 1)) !== -1; )
                    f.push(p);
                  return f;
                }
              }, {
                key: "arrayAllMaxIndexes",
                value: function(h) {
                  return this.getAllIndexes(h, Math.max.apply(null, h));
                }
              }]), l;
            })();
            r.exports = o;
          }),
          /* 26 */
          /***/
          (function(r, n, i) {
            var a = function() {
            };
            a.FDLayout = i(18), a.FDLayoutConstants = i(7), a.FDLayoutEdge = i(19), a.FDLayoutNode = i(20), a.DimensionD = i(21), a.HashMap = i(22), a.HashSet = i(23), a.IGeometry = i(8), a.IMath = i(9), a.Integer = i(10), a.Point = i(12), a.PointD = i(4), a.RandomSeed = i(16), a.RectangleD = i(13), a.Transform = i(17), a.UniqueIDGeneretor = i(14), a.Quicksort = i(24), a.LinkedList = i(11), a.LGraphObject = i(2), a.LGraph = i(5), a.LEdge = i(1), a.LGraphManager = i(6), a.LNode = i(3), a.Layout = i(15), a.LayoutConstants = i(0), a.NeedlemanWunsch = i(25), r.exports = a;
          }),
          /* 27 */
          /***/
          (function(r, n, i) {
            function a() {
              this.listeners = [];
            }
            var s = a.prototype;
            s.addListener = function(o, l) {
              this.listeners.push({
                event: o,
                callback: l
              });
            }, s.removeListener = function(o, l) {
              for (var u = this.listeners.length; u >= 0; u--) {
                var h = this.listeners[u];
                h.event === o && h.callback === l && this.listeners.splice(u, 1);
              }
            }, s.emit = function(o, l) {
              for (var u = 0; u < this.listeners.length; u++) {
                var h = this.listeners[u];
                o === h.event && h.callback(l);
              }
            }, r.exports = a;
          })
          /******/
        ])
      );
    });
  })(Ym)), Ym.exports;
}
var D5e = Wm.exports, NL;
function O5e() {
  return NL || (NL = 1, (function(t, e) {
    (function(n, i) {
      t.exports = i(I5e());
    })(D5e, function(r) {
      return (
        /******/
        (function(n) {
          var i = {};
          function a(s) {
            if (i[s])
              return i[s].exports;
            var o = i[s] = {
              /******/
              i: s,
              /******/
              l: !1,
              /******/
              exports: {}
              /******/
            };
            return n[s].call(o.exports, o, o.exports, a), o.l = !0, o.exports;
          }
          return a.m = n, a.c = i, a.i = function(s) {
            return s;
          }, a.d = function(s, o, l) {
            a.o(s, o) || Object.defineProperty(s, o, {
              /******/
              configurable: !1,
              /******/
              enumerable: !0,
              /******/
              get: l
              /******/
            });
          }, a.n = function(s) {
            var o = s && s.__esModule ? (
              /******/
              function() {
                return s.default;
              }
            ) : (
              /******/
              function() {
                return s;
              }
            );
            return a.d(o, "a", o), o;
          }, a.o = function(s, o) {
            return Object.prototype.hasOwnProperty.call(s, o);
          }, a.p = "", a(a.s = 7);
        })([
          /* 0 */
          /***/
          (function(n, i) {
            n.exports = r;
          }),
          /* 1 */
          /***/
          (function(n, i, a) {
            var s = a(0).FDLayoutConstants;
            function o() {
            }
            for (var l in s)
              o[l] = s[l];
            o.DEFAULT_USE_MULTI_LEVEL_SCALING = !1, o.DEFAULT_RADIAL_SEPARATION = s.DEFAULT_EDGE_LENGTH, o.DEFAULT_COMPONENT_SEPERATION = 60, o.TILE = !0, o.TILING_PADDING_VERTICAL = 10, o.TILING_PADDING_HORIZONTAL = 10, o.TREE_REDUCTION_ON_INCREMENTAL = !1, n.exports = o;
          }),
          /* 2 */
          /***/
          (function(n, i, a) {
            var s = a(0).FDLayoutEdge;
            function o(u, h, d) {
              s.call(this, u, h, d);
            }
            o.prototype = Object.create(s.prototype);
            for (var l in s)
              o[l] = s[l];
            n.exports = o;
          }),
          /* 3 */
          /***/
          (function(n, i, a) {
            var s = a(0).LGraph;
            function o(u, h, d) {
              s.call(this, u, h, d);
            }
            o.prototype = Object.create(s.prototype);
            for (var l in s)
              o[l] = s[l];
            n.exports = o;
          }),
          /* 4 */
          /***/
          (function(n, i, a) {
            var s = a(0).LGraphManager;
            function o(u) {
              s.call(this, u);
            }
            o.prototype = Object.create(s.prototype);
            for (var l in s)
              o[l] = s[l];
            n.exports = o;
          }),
          /* 5 */
          /***/
          (function(n, i, a) {
            var s = a(0).FDLayoutNode, o = a(0).IMath;
            function l(h, d, f, p) {
              s.call(this, h, d, f, p);
            }
            l.prototype = Object.create(s.prototype);
            for (var u in s)
              l[u] = s[u];
            l.prototype.move = function() {
              var h = this.graphManager.getLayout();
              this.displacementX = h.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren, this.displacementY = h.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren, Math.abs(this.displacementX) > h.coolingFactor * h.maxNodeDisplacement && (this.displacementX = h.coolingFactor * h.maxNodeDisplacement * o.sign(this.displacementX)), Math.abs(this.displacementY) > h.coolingFactor * h.maxNodeDisplacement && (this.displacementY = h.coolingFactor * h.maxNodeDisplacement * o.sign(this.displacementY)), this.child == null ? this.moveBy(this.displacementX, this.displacementY) : this.child.getNodes().length == 0 ? this.moveBy(this.displacementX, this.displacementY) : this.propogateDisplacementToChildren(this.displacementX, this.displacementY), h.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY), this.springForceX = 0, this.springForceY = 0, this.repulsionForceX = 0, this.repulsionForceY = 0, this.gravitationForceX = 0, this.gravitationForceY = 0, this.displacementX = 0, this.displacementY = 0;
            }, l.prototype.propogateDisplacementToChildren = function(h, d) {
              for (var f = this.getChild().getNodes(), p, g = 0; g < f.length; g++)
                p = f[g], p.getChild() == null ? (p.moveBy(h, d), p.displacementX += h, p.displacementY += d) : p.propogateDisplacementToChildren(h, d);
            }, l.prototype.setPred1 = function(h) {
              this.pred1 = h;
            }, l.prototype.getPred1 = function() {
              return pred1;
            }, l.prototype.getPred2 = function() {
              return pred2;
            }, l.prototype.setNext = function(h) {
              this.next = h;
            }, l.prototype.getNext = function() {
              return next;
            }, l.prototype.setProcessed = function(h) {
              this.processed = h;
            }, l.prototype.isProcessed = function() {
              return processed;
            }, n.exports = l;
          }),
          /* 6 */
          /***/
          (function(n, i, a) {
            var s = a(0).FDLayout, o = a(4), l = a(3), u = a(5), h = a(2), d = a(1), f = a(0).FDLayoutConstants, p = a(0).LayoutConstants, g = a(0).Point, m = a(0).PointD, v = a(0).Layout, y = a(0).Integer, b = a(0).IGeometry, w = a(0).LGraph, T = a(0).Transform;
            function E() {
              s.call(this), this.toBeTiled = {};
            }
            E.prototype = Object.create(s.prototype);
            for (var L in s)
              E[L] = s[L];
            E.prototype.newGraphManager = function() {
              var k = new o(this);
              return this.graphManager = k, k;
            }, E.prototype.newGraph = function(k) {
              return new l(null, this.graphManager, k);
            }, E.prototype.newNode = function(k) {
              return new u(this.graphManager, k);
            }, E.prototype.newEdge = function(k) {
              return new h(null, null, k);
            }, E.prototype.initParameters = function() {
              s.prototype.initParameters.call(this, arguments), this.isSubLayout || (d.DEFAULT_EDGE_LENGTH < 10 ? this.idealEdgeLength = 10 : this.idealEdgeLength = d.DEFAULT_EDGE_LENGTH, this.useSmartIdealEdgeLengthCalculation = d.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION, this.springConstant = f.DEFAULT_SPRING_STRENGTH, this.repulsionConstant = f.DEFAULT_REPULSION_STRENGTH, this.gravityConstant = f.DEFAULT_GRAVITY_STRENGTH, this.compoundGravityConstant = f.DEFAULT_COMPOUND_GRAVITY_STRENGTH, this.gravityRangeFactor = f.DEFAULT_GRAVITY_RANGE_FACTOR, this.compoundGravityRangeFactor = f.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR, this.prunedNodesAll = [], this.growTreeIterations = 0, this.afterGrowthIterations = 0, this.isTreeGrowing = !1, this.isGrowthFinished = !1, this.coolingCycle = 0, this.maxCoolingCycle = this.maxIterations / f.CONVERGENCE_CHECK_PERIOD, this.finalTemperature = f.CONVERGENCE_CHECK_PERIOD / this.maxIterations, this.coolingAdjuster = 1);
            }, E.prototype.layout = function() {
              var k = p.DEFAULT_CREATE_BENDS_AS_NEEDED;
              return k && (this.createBendpoints(), this.graphManager.resetAllEdges()), this.level = 0, this.classicLayout();
            }, E.prototype.classicLayout = function() {
              if (this.nodesWithGravity = this.calculateNodesToApplyGravitationTo(), this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity), this.calcNoOfChildrenForAllNodes(), this.graphManager.calcLowestCommonAncestors(), this.graphManager.calcInclusionTreeDepths(), this.graphManager.getRoot().calcEstimatedSize(), this.calcIdealEdgeLengths(), this.incremental) {
                if (d.TREE_REDUCTION_ON_INCREMENTAL) {
                  this.reduceTrees(), this.graphManager.resetAllNodesToApplyGravitation();
                  var C = new Set(this.getAllNodes()), A = this.nodesWithGravity.filter(function(O) {
                    return C.has(O);
                  });
                  this.graphManager.setAllNodesToApplyGravitation(A);
                }
              } else {
                var k = this.getFlatForest();
                if (k.length > 0)
                  this.positionNodesRadially(k);
                else {
                  this.reduceTrees(), this.graphManager.resetAllNodesToApplyGravitation();
                  var C = new Set(this.getAllNodes()), A = this.nodesWithGravity.filter(function(R) {
                    return C.has(R);
                  });
                  this.graphManager.setAllNodesToApplyGravitation(A), this.positionNodesRandomly();
                }
              }
              return this.initSpringEmbedder(), this.runSpringEmbedder(), !0;
            }, E.prototype.tick = function() {
              if (this.totalIterations++, this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished)
                if (this.prunedNodesAll.length > 0)
                  this.isTreeGrowing = !0;
                else
                  return !0;
              if (this.totalIterations % f.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {
                if (this.isConverged())
                  if (this.prunedNodesAll.length > 0)
                    this.isTreeGrowing = !0;
                  else
                    return !0;
                this.coolingCycle++, this.layoutQuality == 0 ? this.coolingAdjuster = this.coolingCycle : this.layoutQuality == 1 && (this.coolingAdjuster = this.coolingCycle / 3), this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature), this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));
              }
              if (this.isTreeGrowing) {
                if (this.growTreeIterations % 10 == 0)
                  if (this.prunedNodesAll.length > 0) {
                    this.graphManager.updateBounds(), this.updateGrid(), this.growTree(this.prunedNodesAll), this.graphManager.resetAllNodesToApplyGravitation();
                    var k = new Set(this.getAllNodes()), C = this.nodesWithGravity.filter(function(_) {
                      return k.has(_);
                    });
                    this.graphManager.setAllNodesToApplyGravitation(C), this.graphManager.updateBounds(), this.updateGrid(), this.coolingFactor = f.DEFAULT_COOLING_FACTOR_INCREMENTAL;
                  } else
                    this.isTreeGrowing = !1, this.isGrowthFinished = !0;
                this.growTreeIterations++;
              }
              if (this.isGrowthFinished) {
                if (this.isConverged())
                  return !0;
                this.afterGrowthIterations % 10 == 0 && (this.graphManager.updateBounds(), this.updateGrid()), this.coolingFactor = f.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100), this.afterGrowthIterations++;
              }
              var A = !this.isTreeGrowing && !this.isGrowthFinished, R = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;
              return this.totalDisplacement = 0, this.graphManager.updateBounds(), this.calcSpringForces(), this.calcRepulsionForces(A, R), this.calcGravitationalForces(), this.moveNodes(), this.animate(), !1;
            }, E.prototype.getPositionsData = function() {
              for (var k = this.graphManager.getAllNodes(), C = {}, A = 0; A < k.length; A++) {
                var R = k[A].rect, _ = k[A].id;
                C[_] = {
                  id: _,
                  x: R.getCenterX(),
                  y: R.getCenterY(),
                  w: R.width,
                  h: R.height
                };
              }
              return C;
            }, E.prototype.runSpringEmbedder = function() {
              this.initialAnimationPeriod = 25, this.animationPeriod = this.initialAnimationPeriod;
              var k = !1;
              if (f.ANIMATE === "during")
                this.emit("layoutstarted");
              else {
                for (; !k; )
                  k = this.tick();
                this.graphManager.updateBounds();
              }
            }, E.prototype.calculateNodesToApplyGravitationTo = function() {
              var k = [], C, A = this.graphManager.getGraphs(), R = A.length, _;
              for (_ = 0; _ < R; _++)
                C = A[_], C.updateConnected(), C.isConnected || (k = k.concat(C.getNodes()));
              return k;
            }, E.prototype.createBendpoints = function() {
              var k = [];
              k = k.concat(this.graphManager.getAllEdges());
              var C = /* @__PURE__ */ new Set(), A;
              for (A = 0; A < k.length; A++) {
                var R = k[A];
                if (!C.has(R)) {
                  var _ = R.getSource(), O = R.getTarget();
                  if (_ == O)
                    R.getBendpoints().push(new m()), R.getBendpoints().push(new m()), this.createDummyNodesForBendpoints(R), C.add(R);
                  else {
                    var P = [];
                    if (P = P.concat(_.getEdgeListToNode(O)), P = P.concat(O.getEdgeListToNode(_)), !C.has(P[0])) {
                      if (P.length > 1) {
                        var S;
                        for (S = 0; S < P.length; S++) {
                          var M = P[S];
                          M.getBendpoints().push(new m()), this.createDummyNodesForBendpoints(M);
                        }
                      }
                      P.forEach(function(N) {
                        C.add(N);
                      });
                    }
                  }
                }
                if (C.size == k.length)
                  break;
              }
            }, E.prototype.positionNodesRadially = function(k) {
              for (var C = new g(0, 0), A = Math.ceil(Math.sqrt(k.length)), R = 0, _ = 0, O = 0, P = new m(0, 0), S = 0; S < k.length; S++) {
                S % A == 0 && (O = 0, _ = R, S != 0 && (_ += d.DEFAULT_COMPONENT_SEPERATION), R = 0);
                var M = k[S], N = v.findCenterOfTree(M);
                C.x = O, C.y = _, P = E.radialLayout(M, N, C), P.y > R && (R = Math.floor(P.y)), O = Math.floor(P.x + d.DEFAULT_COMPONENT_SEPERATION);
              }
              this.transform(new m(p.WORLD_CENTER_X - P.x / 2, p.WORLD_CENTER_Y - P.y / 2));
            }, E.radialLayout = function(k, C, A) {
              var R = Math.max(this.maxDiagonalInTree(k), d.DEFAULT_RADIAL_SEPARATION);
              E.branchRadialLayout(C, null, 0, 359, 0, R);
              var _ = w.calculateBounds(k), O = new T();
              O.setDeviceOrgX(_.getMinX()), O.setDeviceOrgY(_.getMinY()), O.setWorldOrgX(A.x), O.setWorldOrgY(A.y);
              for (var P = 0; P < k.length; P++) {
                var S = k[P];
                S.transform(O);
              }
              var M = new m(_.getMaxX(), _.getMaxY());
              return O.inverseTransformPoint(M);
            }, E.branchRadialLayout = function(k, C, A, R, _, O) {
              var P = (R - A + 1) / 2;
              P < 0 && (P += 180);
              var S = (P + A) % 360, M = S * b.TWO_PI / 360, N = _ * Math.cos(M), D = _ * Math.sin(M);
              k.setCenter(N, D);
              var I = [];
              I = I.concat(k.getEdges());
              var B = I.length;
              C != null && B--;
              for (var z = 0, F = I.length, V, H = k.getEdgesBetween(C); H.length > 1; ) {
                var J = H[0];
                H.splice(0, 1);
                var q = I.indexOf(J);
                q >= 0 && I.splice(q, 1), F--, B--;
              }
              C != null ? V = (I.indexOf(H[0]) + 1) % F : V = 0;
              for (var ae = Math.abs(R - A) / B, re = V; z != B; re = ++re % F) {
                var pe = I[re].getOtherEnd(k);
                if (pe != C) {
                  var K = (A + z * ae) % 360, Z = (K + ae) % 360;
                  E.branchRadialLayout(pe, k, K, Z, _ + O, O), z++;
                }
              }
            }, E.maxDiagonalInTree = function(k) {
              for (var C = y.MIN_VALUE, A = 0; A < k.length; A++) {
                var R = k[A], _ = R.getDiagonal();
                _ > C && (C = _);
              }
              return C;
            }, E.prototype.calcRepulsionRange = function() {
              return 2 * (this.level + 1) * this.idealEdgeLength;
            }, E.prototype.groupZeroDegreeMembers = function() {
              var k = this, C = {};
              this.memberGroups = {}, this.idToDummyNode = {};
              for (var A = [], R = this.graphManager.getAllNodes(), _ = 0; _ < R.length; _++) {
                var O = R[_], P = O.getParent();
                this.getNodeDegreeWithChildren(O) === 0 && (P.id == null || !this.getToBeTiled(P)) && A.push(O);
              }
              for (var _ = 0; _ < A.length; _++) {
                var O = A[_], S = O.getParent().id;
                typeof C[S] > "u" && (C[S] = []), C[S] = C[S].concat(O);
              }
              Object.keys(C).forEach(function(M) {
                if (C[M].length > 1) {
                  var N = "DummyCompound_" + M;
                  k.memberGroups[N] = C[M];
                  var D = C[M][0].getParent(), I = new u(k.graphManager);
                  I.id = N, I.paddingLeft = D.paddingLeft || 0, I.paddingRight = D.paddingRight || 0, I.paddingBottom = D.paddingBottom || 0, I.paddingTop = D.paddingTop || 0, k.idToDummyNode[N] = I;
                  var B = k.getGraphManager().add(k.newGraph(), I), z = D.getChild();
                  z.add(I);
                  for (var F = 0; F < C[M].length; F++) {
                    var V = C[M][F];
                    z.remove(V), B.add(V);
                  }
                }
              });
            }, E.prototype.clearCompounds = function() {
              var k = {}, C = {};
              this.performDFSOnCompounds();
              for (var A = 0; A < this.compoundOrder.length; A++)
                C[this.compoundOrder[A].id] = this.compoundOrder[A], k[this.compoundOrder[A].id] = [].concat(this.compoundOrder[A].getChild().getNodes()), this.graphManager.remove(this.compoundOrder[A].getChild()), this.compoundOrder[A].child = null;
              this.graphManager.resetAllNodes(), this.tileCompoundMembers(k, C);
            }, E.prototype.clearZeroDegreeMembers = function() {
              var k = this, C = this.tiledZeroDegreePack = [];
              Object.keys(this.memberGroups).forEach(function(A) {
                var R = k.idToDummyNode[A];
                C[A] = k.tileNodes(k.memberGroups[A], R.paddingLeft + R.paddingRight), R.rect.width = C[A].width, R.rect.height = C[A].height;
              });
            }, E.prototype.repopulateCompounds = function() {
              for (var k = this.compoundOrder.length - 1; k >= 0; k--) {
                var C = this.compoundOrder[k], A = C.id, R = C.paddingLeft, _ = C.paddingTop;
                this.adjustLocations(this.tiledMemberPack[A], C.rect.x, C.rect.y, R, _);
              }
            }, E.prototype.repopulateZeroDegreeMembers = function() {
              var k = this, C = this.tiledZeroDegreePack;
              Object.keys(C).forEach(function(A) {
                var R = k.idToDummyNode[A], _ = R.paddingLeft, O = R.paddingTop;
                k.adjustLocations(C[A], R.rect.x, R.rect.y, _, O);
              });
            }, E.prototype.getToBeTiled = function(k) {
              var C = k.id;
              if (this.toBeTiled[C] != null)
                return this.toBeTiled[C];
              var A = k.getChild();
              if (A == null)
                return this.toBeTiled[C] = !1, !1;
              for (var R = A.getNodes(), _ = 0; _ < R.length; _++) {
                var O = R[_];
                if (this.getNodeDegree(O) > 0)
                  return this.toBeTiled[C] = !1, !1;
                if (O.getChild() == null) {
                  this.toBeTiled[O.id] = !1;
                  continue;
                }
                if (!this.getToBeTiled(O))
                  return this.toBeTiled[C] = !1, !1;
              }
              return this.toBeTiled[C] = !0, !0;
            }, E.prototype.getNodeDegree = function(k) {
              k.id;
              for (var C = k.getEdges(), A = 0, R = 0; R < C.length; R++) {
                var _ = C[R];
                _.getSource().id !== _.getTarget().id && (A = A + 1);
              }
              return A;
            }, E.prototype.getNodeDegreeWithChildren = function(k) {
              var C = this.getNodeDegree(k);
              if (k.getChild() == null)
                return C;
              for (var A = k.getChild().getNodes(), R = 0; R < A.length; R++) {
                var _ = A[R];
                C += this.getNodeDegreeWithChildren(_);
              }
              return C;
            }, E.prototype.performDFSOnCompounds = function() {
              this.compoundOrder = [], this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());
            }, E.prototype.fillCompexOrderByDFS = function(k) {
              for (var C = 0; C < k.length; C++) {
                var A = k[C];
                A.getChild() != null && this.fillCompexOrderByDFS(A.getChild().getNodes()), this.getToBeTiled(A) && this.compoundOrder.push(A);
              }
            }, E.prototype.adjustLocations = function(k, C, A, R, _) {
              C += R, A += _;
              for (var O = C, P = 0; P < k.rows.length; P++) {
                var S = k.rows[P];
                C = O;
                for (var M = 0, N = 0; N < S.length; N++) {
                  var D = S[N];
                  D.rect.x = C, D.rect.y = A, C += D.rect.width + k.horizontalPadding, D.rect.height > M && (M = D.rect.height);
                }
                A += M + k.verticalPadding;
              }
            }, E.prototype.tileCompoundMembers = function(k, C) {
              var A = this;
              this.tiledMemberPack = [], Object.keys(k).forEach(function(R) {
                var _ = C[R];
                A.tiledMemberPack[R] = A.tileNodes(k[R], _.paddingLeft + _.paddingRight), _.rect.width = A.tiledMemberPack[R].width, _.rect.height = A.tiledMemberPack[R].height;
              });
            }, E.prototype.tileNodes = function(k, C) {
              var A = d.TILING_PADDING_VERTICAL, R = d.TILING_PADDING_HORIZONTAL, _ = {
                rows: [],
                rowWidth: [],
                rowHeight: [],
                width: 0,
                height: C,
                // assume minHeight equals to minWidth
                verticalPadding: A,
                horizontalPadding: R
              };
              k.sort(function(S, M) {
                return S.rect.width * S.rect.height > M.rect.width * M.rect.height ? -1 : S.rect.width * S.rect.height < M.rect.width * M.rect.height ? 1 : 0;
              });
              for (var O = 0; O < k.length; O++) {
                var P = k[O];
                _.rows.length == 0 ? this.insertNodeToRow(_, P, 0, C) : this.canAddHorizontal(_, P.rect.width, P.rect.height) ? this.insertNodeToRow(_, P, this.getShortestRowIndex(_), C) : this.insertNodeToRow(_, P, _.rows.length, C), this.shiftToLastRow(_);
              }
              return _;
            }, E.prototype.insertNodeToRow = function(k, C, A, R) {
              var _ = R;
              if (A == k.rows.length) {
                var O = [];
                k.rows.push(O), k.rowWidth.push(_), k.rowHeight.push(0);
              }
              var P = k.rowWidth[A] + C.rect.width;
              k.rows[A].length > 0 && (P += k.horizontalPadding), k.rowWidth[A] = P, k.width < P && (k.width = P);
              var S = C.rect.height;
              A > 0 && (S += k.verticalPadding);
              var M = 0;
              S > k.rowHeight[A] && (M = k.rowHeight[A], k.rowHeight[A] = S, M = k.rowHeight[A] - M), k.height += M, k.rows[A].push(C);
            }, E.prototype.getShortestRowIndex = function(k) {
              for (var C = -1, A = Number.MAX_VALUE, R = 0; R < k.rows.length; R++)
                k.rowWidth[R] < A && (C = R, A = k.rowWidth[R]);
              return C;
            }, E.prototype.getLongestRowIndex = function(k) {
              for (var C = -1, A = Number.MIN_VALUE, R = 0; R < k.rows.length; R++)
                k.rowWidth[R] > A && (C = R, A = k.rowWidth[R]);
              return C;
            }, E.prototype.canAddHorizontal = function(k, C, A) {
              var R = this.getShortestRowIndex(k);
              if (R < 0)
                return !0;
              var _ = k.rowWidth[R];
              if (_ + k.horizontalPadding + C <= k.width) return !0;
              var O = 0;
              k.rowHeight[R] < A && R > 0 && (O = A + k.verticalPadding - k.rowHeight[R]);
              var P;
              k.width - _ >= C + k.horizontalPadding ? P = (k.height + O) / (_ + C + k.horizontalPadding) : P = (k.height + O) / k.width, O = A + k.verticalPadding;
              var S;
              return k.width < C ? S = (k.height + O) / C : S = (k.height + O) / k.width, S < 1 && (S = 1 / S), P < 1 && (P = 1 / P), P < S;
            }, E.prototype.shiftToLastRow = function(k) {
              var C = this.getLongestRowIndex(k), A = k.rowWidth.length - 1, R = k.rows[C], _ = R[R.length - 1], O = _.width + k.horizontalPadding;
              if (k.width - k.rowWidth[A] > O && C != A) {
                R.splice(-1, 1), k.rows[A].push(_), k.rowWidth[C] = k.rowWidth[C] - O, k.rowWidth[A] = k.rowWidth[A] + O, k.width = k.rowWidth[instance.getLongestRowIndex(k)];
                for (var P = Number.MIN_VALUE, S = 0; S < R.length; S++)
                  R[S].height > P && (P = R[S].height);
                C > 0 && (P += k.verticalPadding);
                var M = k.rowHeight[C] + k.rowHeight[A];
                k.rowHeight[C] = P, k.rowHeight[A] < _.height + k.verticalPadding && (k.rowHeight[A] = _.height + k.verticalPadding);
                var N = k.rowHeight[C] + k.rowHeight[A];
                k.height += N - M, this.shiftToLastRow(k);
              }
            }, E.prototype.tilingPreLayout = function() {
              d.TILE && (this.groupZeroDegreeMembers(), this.clearCompounds(), this.clearZeroDegreeMembers());
            }, E.prototype.tilingPostLayout = function() {
              d.TILE && (this.repopulateZeroDegreeMembers(), this.repopulateCompounds());
            }, E.prototype.reduceTrees = function() {
              for (var k = [], C = !0, A; C; ) {
                var R = this.graphManager.getAllNodes(), _ = [];
                C = !1;
                for (var O = 0; O < R.length; O++)
                  A = R[O], A.getEdges().length == 1 && !A.getEdges()[0].isInterGraph && A.getChild() == null && (_.push([A, A.getEdges()[0], A.getOwner()]), C = !0);
                if (C == !0) {
                  for (var P = [], S = 0; S < _.length; S++)
                    _[S][0].getEdges().length == 1 && (P.push(_[S]), _[S][0].getOwner().remove(_[S][0]));
                  k.push(P), this.graphManager.resetAllNodes(), this.graphManager.resetAllEdges();
                }
              }
              this.prunedNodesAll = k;
            }, E.prototype.growTree = function(k) {
              for (var C = k.length, A = k[C - 1], R, _ = 0; _ < A.length; _++)
                R = A[_], this.findPlaceforPrunedNode(R), R[2].add(R[0]), R[2].add(R[1], R[1].source, R[1].target);
              k.splice(k.length - 1, 1), this.graphManager.resetAllNodes(), this.graphManager.resetAllEdges();
            }, E.prototype.findPlaceforPrunedNode = function(k) {
              var C, A, R = k[0];
              R == k[1].source ? A = k[1].target : A = k[1].source;
              var _ = A.startX, O = A.finishX, P = A.startY, S = A.finishY, M = 0, N = 0, D = 0, I = 0, B = [M, D, N, I];
              if (P > 0)
                for (var z = _; z <= O; z++)
                  B[0] += this.grid[z][P - 1].length + this.grid[z][P].length - 1;
              if (O < this.grid.length - 1)
                for (var z = P; z <= S; z++)
                  B[1] += this.grid[O + 1][z].length + this.grid[O][z].length - 1;
              if (S < this.grid[0].length - 1)
                for (var z = _; z <= O; z++)
                  B[2] += this.grid[z][S + 1].length + this.grid[z][S].length - 1;
              if (_ > 0)
                for (var z = P; z <= S; z++)
                  B[3] += this.grid[_ - 1][z].length + this.grid[_][z].length - 1;
              for (var F = y.MAX_VALUE, V, H, J = 0; J < B.length; J++)
                B[J] < F ? (F = B[J], V = 1, H = J) : B[J] == F && V++;
              if (V == 3 && F == 0)
                B[0] == 0 && B[1] == 0 && B[2] == 0 ? C = 1 : B[0] == 0 && B[1] == 0 && B[3] == 0 ? C = 0 : B[0] == 0 && B[2] == 0 && B[3] == 0 ? C = 3 : B[1] == 0 && B[2] == 0 && B[3] == 0 && (C = 2);
              else if (V == 2 && F == 0) {
                var q = Math.floor(Math.random() * 2);
                B[0] == 0 && B[1] == 0 ? q == 0 ? C = 0 : C = 1 : B[0] == 0 && B[2] == 0 ? q == 0 ? C = 0 : C = 2 : B[0] == 0 && B[3] == 0 ? q == 0 ? C = 0 : C = 3 : B[1] == 0 && B[2] == 0 ? q == 0 ? C = 1 : C = 2 : B[1] == 0 && B[3] == 0 ? q == 0 ? C = 1 : C = 3 : q == 0 ? C = 2 : C = 3;
              } else if (V == 4 && F == 0) {
                var q = Math.floor(Math.random() * 4);
                C = q;
              } else
                C = H;
              C == 0 ? R.setCenter(A.getCenterX(), A.getCenterY() - A.getHeight() / 2 - f.DEFAULT_EDGE_LENGTH - R.getHeight() / 2) : C == 1 ? R.setCenter(A.getCenterX() + A.getWidth() / 2 + f.DEFAULT_EDGE_LENGTH + R.getWidth() / 2, A.getCenterY()) : C == 2 ? R.setCenter(A.getCenterX(), A.getCenterY() + A.getHeight() / 2 + f.DEFAULT_EDGE_LENGTH + R.getHeight() / 2) : R.setCenter(A.getCenterX() - A.getWidth() / 2 - f.DEFAULT_EDGE_LENGTH - R.getWidth() / 2, A.getCenterY());
            }, n.exports = E;
          }),
          /* 7 */
          /***/
          (function(n, i, a) {
            var s = {};
            s.layoutBase = a(0), s.CoSEConstants = a(1), s.CoSEEdge = a(2), s.CoSEGraph = a(3), s.CoSEGraphManager = a(4), s.CoSELayout = a(6), s.CoSENode = a(5), n.exports = s;
          })
          /******/
        ])
      );
    });
  })(Wm)), Wm.exports;
}
var P5e = qm.exports, IL;
function B5e() {
  return IL || (IL = 1, (function(t, e) {
    (function(n, i) {
      t.exports = i(O5e());
    })(P5e, function(r) {
      return (
        /******/
        (function(n) {
          var i = {};
          function a(s) {
            if (i[s])
              return i[s].exports;
            var o = i[s] = {
              /******/
              i: s,
              /******/
              l: !1,
              /******/
              exports: {}
              /******/
            };
            return n[s].call(o.exports, o, o.exports, a), o.l = !0, o.exports;
          }
          return a.m = n, a.c = i, a.i = function(s) {
            return s;
          }, a.d = function(s, o, l) {
            a.o(s, o) || Object.defineProperty(s, o, {
              /******/
              configurable: !1,
              /******/
              enumerable: !0,
              /******/
              get: l
              /******/
            });
          }, a.n = function(s) {
            var o = s && s.__esModule ? (
              /******/
              function() {
                return s.default;
              }
            ) : (
              /******/
              function() {
                return s;
              }
            );
            return a.d(o, "a", o), o;
          }, a.o = function(s, o) {
            return Object.prototype.hasOwnProperty.call(s, o);
          }, a.p = "", a(a.s = 1);
        })([
          /* 0 */
          /***/
          (function(n, i) {
            n.exports = r;
          }),
          /* 1 */
          /***/
          (function(n, i, a) {
            var s = a(0).layoutBase.LayoutConstants, o = a(0).layoutBase.FDLayoutConstants, l = a(0).CoSEConstants, u = a(0).CoSELayout, h = a(0).CoSENode, d = a(0).layoutBase.PointD, f = a(0).layoutBase.DimensionD, p = {
              // Called on `layoutready`
              ready: function() {
              },
              // Called on `layoutstop`
              stop: function() {
              },
              // 'draft', 'default' or 'proof" 
              // - 'draft' fast cooling rate 
              // - 'default' moderate cooling rate 
              // - "proof" slow cooling rate
              quality: "default",
              // include labels in node dimensions
              nodeDimensionsIncludeLabels: !1,
              // number of ticks per frame; higher is faster but more jerky
              refresh: 30,
              // Whether to fit the network view after when done
              fit: !0,
              // Padding on fit
              padding: 10,
              // Whether to enable incremental mode
              randomize: !0,
              // Node repulsion (non overlapping) multiplier
              nodeRepulsion: 4500,
              // Ideal edge (non nested) length
              idealEdgeLength: 50,
              // Divisor to compute edge forces
              edgeElasticity: 0.45,
              // Nesting factor (multiplier) to compute ideal edge length for nested edges
              nestingFactor: 0.1,
              // Gravity force (constant)
              gravity: 0.25,
              // Maximum number of iterations to perform
              numIter: 2500,
              // For enabling tiling
              tile: !0,
              // Type of layout animation. The option set is {'during', 'end', false}
              animate: "end",
              // Duration for animate:end
              animationDuration: 500,
              // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)
              tilingPaddingVertical: 10,
              // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)
              tilingPaddingHorizontal: 10,
              // Gravity range (constant) for compounds
              gravityRangeCompound: 1.5,
              // Gravity force (constant) for compounds
              gravityCompound: 1,
              // Gravity range (constant)
              gravityRange: 3.8,
              // Initial cooling factor for incremental layout
              initialEnergyOnIncremental: 0.5
            };
            function g(b, w) {
              var T = {};
              for (var E in b)
                T[E] = b[E];
              for (var E in w)
                T[E] = w[E];
              return T;
            }
            function m(b) {
              this.options = g(p, b), v(this.options);
            }
            var v = function(w) {
              w.nodeRepulsion != null && (l.DEFAULT_REPULSION_STRENGTH = o.DEFAULT_REPULSION_STRENGTH = w.nodeRepulsion), w.idealEdgeLength != null && (l.DEFAULT_EDGE_LENGTH = o.DEFAULT_EDGE_LENGTH = w.idealEdgeLength), w.edgeElasticity != null && (l.DEFAULT_SPRING_STRENGTH = o.DEFAULT_SPRING_STRENGTH = w.edgeElasticity), w.nestingFactor != null && (l.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = o.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = w.nestingFactor), w.gravity != null && (l.DEFAULT_GRAVITY_STRENGTH = o.DEFAULT_GRAVITY_STRENGTH = w.gravity), w.numIter != null && (l.MAX_ITERATIONS = o.MAX_ITERATIONS = w.numIter), w.gravityRange != null && (l.DEFAULT_GRAVITY_RANGE_FACTOR = o.DEFAULT_GRAVITY_RANGE_FACTOR = w.gravityRange), w.gravityCompound != null && (l.DEFAULT_COMPOUND_GRAVITY_STRENGTH = o.DEFAULT_COMPOUND_GRAVITY_STRENGTH = w.gravityCompound), w.gravityRangeCompound != null && (l.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = o.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = w.gravityRangeCompound), w.initialEnergyOnIncremental != null && (l.DEFAULT_COOLING_FACTOR_INCREMENTAL = o.DEFAULT_COOLING_FACTOR_INCREMENTAL = w.initialEnergyOnIncremental), w.quality == "draft" ? s.QUALITY = 0 : w.quality == "proof" ? s.QUALITY = 2 : s.QUALITY = 1, l.NODE_DIMENSIONS_INCLUDE_LABELS = o.NODE_DIMENSIONS_INCLUDE_LABELS = s.NODE_DIMENSIONS_INCLUDE_LABELS = w.nodeDimensionsIncludeLabels, l.DEFAULT_INCREMENTAL = o.DEFAULT_INCREMENTAL = s.DEFAULT_INCREMENTAL = !w.randomize, l.ANIMATE = o.ANIMATE = s.ANIMATE = w.animate, l.TILE = w.tile, l.TILING_PADDING_VERTICAL = typeof w.tilingPaddingVertical == "function" ? w.tilingPaddingVertical.call() : w.tilingPaddingVertical, l.TILING_PADDING_HORIZONTAL = typeof w.tilingPaddingHorizontal == "function" ? w.tilingPaddingHorizontal.call() : w.tilingPaddingHorizontal;
            };
            m.prototype.run = function() {
              var b, w, T = this.options;
              this.idToLNode = {};
              var E = this.layout = new u(), L = this;
              L.stopped = !1, this.cy = this.options.cy, this.cy.trigger({ type: "layoutstart", layout: this });
              var k = E.newGraphManager();
              this.gm = k;
              var C = this.options.eles.nodes(), A = this.options.eles.edges();
              this.root = k.addRoot(), this.processChildrenList(this.root, this.getTopMostNodes(C), E);
              for (var R = 0; R < A.length; R++) {
                var _ = A[R], O = this.idToLNode[_.data("source")], P = this.idToLNode[_.data("target")];
                if (O !== P && O.getEdgesBetween(P).length == 0) {
                  var S = k.add(E.newEdge(), O, P);
                  S.id = _.id();
                }
              }
              var M = function(I, B) {
                typeof I == "number" && (I = B);
                var z = I.data("id"), F = L.idToLNode[z];
                return {
                  x: F.getRect().getCenterX(),
                  y: F.getRect().getCenterY()
                };
              }, N = function D() {
                for (var I = function() {
                  T.fit && T.cy.fit(T.eles, T.padding), b || (b = !0, L.cy.one("layoutready", T.ready), L.cy.trigger({ type: "layoutready", layout: L }));
                }, B = L.options.refresh, z, F = 0; F < B && !z; F++)
                  z = L.stopped || L.layout.tick();
                if (z) {
                  E.checkLayoutSuccess() && !E.isSubLayout && E.doPostLayout(), E.tilingPostLayout && E.tilingPostLayout(), E.isLayoutFinished = !0, L.options.eles.nodes().positions(M), I(), L.cy.one("layoutstop", L.options.stop), L.cy.trigger({ type: "layoutstop", layout: L }), w && cancelAnimationFrame(w), b = !1;
                  return;
                }
                var V = L.layout.getPositionsData();
                T.eles.nodes().positions(function(H, J) {
                  if (typeof H == "number" && (H = J), !H.isParent()) {
                    for (var q = H.id(), ae = V[q], re = H; ae == null && (ae = V[re.data("parent")] || V["DummyCompound_" + re.data("parent")], V[q] = ae, re = re.parent()[0], re != null); )
                      ;
                    return ae != null ? {
                      x: ae.x,
                      y: ae.y
                    } : {
                      x: H.position("x"),
                      y: H.position("y")
                    };
                  }
                }), I(), w = requestAnimationFrame(D);
              };
              return E.addListener("layoutstarted", function() {
                L.options.animate === "during" && (w = requestAnimationFrame(N));
              }), E.runLayout(), this.options.animate !== "during" && (L.options.eles.nodes().not(":parent").layoutPositions(L, L.options, M), b = !1), this;
            }, m.prototype.getTopMostNodes = function(b) {
              for (var w = {}, T = 0; T < b.length; T++)
                w[b[T].id()] = !0;
              var E = b.filter(function(L, k) {
                typeof L == "number" && (L = k);
                for (var C = L.parent()[0]; C != null; ) {
                  if (w[C.id()])
                    return !1;
                  C = C.parent()[0];
                }
                return !0;
              });
              return E;
            }, m.prototype.processChildrenList = function(b, w, T) {
              for (var E = w.length, L = 0; L < E; L++) {
                var k = w[L], C = k.children(), A, R = k.layoutDimensions({
                  nodeDimensionsIncludeLabels: this.options.nodeDimensionsIncludeLabels
                });
                if (k.outerWidth() != null && k.outerHeight() != null ? A = b.add(new h(T.graphManager, new d(k.position("x") - R.w / 2, k.position("y") - R.h / 2), new f(parseFloat(R.w), parseFloat(R.h)))) : A = b.add(new h(this.graphManager)), A.id = k.data("id"), A.paddingLeft = parseInt(k.css("padding")), A.paddingTop = parseInt(k.css("padding")), A.paddingRight = parseInt(k.css("padding")), A.paddingBottom = parseInt(k.css("padding")), this.options.nodeDimensionsIncludeLabels && k.isParent()) {
                  var _ = k.boundingBox({ includeLabels: !0, includeNodes: !1 }).w, O = k.boundingBox({ includeLabels: !0, includeNodes: !1 }).h, P = k.css("text-halign");
                  A.labelWidth = _, A.labelHeight = O, A.labelPos = P;
                }
                if (this.idToLNode[k.data("id")] = A, isNaN(A.rect.x) && (A.rect.x = 0), isNaN(A.rect.y) && (A.rect.y = 0), C != null && C.length > 0) {
                  var S;
                  S = T.getGraphManager().add(T.newGraph(), A), this.processChildrenList(S, C, T);
                }
              }
            }, m.prototype.stop = function() {
              return this.stopped = !0, this;
            };
            var y = function(w) {
              w("layout", "cose-bilkent", m);
            };
            typeof cytoscape < "u" && y(cytoscape), n.exports = y;
          })
          /******/
        ])
      );
    });
  })(qm)), qm.exports;
}
var F5e = B5e();
const $5e = /* @__PURE__ */ $u(F5e);
oo.use($5e);
function tH(t, e) {
  t.forEach((r) => {
    const n = {
      id: r.id,
      labelText: r.label,
      height: r.height,
      width: r.width,
      padding: r.padding ?? 0
    };
    Object.keys(r).forEach((i) => {
      ["id", "label", "height", "width", "padding", "x", "y"].includes(i) || (n[i] = r[i]);
    }), e.add({
      group: "nodes",
      data: n,
      position: {
        x: r.x ?? 0,
        y: r.y ?? 0
      }
    });
  });
}
x(tH, "addNodes");
function rH(t, e) {
  t.forEach((r) => {
    const n = {
      id: r.id,
      source: r.start,
      target: r.end
    };
    Object.keys(r).forEach((i) => {
      ["id", "start", "end"].includes(i) || (n[i] = r[i]);
    }), e.add({
      group: "edges",
      data: n
    });
  });
}
x(rH, "addEdges");
function nH(t) {
  return new Promise((e) => {
    const r = Qe("body").append("div").attr("id", "cy").attr("style", "display:none"), n = oo({
      container: document.getElementById("cy"),
      // container to render in
      style: [
        {
          selector: "edge",
          style: {
            "curve-style": "bezier"
          }
        }
      ]
    });
    r.remove(), tH(t.nodes, n), rH(t.edges, n), n.nodes().forEach(function(a) {
      a.layoutDimensions = () => {
        const s = a.data();
        return { w: s.width, h: s.height };
      };
    });
    const i = {
      name: "cose-bilkent",
      // @ts-ignore Types for cose-bilkent are not correct?
      quality: "proof",
      styleEnabled: !1,
      animate: !1
    };
    n.layout(i).run(), n.ready((a) => {
      ie.info("Cytoscape ready", a), e(n);
    });
  });
}
x(nH, "createCytoscapeInstance");
function iH(t) {
  return t.nodes().map((e) => {
    const r = e.data(), n = e.position(), i = {
      id: r.id,
      x: n.x,
      y: n.y
    };
    return Object.keys(r).forEach((a) => {
      a !== "id" && (i[a] = r[a]);
    }), i;
  });
}
x(iH, "extractPositionedNodes");
function aH(t) {
  return t.edges().map((e) => {
    const r = e.data(), n = e._private.rscratch, i = {
      id: r.id,
      source: r.source,
      target: r.target,
      startX: n.startX,
      startY: n.startY,
      midX: n.midX,
      midY: n.midY,
      endX: n.endX,
      endY: n.endY
    };
    return Object.keys(r).forEach((a) => {
      ["id", "source", "target"].includes(a) || (i[a] = r[a]);
    }), i;
  });
}
x(aH, "extractPositionedEdges");
async function sH(t, e) {
  ie.debug("Starting cose-bilkent layout algorithm");
  try {
    oH(t);
    const r = await nH(t), n = iH(r), i = aH(r);
    return ie.debug(`Layout completed: ${n.length} nodes, ${i.length} edges`), {
      nodes: n,
      edges: i
    };
  } catch (r) {
    throw ie.error("Error in cose-bilkent layout algorithm:", r), r;
  }
}
x(sH, "executeCoseBilkentLayout");
function oH(t) {
  if (!t)
    throw new Error("Layout data is required");
  if (!t.config)
    throw new Error("Configuration is required in layout data");
  if (!t.rootNode)
    throw new Error("Root node is required");
  if (!t.nodes || !Array.isArray(t.nodes))
    throw new Error("No nodes found in layout data");
  if (!Array.isArray(t.edges))
    throw new Error("Edges array is required in layout data");
  return !0;
}
x(oH, "validateLayoutData");
var z5e = /* @__PURE__ */ x(async (t, e, {
  insertCluster: r,
  insertEdge: n,
  insertEdgeLabel: i,
  insertMarkers: a,
  insertNode: s,
  log: o,
  positionEdgeLabel: l
}, { algorithm: u }) => {
  const h = {}, d = {}, f = e.select("g");
  a(f, t.markers, t.type, t.diagramId);
  const p = f.insert("g").attr("class", "subgraphs"), g = f.insert("g").attr("class", "edgePaths"), m = f.insert("g").attr("class", "edgeLabels"), v = f.insert("g").attr("class", "nodes");
  o.debug("Inserting nodes into DOM for dimension calculation"), await Promise.all(
    t.nodes.map(async (w) => {
      if (w.isGroup) {
        const T = { ...w };
        d[w.id] = T, h[w.id] = T, await r(p, w);
      } else {
        const T = { ...w };
        h[w.id] = T;
        const E = await s(v, w, {
          config: t.config,
          dir: t.direction || "TB"
        }), L = E.node().getBBox();
        T.width = L.width, T.height = L.height, T.domId = E, o.debug(`Node ${w.id} dimensions: ${L.width}x${L.height}`);
      }
    })
  ), o.debug("Running cose-bilkent layout algorithm");
  const y = {
    ...t,
    nodes: t.nodes.map((w) => {
      const T = h[w.id];
      return {
        ...w,
        width: T.width,
        height: T.height
      };
    })
  }, b = await sH(y, t.config);
  o.debug("Positioning nodes based on layout results"), b.nodes.forEach((w) => {
    const T = h[w.id];
    T?.domId && (T.domId.attr(
      "transform",
      `translate(${w.x}, ${w.y})`
    ), T.x = w.x, T.y = w.y, o.debug(`Positioned node ${T.id} at center (${w.x}, ${w.y})`));
  }), b.edges.forEach((w) => {
    const T = t.edges.find((E) => E.id === w.id);
    T && (T.points = [
      { x: w.startX, y: w.startY },
      { x: w.midX, y: w.midY },
      { x: w.endX, y: w.endY }
    ]);
  }), o.debug("Inserting and positioning edges"), await Promise.all(
    t.edges.map(async (w) => {
      await i(m, w);
      const T = h[w.start ?? ""], E = h[w.end ?? ""];
      if (T && E) {
        const L = b.edges.find((k) => k.id === w.id);
        if (L) {
          o.debug("APA01 positionedEdge", L);
          const k = { ...w }, C = n(
            g,
            k,
            d,
            t.type,
            T,
            E,
            t.diagramId
          );
          l(k, C);
        } else {
          const k = {
            ...w,
            points: [
              { x: T.x || 0, y: T.y || 0 },
              { x: E.x || 0, y: E.y || 0 }
            ]
          }, C = n(
            g,
            k,
            d,
            t.type,
            T,
            E,
            t.diagramId
          );
          l(k, C);
        }
      }
    })
  ), o.debug("Cose-bilkent rendering completed");
}, "render"), G5e = z5e;
const V5e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  render: G5e
}, Symbol.toStringTag, { value: "Module" }));
var Ux = /* @__PURE__ */ x((t, e) => {
  const r = t.append("rect");
  if (r.attr("x", e.x), r.attr("y", e.y), r.attr("fill", e.fill), r.attr("stroke", e.stroke), r.attr("width", e.width), r.attr("height", e.height), e.name && r.attr("name", e.name), e.rx && r.attr("rx", e.rx), e.ry && r.attr("ry", e.ry), e.attrs !== void 0)
    for (const n in e.attrs)
      r.attr(n, e.attrs[n]);
  return e.class && r.attr("class", e.class), r;
}, "drawRect"), lH = /* @__PURE__ */ x((t, e) => {
  const r = {
    x: e.startx,
    y: e.starty,
    width: e.stopx - e.startx,
    height: e.stopy - e.starty,
    fill: e.fill,
    stroke: e.stroke,
    class: "rect"
  };
  Ux(t, r).lower();
}, "drawBackgroundRect"), U5e = /* @__PURE__ */ x((t, e) => {
  const r = e.text.replace(qd, " "), n = t.append("text");
  n.attr("x", e.x), n.attr("y", e.y), n.attr("class", "legend"), n.style("text-anchor", e.anchor), e.class && n.attr("class", e.class);
  const i = n.append("tspan");
  return i.attr("x", e.x + e.textMargin * 2), i.text(r), n;
}, "drawText"), vS = /* @__PURE__ */ x((t, e, r, n) => {
  const i = t.append("image");
  i.attr("x", e), i.attr("y", r);
  const a = Uu.sanitizeUrl(n);
  i.attr("xlink:href", a);
}, "drawImage"), yS = /* @__PURE__ */ x((t, e, r, n) => {
  const i = t.append("use");
  i.attr("x", e), i.attr("y", r);
  const a = Uu.sanitizeUrl(n);
  i.attr("xlink:href", `#${a}`);
}, "drawEmbeddedImage"), Ma = /* @__PURE__ */ x(() => ({
  x: 0,
  y: 0,
  width: 100,
  height: 100,
  fill: "#EDF2AE",
  stroke: "#666",
  anchor: "start",
  rx: 0,
  ry: 0
}), "getNoteRect"), xS = /* @__PURE__ */ x(() => ({
  x: 0,
  y: 0,
  width: 100,
  height: 100,
  "text-anchor": "start",
  style: "#666",
  textMargin: 0,
  rx: 0,
  ry: 0,
  tspan: !0
}), "getTextObj"), By = (function() {
  var t = /* @__PURE__ */ x(function(Ve, ke, Oe, Se) {
    for (Oe = Oe || {}, Se = Ve.length; Se--; Oe[Ve[Se]] = ke) ;
    return Oe;
  }, "o"), e = [1, 24], r = [1, 25], n = [1, 26], i = [1, 27], a = [1, 28], s = [1, 63], o = [1, 64], l = [1, 65], u = [1, 66], h = [1, 67], d = [1, 68], f = [1, 69], p = [1, 29], g = [1, 30], m = [1, 31], v = [1, 32], y = [1, 33], b = [1, 34], w = [1, 35], T = [1, 36], E = [1, 37], L = [1, 38], k = [1, 39], C = [1, 40], A = [1, 41], R = [1, 42], _ = [1, 43], O = [1, 44], P = [1, 45], S = [1, 46], M = [1, 47], N = [1, 48], D = [1, 50], I = [1, 51], B = [1, 52], z = [1, 53], F = [1, 54], V = [1, 55], H = [1, 56], J = [1, 57], q = [1, 58], ae = [1, 59], re = [1, 60], pe = [14, 42], K = [14, 34, 36, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74], Z = [12, 14, 34, 36, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74], X = [1, 82], Y = [1, 83], ee = [1, 84], j = [1, 85], fe = [12, 14, 42], te = [12, 14, 33, 42], Ae = [12, 14, 33, 42, 76, 77, 79, 80], W = [12, 33], De = [34, 36, 37, 38, 39, 40, 41, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74], ue = {
    trace: /* @__PURE__ */ x(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, mermaidDoc: 4, direction: 5, direction_tb: 6, direction_bt: 7, direction_rl: 8, direction_lr: 9, graphConfig: 10, C4_CONTEXT: 11, NEWLINE: 12, statements: 13, EOF: 14, C4_CONTAINER: 15, C4_COMPONENT: 16, C4_DYNAMIC: 17, C4_DEPLOYMENT: 18, otherStatements: 19, diagramStatements: 20, otherStatement: 21, title: 22, accDescription: 23, acc_title: 24, acc_title_value: 25, acc_descr: 26, acc_descr_value: 27, acc_descr_multiline_value: 28, boundaryStatement: 29, boundaryStartStatement: 30, boundaryStopStatement: 31, boundaryStart: 32, LBRACE: 33, ENTERPRISE_BOUNDARY: 34, attributes: 35, SYSTEM_BOUNDARY: 36, BOUNDARY: 37, CONTAINER_BOUNDARY: 38, NODE: 39, NODE_L: 40, NODE_R: 41, RBRACE: 42, diagramStatement: 43, PERSON: 44, PERSON_EXT: 45, SYSTEM: 46, SYSTEM_DB: 47, SYSTEM_QUEUE: 48, SYSTEM_EXT: 49, SYSTEM_EXT_DB: 50, SYSTEM_EXT_QUEUE: 51, CONTAINER: 52, CONTAINER_DB: 53, CONTAINER_QUEUE: 54, CONTAINER_EXT: 55, CONTAINER_EXT_DB: 56, CONTAINER_EXT_QUEUE: 57, COMPONENT: 58, COMPONENT_DB: 59, COMPONENT_QUEUE: 60, COMPONENT_EXT: 61, COMPONENT_EXT_DB: 62, COMPONENT_EXT_QUEUE: 63, REL: 64, BIREL: 65, REL_U: 66, REL_D: 67, REL_L: 68, REL_R: 69, REL_B: 70, REL_INDEX: 71, UPDATE_EL_STYLE: 72, UPDATE_REL_STYLE: 73, UPDATE_LAYOUT_CONFIG: 74, attribute: 75, STR: 76, STR_KEY: 77, STR_VALUE: 78, ATTRIBUTE: 79, ATTRIBUTE_EMPTY: 80, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 6: "direction_tb", 7: "direction_bt", 8: "direction_rl", 9: "direction_lr", 11: "C4_CONTEXT", 12: "NEWLINE", 14: "EOF", 15: "C4_CONTAINER", 16: "C4_COMPONENT", 17: "C4_DYNAMIC", 18: "C4_DEPLOYMENT", 22: "title", 23: "accDescription", 24: "acc_title", 25: "acc_title_value", 26: "acc_descr", 27: "acc_descr_value", 28: "acc_descr_multiline_value", 33: "LBRACE", 34: "ENTERPRISE_BOUNDARY", 36: "SYSTEM_BOUNDARY", 37: "BOUNDARY", 38: "CONTAINER_BOUNDARY", 39: "NODE", 40: "NODE_L", 41: "NODE_R", 42: "RBRACE", 44: "PERSON", 45: "PERSON_EXT", 46: "SYSTEM", 47: "SYSTEM_DB", 48: "SYSTEM_QUEUE", 49: "SYSTEM_EXT", 50: "SYSTEM_EXT_DB", 51: "SYSTEM_EXT_QUEUE", 52: "CONTAINER", 53: "CONTAINER_DB", 54: "CONTAINER_QUEUE", 55: "CONTAINER_EXT", 56: "CONTAINER_EXT_DB", 57: "CONTAINER_EXT_QUEUE", 58: "COMPONENT", 59: "COMPONENT_DB", 60: "COMPONENT_QUEUE", 61: "COMPONENT_EXT", 62: "COMPONENT_EXT_DB", 63: "COMPONENT_EXT_QUEUE", 64: "REL", 65: "BIREL", 66: "REL_U", 67: "REL_D", 68: "REL_L", 69: "REL_R", 70: "REL_B", 71: "REL_INDEX", 72: "UPDATE_EL_STYLE", 73: "UPDATE_REL_STYLE", 74: "UPDATE_LAYOUT_CONFIG", 76: "STR", 77: "STR_KEY", 78: "STR_VALUE", 79: "ATTRIBUTE", 80: "ATTRIBUTE_EMPTY" },
    productions_: [0, [3, 1], [3, 1], [5, 1], [5, 1], [5, 1], [5, 1], [4, 1], [10, 4], [10, 4], [10, 4], [10, 4], [10, 4], [13, 1], [13, 1], [13, 2], [19, 1], [19, 2], [19, 3], [21, 1], [21, 1], [21, 2], [21, 2], [21, 1], [29, 3], [30, 3], [30, 3], [30, 4], [32, 2], [32, 2], [32, 2], [32, 2], [32, 2], [32, 2], [32, 2], [31, 1], [20, 1], [20, 2], [20, 3], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 1], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [35, 1], [35, 2], [75, 1], [75, 2], [75, 1], [75, 1]],
    performAction: /* @__PURE__ */ x(function(ke, Oe, Se, _e, $e, me, Ne) {
      var Q = me.length - 1;
      switch ($e) {
        case 3:
          _e.setDirection("TB");
          break;
        case 4:
          _e.setDirection("BT");
          break;
        case 5:
          _e.setDirection("RL");
          break;
        case 6:
          _e.setDirection("LR");
          break;
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
          _e.setC4Type(me[Q - 3]);
          break;
        case 19:
          _e.setTitle(me[Q].substring(6)), this.$ = me[Q].substring(6);
          break;
        case 20:
          _e.setAccDescription(me[Q].substring(15)), this.$ = me[Q].substring(15);
          break;
        case 21:
          this.$ = me[Q].trim(), _e.setTitle(this.$);
          break;
        case 22:
        case 23:
          this.$ = me[Q].trim(), _e.setAccDescription(this.$);
          break;
        case 28:
          me[Q].splice(2, 0, "ENTERPRISE"), _e.addPersonOrSystemBoundary(...me[Q]), this.$ = me[Q];
          break;
        case 29:
          me[Q].splice(2, 0, "SYSTEM"), _e.addPersonOrSystemBoundary(...me[Q]), this.$ = me[Q];
          break;
        case 30:
          _e.addPersonOrSystemBoundary(...me[Q]), this.$ = me[Q];
          break;
        case 31:
          me[Q].splice(2, 0, "CONTAINER"), _e.addContainerBoundary(...me[Q]), this.$ = me[Q];
          break;
        case 32:
          _e.addDeploymentNode("node", ...me[Q]), this.$ = me[Q];
          break;
        case 33:
          _e.addDeploymentNode("nodeL", ...me[Q]), this.$ = me[Q];
          break;
        case 34:
          _e.addDeploymentNode("nodeR", ...me[Q]), this.$ = me[Q];
          break;
        case 35:
          _e.popBoundaryParseStack();
          break;
        case 39:
          _e.addPersonOrSystem("person", ...me[Q]), this.$ = me[Q];
          break;
        case 40:
          _e.addPersonOrSystem("external_person", ...me[Q]), this.$ = me[Q];
          break;
        case 41:
          _e.addPersonOrSystem("system", ...me[Q]), this.$ = me[Q];
          break;
        case 42:
          _e.addPersonOrSystem("system_db", ...me[Q]), this.$ = me[Q];
          break;
        case 43:
          _e.addPersonOrSystem("system_queue", ...me[Q]), this.$ = me[Q];
          break;
        case 44:
          _e.addPersonOrSystem("external_system", ...me[Q]), this.$ = me[Q];
          break;
        case 45:
          _e.addPersonOrSystem("external_system_db", ...me[Q]), this.$ = me[Q];
          break;
        case 46:
          _e.addPersonOrSystem("external_system_queue", ...me[Q]), this.$ = me[Q];
          break;
        case 47:
          _e.addContainer("container", ...me[Q]), this.$ = me[Q];
          break;
        case 48:
          _e.addContainer("container_db", ...me[Q]), this.$ = me[Q];
          break;
        case 49:
          _e.addContainer("container_queue", ...me[Q]), this.$ = me[Q];
          break;
        case 50:
          _e.addContainer("external_container", ...me[Q]), this.$ = me[Q];
          break;
        case 51:
          _e.addContainer("external_container_db", ...me[Q]), this.$ = me[Q];
          break;
        case 52:
          _e.addContainer("external_container_queue", ...me[Q]), this.$ = me[Q];
          break;
        case 53:
          _e.addComponent("component", ...me[Q]), this.$ = me[Q];
          break;
        case 54:
          _e.addComponent("component_db", ...me[Q]), this.$ = me[Q];
          break;
        case 55:
          _e.addComponent("component_queue", ...me[Q]), this.$ = me[Q];
          break;
        case 56:
          _e.addComponent("external_component", ...me[Q]), this.$ = me[Q];
          break;
        case 57:
          _e.addComponent("external_component_db", ...me[Q]), this.$ = me[Q];
          break;
        case 58:
          _e.addComponent("external_component_queue", ...me[Q]), this.$ = me[Q];
          break;
        case 60:
          _e.addRel("rel", ...me[Q]), this.$ = me[Q];
          break;
        case 61:
          _e.addRel("birel", ...me[Q]), this.$ = me[Q];
          break;
        case 62:
          _e.addRel("rel_u", ...me[Q]), this.$ = me[Q];
          break;
        case 63:
          _e.addRel("rel_d", ...me[Q]), this.$ = me[Q];
          break;
        case 64:
          _e.addRel("rel_l", ...me[Q]), this.$ = me[Q];
          break;
        case 65:
          _e.addRel("rel_r", ...me[Q]), this.$ = me[Q];
          break;
        case 66:
          _e.addRel("rel_b", ...me[Q]), this.$ = me[Q];
          break;
        case 67:
          me[Q].splice(0, 1), _e.addRel("rel", ...me[Q]), this.$ = me[Q];
          break;
        case 68:
          _e.updateElStyle("update_el_style", ...me[Q]), this.$ = me[Q];
          break;
        case 69:
          _e.updateRelStyle("update_rel_style", ...me[Q]), this.$ = me[Q];
          break;
        case 70:
          _e.updateLayoutConfig("update_layout_config", ...me[Q]), this.$ = me[Q];
          break;
        case 71:
          this.$ = [me[Q]];
          break;
        case 72:
          me[Q].unshift(me[Q - 1]), this.$ = me[Q];
          break;
        case 73:
        case 75:
          this.$ = me[Q].trim();
          break;
        case 74:
          let ce = {};
          ce[me[Q - 1].trim()] = me[Q].trim(), this.$ = ce;
          break;
        case 76:
          this.$ = "";
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: 2, 5: 3, 6: [1, 5], 7: [1, 6], 8: [1, 7], 9: [1, 8], 10: 4, 11: [1, 9], 15: [1, 10], 16: [1, 11], 17: [1, 12], 18: [1, 13] }, { 1: [3] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 7] }, { 1: [2, 3] }, { 1: [2, 4] }, { 1: [2, 5] }, { 1: [2, 6] }, { 12: [1, 14] }, { 12: [1, 15] }, { 12: [1, 16] }, { 12: [1, 17] }, { 12: [1, 18] }, { 13: 19, 19: 20, 20: 21, 21: 22, 22: e, 23: r, 24: n, 26: i, 28: a, 29: 49, 30: 61, 32: 62, 34: s, 36: o, 37: l, 38: u, 39: h, 40: d, 41: f, 43: 23, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: w, 51: T, 52: E, 53: L, 54: k, 55: C, 56: A, 57: R, 58: _, 59: O, 60: P, 61: S, 62: M, 63: N, 64: D, 65: I, 66: B, 67: z, 68: F, 69: V, 70: H, 71: J, 72: q, 73: ae, 74: re }, { 13: 70, 19: 20, 20: 21, 21: 22, 22: e, 23: r, 24: n, 26: i, 28: a, 29: 49, 30: 61, 32: 62, 34: s, 36: o, 37: l, 38: u, 39: h, 40: d, 41: f, 43: 23, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: w, 51: T, 52: E, 53: L, 54: k, 55: C, 56: A, 57: R, 58: _, 59: O, 60: P, 61: S, 62: M, 63: N, 64: D, 65: I, 66: B, 67: z, 68: F, 69: V, 70: H, 71: J, 72: q, 73: ae, 74: re }, { 13: 71, 19: 20, 20: 21, 21: 22, 22: e, 23: r, 24: n, 26: i, 28: a, 29: 49, 30: 61, 32: 62, 34: s, 36: o, 37: l, 38: u, 39: h, 40: d, 41: f, 43: 23, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: w, 51: T, 52: E, 53: L, 54: k, 55: C, 56: A, 57: R, 58: _, 59: O, 60: P, 61: S, 62: M, 63: N, 64: D, 65: I, 66: B, 67: z, 68: F, 69: V, 70: H, 71: J, 72: q, 73: ae, 74: re }, { 13: 72, 19: 20, 20: 21, 21: 22, 22: e, 23: r, 24: n, 26: i, 28: a, 29: 49, 30: 61, 32: 62, 34: s, 36: o, 37: l, 38: u, 39: h, 40: d, 41: f, 43: 23, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: w, 51: T, 52: E, 53: L, 54: k, 55: C, 56: A, 57: R, 58: _, 59: O, 60: P, 61: S, 62: M, 63: N, 64: D, 65: I, 66: B, 67: z, 68: F, 69: V, 70: H, 71: J, 72: q, 73: ae, 74: re }, { 13: 73, 19: 20, 20: 21, 21: 22, 22: e, 23: r, 24: n, 26: i, 28: a, 29: 49, 30: 61, 32: 62, 34: s, 36: o, 37: l, 38: u, 39: h, 40: d, 41: f, 43: 23, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: w, 51: T, 52: E, 53: L, 54: k, 55: C, 56: A, 57: R, 58: _, 59: O, 60: P, 61: S, 62: M, 63: N, 64: D, 65: I, 66: B, 67: z, 68: F, 69: V, 70: H, 71: J, 72: q, 73: ae, 74: re }, { 14: [1, 74] }, t(pe, [2, 13], { 43: 23, 29: 49, 30: 61, 32: 62, 20: 75, 34: s, 36: o, 37: l, 38: u, 39: h, 40: d, 41: f, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: w, 51: T, 52: E, 53: L, 54: k, 55: C, 56: A, 57: R, 58: _, 59: O, 60: P, 61: S, 62: M, 63: N, 64: D, 65: I, 66: B, 67: z, 68: F, 69: V, 70: H, 71: J, 72: q, 73: ae, 74: re }), t(pe, [2, 14]), t(K, [2, 16], { 12: [1, 76] }), t(pe, [2, 36], { 12: [1, 77] }), t(Z, [2, 19]), t(Z, [2, 20]), { 25: [1, 78] }, { 27: [1, 79] }, t(Z, [2, 23]), { 35: 80, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 86, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 87, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 88, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 89, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 90, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 91, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 92, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 93, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 94, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 95, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 96, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 97, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 98, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 99, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 100, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 101, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 102, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 103, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 104, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, t(fe, [2, 59]), { 35: 105, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 106, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 107, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 108, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 109, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 110, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 111, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 112, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 113, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 114, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 115, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 20: 116, 29: 49, 30: 61, 32: 62, 34: s, 36: o, 37: l, 38: u, 39: h, 40: d, 41: f, 43: 23, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: w, 51: T, 52: E, 53: L, 54: k, 55: C, 56: A, 57: R, 58: _, 59: O, 60: P, 61: S, 62: M, 63: N, 64: D, 65: I, 66: B, 67: z, 68: F, 69: V, 70: H, 71: J, 72: q, 73: ae, 74: re }, { 12: [1, 118], 33: [1, 117] }, { 35: 119, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 120, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 121, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 122, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 123, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 124, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 35: 125, 75: 81, 76: X, 77: Y, 79: ee, 80: j }, { 14: [1, 126] }, { 14: [1, 127] }, { 14: [1, 128] }, { 14: [1, 129] }, { 1: [2, 8] }, t(pe, [2, 15]), t(K, [2, 17], { 21: 22, 19: 130, 22: e, 23: r, 24: n, 26: i, 28: a }), t(pe, [2, 37], { 19: 20, 20: 21, 21: 22, 43: 23, 29: 49, 30: 61, 32: 62, 13: 131, 22: e, 23: r, 24: n, 26: i, 28: a, 34: s, 36: o, 37: l, 38: u, 39: h, 40: d, 41: f, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: w, 51: T, 52: E, 53: L, 54: k, 55: C, 56: A, 57: R, 58: _, 59: O, 60: P, 61: S, 62: M, 63: N, 64: D, 65: I, 66: B, 67: z, 68: F, 69: V, 70: H, 71: J, 72: q, 73: ae, 74: re }), t(Z, [2, 21]), t(Z, [2, 22]), t(fe, [2, 39]), t(te, [2, 71], { 75: 81, 35: 132, 76: X, 77: Y, 79: ee, 80: j }), t(Ae, [2, 73]), { 78: [1, 133] }, t(Ae, [2, 75]), t(Ae, [2, 76]), t(fe, [2, 40]), t(fe, [2, 41]), t(fe, [2, 42]), t(fe, [2, 43]), t(fe, [2, 44]), t(fe, [2, 45]), t(fe, [2, 46]), t(fe, [2, 47]), t(fe, [2, 48]), t(fe, [2, 49]), t(fe, [2, 50]), t(fe, [2, 51]), t(fe, [2, 52]), t(fe, [2, 53]), t(fe, [2, 54]), t(fe, [2, 55]), t(fe, [2, 56]), t(fe, [2, 57]), t(fe, [2, 58]), t(fe, [2, 60]), t(fe, [2, 61]), t(fe, [2, 62]), t(fe, [2, 63]), t(fe, [2, 64]), t(fe, [2, 65]), t(fe, [2, 66]), t(fe, [2, 67]), t(fe, [2, 68]), t(fe, [2, 69]), t(fe, [2, 70]), { 31: 134, 42: [1, 135] }, { 12: [1, 136] }, { 33: [1, 137] }, t(W, [2, 28]), t(W, [2, 29]), t(W, [2, 30]), t(W, [2, 31]), t(W, [2, 32]), t(W, [2, 33]), t(W, [2, 34]), { 1: [2, 9] }, { 1: [2, 10] }, { 1: [2, 11] }, { 1: [2, 12] }, t(K, [2, 18]), t(pe, [2, 38]), t(te, [2, 72]), t(Ae, [2, 74]), t(fe, [2, 24]), t(fe, [2, 35]), t(De, [2, 25]), t(De, [2, 26], { 12: [1, 138] }), t(De, [2, 27])],
    defaultActions: { 2: [2, 1], 3: [2, 2], 4: [2, 7], 5: [2, 3], 6: [2, 4], 7: [2, 5], 8: [2, 6], 74: [2, 8], 126: [2, 9], 127: [2, 10], 128: [2, 11], 129: [2, 12] },
    parseError: /* @__PURE__ */ x(function(ke, Oe) {
      if (Oe.recoverable)
        this.trace(ke);
      else {
        var Se = new Error(ke);
        throw Se.hash = Oe, Se;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ x(function(ke) {
      var Oe = this, Se = [0], _e = [], $e = [null], me = [], Ne = this.table, Q = "", ce = 0, $ = 0, oe = 2, se = 1, ge = me.slice.call(arguments, 1), he = Object.create(this.lexer), be = { yy: {} };
      for (var Ce in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, Ce) && (be.yy[Ce] = this.yy[Ce]);
      he.setInput(ke, be.yy), be.yy.lexer = he, be.yy.parser = this, typeof he.yylloc > "u" && (he.yylloc = {});
      var Te = he.yylloc;
      me.push(Te);
      var Me = he.options && he.options.ranges;
      typeof be.yy.parseError == "function" ? this.parseError = be.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Xe(ct) {
        Se.length = Se.length - 2 * ct, $e.length = $e.length - ct, me.length = me.length - ct;
      }
      x(Xe, "popStack");
      function We() {
        var ct;
        return ct = _e.pop() || he.lex() || se, typeof ct != "number" && (ct instanceof Array && (_e = ct, ct = _e.pop()), ct = Oe.symbols_[ct] || ct), ct;
      }
      x(We, "lex");
      for (var Ke, Ze, Pe, He, ht = {}, st, Ue, Et, qe; ; ) {
        if (Ze = Se[Se.length - 1], this.defaultActions[Ze] ? Pe = this.defaultActions[Ze] : ((Ke === null || typeof Ke > "u") && (Ke = We()), Pe = Ne[Ze] && Ne[Ze][Ke]), typeof Pe > "u" || !Pe.length || !Pe[0]) {
          var rt = "";
          qe = [];
          for (st in Ne[Ze])
            this.terminals_[st] && st > oe && qe.push("'" + this.terminals_[st] + "'");
          he.showPosition ? rt = "Parse error on line " + (ce + 1) + `:
` + he.showPosition() + `
Expecting ` + qe.join(", ") + ", got '" + (this.terminals_[Ke] || Ke) + "'" : rt = "Parse error on line " + (ce + 1) + ": Unexpected " + (Ke == se ? "end of input" : "'" + (this.terminals_[Ke] || Ke) + "'"), this.parseError(rt, {
            text: he.match,
            token: this.terminals_[Ke] || Ke,
            line: he.yylineno,
            loc: Te,
            expected: qe
          });
        }
        if (Pe[0] instanceof Array && Pe.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Ze + ", token: " + Ke);
        switch (Pe[0]) {
          case 1:
            Se.push(Ke), $e.push(he.yytext), me.push(he.yylloc), Se.push(Pe[1]), Ke = null, $ = he.yyleng, Q = he.yytext, ce = he.yylineno, Te = he.yylloc;
            break;
          case 2:
            if (Ue = this.productions_[Pe[1]][1], ht.$ = $e[$e.length - Ue], ht._$ = {
              first_line: me[me.length - (Ue || 1)].first_line,
              last_line: me[me.length - 1].last_line,
              first_column: me[me.length - (Ue || 1)].first_column,
              last_column: me[me.length - 1].last_column
            }, Me && (ht._$.range = [
              me[me.length - (Ue || 1)].range[0],
              me[me.length - 1].range[1]
            ]), He = this.performAction.apply(ht, [
              Q,
              $,
              ce,
              be.yy,
              Pe[1],
              $e,
              me
            ].concat(ge)), typeof He < "u")
              return He;
            Ue && (Se = Se.slice(0, -1 * Ue * 2), $e = $e.slice(0, -1 * Ue), me = me.slice(0, -1 * Ue)), Se.push(this.productions_[Pe[1]][0]), $e.push(ht.$), me.push(ht._$), Et = Ne[Se[Se.length - 2]][Se[Se.length - 1]], Se.push(Et);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, ze = /* @__PURE__ */ (function() {
    var Ve = {
      EOF: 1,
      parseError: /* @__PURE__ */ x(function(Oe, Se) {
        if (this.yy.parser)
          this.yy.parser.parseError(Oe, Se);
        else
          throw new Error(Oe);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ x(function(ke, Oe) {
        return this.yy = Oe || this.yy || {}, this._input = ke, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ x(function() {
        var ke = this._input[0];
        this.yytext += ke, this.yyleng++, this.offset++, this.match += ke, this.matched += ke;
        var Oe = ke.match(/(?:\r\n?|\n).*/g);
        return Oe ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), ke;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ x(function(ke) {
        var Oe = ke.length, Se = ke.split(/(?:\r\n?|\n)/g);
        this._input = ke + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - Oe), this.offset -= Oe;
        var _e = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), Se.length - 1 && (this.yylineno -= Se.length - 1);
        var $e = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: Se ? (Se.length === _e.length ? this.yylloc.first_column : 0) + _e[_e.length - Se.length].length - Se[0].length : this.yylloc.first_column - Oe
        }, this.options.ranges && (this.yylloc.range = [$e[0], $e[0] + this.yyleng - Oe]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ x(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ x(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ x(function(ke) {
        this.unput(this.match.slice(ke));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ x(function() {
        var ke = this.matched.substr(0, this.matched.length - this.match.length);
        return (ke.length > 20 ? "..." : "") + ke.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ x(function() {
        var ke = this.match;
        return ke.length < 20 && (ke += this._input.substr(0, 20 - ke.length)), (ke.substr(0, 20) + (ke.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ x(function() {
        var ke = this.pastInput(), Oe = new Array(ke.length + 1).join("-");
        return ke + this.upcomingInput() + `
` + Oe + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ x(function(ke, Oe) {
        var Se, _e, $e;
        if (this.options.backtrack_lexer && ($e = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && ($e.yylloc.range = this.yylloc.range.slice(0))), _e = ke[0].match(/(?:\r\n?|\n).*/g), _e && (this.yylineno += _e.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: _e ? _e[_e.length - 1].length - _e[_e.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + ke[0].length
        }, this.yytext += ke[0], this.match += ke[0], this.matches = ke, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(ke[0].length), this.matched += ke[0], Se = this.performAction.call(this, this.yy, this, Oe, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), Se)
          return Se;
        if (this._backtrack) {
          for (var me in $e)
            this[me] = $e[me];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ x(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var ke, Oe, Se, _e;
        this._more || (this.yytext = "", this.match = "");
        for (var $e = this._currentRules(), me = 0; me < $e.length; me++)
          if (Se = this._input.match(this.rules[$e[me]]), Se && (!Oe || Se[0].length > Oe[0].length)) {
            if (Oe = Se, _e = me, this.options.backtrack_lexer) {
              if (ke = this.test_match(Se, $e[me]), ke !== !1)
                return ke;
              if (this._backtrack) {
                Oe = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return Oe ? (ke = this.test_match(Oe, $e[_e]), ke !== !1 ? ke : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ x(function() {
        var Oe = this.next();
        return Oe || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ x(function(Oe) {
        this.conditionStack.push(Oe);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ x(function() {
        var Oe = this.conditionStack.length - 1;
        return Oe > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ x(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ x(function(Oe) {
        return Oe = this.conditionStack.length - 1 - Math.abs(Oe || 0), Oe >= 0 ? this.conditionStack[Oe] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ x(function(Oe) {
        this.begin(Oe);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ x(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: {},
      performAction: /* @__PURE__ */ x(function(Oe, Se, _e, $e) {
        switch (_e) {
          case 0:
            return 6;
          case 1:
            return 7;
          case 2:
            return 8;
          case 3:
            return 9;
          case 4:
            return 22;
          case 5:
            return 23;
          case 6:
            return this.begin("acc_title"), 24;
          case 7:
            return this.popState(), "acc_title_value";
          case 8:
            return this.begin("acc_descr"), 26;
          case 9:
            return this.popState(), "acc_descr_value";
          case 10:
            this.begin("acc_descr_multiline");
            break;
          case 11:
            this.popState();
            break;
          case 12:
            return "acc_descr_multiline_value";
          case 13:
            break;
          case 14:
            c;
            break;
          case 15:
            return 12;
          case 16:
            break;
          case 17:
            return 11;
          case 18:
            return 15;
          case 19:
            return 16;
          case 20:
            return 17;
          case 21:
            return 18;
          case 22:
            return this.begin("person_ext"), 45;
          case 23:
            return this.begin("person"), 44;
          case 24:
            return this.begin("system_ext_queue"), 51;
          case 25:
            return this.begin("system_ext_db"), 50;
          case 26:
            return this.begin("system_ext"), 49;
          case 27:
            return this.begin("system_queue"), 48;
          case 28:
            return this.begin("system_db"), 47;
          case 29:
            return this.begin("system"), 46;
          case 30:
            return this.begin("boundary"), 37;
          case 31:
            return this.begin("enterprise_boundary"), 34;
          case 32:
            return this.begin("system_boundary"), 36;
          case 33:
            return this.begin("container_ext_queue"), 57;
          case 34:
            return this.begin("container_ext_db"), 56;
          case 35:
            return this.begin("container_ext"), 55;
          case 36:
            return this.begin("container_queue"), 54;
          case 37:
            return this.begin("container_db"), 53;
          case 38:
            return this.begin("container"), 52;
          case 39:
            return this.begin("container_boundary"), 38;
          case 40:
            return this.begin("component_ext_queue"), 63;
          case 41:
            return this.begin("component_ext_db"), 62;
          case 42:
            return this.begin("component_ext"), 61;
          case 43:
            return this.begin("component_queue"), 60;
          case 44:
            return this.begin("component_db"), 59;
          case 45:
            return this.begin("component"), 58;
          case 46:
            return this.begin("node"), 39;
          case 47:
            return this.begin("node"), 39;
          case 48:
            return this.begin("node_l"), 40;
          case 49:
            return this.begin("node_r"), 41;
          case 50:
            return this.begin("rel"), 64;
          case 51:
            return this.begin("birel"), 65;
          case 52:
            return this.begin("rel_u"), 66;
          case 53:
            return this.begin("rel_u"), 66;
          case 54:
            return this.begin("rel_d"), 67;
          case 55:
            return this.begin("rel_d"), 67;
          case 56:
            return this.begin("rel_l"), 68;
          case 57:
            return this.begin("rel_l"), 68;
          case 58:
            return this.begin("rel_r"), 69;
          case 59:
            return this.begin("rel_r"), 69;
          case 60:
            return this.begin("rel_b"), 70;
          case 61:
            return this.begin("rel_index"), 71;
          case 62:
            return this.begin("update_el_style"), 72;
          case 63:
            return this.begin("update_rel_style"), 73;
          case 64:
            return this.begin("update_layout_config"), 74;
          case 65:
            return "EOF_IN_STRUCT";
          case 66:
            return this.begin("attribute"), "ATTRIBUTE_EMPTY";
          case 67:
            this.begin("attribute");
            break;
          case 68:
            this.popState(), this.popState();
            break;
          case 69:
            return 80;
          case 70:
            break;
          case 71:
            return 80;
          case 72:
            this.begin("string");
            break;
          case 73:
            this.popState();
            break;
          case 74:
            return "STR";
          case 75:
            this.begin("string_kv");
            break;
          case 76:
            return this.begin("string_kv_key"), "STR_KEY";
          case 77:
            this.popState(), this.begin("string_kv_value");
            break;
          case 78:
            return "STR_VALUE";
          case 79:
            this.popState(), this.popState();
            break;
          case 80:
            return "STR";
          case 81:
            return "LBRACE";
          case 82:
            return "RBRACE";
          case 83:
            return "SPACE";
          case 84:
            return "EOL";
          case 85:
            return 14;
        }
      }, "anonymous"),
      rules: [/^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:title\s[^#\n;]+)/, /^(?:accDescription\s[^#\n;]+)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/, /^(?:%%[^\n]*(\r?\n)*)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:C4Context\b)/, /^(?:C4Container\b)/, /^(?:C4Component\b)/, /^(?:C4Dynamic\b)/, /^(?:C4Deployment\b)/, /^(?:Person_Ext\b)/, /^(?:Person\b)/, /^(?:SystemQueue_Ext\b)/, /^(?:SystemDb_Ext\b)/, /^(?:System_Ext\b)/, /^(?:SystemQueue\b)/, /^(?:SystemDb\b)/, /^(?:System\b)/, /^(?:Boundary\b)/, /^(?:Enterprise_Boundary\b)/, /^(?:System_Boundary\b)/, /^(?:ContainerQueue_Ext\b)/, /^(?:ContainerDb_Ext\b)/, /^(?:Container_Ext\b)/, /^(?:ContainerQueue\b)/, /^(?:ContainerDb\b)/, /^(?:Container\b)/, /^(?:Container_Boundary\b)/, /^(?:ComponentQueue_Ext\b)/, /^(?:ComponentDb_Ext\b)/, /^(?:Component_Ext\b)/, /^(?:ComponentQueue\b)/, /^(?:ComponentDb\b)/, /^(?:Component\b)/, /^(?:Deployment_Node\b)/, /^(?:Node\b)/, /^(?:Node_L\b)/, /^(?:Node_R\b)/, /^(?:Rel\b)/, /^(?:BiRel\b)/, /^(?:Rel_Up\b)/, /^(?:Rel_U\b)/, /^(?:Rel_Down\b)/, /^(?:Rel_D\b)/, /^(?:Rel_Left\b)/, /^(?:Rel_L\b)/, /^(?:Rel_Right\b)/, /^(?:Rel_R\b)/, /^(?:Rel_Back\b)/, /^(?:RelIndex\b)/, /^(?:UpdateElementStyle\b)/, /^(?:UpdateRelStyle\b)/, /^(?:UpdateLayoutConfig\b)/, /^(?:$)/, /^(?:[(][ ]*[,])/, /^(?:[(])/, /^(?:[)])/, /^(?:,,)/, /^(?:,)/, /^(?:[ ]*["]["])/, /^(?:[ ]*["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:[ ]*[\$])/, /^(?:[^=]*)/, /^(?:[=][ ]*["])/, /^(?:[^"]+)/, /^(?:["])/, /^(?:[^,]+)/, /^(?:\{)/, /^(?:\})/, /^(?:[\s]+)/, /^(?:[\n\r]+)/, /^(?:$)/],
      conditions: { acc_descr_multiline: { rules: [11, 12], inclusive: !1 }, acc_descr: { rules: [9], inclusive: !1 }, acc_title: { rules: [7], inclusive: !1 }, string_kv_value: { rules: [78, 79], inclusive: !1 }, string_kv_key: { rules: [77], inclusive: !1 }, string_kv: { rules: [76], inclusive: !1 }, string: { rules: [73, 74], inclusive: !1 }, attribute: { rules: [68, 69, 70, 71, 72, 75, 80], inclusive: !1 }, update_layout_config: { rules: [65, 66, 67, 68], inclusive: !1 }, update_rel_style: { rules: [65, 66, 67, 68], inclusive: !1 }, update_el_style: { rules: [65, 66, 67, 68], inclusive: !1 }, rel_b: { rules: [65, 66, 67, 68], inclusive: !1 }, rel_r: { rules: [65, 66, 67, 68], inclusive: !1 }, rel_l: { rules: [65, 66, 67, 68], inclusive: !1 }, rel_d: { rules: [65, 66, 67, 68], inclusive: !1 }, rel_u: { rules: [65, 66, 67, 68], inclusive: !1 }, rel_bi: { rules: [], inclusive: !1 }, rel: { rules: [65, 66, 67, 68], inclusive: !1 }, node_r: { rules: [65, 66, 67, 68], inclusive: !1 }, node_l: { rules: [65, 66, 67, 68], inclusive: !1 }, node: { rules: [65, 66, 67, 68], inclusive: !1 }, index: { rules: [], inclusive: !1 }, rel_index: { rules: [65, 66, 67, 68], inclusive: !1 }, component_ext_queue: { rules: [], inclusive: !1 }, component_ext_db: { rules: [65, 66, 67, 68], inclusive: !1 }, component_ext: { rules: [65, 66, 67, 68], inclusive: !1 }, component_queue: { rules: [65, 66, 67, 68], inclusive: !1 }, component_db: { rules: [65, 66, 67, 68], inclusive: !1 }, component: { rules: [65, 66, 67, 68], inclusive: !1 }, container_boundary: { rules: [65, 66, 67, 68], inclusive: !1 }, container_ext_queue: { rules: [65, 66, 67, 68], inclusive: !1 }, container_ext_db: { rules: [65, 66, 67, 68], inclusive: !1 }, container_ext: { rules: [65, 66, 67, 68], inclusive: !1 }, container_queue: { rules: [65, 66, 67, 68], inclusive: !1 }, container_db: { rules: [65, 66, 67, 68], inclusive: !1 }, container: { rules: [65, 66, 67, 68], inclusive: !1 }, birel: { rules: [65, 66, 67, 68], inclusive: !1 }, system_boundary: { rules: [65, 66, 67, 68], inclusive: !1 }, enterprise_boundary: { rules: [65, 66, 67, 68], inclusive: !1 }, boundary: { rules: [65, 66, 67, 68], inclusive: !1 }, system_ext_queue: { rules: [65, 66, 67, 68], inclusive: !1 }, system_ext_db: { rules: [65, 66, 67, 68], inclusive: !1 }, system_ext: { rules: [65, 66, 67, 68], inclusive: !1 }, system_queue: { rules: [65, 66, 67, 68], inclusive: !1 }, system_db: { rules: [65, 66, 67, 68], inclusive: !1 }, system: { rules: [65, 66, 67, 68], inclusive: !1 }, person_ext: { rules: [65, 66, 67, 68], inclusive: !1 }, person: { rules: [65, 66, 67, 68], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 8, 10, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 81, 82, 83, 84, 85], inclusive: !0 } }
    };
    return Ve;
  })();
  ue.lexer = ze;
  function Ge() {
    this.yy = {};
  }
  return x(Ge, "Parser"), Ge.prototype = ue, ue.Parser = Ge, new Ge();
})();
By.parser = By;
var H5e = By, As = [], Vl = [""], Gi = "global", ws = "", lo = [
  {
    alias: "global",
    label: { text: "global" },
    type: { text: "global" },
    tags: null,
    link: null,
    parentBoundary: ""
  }
], Up = [], bS = "", wS = !1, Fy = 4, $y = 2, cH, q5e = /* @__PURE__ */ x(function() {
  return cH;
}, "getC4Type"), W5e = /* @__PURE__ */ x(function(t) {
  cH = dr(t, we());
}, "setC4Type"), Y5e = /* @__PURE__ */ x(function(t, e, r, n, i, a, s, o, l) {
  if (t == null || e === void 0 || e === null || r === void 0 || r === null || n === void 0 || n === null)
    return;
  let u = {};
  const h = Up.find((d) => d.from === e && d.to === r);
  if (h ? u = h : Up.push(u), u.type = t, u.from = e, u.to = r, u.label = { text: n }, i == null)
    u.techn = { text: "" };
  else if (typeof i == "object") {
    let [d, f] = Object.entries(i)[0];
    u[d] = { text: f };
  } else
    u.techn = { text: i };
  if (a == null)
    u.descr = { text: "" };
  else if (typeof a == "object") {
    let [d, f] = Object.entries(a)[0];
    u[d] = { text: f };
  } else
    u.descr = { text: a };
  if (typeof s == "object") {
    let [d, f] = Object.entries(s)[0];
    u[d] = f;
  } else
    u.sprite = s;
  if (typeof o == "object") {
    let [d, f] = Object.entries(o)[0];
    u[d] = f;
  } else
    u.tags = o;
  if (typeof l == "object") {
    let [d, f] = Object.entries(l)[0];
    u[d] = f;
  } else
    u.link = l;
  u.wrap = wc();
}, "addRel"), X5e = /* @__PURE__ */ x(function(t, e, r, n, i, a, s) {
  if (e === null || r === null)
    return;
  let o = {};
  const l = As.find((u) => u.alias === e);
  if (l && e === l.alias ? o = l : (o.alias = e, As.push(o)), r == null ? o.label = { text: "" } : o.label = { text: r }, n == null)
    o.descr = { text: "" };
  else if (typeof n == "object") {
    let [u, h] = Object.entries(n)[0];
    o[u] = { text: h };
  } else
    o.descr = { text: n };
  if (typeof i == "object") {
    let [u, h] = Object.entries(i)[0];
    o[u] = h;
  } else
    o.sprite = i;
  if (typeof a == "object") {
    let [u, h] = Object.entries(a)[0];
    o[u] = h;
  } else
    o.tags = a;
  if (typeof s == "object") {
    let [u, h] = Object.entries(s)[0];
    o[u] = h;
  } else
    o.link = s;
  o.typeC4Shape = { text: t }, o.parentBoundary = Gi, o.wrap = wc();
}, "addPersonOrSystem"), j5e = /* @__PURE__ */ x(function(t, e, r, n, i, a, s, o) {
  if (e === null || r === null)
    return;
  let l = {};
  const u = As.find((h) => h.alias === e);
  if (u && e === u.alias ? l = u : (l.alias = e, As.push(l)), r == null ? l.label = { text: "" } : l.label = { text: r }, n == null)
    l.techn = { text: "" };
  else if (typeof n == "object") {
    let [h, d] = Object.entries(n)[0];
    l[h] = { text: d };
  } else
    l.techn = { text: n };
  if (i == null)
    l.descr = { text: "" };
  else if (typeof i == "object") {
    let [h, d] = Object.entries(i)[0];
    l[h] = { text: d };
  } else
    l.descr = { text: i };
  if (typeof a == "object") {
    let [h, d] = Object.entries(a)[0];
    l[h] = d;
  } else
    l.sprite = a;
  if (typeof s == "object") {
    let [h, d] = Object.entries(s)[0];
    l[h] = d;
  } else
    l.tags = s;
  if (typeof o == "object") {
    let [h, d] = Object.entries(o)[0];
    l[h] = d;
  } else
    l.link = o;
  l.wrap = wc(), l.typeC4Shape = { text: t }, l.parentBoundary = Gi;
}, "addContainer"), K5e = /* @__PURE__ */ x(function(t, e, r, n, i, a, s, o) {
  if (e === null || r === null)
    return;
  let l = {};
  const u = As.find((h) => h.alias === e);
  if (u && e === u.alias ? l = u : (l.alias = e, As.push(l)), r == null ? l.label = { text: "" } : l.label = { text: r }, n == null)
    l.techn = { text: "" };
  else if (typeof n == "object") {
    let [h, d] = Object.entries(n)[0];
    l[h] = { text: d };
  } else
    l.techn = { text: n };
  if (i == null)
    l.descr = { text: "" };
  else if (typeof i == "object") {
    let [h, d] = Object.entries(i)[0];
    l[h] = { text: d };
  } else
    l.descr = { text: i };
  if (typeof a == "object") {
    let [h, d] = Object.entries(a)[0];
    l[h] = d;
  } else
    l.sprite = a;
  if (typeof s == "object") {
    let [h, d] = Object.entries(s)[0];
    l[h] = d;
  } else
    l.tags = s;
  if (typeof o == "object") {
    let [h, d] = Object.entries(o)[0];
    l[h] = d;
  } else
    l.link = o;
  l.wrap = wc(), l.typeC4Shape = { text: t }, l.parentBoundary = Gi;
}, "addComponent"), Z5e = /* @__PURE__ */ x(function(t, e, r, n, i) {
  if (t === null || e === null)
    return;
  let a = {};
  const s = lo.find((o) => o.alias === t);
  if (s && t === s.alias ? a = s : (a.alias = t, lo.push(a)), e == null ? a.label = { text: "" } : a.label = { text: e }, r == null)
    a.type = { text: "system" };
  else if (typeof r == "object") {
    let [o, l] = Object.entries(r)[0];
    a[o] = { text: l };
  } else
    a.type = { text: r };
  if (typeof n == "object") {
    let [o, l] = Object.entries(n)[0];
    a[o] = l;
  } else
    a.tags = n;
  if (typeof i == "object") {
    let [o, l] = Object.entries(i)[0];
    a[o] = l;
  } else
    a.link = i;
  a.parentBoundary = Gi, a.wrap = wc(), ws = Gi, Gi = t, Vl.push(ws);
}, "addPersonOrSystemBoundary"), Q5e = /* @__PURE__ */ x(function(t, e, r, n, i) {
  if (t === null || e === null)
    return;
  let a = {};
  const s = lo.find((o) => o.alias === t);
  if (s && t === s.alias ? a = s : (a.alias = t, lo.push(a)), e == null ? a.label = { text: "" } : a.label = { text: e }, r == null)
    a.type = { text: "container" };
  else if (typeof r == "object") {
    let [o, l] = Object.entries(r)[0];
    a[o] = { text: l };
  } else
    a.type = { text: r };
  if (typeof n == "object") {
    let [o, l] = Object.entries(n)[0];
    a[o] = l;
  } else
    a.tags = n;
  if (typeof i == "object") {
    let [o, l] = Object.entries(i)[0];
    a[o] = l;
  } else
    a.link = i;
  a.parentBoundary = Gi, a.wrap = wc(), ws = Gi, Gi = t, Vl.push(ws);
}, "addContainerBoundary"), J5e = /* @__PURE__ */ x(function(t, e, r, n, i, a, s, o) {
  if (e === null || r === null)
    return;
  let l = {};
  const u = lo.find((h) => h.alias === e);
  if (u && e === u.alias ? l = u : (l.alias = e, lo.push(l)), r == null ? l.label = { text: "" } : l.label = { text: r }, n == null)
    l.type = { text: "node" };
  else if (typeof n == "object") {
    let [h, d] = Object.entries(n)[0];
    l[h] = { text: d };
  } else
    l.type = { text: n };
  if (i == null)
    l.descr = { text: "" };
  else if (typeof i == "object") {
    let [h, d] = Object.entries(i)[0];
    l[h] = { text: d };
  } else
    l.descr = { text: i };
  if (typeof s == "object") {
    let [h, d] = Object.entries(s)[0];
    l[h] = d;
  } else
    l.tags = s;
  if (typeof o == "object") {
    let [h, d] = Object.entries(o)[0];
    l[h] = d;
  } else
    l.link = o;
  l.nodeType = t, l.parentBoundary = Gi, l.wrap = wc(), ws = Gi, Gi = e, Vl.push(ws);
}, "addDeploymentNode"), ewe = /* @__PURE__ */ x(function() {
  Gi = ws, Vl.pop(), ws = Vl.pop(), Vl.push(ws);
}, "popBoundaryParseStack"), twe = /* @__PURE__ */ x(function(t, e, r, n, i, a, s, o, l, u, h) {
  let d = As.find((f) => f.alias === e);
  if (!(d === void 0 && (d = lo.find((f) => f.alias === e), d === void 0))) {
    if (r != null)
      if (typeof r == "object") {
        let [f, p] = Object.entries(r)[0];
        d[f] = p;
      } else
        d.bgColor = r;
    if (n != null)
      if (typeof n == "object") {
        let [f, p] = Object.entries(n)[0];
        d[f] = p;
      } else
        d.fontColor = n;
    if (i != null)
      if (typeof i == "object") {
        let [f, p] = Object.entries(i)[0];
        d[f] = p;
      } else
        d.borderColor = i;
    if (a != null)
      if (typeof a == "object") {
        let [f, p] = Object.entries(a)[0];
        d[f] = p;
      } else
        d.shadowing = a;
    if (s != null)
      if (typeof s == "object") {
        let [f, p] = Object.entries(s)[0];
        d[f] = p;
      } else
        d.shape = s;
    if (o != null)
      if (typeof o == "object") {
        let [f, p] = Object.entries(o)[0];
        d[f] = p;
      } else
        d.sprite = o;
    if (l != null)
      if (typeof l == "object") {
        let [f, p] = Object.entries(l)[0];
        d[f] = p;
      } else
        d.techn = l;
    if (u != null)
      if (typeof u == "object") {
        let [f, p] = Object.entries(u)[0];
        d[f] = p;
      } else
        d.legendText = u;
    if (h != null)
      if (typeof h == "object") {
        let [f, p] = Object.entries(h)[0];
        d[f] = p;
      } else
        d.legendSprite = h;
  }
}, "updateElStyle"), rwe = /* @__PURE__ */ x(function(t, e, r, n, i, a, s) {
  const o = Up.find((l) => l.from === e && l.to === r);
  if (o !== void 0) {
    if (n != null)
      if (typeof n == "object") {
        let [l, u] = Object.entries(n)[0];
        o[l] = u;
      } else
        o.textColor = n;
    if (i != null)
      if (typeof i == "object") {
        let [l, u] = Object.entries(i)[0];
        o[l] = u;
      } else
        o.lineColor = i;
    if (a != null)
      if (typeof a == "object") {
        let [l, u] = Object.entries(a)[0];
        o[l] = parseInt(u);
      } else
        o.offsetX = parseInt(a);
    if (s != null)
      if (typeof s == "object") {
        let [l, u] = Object.entries(s)[0];
        o[l] = parseInt(u);
      } else
        o.offsetY = parseInt(s);
  }
}, "updateRelStyle"), nwe = /* @__PURE__ */ x(function(t, e, r) {
  let n = Fy, i = $y;
  if (typeof e == "object") {
    const a = Object.values(e)[0];
    n = parseInt(a);
  } else
    n = parseInt(e);
  if (typeof r == "object") {
    const a = Object.values(r)[0];
    i = parseInt(a);
  } else
    i = parseInt(r);
  n >= 1 && (Fy = n), i >= 1 && ($y = i);
}, "updateLayoutConfig"), iwe = /* @__PURE__ */ x(function() {
  return Fy;
}, "getC4ShapeInRow"), awe = /* @__PURE__ */ x(function() {
  return $y;
}, "getC4BoundaryInRow"), swe = /* @__PURE__ */ x(function() {
  return Gi;
}, "getCurrentBoundaryParse"), owe = /* @__PURE__ */ x(function() {
  return ws;
}, "getParentBoundaryParse"), uH = /* @__PURE__ */ x(function(t) {
  return t == null ? As : As.filter((e) => e.parentBoundary === t);
}, "getC4ShapeArray"), lwe = /* @__PURE__ */ x(function(t) {
  return As.find((e) => e.alias === t);
}, "getC4Shape"), cwe = /* @__PURE__ */ x(function(t) {
  return Object.keys(uH(t));
}, "getC4ShapeKeys"), hH = /* @__PURE__ */ x(function(t) {
  return t == null ? lo : lo.filter((e) => e.parentBoundary === t);
}, "getBoundaries"), uwe = hH, hwe = /* @__PURE__ */ x(function() {
  return Up;
}, "getRels"), dwe = /* @__PURE__ */ x(function() {
  return bS;
}, "getTitle"), fwe = /* @__PURE__ */ x(function(t) {
  wS = t;
}, "setWrap"), wc = /* @__PURE__ */ x(function() {
  return wS;
}, "autoWrap"), pwe = /* @__PURE__ */ x(function() {
  As = [], lo = [
    {
      alias: "global",
      label: { text: "global" },
      type: { text: "global" },
      tags: null,
      link: null,
      parentBoundary: ""
    }
  ], ws = "", Gi = "global", Vl = [""], Up = [], Vl = [""], bS = "", wS = !1, Fy = 4, $y = 2;
}, "clear"), gwe = {
  SOLID: 0,
  DOTTED: 1,
  NOTE: 2,
  SOLID_CROSS: 3,
  DOTTED_CROSS: 4,
  SOLID_OPEN: 5,
  DOTTED_OPEN: 6,
  LOOP_START: 10,
  LOOP_END: 11,
  ALT_START: 12,
  ALT_ELSE: 13,
  ALT_END: 14,
  OPT_START: 15,
  OPT_END: 16,
  ACTIVE_START: 17,
  ACTIVE_END: 18,
  PAR_START: 19,
  PAR_AND: 20,
  PAR_END: 21,
  RECT_START: 22,
  RECT_END: 23,
  SOLID_POINT: 24,
  DOTTED_POINT: 25
}, mwe = {
  FILLED: 0,
  OPEN: 1
}, vwe = {
  LEFTOF: 0,
  RIGHTOF: 1,
  OVER: 2
}, ywe = /* @__PURE__ */ x(function(t) {
  bS = dr(t, we());
}, "setTitle"), NT = {
  addPersonOrSystem: X5e,
  addPersonOrSystemBoundary: Z5e,
  addContainer: j5e,
  addContainerBoundary: Q5e,
  addComponent: K5e,
  addDeploymentNode: J5e,
  popBoundaryParseStack: ewe,
  addRel: Y5e,
  updateElStyle: twe,
  updateRelStyle: rwe,
  updateLayoutConfig: nwe,
  autoWrap: wc,
  setWrap: fwe,
  getC4ShapeArray: uH,
  getC4Shape: lwe,
  getC4ShapeKeys: cwe,
  getBoundaries: hH,
  getBoundarys: uwe,
  getCurrentBoundaryParse: swe,
  getParentBoundaryParse: owe,
  getRels: hwe,
  getTitle: dwe,
  getC4Type: q5e,
  getC4ShapeInRow: iwe,
  getC4BoundaryInRow: awe,
  setAccTitle: Cn,
  getAccTitle: Gn,
  getAccDescription: Un,
  setAccDescription: Vn,
  getConfig: /* @__PURE__ */ x(() => we().c4, "getConfig"),
  clear: pwe,
  LINETYPE: gwe,
  ARROWTYPE: mwe,
  PLACEMENT: vwe,
  setTitle: ywe,
  setC4Type: W5e
  // apply,
}, TS = /* @__PURE__ */ x(function(t, e) {
  return Ux(t, e);
}, "drawRect"), dH = /* @__PURE__ */ x(function(t, e, r, n, i, a) {
  const s = t.append("image");
  s.attr("width", e), s.attr("height", r), s.attr("x", n), s.attr("y", i);
  let o = a.startsWith("data:image/png;base64") ? a : Uu.sanitizeUrl(a);
  s.attr("xlink:href", o);
}, "drawImage"), xwe = /* @__PURE__ */ x((t, e, r) => {
  const n = t.append("g");
  let i = 0;
  for (let a of e) {
    let s = a.textColor ? a.textColor : "#444444", o = a.lineColor ? a.lineColor : "#444444", l = a.offsetX ? parseInt(a.offsetX) : 0, u = a.offsetY ? parseInt(a.offsetY) : 0, h = "";
    if (i === 0) {
      let f = n.append("line");
      f.attr("x1", a.startPoint.x), f.attr("y1", a.startPoint.y), f.attr("x2", a.endPoint.x), f.attr("y2", a.endPoint.y), f.attr("stroke-width", "1"), f.attr("stroke", o), f.style("fill", "none"), a.type !== "rel_b" && f.attr("marker-end", "url(" + h + "#arrowhead)"), (a.type === "birel" || a.type === "rel_b") && f.attr("marker-start", "url(" + h + "#arrowend)"), i = -1;
    } else {
      let f = n.append("path");
      f.attr("fill", "none").attr("stroke-width", "1").attr("stroke", o).attr(
        "d",
        "Mstartx,starty Qcontrolx,controly stopx,stopy ".replaceAll("startx", a.startPoint.x).replaceAll("starty", a.startPoint.y).replaceAll(
          "controlx",
          a.startPoint.x + (a.endPoint.x - a.startPoint.x) / 2 - (a.endPoint.x - a.startPoint.x) / 4
        ).replaceAll("controly", a.startPoint.y + (a.endPoint.y - a.startPoint.y) / 2).replaceAll("stopx", a.endPoint.x).replaceAll("stopy", a.endPoint.y)
      ), a.type !== "rel_b" && f.attr("marker-end", "url(" + h + "#arrowhead)"), (a.type === "birel" || a.type === "rel_b") && f.attr("marker-start", "url(" + h + "#arrowend)");
    }
    let d = r.messageFont();
    Vo(r)(
      a.label.text,
      n,
      Math.min(a.startPoint.x, a.endPoint.x) + Math.abs(a.endPoint.x - a.startPoint.x) / 2 + l,
      Math.min(a.startPoint.y, a.endPoint.y) + Math.abs(a.endPoint.y - a.startPoint.y) / 2 + u,
      a.label.width,
      a.label.height,
      { fill: s },
      d
    ), a.techn && a.techn.text !== "" && (d = r.messageFont(), Vo(r)(
      "[" + a.techn.text + "]",
      n,
      Math.min(a.startPoint.x, a.endPoint.x) + Math.abs(a.endPoint.x - a.startPoint.x) / 2 + l,
      Math.min(a.startPoint.y, a.endPoint.y) + Math.abs(a.endPoint.y - a.startPoint.y) / 2 + r.messageFontSize + 5 + u,
      Math.max(a.label.width, a.techn.width),
      a.techn.height,
      { fill: s, "font-style": "italic" },
      d
    ));
  }
}, "drawRels"), bwe = /* @__PURE__ */ x(function(t, e, r) {
  const n = t.append("g");
  let i = e.bgColor ? e.bgColor : "none", a = e.borderColor ? e.borderColor : "#444444", s = e.fontColor ? e.fontColor : "black", o = { "stroke-width": 1, "stroke-dasharray": "7.0,7.0" };
  e.nodeType && (o = { "stroke-width": 1 });
  let l = {
    x: e.x,
    y: e.y,
    fill: i,
    stroke: a,
    width: e.width,
    height: e.height,
    rx: 2.5,
    ry: 2.5,
    attrs: o
  };
  TS(n, l);
  let u = r.boundaryFont();
  u.fontWeight = "bold", u.fontSize = u.fontSize + 2, u.fontColor = s, Vo(r)(
    e.label.text,
    n,
    e.x,
    e.y + e.label.Y,
    e.width,
    e.height,
    { fill: "#444444" },
    u
  ), e.type && e.type.text !== "" && (u = r.boundaryFont(), u.fontColor = s, Vo(r)(
    e.type.text,
    n,
    e.x,
    e.y + e.type.Y,
    e.width,
    e.height,
    { fill: "#444444" },
    u
  )), e.descr && e.descr.text !== "" && (u = r.boundaryFont(), u.fontSize = u.fontSize - 2, u.fontColor = s, Vo(r)(
    e.descr.text,
    n,
    e.x,
    e.y + e.descr.Y,
    e.width,
    e.height,
    { fill: "#444444" },
    u
  ));
}, "drawBoundary"), wwe = /* @__PURE__ */ x(function(t, e, r) {
  let n = e.bgColor ? e.bgColor : r[e.typeC4Shape.text + "_bg_color"], i = e.borderColor ? e.borderColor : r[e.typeC4Shape.text + "_border_color"], a = e.fontColor ? e.fontColor : "#FFFFFF", s = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
  switch (e.typeC4Shape.text) {
    case "person":
      s = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
      break;
    case "external_person":
      s = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAAB6ElEQVR4Xu2YLY+EMBCG9+dWr0aj0Wg0Go1Go0+j8Xdv2uTCvv1gpt0ebHKPuhDaeW4605Z9mJvx4AdXUyTUdd08z+u6flmWZRnHsWkafk9DptAwDPu+f0eAYtu2PEaGWuj5fCIZrBAC2eLBAnRCsEkkxmeaJp7iDJ2QMDdHsLg8SxKFEJaAo8lAXnmuOFIhTMpxxKATebo4UiFknuNo4OniSIXQyRxEA3YsnjGCVEjVXD7yLUAqxBGUyPv/Y4W2beMgGuS7kVQIBycH0fD+oi5pezQETxdHKmQKGk1eQEYldK+jw5GxPfZ9z7Mk0Qnhf1W1m3w//EUn5BDmSZsbR44QQLBEqrBHqOrmSKaQAxdnLArCrxZcM7A7ZKs4ioRq8LFC+NpC3WCBJsvpVw5edm9iEXFuyNfxXAgSwfrFQ1c0iNda8AdejvUgnktOtJQQxmcfFzGglc5WVCj7oDgFqU18boeFSs52CUh8LE8BIVQDT1ABrB0HtgSEYlX5doJnCwv9TXocKCaKbnwhdDKPq4lf3SwU3HLq4V/+WYhHVMa/3b4IlfyikAduCkcBc7mQ3/z/Qq/cTuikhkzB12Ae/mcJC9U+Vo8Ej1gWAtgbeGgFsAMHr50BIWOLCbezvhpBFUdY6EJuJ/QDW0XoMX60zZ0AAAAASUVORK5CYII=";
      break;
  }
  const o = t.append("g");
  o.attr("class", "person-man");
  const l = Ma();
  switch (e.typeC4Shape.text) {
    case "person":
    case "external_person":
    case "system":
    case "external_system":
    case "container":
    case "external_container":
    case "component":
    case "external_component":
      l.x = e.x, l.y = e.y, l.fill = n, l.width = e.width, l.height = e.height, l.stroke = i, l.rx = 2.5, l.ry = 2.5, l.attrs = { "stroke-width": 0.5 }, TS(o, l);
      break;
    case "system_db":
    case "external_system_db":
    case "container_db":
    case "external_container_db":
    case "component_db":
    case "external_component_db":
      o.append("path").attr("fill", n).attr("stroke-width", "0.5").attr("stroke", i).attr(
        "d",
        "Mstartx,startyc0,-10 half,-10 half,-10c0,0 half,0 half,10l0,heightc0,10 -half,10 -half,10c0,0 -half,0 -half,-10l0,-height".replaceAll("startx", e.x).replaceAll("starty", e.y).replaceAll("half", e.width / 2).replaceAll("height", e.height)
      ), o.append("path").attr("fill", "none").attr("stroke-width", "0.5").attr("stroke", i).attr(
        "d",
        "Mstartx,startyc0,10 half,10 half,10c0,0 half,0 half,-10".replaceAll("startx", e.x).replaceAll("starty", e.y).replaceAll("half", e.width / 2)
      );
      break;
    case "system_queue":
    case "external_system_queue":
    case "container_queue":
    case "external_container_queue":
    case "component_queue":
    case "external_component_queue":
      o.append("path").attr("fill", n).attr("stroke-width", "0.5").attr("stroke", i).attr(
        "d",
        "Mstartx,startylwidth,0c5,0 5,half 5,halfc0,0 0,half -5,halfl-width,0c-5,0 -5,-half -5,-halfc0,0 0,-half 5,-half".replaceAll("startx", e.x).replaceAll("starty", e.y).replaceAll("width", e.width).replaceAll("half", e.height / 2)
      ), o.append("path").attr("fill", "none").attr("stroke-width", "0.5").attr("stroke", i).attr(
        "d",
        "Mstartx,startyc-5,0 -5,half -5,halfc0,half 5,half 5,half".replaceAll("startx", e.x + e.width).replaceAll("starty", e.y).replaceAll("half", e.height / 2)
      );
      break;
  }
  let u = Rwe(r, e.typeC4Shape.text);
  switch (o.append("text").attr("fill", a).attr("font-family", u.fontFamily).attr("font-size", u.fontSize - 2).attr("font-style", "italic").attr("lengthAdjust", "spacing").attr("textLength", e.typeC4Shape.width).attr("x", e.x + e.width / 2 - e.typeC4Shape.width / 2).attr("y", e.y + e.typeC4Shape.Y).text("<<" + e.typeC4Shape.text + ">>"), e.typeC4Shape.text) {
    case "person":
    case "external_person":
      dH(
        o,
        48,
        48,
        e.x + e.width / 2 - 24,
        e.y + e.image.Y,
        s
      );
      break;
  }
  let h = r[e.typeC4Shape.text + "Font"]();
  return h.fontWeight = "bold", h.fontSize = h.fontSize + 2, h.fontColor = a, Vo(r)(
    e.label.text,
    o,
    e.x,
    e.y + e.label.Y,
    e.width,
    e.height,
    { fill: a },
    h
  ), h = r[e.typeC4Shape.text + "Font"](), h.fontColor = a, e.techn && e.techn?.text !== "" ? Vo(r)(
    e.techn.text,
    o,
    e.x,
    e.y + e.techn.Y,
    e.width,
    e.height,
    { fill: a, "font-style": "italic" },
    h
  ) : e.type && e.type.text !== "" && Vo(r)(
    e.type.text,
    o,
    e.x,
    e.y + e.type.Y,
    e.width,
    e.height,
    { fill: a, "font-style": "italic" },
    h
  ), e.descr && e.descr.text !== "" && (h = r.personFont(), h.fontColor = a, Vo(r)(
    e.descr.text,
    o,
    e.x,
    e.y + e.descr.Y,
    e.width,
    e.height,
    { fill: a },
    h
  )), e.height;
}, "drawC4Shape"), Twe = /* @__PURE__ */ x(function(t) {
  t.append("defs").append("symbol").attr("id", "database").attr("fill-rule", "evenodd").attr("clip-rule", "evenodd").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z"
  );
}, "insertDatabaseIcon"), Ewe = /* @__PURE__ */ x(function(t) {
  t.append("defs").append("symbol").attr("id", "computer").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z"
  );
}, "insertComputerIcon"), kwe = /* @__PURE__ */ x(function(t) {
  t.append("defs").append("symbol").attr("id", "clock").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z"
  );
}, "insertClockIcon"), Swe = /* @__PURE__ */ x(function(t) {
  t.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 9).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z");
}, "insertArrowHead"), Cwe = /* @__PURE__ */ x(function(t) {
  t.append("defs").append("marker").attr("id", "arrowend").attr("refX", 1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 10 0 L 0 5 L 10 10 z");
}, "insertArrowEnd"), Awe = /* @__PURE__ */ x(function(t) {
  t.append("defs").append("marker").attr("id", "filled-head").attr("refX", 18).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, "insertArrowFilledHead"), _we = /* @__PURE__ */ x(function(t) {
  t.append("defs").append("marker").attr("id", "sequencenumber").attr("refX", 15).attr("refY", 15).attr("markerWidth", 60).attr("markerHeight", 40).attr("orient", "auto").append("circle").attr("cx", 15).attr("cy", 15).attr("r", 6);
}, "insertDynamicNumber"), Lwe = /* @__PURE__ */ x(function(t) {
  const r = t.append("defs").append("marker").attr("id", "crosshead").attr("markerWidth", 15).attr("markerHeight", 8).attr("orient", "auto").attr("refX", 16).attr("refY", 4);
  r.append("path").attr("fill", "black").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 9,2 V 6 L16,4 Z"), r.append("path").attr("fill", "none").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 0,1 L 6,7 M 6,1 L 0,7");
}, "insertArrowCrossHead"), Rwe = /* @__PURE__ */ x((t, e) => ({
  fontFamily: t[e + "FontFamily"],
  fontSize: t[e + "FontSize"],
  fontWeight: t[e + "FontWeight"]
}), "getC4ShapeFont"), Vo = /* @__PURE__ */ (function() {
  function t(i, a, s, o, l, u, h) {
    const d = a.append("text").attr("x", s + l / 2).attr("y", o + u / 2 + 5).style("text-anchor", "middle").text(i);
    n(d, h);
  }
  x(t, "byText");
  function e(i, a, s, o, l, u, h, d) {
    const { fontSize: f, fontFamily: p, fontWeight: g } = d, m = i.split(at.lineBreakRegex);
    for (let v = 0; v < m.length; v++) {
      const y = v * f - f * (m.length - 1) / 2, b = a.append("text").attr("x", s + l / 2).attr("y", o).style("text-anchor", "middle").attr("dominant-baseline", "middle").style("font-size", f).style("font-weight", g).style("font-family", p);
      b.append("tspan").attr("dy", y).text(m[v]).attr("alignment-baseline", "mathematical"), n(b, h);
    }
  }
  x(e, "byTspan");
  function r(i, a, s, o, l, u, h, d) {
    const f = a.append("switch"), g = f.append("foreignObject").attr("x", s).attr("y", o).attr("width", l).attr("height", u).append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    g.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(i), e(i, f, s, o, l, u, h, d), n(g, h);
  }
  x(r, "byFo");
  function n(i, a) {
    for (const s in a)
      a.hasOwnProperty(s) && i.attr(s, a[s]);
  }
  return x(n, "_setTextAttrs"), function(i) {
    return i.textPlacement === "fo" ? r : i.textPlacement === "old" ? t : e;
  };
})(), Hs = {
  drawRect: TS,
  drawBoundary: bwe,
  drawC4Shape: wwe,
  drawRels: xwe,
  drawImage: dH,
  insertArrowHead: Swe,
  insertArrowEnd: Cwe,
  insertArrowFilledHead: Awe,
  insertDynamicNumber: _we,
  insertArrowCrossHead: Lwe,
  insertDatabaseIcon: Twe,
  insertComputerIcon: Ewe,
  insertClockIcon: kwe
}, zy = 0, Gy = 0, fH = 4, IT = 2;
By.yy = NT;
var Nt = {}, pH = class {
  static {
    x(this, "Bounds");
  }
  constructor(t) {
    this.name = "", this.data = {}, this.data.startx = void 0, this.data.stopx = void 0, this.data.starty = void 0, this.data.stopy = void 0, this.data.widthLimit = void 0, this.nextData = {}, this.nextData.startx = void 0, this.nextData.stopx = void 0, this.nextData.starty = void 0, this.nextData.stopy = void 0, this.nextData.cnt = 0, DT(t.db.getConfig());
  }
  setData(t, e, r, n) {
    this.nextData.startx = this.data.startx = t, this.nextData.stopx = this.data.stopx = e, this.nextData.starty = this.data.starty = r, this.nextData.stopy = this.data.stopy = n;
  }
  updateVal(t, e, r, n) {
    t[e] === void 0 ? t[e] = r : t[e] = n(r, t[e]);
  }
  insert(t) {
    this.nextData.cnt = this.nextData.cnt + 1;
    let e = this.nextData.startx === this.nextData.stopx ? this.nextData.stopx + t.margin : this.nextData.stopx + t.margin * 2, r = e + t.width, n = this.nextData.starty + t.margin * 2, i = n + t.height;
    (e >= this.data.widthLimit || r >= this.data.widthLimit || this.nextData.cnt > fH) && (e = this.nextData.startx + t.margin + Nt.nextLinePaddingX, n = this.nextData.stopy + t.margin * 2, this.nextData.stopx = r = e + t.width, this.nextData.starty = this.nextData.stopy, this.nextData.stopy = i = n + t.height, this.nextData.cnt = 1), t.x = e, t.y = n, this.updateVal(this.data, "startx", e, Math.min), this.updateVal(this.data, "starty", n, Math.min), this.updateVal(this.data, "stopx", r, Math.max), this.updateVal(this.data, "stopy", i, Math.max), this.updateVal(this.nextData, "startx", e, Math.min), this.updateVal(this.nextData, "starty", n, Math.min), this.updateVal(this.nextData, "stopx", r, Math.max), this.updateVal(this.nextData, "stopy", i, Math.max);
  }
  init(t) {
    this.name = "", this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0,
      widthLimit: void 0
    }, this.nextData = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0,
      cnt: 0
    }, DT(t.db.getConfig());
  }
  bumpLastMargin(t) {
    this.data.stopx += t, this.data.stopy += t;
  }
}, DT = /* @__PURE__ */ x(function(t) {
  mn(Nt, t), t.fontFamily && (Nt.personFontFamily = Nt.systemFontFamily = Nt.messageFontFamily = t.fontFamily), t.fontSize && (Nt.personFontSize = Nt.systemFontSize = Nt.messageFontSize = t.fontSize), t.fontWeight && (Nt.personFontWeight = Nt.systemFontWeight = Nt.messageFontWeight = t.fontWeight);
}, "setConf"), Bf = /* @__PURE__ */ x((t, e) => ({
  fontFamily: t[e + "FontFamily"],
  fontSize: t[e + "FontSize"],
  fontWeight: t[e + "FontWeight"]
}), "c4ShapeFont"), Xm = /* @__PURE__ */ x((t) => ({
  fontFamily: t.boundaryFontFamily,
  fontSize: t.boundaryFontSize,
  fontWeight: t.boundaryFontWeight
}), "boundaryFont"), Mwe = /* @__PURE__ */ x((t) => ({
  fontFamily: t.messageFontFamily,
  fontSize: t.messageFontSize,
  fontWeight: t.messageFontWeight
}), "messageFont");
function ja(t, e, r, n, i) {
  if (!e[t].width)
    if (r)
      e[t].text = dB(e[t].text, i, n), e[t].textLines = e[t].text.split(at.lineBreakRegex).length, e[t].width = i, e[t].height = ny(e[t].text, n);
    else {
      let a = e[t].text.split(at.lineBreakRegex);
      e[t].textLines = a.length;
      let s = 0;
      e[t].height = 0, e[t].width = 0;
      for (const o of a)
        e[t].width = Math.max(
          zi(o, n),
          e[t].width
        ), s = ny(o, n), e[t].height = e[t].height + s;
    }
}
x(ja, "calcC4ShapeTextWH");
var gH = /* @__PURE__ */ x(function(t, e, r) {
  e.x = r.data.startx, e.y = r.data.starty, e.width = r.data.stopx - r.data.startx, e.height = r.data.stopy - r.data.starty, e.label.y = Nt.c4ShapeMargin - 35;
  let n = e.wrap && Nt.wrap, i = Xm(Nt);
  i.fontSize = i.fontSize + 2, i.fontWeight = "bold";
  let a = zi(e.label.text, i);
  ja("label", e, n, i, a), Hs.drawBoundary(t, e, Nt);
}, "drawBoundary"), mH = /* @__PURE__ */ x(function(t, e, r, n) {
  let i = 0;
  for (const a of n) {
    i = 0;
    const s = r[a];
    let o = Bf(Nt, s.typeC4Shape.text);
    switch (o.fontSize = o.fontSize - 2, s.typeC4Shape.width = zi(
      "" + s.typeC4Shape.text + "",
      o
    ), s.typeC4Shape.height = o.fontSize + 2, s.typeC4Shape.Y = Nt.c4ShapePadding, i = s.typeC4Shape.Y + s.typeC4Shape.height - 4, s.image = { width: 0, height: 0, Y: 0 }, s.typeC4Shape.text) {
      case "person":
      case "external_person":
        s.image.width = 48, s.image.height = 48, s.image.Y = i, i = s.image.Y + s.image.height;
        break;
    }
    s.sprite && (s.image.width = 48, s.image.height = 48, s.image.Y = i, i = s.image.Y + s.image.height);
    let l = s.wrap && Nt.wrap, u = Nt.width - Nt.c4ShapePadding * 2, h = Bf(Nt, s.typeC4Shape.text);
    if (h.fontSize = h.fontSize + 2, h.fontWeight = "bold", ja("label", s, l, h, u), s.label.Y = i + 8, i = s.label.Y + s.label.height, s.type && s.type.text !== "") {
      s.type.text = "[" + s.type.text + "]";
      let p = Bf(Nt, s.typeC4Shape.text);
      ja("type", s, l, p, u), s.type.Y = i + 5, i = s.type.Y + s.type.height;
    } else if (s.techn && s.techn.text !== "") {
      s.techn.text = "[" + s.techn.text + "]";
      let p = Bf(Nt, s.techn.text);
      ja("techn", s, l, p, u), s.techn.Y = i + 5, i = s.techn.Y + s.techn.height;
    }
    let d = i, f = s.label.width;
    if (s.descr && s.descr.text !== "") {
      let p = Bf(Nt, s.typeC4Shape.text);
      ja("descr", s, l, p, u), s.descr.Y = i + 20, i = s.descr.Y + s.descr.height, f = Math.max(s.label.width, s.descr.width), d = i - s.descr.textLines * 5;
    }
    f = f + Nt.c4ShapePadding, s.width = Math.max(s.width || Nt.width, f, Nt.width), s.height = Math.max(s.height || Nt.height, d, Nt.height), s.margin = s.margin || Nt.c4ShapeMargin, t.insert(s), Hs.drawC4Shape(e, s, Nt);
  }
  t.bumpLastMargin(Nt.c4ShapeMargin);
}, "drawC4ShapeArray"), Ba = class {
  static {
    x(this, "Point");
  }
  constructor(e, r) {
    this.x = e, this.y = r;
  }
}, DL = /* @__PURE__ */ x(function(t, e) {
  let r = t.x, n = t.y, i = e.x, a = e.y, s = r + t.width / 2, o = n + t.height / 2, l = Math.abs(r - i), u = Math.abs(n - a), h = u / l, d = t.height / t.width, f = null;
  return n == a && r < i ? f = new Ba(r + t.width, o) : n == a && r > i ? f = new Ba(r, o) : r == i && n < a ? f = new Ba(s, n + t.height) : r == i && n > a && (f = new Ba(s, n)), r > i && n < a ? d >= h ? f = new Ba(r, o + h * t.width / 2) : f = new Ba(
    s - l / u * t.height / 2,
    n + t.height
  ) : r < i && n < a ? d >= h ? f = new Ba(r + t.width, o + h * t.width / 2) : f = new Ba(
    s + l / u * t.height / 2,
    n + t.height
  ) : r < i && n > a ? d >= h ? f = new Ba(r + t.width, o - h * t.width / 2) : f = new Ba(s + t.height / 2 * l / u, n) : r > i && n > a && (d >= h ? f = new Ba(r, o - t.width / 2 * h) : f = new Ba(s - t.height / 2 * l / u, n)), f;
}, "getIntersectPoint"), Nwe = /* @__PURE__ */ x(function(t, e) {
  let r = { x: 0, y: 0 };
  r.x = e.x + e.width / 2, r.y = e.y + e.height / 2;
  let n = DL(t, r);
  r.x = t.x + t.width / 2, r.y = t.y + t.height / 2;
  let i = DL(e, r);
  return { startPoint: n, endPoint: i };
}, "getIntersectPoints"), Iwe = /* @__PURE__ */ x(function(t, e, r, n) {
  let i = 0;
  for (let a of e) {
    i = i + 1;
    let s = a.wrap && Nt.wrap, o = Mwe(Nt);
    n.db.getC4Type() === "C4Dynamic" && (a.label.text = i + ": " + a.label.text);
    let u = zi(a.label.text, o);
    ja("label", a, s, o, u), a.techn && a.techn.text !== "" && (u = zi(a.techn.text, o), ja("techn", a, s, o, u)), a.descr && a.descr.text !== "" && (u = zi(a.descr.text, o), ja("descr", a, s, o, u));
    let h = r(a.from), d = r(a.to), f = Nwe(h, d);
    a.startPoint = f.startPoint, a.endPoint = f.endPoint;
  }
  Hs.drawRels(t, e, Nt);
}, "drawRels");
function ES(t, e, r, n, i) {
  let a = new pH(i);
  a.data.widthLimit = r.data.widthLimit / Math.min(IT, n.length);
  for (let [s, o] of n.entries()) {
    let l = 0;
    o.image = { width: 0, height: 0, Y: 0 }, o.sprite && (o.image.width = 48, o.image.height = 48, o.image.Y = l, l = o.image.Y + o.image.height);
    let u = o.wrap && Nt.wrap, h = Xm(Nt);
    if (h.fontSize = h.fontSize + 2, h.fontWeight = "bold", ja(
      "label",
      o,
      u,
      h,
      a.data.widthLimit
    ), o.label.Y = l + 8, l = o.label.Y + o.label.height, o.type && o.type.text !== "") {
      o.type.text = "[" + o.type.text + "]";
      let g = Xm(Nt);
      ja(
        "type",
        o,
        u,
        g,
        a.data.widthLimit
      ), o.type.Y = l + 5, l = o.type.Y + o.type.height;
    }
    if (o.descr && o.descr.text !== "") {
      let g = Xm(Nt);
      g.fontSize = g.fontSize - 2, ja(
        "descr",
        o,
        u,
        g,
        a.data.widthLimit
      ), o.descr.Y = l + 20, l = o.descr.Y + o.descr.height;
    }
    if (s == 0 || s % IT === 0) {
      let g = r.data.startx + Nt.diagramMarginX, m = r.data.stopy + Nt.diagramMarginY + l;
      a.setData(g, g, m, m);
    } else {
      let g = a.data.stopx !== a.data.startx ? a.data.stopx + Nt.diagramMarginX : a.data.startx, m = a.data.starty;
      a.setData(g, g, m, m);
    }
    a.name = o.alias;
    let d = i.db.getC4ShapeArray(o.alias), f = i.db.getC4ShapeKeys(o.alias);
    f.length > 0 && mH(
      a,
      t,
      d,
      f
    ), e = o.alias;
    let p = i.db.getBoundaries(e);
    p.length > 0 && ES(
      t,
      e,
      a,
      p,
      i
    ), o.alias !== "global" && gH(t, o, a), r.data.stopy = Math.max(
      a.data.stopy + Nt.c4ShapeMargin,
      r.data.stopy
    ), r.data.stopx = Math.max(
      a.data.stopx + Nt.c4ShapeMargin,
      r.data.stopx
    ), zy = Math.max(zy, r.data.stopx), Gy = Math.max(Gy, r.data.stopy);
  }
}
x(ES, "drawInsideBoundary");
var Dwe = /* @__PURE__ */ x(function(t, e, r, n) {
  Nt = we().c4;
  const i = we().securityLevel;
  let a;
  i === "sandbox" && (a = Qe("#i" + e));
  const s = Qe(i === "sandbox" ? a.nodes()[0].contentDocument.body : "body");
  let o = n.db;
  n.db.setWrap(Nt.wrap), fH = o.getC4ShapeInRow(), IT = o.getC4BoundaryInRow(), ie.debug(`C:${JSON.stringify(Nt, null, 2)}`);
  const l = i === "sandbox" ? s.select(`[id="${e}"]`) : Qe(`[id="${e}"]`);
  Hs.insertComputerIcon(l), Hs.insertDatabaseIcon(l), Hs.insertClockIcon(l);
  let u = new pH(n);
  u.setData(
    Nt.diagramMarginX,
    Nt.diagramMarginX,
    Nt.diagramMarginY,
    Nt.diagramMarginY
  ), u.data.widthLimit = screen.availWidth, zy = Nt.diagramMarginX, Gy = Nt.diagramMarginY;
  const h = n.db.getTitle();
  let d = n.db.getBoundaries("");
  ES(l, "", u, d, n), Hs.insertArrowHead(l), Hs.insertArrowEnd(l), Hs.insertArrowCrossHead(l), Hs.insertArrowFilledHead(l), Iwe(l, n.db.getRels(), n.db.getC4Shape, n), u.data.stopx = zy, u.data.stopy = Gy;
  const f = u.data;
  let g = f.stopy - f.starty + 2 * Nt.diagramMarginY;
  const v = f.stopx - f.startx + 2 * Nt.diagramMarginX;
  h && l.append("text").text(h).attr("x", (f.stopx - f.startx) / 2 - 4 * Nt.diagramMarginX).attr("y", f.starty + Nt.diagramMarginY), Xi(l, g, v, Nt.useMaxWidth);
  const y = h ? 60 : 0;
  l.attr(
    "viewBox",
    f.startx - Nt.diagramMarginX + " -" + (Nt.diagramMarginY + y) + " " + v + " " + (g + y)
  ), ie.debug("models:", f);
}, "draw"), OL = {
  drawPersonOrSystemArray: mH,
  drawBoundary: gH,
  setConf: DT,
  draw: Dwe
}, Owe = /* @__PURE__ */ x((t) => `.person {
    stroke: ${t.personBorder};
    fill: ${t.personBkg};
  }
`, "getStyles"), Pwe = Owe, Bwe = {
  parser: H5e,
  db: NT,
  renderer: OL,
  styles: Pwe,
  init: /* @__PURE__ */ x(({ c4: t, wrap: e }) => {
    OL.setConf(t), NT.setWrap(e);
  }, "init")
};
const Fwe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: Bwe
}, Symbol.toStringTag, { value: "Module" }));
var Dg = /* @__PURE__ */ x(() => `
  /* Font Awesome icon styling - consolidated */
  .label-icon {
    display: inline-block;
    height: 1em;
    overflow: visible;
    vertical-align: -0.125em;
  }
  
  .node .label-icon path {
    fill: currentColor;
    stroke: revert;
    stroke-width: revert;
  }
`, "getIconStyles"), lf = /* @__PURE__ */ x((t, e) => {
  let r;
  return e === "sandbox" && (r = Qe("#i" + t)), Qe(e === "sandbox" ? r.nodes()[0].contentDocument.body : "body").select(`[id="${t}"]`);
}, "getDiagramElement"), rh = /* @__PURE__ */ x((t, e, r, n) => {
  t.attr("class", r);
  const { width: i, height: a, x: s, y: o } = $we(t, e);
  Xi(t, a, i, n);
  const l = zwe(s, o, i, a, e);
  t.attr("viewBox", l), ie.debug(`viewBox configured: ${l} with padding: ${e}`);
}, "setupViewPortForSVG"), $we = /* @__PURE__ */ x((t, e) => {
  const r = t.node()?.getBBox() || { width: 0, height: 0, x: 0, y: 0 };
  return {
    width: r.width + e * 2,
    height: r.height + e * 2,
    x: r.x,
    y: r.y
  };
}, "calculateDimensionsWithPadding"), zwe = /* @__PURE__ */ x((t, e, r, n, i) => `${t - i} ${e - i} ${r} ${n}`, "createViewBox"), Gwe = "flowchart-", Vwe = class {
  // cspell:ignore funs
  constructor() {
    this.vertexCounter = 0, this.config = we(), this.vertices = /* @__PURE__ */ new Map(), this.edges = [], this.classes = /* @__PURE__ */ new Map(), this.subGraphs = [], this.subGraphLookup = /* @__PURE__ */ new Map(), this.tooltips = /* @__PURE__ */ new Map(), this.subCount = 0, this.firstGraphFlag = !0, this.secCount = -1, this.posCrossRef = [], this.funs = [], this.setAccTitle = Cn, this.setAccDescription = Vn, this.setDiagramTitle = Zn, this.getAccTitle = Gn, this.getAccDescription = Un, this.getDiagramTitle = Ln, this.funs.push(this.setupToolTips.bind(this)), this.addVertex = this.addVertex.bind(this), this.firstGraph = this.firstGraph.bind(this), this.setDirection = this.setDirection.bind(this), this.addSubGraph = this.addSubGraph.bind(this), this.addLink = this.addLink.bind(this), this.setLink = this.setLink.bind(this), this.updateLink = this.updateLink.bind(this), this.addClass = this.addClass.bind(this), this.setClass = this.setClass.bind(this), this.destructLink = this.destructLink.bind(this), this.setClickEvent = this.setClickEvent.bind(this), this.setTooltip = this.setTooltip.bind(this), this.updateLinkInterpolate = this.updateLinkInterpolate.bind(this), this.setClickFun = this.setClickFun.bind(this), this.bindFunctions = this.bindFunctions.bind(this), this.lex = {
      firstGraph: this.firstGraph.bind(this)
    }, this.clear(), this.setGen("gen-2");
  }
  static {
    x(this, "FlowDB");
  }
  sanitizeText(t) {
    return at.sanitizeText(t, this.config);
  }
  /**
   * Function to lookup domId from id in the graph definition.
   *
   * @param id - id of the node
   */
  lookUpDomId(t) {
    for (const e of this.vertices.values())
      if (e.id === t)
        return e.domId;
    return t;
  }
  /**
   * Function called by parser when a node definition has been found
   */
  addVertex(t, e, r, n, i, a, s = {}, o) {
    if (!t || t.trim().length === 0)
      return;
    let l;
    if (o !== void 0) {
      let f;
      o.includes(`
`) ? f = o + `
` : f = `{
` + o + `
}`, l = q2(f, { schema: H2 });
    }
    const u = this.edges.find((f) => f.id === t);
    if (u) {
      const f = l;
      f?.animate !== void 0 && (u.animate = f.animate), f?.animation !== void 0 && (u.animation = f.animation), f?.curve !== void 0 && (u.interpolate = f.curve);
      return;
    }
    let h, d = this.vertices.get(t);
    if (d === void 0 && (d = {
      id: t,
      labelType: "text",
      domId: Gwe + t + "-" + this.vertexCounter,
      styles: [],
      classes: []
    }, this.vertices.set(t, d)), this.vertexCounter++, e !== void 0 ? (this.config = we(), h = this.sanitizeText(e.text.trim()), d.labelType = e.type, h.startsWith('"') && h.endsWith('"') && (h = h.substring(1, h.length - 1)), d.text = h) : d.text === void 0 && (d.text = t), r !== void 0 && (d.type = r), n?.forEach((f) => {
      d.styles.push(f);
    }), i?.forEach((f) => {
      d.classes.push(f);
    }), a !== void 0 && (d.dir = a), d.props === void 0 ? d.props = s : s !== void 0 && Object.assign(d.props, s), l !== void 0) {
      if (l.shape) {
        if (l.shape !== l.shape.toLowerCase() || l.shape.includes("_"))
          throw new Error(`No such shape: ${l.shape}. Shape names should be lowercase.`);
        if (!p$(l.shape))
          throw new Error(`No such shape: ${l.shape}.`);
        d.type = l?.shape;
      }
      l?.label && (d.text = l?.label), l?.icon && (d.icon = l?.icon, !l.label?.trim() && d.text === t && (d.text = "")), l?.form && (d.form = l?.form), l?.pos && (d.pos = l?.pos), l?.img && (d.img = l?.img, !l.label?.trim() && d.text === t && (d.text = "")), l?.constraint && (d.constraint = l.constraint), l.w && (d.assetWidth = Number(l.w)), l.h && (d.assetHeight = Number(l.h));
    }
  }
  /**
   * Function called by parser when a link/edge definition has been found
   *
   */
  addSingleLink(t, e, r, n) {
    const s = {
      start: t,
      end: e,
      type: void 0,
      text: "",
      labelType: "text",
      classes: [],
      isUserDefinedId: !1,
      interpolate: this.edges.defaultInterpolate
    };
    ie.info("abc78 Got edge...", s);
    const o = r.text;
    if (o !== void 0 && (s.text = this.sanitizeText(o.text.trim()), s.text.startsWith('"') && s.text.endsWith('"') && (s.text = s.text.substring(1, s.text.length - 1)), s.labelType = o.type), r !== void 0 && (s.type = r.type, s.stroke = r.stroke, s.length = r.length > 10 ? 10 : r.length), n && !this.edges.some((l) => l.id === n))
      s.id = n, s.isUserDefinedId = !0;
    else {
      const l = this.edges.filter((u) => u.start === s.start && u.end === s.end);
      l.length === 0 ? s.id = Kh(s.start, s.end, { counter: 0, prefix: "L" }) : s.id = Kh(s.start, s.end, {
        counter: l.length + 1,
        prefix: "L"
      });
    }
    if (this.edges.length < (this.config.maxEdges ?? 500))
      ie.info("Pushing edge..."), this.edges.push(s);
    else
      throw new Error(
        `Edge limit exceeded. ${this.edges.length} edges found, but the limit is ${this.config.maxEdges}.

Initialize mermaid with maxEdges set to a higher number to allow more edges.
You cannot set this config via configuration inside the diagram as it is a secure config.
You have to call mermaid.initialize.`
      );
  }
  isLinkData(t) {
    return t !== null && typeof t == "object" && "id" in t && typeof t.id == "string";
  }
  addLink(t, e, r) {
    const n = this.isLinkData(r) ? r.id.replace("@", "") : void 0;
    ie.info("addLink", t, e, n);
    for (const i of t)
      for (const a of e) {
        const s = i === t[t.length - 1], o = a === e[0];
        s && o ? this.addSingleLink(i, a, r, n) : this.addSingleLink(i, a, r, void 0);
      }
  }
  /**
   * Updates a link's line interpolation algorithm
   */
  updateLinkInterpolate(t, e) {
    t.forEach((r) => {
      r === "default" ? this.edges.defaultInterpolate = e : this.edges[r].interpolate = e;
    });
  }
  /**
   * Updates a link with a style
   *
   */
  updateLink(t, e) {
    t.forEach((r) => {
      if (typeof r == "number" && r >= this.edges.length)
        throw new Error(
          `The index ${r} for linkStyle is out of bounds. Valid indices for linkStyle are between 0 and ${this.edges.length - 1}. (Help: Ensure that the index is within the range of existing edges.)`
        );
      r === "default" ? this.edges.defaultStyle = e : (this.edges[r].style = e, (this.edges[r]?.style?.length ?? 0) > 0 && !this.edges[r]?.style?.some((n) => n?.startsWith("fill")) && this.edges[r]?.style?.push("fill:none"));
    });
  }
  addClass(t, e) {
    const r = e.join().replace(/\\,/g, "").replace(/,/g, ";").replace(//g, ",").split(";");
    t.split(",").forEach((n) => {
      let i = this.classes.get(n);
      i === void 0 && (i = { id: n, styles: [], textStyles: [] }, this.classes.set(n, i)), r?.forEach((a) => {
        if (/color/.exec(a)) {
          const s = a.replace("fill", "bgFill");
          i.textStyles.push(s);
        }
        i.styles.push(a);
      });
    });
  }
  /**
   * Called by parser when a graph definition is found, stores the direction of the chart.
   *
   */
  setDirection(t) {
    this.direction = t.trim(), /.*</.exec(this.direction) && (this.direction = "RL"), /.*\^/.exec(this.direction) && (this.direction = "BT"), /.*>/.exec(this.direction) && (this.direction = "LR"), /.*v/.exec(this.direction) && (this.direction = "TB"), this.direction === "TD" && (this.direction = "TB");
  }
  /**
   * Called by parser when a special node is found, e.g. a clickable element.
   *
   * @param ids - Comma separated list of ids
   * @param className - Class to add
   */
  setClass(t, e) {
    for (const r of t.split(",")) {
      const n = this.vertices.get(r);
      n && n.classes.push(e);
      const i = this.edges.find((s) => s.id === r);
      i && i.classes.push(e);
      const a = this.subGraphLookup.get(r);
      a && a.classes.push(e);
    }
  }
  setTooltip(t, e) {
    if (e !== void 0) {
      e = this.sanitizeText(e);
      for (const r of t.split(","))
        this.tooltips.set(this.version === "gen-1" ? this.lookUpDomId(r) : r, e);
    }
  }
  setClickFun(t, e, r) {
    const n = this.lookUpDomId(t);
    if (we().securityLevel !== "loose" || e === void 0)
      return;
    let i = [];
    if (typeof r == "string") {
      i = r.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
      for (let s = 0; s < i.length; s++) {
        let o = i[s].trim();
        o.startsWith('"') && o.endsWith('"') && (o = o.substr(1, o.length - 2)), i[s] = o;
      }
    }
    i.length === 0 && i.push(t);
    const a = this.vertices.get(t);
    a && (a.haveCallback = !0, this.funs.push(() => {
      const s = document.querySelector(`[id="${n}"]`);
      s !== null && s.addEventListener(
        "click",
        () => {
          Zt.runFunc(e, ...i);
        },
        !1
      );
    }));
  }
  /**
   * Called by parser when a link is found. Adds the URL to the vertex data.
   *
   * @param ids - Comma separated list of ids
   * @param linkStr - URL to create a link for
   * @param target - Target attribute for the link
   */
  setLink(t, e, r) {
    t.split(",").forEach((n) => {
      const i = this.vertices.get(n);
      i !== void 0 && (i.link = Zt.formatUrl(e, this.config), i.linkTarget = r);
    }), this.setClass(t, "clickable");
  }
  getTooltip(t) {
    return this.tooltips.get(t);
  }
  /**
   * Called by parser when a click definition is found. Registers an event handler.
   *
   * @param ids - Comma separated list of ids
   * @param functionName - Function to be called on click
   * @param functionArgs - Arguments to be passed to the function
   */
  setClickEvent(t, e, r) {
    t.split(",").forEach((n) => {
      this.setClickFun(n, e, r);
    }), this.setClass(t, "clickable");
  }
  bindFunctions(t) {
    this.funs.forEach((e) => {
      e(t);
    });
  }
  getDirection() {
    return this.direction?.trim();
  }
  /**
   * Retrieval function for fetching the found nodes after parsing has completed.
   *
   */
  getVertices() {
    return this.vertices;
  }
  /**
   * Retrieval function for fetching the found links after parsing has completed.
   *
   */
  getEdges() {
    return this.edges;
  }
  /**
   * Retrieval function for fetching the found class definitions after parsing has completed.
   *
   */
  getClasses() {
    return this.classes;
  }
  setupToolTips(t) {
    let e = Qe(".mermaidTooltip");
    (e._groups || e)[0][0] === null && (e = Qe("body").append("div").attr("class", "mermaidTooltip").style("opacity", 0)), Qe(t).select("svg").selectAll("g.node").on("mouseover", (i) => {
      const a = Qe(i.currentTarget);
      if (a.attr("title") === null)
        return;
      const o = i.currentTarget?.getBoundingClientRect();
      e.transition().duration(200).style("opacity", ".9"), e.text(a.attr("title")).style("left", window.scrollX + o.left + (o.right - o.left) / 2 + "px").style("top", window.scrollY + o.bottom + "px"), e.html(e.html().replace(/&lt;br\/&gt;/g, "<br/>")), a.classed("hover", !0);
    }).on("mouseout", (i) => {
      e.transition().duration(500).style("opacity", 0), Qe(i.currentTarget).classed("hover", !1);
    });
  }
  /**
   * Clears the internal graph db so that a new graph can be parsed.
   *
   */
  clear(t = "gen-2") {
    this.vertices = /* @__PURE__ */ new Map(), this.classes = /* @__PURE__ */ new Map(), this.edges = [], this.funs = [this.setupToolTips.bind(this)], this.subGraphs = [], this.subGraphLookup = /* @__PURE__ */ new Map(), this.subCount = 0, this.tooltips = /* @__PURE__ */ new Map(), this.firstGraphFlag = !0, this.version = t, this.config = we(), _n();
  }
  setGen(t) {
    this.version = t || "gen-2";
  }
  defaultStyle() {
    return "fill:#ffa;stroke: #f66; stroke-width: 3px; stroke-dasharray: 5, 5;fill:#ffa;stroke: #666;";
  }
  addSubGraph(t, e, r) {
    let n = t.text.trim(), i = r.text;
    t === r && /\s/.exec(r.text) && (n = void 0);
    const s = (/* @__PURE__ */ x((d) => {
      const f = { boolean: {}, number: {}, string: {} }, p = [];
      let g;
      return { nodeList: d.filter(function(v) {
        const y = typeof v;
        return v.stmt && v.stmt === "dir" ? (g = v.value, !1) : v.trim() === "" ? !1 : y in f ? f[y].hasOwnProperty(v) ? !1 : f[y][v] = !0 : p.includes(v) ? !1 : p.push(v);
      }), dir: g };
    }, "uniq"))(e.flat()), o = s.nodeList;
    let l = s.dir;
    const u = we().flowchart ?? {};
    if (l = l ?? (u.inheritDir ? this.getDirection() ?? we().direction ?? void 0 : void 0), this.version === "gen-1")
      for (let d = 0; d < o.length; d++)
        o[d] = this.lookUpDomId(o[d]);
    n = n ?? "subGraph" + this.subCount, i = i || "", i = this.sanitizeText(i), this.subCount = this.subCount + 1;
    const h = {
      id: n,
      nodes: o,
      title: i.trim(),
      classes: [],
      dir: l,
      labelType: r.type
    };
    return ie.info("Adding", h.id, h.nodes, h.dir), h.nodes = this.makeUniq(h, this.subGraphs).nodes, this.subGraphs.push(h), this.subGraphLookup.set(n, h), n;
  }
  getPosForId(t) {
    for (const [e, r] of this.subGraphs.entries())
      if (r.id === t)
        return e;
    return -1;
  }
  indexNodes2(t, e) {
    const r = this.subGraphs[e].nodes;
    if (this.secCount = this.secCount + 1, this.secCount > 2e3)
      return {
        result: !1,
        count: 0
      };
    if (this.posCrossRef[this.secCount] = e, this.subGraphs[e].id === t)
      return {
        result: !0,
        count: 0
      };
    let n = 0, i = 1;
    for (; n < r.length; ) {
      const a = this.getPosForId(r[n]);
      if (a >= 0) {
        const s = this.indexNodes2(t, a);
        if (s.result)
          return {
            result: !0,
            count: i + s.count
          };
        i = i + s.count;
      }
      n = n + 1;
    }
    return {
      result: !1,
      count: i
    };
  }
  getDepthFirstPos(t) {
    return this.posCrossRef[t];
  }
  indexNodes() {
    this.secCount = -1, this.subGraphs.length > 0 && this.indexNodes2("none", this.subGraphs.length - 1);
  }
  getSubGraphs() {
    return this.subGraphs;
  }
  firstGraph() {
    return this.firstGraphFlag ? (this.firstGraphFlag = !1, !0) : !1;
  }
  destructStartLink(t) {
    let e = t.trim(), r = "arrow_open";
    switch (e[0]) {
      case "<":
        r = "arrow_point", e = e.slice(1);
        break;
      case "x":
        r = "arrow_cross", e = e.slice(1);
        break;
      case "o":
        r = "arrow_circle", e = e.slice(1);
        break;
    }
    let n = "normal";
    return e.includes("=") && (n = "thick"), e.includes(".") && (n = "dotted"), { type: r, stroke: n };
  }
  countChar(t, e) {
    const r = e.length;
    let n = 0;
    for (let i = 0; i < r; ++i)
      e[i] === t && ++n;
    return n;
  }
  destructEndLink(t) {
    const e = t.trim();
    let r = e.slice(0, -1), n = "arrow_open";
    switch (e.slice(-1)) {
      case "x":
        n = "arrow_cross", e.startsWith("x") && (n = "double_" + n, r = r.slice(1));
        break;
      case ">":
        n = "arrow_point", e.startsWith("<") && (n = "double_" + n, r = r.slice(1));
        break;
      case "o":
        n = "arrow_circle", e.startsWith("o") && (n = "double_" + n, r = r.slice(1));
        break;
    }
    let i = "normal", a = r.length - 1;
    r.startsWith("=") && (i = "thick"), r.startsWith("~") && (i = "invisible");
    const s = this.countChar(".", r);
    return s && (i = "dotted", a = s), { type: n, stroke: i, length: a };
  }
  destructLink(t, e) {
    const r = this.destructEndLink(t);
    let n;
    if (e) {
      if (n = this.destructStartLink(e), n.stroke !== r.stroke)
        return { type: "INVALID", stroke: "INVALID" };
      if (n.type === "arrow_open")
        n.type = r.type;
      else {
        if (n.type !== r.type)
          return { type: "INVALID", stroke: "INVALID" };
        n.type = "double_" + n.type;
      }
      return n.type === "double_arrow" && (n.type = "double_arrow_point"), n.length = r.length, n;
    }
    return r;
  }
  // Todo optimizer this by caching existing nodes
  exists(t, e) {
    for (const r of t)
      if (r.nodes.includes(e))
        return !0;
    return !1;
  }
  /**
   * Deletes an id from all subgraphs
   *
   */
  makeUniq(t, e) {
    const r = [];
    return t.nodes.forEach((n, i) => {
      this.exists(e, n) || r.push(t.nodes[i]);
    }), { nodes: r };
  }
  getTypeFromVertex(t) {
    if (t.img)
      return "imageSquare";
    if (t.icon)
      return t.form === "circle" ? "iconCircle" : t.form === "square" ? "iconSquare" : t.form === "rounded" ? "iconRounded" : "icon";
    switch (t.type) {
      case "square":
      case void 0:
        return "squareRect";
      case "round":
        return "roundedRect";
      case "ellipse":
        return "ellipse";
      default:
        return t.type;
    }
  }
  findNode(t, e) {
    return t.find((r) => r.id === e);
  }
  destructEdgeType(t) {
    let e = "none", r = "arrow_point";
    switch (t) {
      case "arrow_point":
      case "arrow_circle":
      case "arrow_cross":
        r = t;
        break;
      case "double_arrow_point":
      case "double_arrow_circle":
      case "double_arrow_cross":
        e = t.replace("double_", ""), r = e;
        break;
    }
    return { arrowTypeStart: e, arrowTypeEnd: r };
  }
  addNodeFromVertex(t, e, r, n, i, a) {
    const s = r.get(t.id), o = n.get(t.id) ?? !1, l = this.findNode(e, t.id);
    if (l)
      l.cssStyles = t.styles, l.cssCompiledStyles = this.getCompiledStyles(t.classes), l.cssClasses = t.classes.join(" ");
    else {
      const u = {
        id: t.id,
        label: t.text,
        labelStyle: "",
        parentId: s,
        padding: i.flowchart?.padding || 8,
        cssStyles: t.styles,
        cssCompiledStyles: this.getCompiledStyles(["default", "node", ...t.classes]),
        cssClasses: "default " + t.classes.join(" "),
        dir: t.dir,
        domId: t.domId,
        look: a,
        link: t.link,
        linkTarget: t.linkTarget,
        tooltip: this.getTooltip(t.id),
        icon: t.icon,
        pos: t.pos,
        img: t.img,
        assetWidth: t.assetWidth,
        assetHeight: t.assetHeight,
        constraint: t.constraint
      };
      o ? e.push({
        ...u,
        isGroup: !0,
        shape: "rect"
      }) : e.push({
        ...u,
        isGroup: !1,
        shape: this.getTypeFromVertex(t)
      });
    }
  }
  getCompiledStyles(t) {
    let e = [];
    for (const r of t) {
      const n = this.classes.get(r);
      n?.styles && (e = [...e, ...n.styles ?? []].map((i) => i.trim())), n?.textStyles && (e = [...e, ...n.textStyles ?? []].map((i) => i.trim()));
    }
    return e;
  }
  getData() {
    const t = we(), e = [], r = [], n = this.getSubGraphs(), i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
    for (let l = n.length - 1; l >= 0; l--) {
      const u = n[l];
      u.nodes.length > 0 && a.set(u.id, !0);
      for (const h of u.nodes)
        i.set(h, u.id);
    }
    for (let l = n.length - 1; l >= 0; l--) {
      const u = n[l];
      e.push({
        id: u.id,
        label: u.title,
        labelStyle: "",
        parentId: i.get(u.id),
        padding: 8,
        cssCompiledStyles: this.getCompiledStyles(u.classes),
        cssClasses: u.classes.join(" "),
        shape: "rect",
        dir: u.dir,
        isGroup: !0,
        look: t.look
      });
    }
    this.getVertices().forEach((l) => {
      this.addNodeFromVertex(l, e, i, a, t, t.look || "classic");
    });
    const o = this.getEdges();
    return o.forEach((l, u) => {
      const { arrowTypeStart: h, arrowTypeEnd: d } = this.destructEdgeType(l.type), f = [...o.defaultStyle ?? []];
      l.style && f.push(...l.style);
      const p = {
        id: Kh(l.start, l.end, { counter: u, prefix: "L" }, l.id),
        isUserDefinedId: l.isUserDefinedId,
        start: l.start,
        end: l.end,
        type: l.type ?? "normal",
        label: l.text,
        labelpos: "c",
        thickness: l.stroke,
        minlen: l.length,
        classes: l?.stroke === "invisible" ? "" : "edge-thickness-normal edge-pattern-solid flowchart-link",
        arrowTypeStart: l?.stroke === "invisible" || l?.type === "arrow_open" ? "none" : h,
        arrowTypeEnd: l?.stroke === "invisible" || l?.type === "arrow_open" ? "none" : d,
        arrowheadStyle: "fill: #333",
        cssCompiledStyles: this.getCompiledStyles(l.classes),
        labelStyle: f,
        style: f,
        pattern: l.stroke,
        look: t.look,
        animate: l.animate,
        animation: l.animation,
        curve: l.interpolate || this.edges.defaultInterpolate || t.flowchart?.curve
      };
      r.push(p);
    }), { nodes: e, edges: r, other: {}, config: t };
  }
  defaultConfig() {
    return BI.flowchart;
  }
}, Uwe = /* @__PURE__ */ x(function(t, e) {
  return e.db.getClasses();
}, "getClasses"), Hwe = /* @__PURE__ */ x(async function(t, e, r, n) {
  ie.info("REF0:"), ie.info("Drawing state diagram (v2)", e);
  const { securityLevel: i, flowchart: a, layout: s } = we();
  let o;
  i === "sandbox" && (o = Qe("#i" + e));
  const l = i === "sandbox" ? o.nodes()[0].contentDocument : document;
  ie.debug("Before getData: ");
  const u = n.db.getData();
  ie.debug("Data: ", u);
  const h = lf(e, i), d = n.db.getDirection();
  u.type = n.type, u.layoutAlgorithm = mg(s), u.layoutAlgorithm === "dagre" && s === "elk" && ie.warn(
    "flowchart-elk was moved to an external package in Mermaid v11. Please refer [release notes](https://github.com/mermaid-js/mermaid/releases/tag/v11.0.0) for more details. This diagram will be rendered using `dagre` layout as a fallback."
  ), u.direction = d, u.nodeSpacing = a?.nodeSpacing || 50, u.rankSpacing = a?.rankSpacing || 50, u.markers = ["point", "circle", "cross"], u.diagramId = e, ie.debug("REF1:", u), await Kd(u, h);
  const f = u.config.flowchart?.diagramPadding ?? 8;
  Zt.insertTitle(
    h,
    "flowchartTitleText",
    a?.titleTopMargin || 0,
    n.db.getDiagramTitle()
  ), rh(h, f, "flowchart", a?.useMaxWidth || !1);
  for (const p of u.nodes) {
    const g = Qe(`#${e} [id="${p.id}"]`);
    if (!g || !p.link)
      continue;
    const m = l.createElementNS("http://www.w3.org/2000/svg", "a");
    m.setAttributeNS("http://www.w3.org/2000/svg", "class", p.cssClasses), m.setAttributeNS("http://www.w3.org/2000/svg", "rel", "noopener"), i === "sandbox" ? m.setAttributeNS("http://www.w3.org/2000/svg", "target", "_top") : p.linkTarget && m.setAttributeNS("http://www.w3.org/2000/svg", "target", p.linkTarget);
    const v = g.insert(function() {
      return m;
    }, ":first-child"), y = g.select(".label-container");
    y && v.append(function() {
      return y.node();
    });
    const b = g.select(".label");
    b && v.append(function() {
      return b.node();
    });
  }
}, "draw"), qwe = {
  getClasses: Uwe,
  draw: Hwe
}, OT = (function() {
  var t = /* @__PURE__ */ x(function(wn, ft, wt, lt) {
    for (wt = wt || {}, lt = wn.length; lt--; wt[wn[lt]] = ft) ;
    return wt;
  }, "o"), e = [1, 4], r = [1, 3], n = [1, 5], i = [1, 8, 9, 10, 11, 27, 34, 36, 38, 44, 60, 84, 85, 86, 87, 88, 89, 102, 105, 106, 109, 111, 114, 115, 116, 121, 122, 123, 124], a = [2, 2], s = [1, 13], o = [1, 14], l = [1, 15], u = [1, 16], h = [1, 23], d = [1, 25], f = [1, 26], p = [1, 27], g = [1, 49], m = [1, 48], v = [1, 29], y = [1, 30], b = [1, 31], w = [1, 32], T = [1, 33], E = [1, 44], L = [1, 46], k = [1, 42], C = [1, 47], A = [1, 43], R = [1, 50], _ = [1, 45], O = [1, 51], P = [1, 52], S = [1, 34], M = [1, 35], N = [1, 36], D = [1, 37], I = [1, 57], B = [1, 8, 9, 10, 11, 27, 32, 34, 36, 38, 44, 60, 84, 85, 86, 87, 88, 89, 102, 105, 106, 109, 111, 114, 115, 116, 121, 122, 123, 124], z = [1, 61], F = [1, 60], V = [1, 62], H = [8, 9, 11, 75, 77, 78], J = [1, 78], q = [1, 91], ae = [1, 96], re = [1, 95], pe = [1, 92], K = [1, 88], Z = [1, 94], X = [1, 90], Y = [1, 97], ee = [1, 93], j = [1, 98], fe = [1, 89], te = [8, 9, 10, 11, 40, 75, 77, 78], Ae = [8, 9, 10, 11, 40, 46, 75, 77, 78], W = [8, 9, 10, 11, 29, 40, 44, 46, 48, 50, 52, 54, 56, 58, 60, 63, 65, 67, 68, 70, 75, 77, 78, 89, 102, 105, 106, 109, 111, 114, 115, 116], De = [8, 9, 11, 44, 60, 75, 77, 78, 89, 102, 105, 106, 109, 111, 114, 115, 116], ue = [44, 60, 89, 102, 105, 106, 109, 111, 114, 115, 116], ze = [1, 121], Ge = [1, 122], Ve = [1, 124], ke = [1, 123], Oe = [44, 60, 62, 74, 89, 102, 105, 106, 109, 111, 114, 115, 116], Se = [1, 133], _e = [1, 147], $e = [1, 148], me = [1, 149], Ne = [1, 150], Q = [1, 135], ce = [1, 137], $ = [1, 141], oe = [1, 142], se = [1, 143], ge = [1, 144], he = [1, 145], be = [1, 146], Ce = [1, 151], Te = [1, 152], Me = [1, 131], Xe = [1, 132], We = [1, 139], Ke = [1, 134], Ze = [1, 138], Pe = [1, 136], He = [8, 9, 10, 11, 27, 32, 34, 36, 38, 44, 60, 84, 85, 86, 87, 88, 89, 102, 105, 106, 109, 111, 114, 115, 116, 121, 122, 123, 124], ht = [1, 154], st = [1, 156], Ue = [8, 9, 11], Et = [8, 9, 10, 11, 14, 44, 60, 89, 105, 106, 109, 111, 114, 115, 116], qe = [1, 176], rt = [1, 172], ct = [1, 173], ut = [1, 177], nt = [1, 174], xt = [1, 175], Qt = [77, 116, 119], Dt = [8, 9, 10, 11, 12, 14, 27, 29, 32, 44, 60, 75, 84, 85, 86, 87, 88, 89, 90, 105, 109, 111, 114, 115, 116], rr = [10, 106], xr = [31, 49, 51, 53, 55, 57, 62, 64, 66, 67, 69, 71, 116, 117, 118], nr = [1, 247], Ht = [1, 245], lr = [1, 249], sn = [1, 243], dt = [1, 244], Ee = [1, 246], Je = [1, 248], bt = [1, 250], sr = [1, 268], Ur = [8, 9, 11, 106], cr = [8, 9, 10, 11, 60, 84, 105, 106, 109, 110, 111, 112], Xr = {
    trace: /* @__PURE__ */ x(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, graphConfig: 4, document: 5, line: 6, statement: 7, SEMI: 8, NEWLINE: 9, SPACE: 10, EOF: 11, GRAPH: 12, NODIR: 13, DIR: 14, FirstStmtSeparator: 15, ending: 16, endToken: 17, spaceList: 18, spaceListNewline: 19, vertexStatement: 20, separator: 21, styleStatement: 22, linkStyleStatement: 23, classDefStatement: 24, classStatement: 25, clickStatement: 26, subgraph: 27, textNoTags: 28, SQS: 29, text: 30, SQE: 31, end: 32, direction: 33, acc_title: 34, acc_title_value: 35, acc_descr: 36, acc_descr_value: 37, acc_descr_multiline_value: 38, shapeData: 39, SHAPE_DATA: 40, link: 41, node: 42, styledVertex: 43, AMP: 44, vertex: 45, STYLE_SEPARATOR: 46, idString: 47, DOUBLECIRCLESTART: 48, DOUBLECIRCLEEND: 49, PS: 50, PE: 51, "(-": 52, "-)": 53, STADIUMSTART: 54, STADIUMEND: 55, SUBROUTINESTART: 56, SUBROUTINEEND: 57, VERTEX_WITH_PROPS_START: 58, "NODE_STRING[field]": 59, COLON: 60, "NODE_STRING[value]": 61, PIPE: 62, CYLINDERSTART: 63, CYLINDEREND: 64, DIAMOND_START: 65, DIAMOND_STOP: 66, TAGEND: 67, TRAPSTART: 68, TRAPEND: 69, INVTRAPSTART: 70, INVTRAPEND: 71, linkStatement: 72, arrowText: 73, TESTSTR: 74, START_LINK: 75, edgeText: 76, LINK: 77, LINK_ID: 78, edgeTextToken: 79, STR: 80, MD_STR: 81, textToken: 82, keywords: 83, STYLE: 84, LINKSTYLE: 85, CLASSDEF: 86, CLASS: 87, CLICK: 88, DOWN: 89, UP: 90, textNoTagsToken: 91, stylesOpt: 92, "idString[vertex]": 93, "idString[class]": 94, CALLBACKNAME: 95, CALLBACKARGS: 96, HREF: 97, LINK_TARGET: 98, "STR[link]": 99, "STR[tooltip]": 100, alphaNum: 101, DEFAULT: 102, numList: 103, INTERPOLATE: 104, NUM: 105, COMMA: 106, style: 107, styleComponent: 108, NODE_STRING: 109, UNIT: 110, BRKT: 111, PCT: 112, idStringToken: 113, MINUS: 114, MULT: 115, UNICODE_TEXT: 116, TEXT: 117, TAGSTART: 118, EDGE_TEXT: 119, alphaNumToken: 120, direction_tb: 121, direction_bt: 122, direction_rl: 123, direction_lr: 124, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 8: "SEMI", 9: "NEWLINE", 10: "SPACE", 11: "EOF", 12: "GRAPH", 13: "NODIR", 14: "DIR", 27: "subgraph", 29: "SQS", 31: "SQE", 32: "end", 34: "acc_title", 35: "acc_title_value", 36: "acc_descr", 37: "acc_descr_value", 38: "acc_descr_multiline_value", 40: "SHAPE_DATA", 44: "AMP", 46: "STYLE_SEPARATOR", 48: "DOUBLECIRCLESTART", 49: "DOUBLECIRCLEEND", 50: "PS", 51: "PE", 52: "(-", 53: "-)", 54: "STADIUMSTART", 55: "STADIUMEND", 56: "SUBROUTINESTART", 57: "SUBROUTINEEND", 58: "VERTEX_WITH_PROPS_START", 59: "NODE_STRING[field]", 60: "COLON", 61: "NODE_STRING[value]", 62: "PIPE", 63: "CYLINDERSTART", 64: "CYLINDEREND", 65: "DIAMOND_START", 66: "DIAMOND_STOP", 67: "TAGEND", 68: "TRAPSTART", 69: "TRAPEND", 70: "INVTRAPSTART", 71: "INVTRAPEND", 74: "TESTSTR", 75: "START_LINK", 77: "LINK", 78: "LINK_ID", 80: "STR", 81: "MD_STR", 84: "STYLE", 85: "LINKSTYLE", 86: "CLASSDEF", 87: "CLASS", 88: "CLICK", 89: "DOWN", 90: "UP", 93: "idString[vertex]", 94: "idString[class]", 95: "CALLBACKNAME", 96: "CALLBACKARGS", 97: "HREF", 98: "LINK_TARGET", 99: "STR[link]", 100: "STR[tooltip]", 102: "DEFAULT", 104: "INTERPOLATE", 105: "NUM", 106: "COMMA", 109: "NODE_STRING", 110: "UNIT", 111: "BRKT", 112: "PCT", 114: "MINUS", 115: "MULT", 116: "UNICODE_TEXT", 117: "TEXT", 118: "TAGSTART", 119: "EDGE_TEXT", 121: "direction_tb", 122: "direction_bt", 123: "direction_rl", 124: "direction_lr" },
    productions_: [0, [3, 2], [5, 0], [5, 2], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [4, 2], [4, 2], [4, 2], [4, 3], [16, 2], [16, 1], [17, 1], [17, 1], [17, 1], [15, 1], [15, 1], [15, 2], [19, 2], [19, 2], [19, 1], [19, 1], [18, 2], [18, 1], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [7, 9], [7, 6], [7, 4], [7, 1], [7, 2], [7, 2], [7, 1], [21, 1], [21, 1], [21, 1], [39, 2], [39, 1], [20, 4], [20, 3], [20, 4], [20, 2], [20, 2], [20, 1], [42, 1], [42, 6], [42, 5], [43, 1], [43, 3], [45, 4], [45, 4], [45, 6], [45, 4], [45, 4], [45, 4], [45, 8], [45, 4], [45, 4], [45, 4], [45, 6], [45, 4], [45, 4], [45, 4], [45, 4], [45, 4], [45, 1], [41, 2], [41, 3], [41, 3], [41, 1], [41, 3], [41, 4], [76, 1], [76, 2], [76, 1], [76, 1], [72, 1], [72, 2], [73, 3], [30, 1], [30, 2], [30, 1], [30, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [28, 1], [28, 2], [28, 1], [28, 1], [24, 5], [25, 5], [26, 2], [26, 4], [26, 3], [26, 5], [26, 3], [26, 5], [26, 5], [26, 7], [26, 2], [26, 4], [26, 2], [26, 4], [26, 4], [26, 6], [22, 5], [23, 5], [23, 5], [23, 9], [23, 9], [23, 7], [23, 7], [103, 1], [103, 3], [92, 1], [92, 3], [107, 1], [107, 2], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [82, 1], [82, 1], [82, 1], [82, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [79, 1], [79, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [47, 1], [47, 2], [101, 1], [101, 2], [33, 1], [33, 1], [33, 1], [33, 1]],
    performAction: /* @__PURE__ */ x(function(ft, wt, lt, je, Kt, de, xl) {
      var ve = de.length - 1;
      switch (Kt) {
        case 2:
          this.$ = [];
          break;
        case 3:
          (!Array.isArray(de[ve]) || de[ve].length > 0) && de[ve - 1].push(de[ve]), this.$ = de[ve - 1];
          break;
        case 4:
        case 183:
          this.$ = de[ve];
          break;
        case 11:
          je.setDirection("TB"), this.$ = "TB";
          break;
        case 12:
          je.setDirection(de[ve - 1]), this.$ = de[ve - 1];
          break;
        case 27:
          this.$ = de[ve - 1].nodes;
          break;
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
          this.$ = [];
          break;
        case 33:
          this.$ = je.addSubGraph(de[ve - 6], de[ve - 1], de[ve - 4]);
          break;
        case 34:
          this.$ = je.addSubGraph(de[ve - 3], de[ve - 1], de[ve - 3]);
          break;
        case 35:
          this.$ = je.addSubGraph(void 0, de[ve - 1], void 0);
          break;
        case 37:
          this.$ = de[ve].trim(), je.setAccTitle(this.$);
          break;
        case 38:
        case 39:
          this.$ = de[ve].trim(), je.setAccDescription(this.$);
          break;
        case 43:
          this.$ = de[ve - 1] + de[ve];
          break;
        case 44:
          this.$ = de[ve];
          break;
        case 45:
          je.addVertex(de[ve - 1][de[ve - 1].length - 1], void 0, void 0, void 0, void 0, void 0, void 0, de[ve]), je.addLink(de[ve - 3].stmt, de[ve - 1], de[ve - 2]), this.$ = { stmt: de[ve - 1], nodes: de[ve - 1].concat(de[ve - 3].nodes) };
          break;
        case 46:
          je.addLink(de[ve - 2].stmt, de[ve], de[ve - 1]), this.$ = { stmt: de[ve], nodes: de[ve].concat(de[ve - 2].nodes) };
          break;
        case 47:
          je.addLink(de[ve - 3].stmt, de[ve - 1], de[ve - 2]), this.$ = { stmt: de[ve - 1], nodes: de[ve - 1].concat(de[ve - 3].nodes) };
          break;
        case 48:
          this.$ = { stmt: de[ve - 1], nodes: de[ve - 1] };
          break;
        case 49:
          je.addVertex(de[ve - 1][de[ve - 1].length - 1], void 0, void 0, void 0, void 0, void 0, void 0, de[ve]), this.$ = { stmt: de[ve - 1], nodes: de[ve - 1], shapeData: de[ve] };
          break;
        case 50:
          this.$ = { stmt: de[ve], nodes: de[ve] };
          break;
        case 51:
          this.$ = [de[ve]];
          break;
        case 52:
          je.addVertex(de[ve - 5][de[ve - 5].length - 1], void 0, void 0, void 0, void 0, void 0, void 0, de[ve - 4]), this.$ = de[ve - 5].concat(de[ve]);
          break;
        case 53:
          this.$ = de[ve - 4].concat(de[ve]);
          break;
        case 54:
          this.$ = de[ve];
          break;
        case 55:
          this.$ = de[ve - 2], je.setClass(de[ve - 2], de[ve]);
          break;
        case 56:
          this.$ = de[ve - 3], je.addVertex(de[ve - 3], de[ve - 1], "square");
          break;
        case 57:
          this.$ = de[ve - 3], je.addVertex(de[ve - 3], de[ve - 1], "doublecircle");
          break;
        case 58:
          this.$ = de[ve - 5], je.addVertex(de[ve - 5], de[ve - 2], "circle");
          break;
        case 59:
          this.$ = de[ve - 3], je.addVertex(de[ve - 3], de[ve - 1], "ellipse");
          break;
        case 60:
          this.$ = de[ve - 3], je.addVertex(de[ve - 3], de[ve - 1], "stadium");
          break;
        case 61:
          this.$ = de[ve - 3], je.addVertex(de[ve - 3], de[ve - 1], "subroutine");
          break;
        case 62:
          this.$ = de[ve - 7], je.addVertex(de[ve - 7], de[ve - 1], "rect", void 0, void 0, void 0, Object.fromEntries([[de[ve - 5], de[ve - 3]]]));
          break;
        case 63:
          this.$ = de[ve - 3], je.addVertex(de[ve - 3], de[ve - 1], "cylinder");
          break;
        case 64:
          this.$ = de[ve - 3], je.addVertex(de[ve - 3], de[ve - 1], "round");
          break;
        case 65:
          this.$ = de[ve - 3], je.addVertex(de[ve - 3], de[ve - 1], "diamond");
          break;
        case 66:
          this.$ = de[ve - 5], je.addVertex(de[ve - 5], de[ve - 2], "hexagon");
          break;
        case 67:
          this.$ = de[ve - 3], je.addVertex(de[ve - 3], de[ve - 1], "odd");
          break;
        case 68:
          this.$ = de[ve - 3], je.addVertex(de[ve - 3], de[ve - 1], "trapezoid");
          break;
        case 69:
          this.$ = de[ve - 3], je.addVertex(de[ve - 3], de[ve - 1], "inv_trapezoid");
          break;
        case 70:
          this.$ = de[ve - 3], je.addVertex(de[ve - 3], de[ve - 1], "lean_right");
          break;
        case 71:
          this.$ = de[ve - 3], je.addVertex(de[ve - 3], de[ve - 1], "lean_left");
          break;
        case 72:
          this.$ = de[ve], je.addVertex(de[ve]);
          break;
        case 73:
          de[ve - 1].text = de[ve], this.$ = de[ve - 1];
          break;
        case 74:
        case 75:
          de[ve - 2].text = de[ve - 1], this.$ = de[ve - 2];
          break;
        case 76:
          this.$ = de[ve];
          break;
        case 77:
          var br = je.destructLink(de[ve], de[ve - 2]);
          this.$ = { type: br.type, stroke: br.stroke, length: br.length, text: de[ve - 1] };
          break;
        case 78:
          var br = je.destructLink(de[ve], de[ve - 2]);
          this.$ = { type: br.type, stroke: br.stroke, length: br.length, text: de[ve - 1], id: de[ve - 3] };
          break;
        case 79:
          this.$ = { text: de[ve], type: "text" };
          break;
        case 80:
          this.$ = { text: de[ve - 1].text + "" + de[ve], type: de[ve - 1].type };
          break;
        case 81:
          this.$ = { text: de[ve], type: "string" };
          break;
        case 82:
          this.$ = { text: de[ve], type: "markdown" };
          break;
        case 83:
          var br = je.destructLink(de[ve]);
          this.$ = { type: br.type, stroke: br.stroke, length: br.length };
          break;
        case 84:
          var br = je.destructLink(de[ve]);
          this.$ = { type: br.type, stroke: br.stroke, length: br.length, id: de[ve - 1] };
          break;
        case 85:
          this.$ = de[ve - 1];
          break;
        case 86:
          this.$ = { text: de[ve], type: "text" };
          break;
        case 87:
          this.$ = { text: de[ve - 1].text + "" + de[ve], type: de[ve - 1].type };
          break;
        case 88:
          this.$ = { text: de[ve], type: "string" };
          break;
        case 89:
        case 104:
          this.$ = { text: de[ve], type: "markdown" };
          break;
        case 101:
          this.$ = { text: de[ve], type: "text" };
          break;
        case 102:
          this.$ = { text: de[ve - 1].text + "" + de[ve], type: de[ve - 1].type };
          break;
        case 103:
          this.$ = { text: de[ve], type: "text" };
          break;
        case 105:
          this.$ = de[ve - 4], je.addClass(de[ve - 2], de[ve]);
          break;
        case 106:
          this.$ = de[ve - 4], je.setClass(de[ve - 2], de[ve]);
          break;
        case 107:
        case 115:
          this.$ = de[ve - 1], je.setClickEvent(de[ve - 1], de[ve]);
          break;
        case 108:
        case 116:
          this.$ = de[ve - 3], je.setClickEvent(de[ve - 3], de[ve - 2]), je.setTooltip(de[ve - 3], de[ve]);
          break;
        case 109:
          this.$ = de[ve - 2], je.setClickEvent(de[ve - 2], de[ve - 1], de[ve]);
          break;
        case 110:
          this.$ = de[ve - 4], je.setClickEvent(de[ve - 4], de[ve - 3], de[ve - 2]), je.setTooltip(de[ve - 4], de[ve]);
          break;
        case 111:
          this.$ = de[ve - 2], je.setLink(de[ve - 2], de[ve]);
          break;
        case 112:
          this.$ = de[ve - 4], je.setLink(de[ve - 4], de[ve - 2]), je.setTooltip(de[ve - 4], de[ve]);
          break;
        case 113:
          this.$ = de[ve - 4], je.setLink(de[ve - 4], de[ve - 2], de[ve]);
          break;
        case 114:
          this.$ = de[ve - 6], je.setLink(de[ve - 6], de[ve - 4], de[ve]), je.setTooltip(de[ve - 6], de[ve - 2]);
          break;
        case 117:
          this.$ = de[ve - 1], je.setLink(de[ve - 1], de[ve]);
          break;
        case 118:
          this.$ = de[ve - 3], je.setLink(de[ve - 3], de[ve - 2]), je.setTooltip(de[ve - 3], de[ve]);
          break;
        case 119:
          this.$ = de[ve - 3], je.setLink(de[ve - 3], de[ve - 2], de[ve]);
          break;
        case 120:
          this.$ = de[ve - 5], je.setLink(de[ve - 5], de[ve - 4], de[ve]), je.setTooltip(de[ve - 5], de[ve - 2]);
          break;
        case 121:
          this.$ = de[ve - 4], je.addVertex(de[ve - 2], void 0, void 0, de[ve]);
          break;
        case 122:
          this.$ = de[ve - 4], je.updateLink([de[ve - 2]], de[ve]);
          break;
        case 123:
          this.$ = de[ve - 4], je.updateLink(de[ve - 2], de[ve]);
          break;
        case 124:
          this.$ = de[ve - 8], je.updateLinkInterpolate([de[ve - 6]], de[ve - 2]), je.updateLink([de[ve - 6]], de[ve]);
          break;
        case 125:
          this.$ = de[ve - 8], je.updateLinkInterpolate(de[ve - 6], de[ve - 2]), je.updateLink(de[ve - 6], de[ve]);
          break;
        case 126:
          this.$ = de[ve - 6], je.updateLinkInterpolate([de[ve - 4]], de[ve]);
          break;
        case 127:
          this.$ = de[ve - 6], je.updateLinkInterpolate(de[ve - 4], de[ve]);
          break;
        case 128:
        case 130:
          this.$ = [de[ve]];
          break;
        case 129:
        case 131:
          de[ve - 2].push(de[ve]), this.$ = de[ve - 2];
          break;
        case 133:
          this.$ = de[ve - 1] + de[ve];
          break;
        case 181:
          this.$ = de[ve];
          break;
        case 182:
          this.$ = de[ve - 1] + "" + de[ve];
          break;
        case 184:
          this.$ = de[ve - 1] + "" + de[ve];
          break;
        case 185:
          this.$ = { stmt: "dir", value: "TB" };
          break;
        case 186:
          this.$ = { stmt: "dir", value: "BT" };
          break;
        case 187:
          this.$ = { stmt: "dir", value: "RL" };
          break;
        case 188:
          this.$ = { stmt: "dir", value: "LR" };
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: 2, 9: e, 10: r, 12: n }, { 1: [3] }, t(i, a, { 5: 6 }), { 4: 7, 9: e, 10: r, 12: n }, { 4: 8, 9: e, 10: r, 12: n }, { 13: [1, 9], 14: [1, 10] }, { 1: [2, 1], 6: 11, 7: 12, 8: s, 9: o, 10: l, 11: u, 20: 17, 22: 18, 23: 19, 24: 20, 25: 21, 26: 22, 27: h, 33: 24, 34: d, 36: f, 38: p, 42: 28, 43: 38, 44: g, 45: 39, 47: 40, 60: m, 84: v, 85: y, 86: b, 87: w, 88: T, 89: E, 102: L, 105: k, 106: C, 109: A, 111: R, 113: 41, 114: _, 115: O, 116: P, 121: S, 122: M, 123: N, 124: D }, t(i, [2, 9]), t(i, [2, 10]), t(i, [2, 11]), { 8: [1, 54], 9: [1, 55], 10: I, 15: 53, 18: 56 }, t(B, [2, 3]), t(B, [2, 4]), t(B, [2, 5]), t(B, [2, 6]), t(B, [2, 7]), t(B, [2, 8]), { 8: z, 9: F, 11: V, 21: 58, 41: 59, 72: 63, 75: [1, 64], 77: [1, 66], 78: [1, 65] }, { 8: z, 9: F, 11: V, 21: 67 }, { 8: z, 9: F, 11: V, 21: 68 }, { 8: z, 9: F, 11: V, 21: 69 }, { 8: z, 9: F, 11: V, 21: 70 }, { 8: z, 9: F, 11: V, 21: 71 }, { 8: z, 9: F, 10: [1, 72], 11: V, 21: 73 }, t(B, [2, 36]), { 35: [1, 74] }, { 37: [1, 75] }, t(B, [2, 39]), t(H, [2, 50], { 18: 76, 39: 77, 10: I, 40: J }), { 10: [1, 79] }, { 10: [1, 80] }, { 10: [1, 81] }, { 10: [1, 82] }, { 14: q, 44: ae, 60: re, 80: [1, 86], 89: pe, 95: [1, 83], 97: [1, 84], 101: 85, 105: K, 106: Z, 109: X, 111: Y, 114: ee, 115: j, 116: fe, 120: 87 }, t(B, [2, 185]), t(B, [2, 186]), t(B, [2, 187]), t(B, [2, 188]), t(te, [2, 51]), t(te, [2, 54], { 46: [1, 99] }), t(Ae, [2, 72], { 113: 112, 29: [1, 100], 44: g, 48: [1, 101], 50: [1, 102], 52: [1, 103], 54: [1, 104], 56: [1, 105], 58: [1, 106], 60: m, 63: [1, 107], 65: [1, 108], 67: [1, 109], 68: [1, 110], 70: [1, 111], 89: E, 102: L, 105: k, 106: C, 109: A, 111: R, 114: _, 115: O, 116: P }), t(W, [2, 181]), t(W, [2, 142]), t(W, [2, 143]), t(W, [2, 144]), t(W, [2, 145]), t(W, [2, 146]), t(W, [2, 147]), t(W, [2, 148]), t(W, [2, 149]), t(W, [2, 150]), t(W, [2, 151]), t(W, [2, 152]), t(i, [2, 12]), t(i, [2, 18]), t(i, [2, 19]), { 9: [1, 113] }, t(De, [2, 26], { 18: 114, 10: I }), t(B, [2, 27]), { 42: 115, 43: 38, 44: g, 45: 39, 47: 40, 60: m, 89: E, 102: L, 105: k, 106: C, 109: A, 111: R, 113: 41, 114: _, 115: O, 116: P }, t(B, [2, 40]), t(B, [2, 41]), t(B, [2, 42]), t(ue, [2, 76], { 73: 116, 62: [1, 118], 74: [1, 117] }), { 76: 119, 79: 120, 80: ze, 81: Ge, 116: Ve, 119: ke }, { 75: [1, 125], 77: [1, 126] }, t(Oe, [2, 83]), t(B, [2, 28]), t(B, [2, 29]), t(B, [2, 30]), t(B, [2, 31]), t(B, [2, 32]), { 10: Se, 12: _e, 14: $e, 27: me, 28: 127, 32: Ne, 44: Q, 60: ce, 75: $, 80: [1, 129], 81: [1, 130], 83: 140, 84: oe, 85: se, 86: ge, 87: he, 88: be, 89: Ce, 90: Te, 91: 128, 105: Me, 109: Xe, 111: We, 114: Ke, 115: Ze, 116: Pe }, t(He, a, { 5: 153 }), t(B, [2, 37]), t(B, [2, 38]), t(H, [2, 48], { 44: ht }), t(H, [2, 49], { 18: 155, 10: I, 40: st }), t(te, [2, 44]), { 44: g, 47: 157, 60: m, 89: E, 102: L, 105: k, 106: C, 109: A, 111: R, 113: 41, 114: _, 115: O, 116: P }, { 102: [1, 158], 103: 159, 105: [1, 160] }, { 44: g, 47: 161, 60: m, 89: E, 102: L, 105: k, 106: C, 109: A, 111: R, 113: 41, 114: _, 115: O, 116: P }, { 44: g, 47: 162, 60: m, 89: E, 102: L, 105: k, 106: C, 109: A, 111: R, 113: 41, 114: _, 115: O, 116: P }, t(Ue, [2, 107], { 10: [1, 163], 96: [1, 164] }), { 80: [1, 165] }, t(Ue, [2, 115], { 120: 167, 10: [1, 166], 14: q, 44: ae, 60: re, 89: pe, 105: K, 106: Z, 109: X, 111: Y, 114: ee, 115: j, 116: fe }), t(Ue, [2, 117], { 10: [1, 168] }), t(Et, [2, 183]), t(Et, [2, 170]), t(Et, [2, 171]), t(Et, [2, 172]), t(Et, [2, 173]), t(Et, [2, 174]), t(Et, [2, 175]), t(Et, [2, 176]), t(Et, [2, 177]), t(Et, [2, 178]), t(Et, [2, 179]), t(Et, [2, 180]), { 44: g, 47: 169, 60: m, 89: E, 102: L, 105: k, 106: C, 109: A, 111: R, 113: 41, 114: _, 115: O, 116: P }, { 30: 170, 67: qe, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: xt }, { 30: 178, 67: qe, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: xt }, { 30: 180, 50: [1, 179], 67: qe, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: xt }, { 30: 181, 67: qe, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: xt }, { 30: 182, 67: qe, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: xt }, { 30: 183, 67: qe, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: xt }, { 109: [1, 184] }, { 30: 185, 67: qe, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: xt }, { 30: 186, 65: [1, 187], 67: qe, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: xt }, { 30: 188, 67: qe, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: xt }, { 30: 189, 67: qe, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: xt }, { 30: 190, 67: qe, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: xt }, t(W, [2, 182]), t(i, [2, 20]), t(De, [2, 25]), t(H, [2, 46], { 39: 191, 18: 192, 10: I, 40: J }), t(ue, [2, 73], { 10: [1, 193] }), { 10: [1, 194] }, { 30: 195, 67: qe, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: xt }, { 77: [1, 196], 79: 197, 116: Ve, 119: ke }, t(Qt, [2, 79]), t(Qt, [2, 81]), t(Qt, [2, 82]), t(Qt, [2, 168]), t(Qt, [2, 169]), { 76: 198, 79: 120, 80: ze, 81: Ge, 116: Ve, 119: ke }, t(Oe, [2, 84]), { 8: z, 9: F, 10: Se, 11: V, 12: _e, 14: $e, 21: 200, 27: me, 29: [1, 199], 32: Ne, 44: Q, 60: ce, 75: $, 83: 140, 84: oe, 85: se, 86: ge, 87: he, 88: be, 89: Ce, 90: Te, 91: 201, 105: Me, 109: Xe, 111: We, 114: Ke, 115: Ze, 116: Pe }, t(Dt, [2, 101]), t(Dt, [2, 103]), t(Dt, [2, 104]), t(Dt, [2, 157]), t(Dt, [2, 158]), t(Dt, [2, 159]), t(Dt, [2, 160]), t(Dt, [2, 161]), t(Dt, [2, 162]), t(Dt, [2, 163]), t(Dt, [2, 164]), t(Dt, [2, 165]), t(Dt, [2, 166]), t(Dt, [2, 167]), t(Dt, [2, 90]), t(Dt, [2, 91]), t(Dt, [2, 92]), t(Dt, [2, 93]), t(Dt, [2, 94]), t(Dt, [2, 95]), t(Dt, [2, 96]), t(Dt, [2, 97]), t(Dt, [2, 98]), t(Dt, [2, 99]), t(Dt, [2, 100]), { 6: 11, 7: 12, 8: s, 9: o, 10: l, 11: u, 20: 17, 22: 18, 23: 19, 24: 20, 25: 21, 26: 22, 27: h, 32: [1, 202], 33: 24, 34: d, 36: f, 38: p, 42: 28, 43: 38, 44: g, 45: 39, 47: 40, 60: m, 84: v, 85: y, 86: b, 87: w, 88: T, 89: E, 102: L, 105: k, 106: C, 109: A, 111: R, 113: 41, 114: _, 115: O, 116: P, 121: S, 122: M, 123: N, 124: D }, { 10: I, 18: 203 }, { 44: [1, 204] }, t(te, [2, 43]), { 10: [1, 205], 44: g, 60: m, 89: E, 102: L, 105: k, 106: C, 109: A, 111: R, 113: 112, 114: _, 115: O, 116: P }, { 10: [1, 206] }, { 10: [1, 207], 106: [1, 208] }, t(rr, [2, 128]), { 10: [1, 209], 44: g, 60: m, 89: E, 102: L, 105: k, 106: C, 109: A, 111: R, 113: 112, 114: _, 115: O, 116: P }, { 10: [1, 210], 44: g, 60: m, 89: E, 102: L, 105: k, 106: C, 109: A, 111: R, 113: 112, 114: _, 115: O, 116: P }, { 80: [1, 211] }, t(Ue, [2, 109], { 10: [1, 212] }), t(Ue, [2, 111], { 10: [1, 213] }), { 80: [1, 214] }, t(Et, [2, 184]), { 80: [1, 215], 98: [1, 216] }, t(te, [2, 55], { 113: 112, 44: g, 60: m, 89: E, 102: L, 105: k, 106: C, 109: A, 111: R, 114: _, 115: O, 116: P }), { 31: [1, 217], 67: qe, 82: 218, 116: ut, 117: nt, 118: xt }, t(xr, [2, 86]), t(xr, [2, 88]), t(xr, [2, 89]), t(xr, [2, 153]), t(xr, [2, 154]), t(xr, [2, 155]), t(xr, [2, 156]), { 49: [1, 219], 67: qe, 82: 218, 116: ut, 117: nt, 118: xt }, { 30: 220, 67: qe, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: xt }, { 51: [1, 221], 67: qe, 82: 218, 116: ut, 117: nt, 118: xt }, { 53: [1, 222], 67: qe, 82: 218, 116: ut, 117: nt, 118: xt }, { 55: [1, 223], 67: qe, 82: 218, 116: ut, 117: nt, 118: xt }, { 57: [1, 224], 67: qe, 82: 218, 116: ut, 117: nt, 118: xt }, { 60: [1, 225] }, { 64: [1, 226], 67: qe, 82: 218, 116: ut, 117: nt, 118: xt }, { 66: [1, 227], 67: qe, 82: 218, 116: ut, 117: nt, 118: xt }, { 30: 228, 67: qe, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: xt }, { 31: [1, 229], 67: qe, 82: 218, 116: ut, 117: nt, 118: xt }, { 67: qe, 69: [1, 230], 71: [1, 231], 82: 218, 116: ut, 117: nt, 118: xt }, { 67: qe, 69: [1, 233], 71: [1, 232], 82: 218, 116: ut, 117: nt, 118: xt }, t(H, [2, 45], { 18: 155, 10: I, 40: st }), t(H, [2, 47], { 44: ht }), t(ue, [2, 75]), t(ue, [2, 74]), { 62: [1, 234], 67: qe, 82: 218, 116: ut, 117: nt, 118: xt }, t(ue, [2, 77]), t(Qt, [2, 80]), { 77: [1, 235], 79: 197, 116: Ve, 119: ke }, { 30: 236, 67: qe, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: xt }, t(He, a, { 5: 237 }), t(Dt, [2, 102]), t(B, [2, 35]), { 43: 238, 44: g, 45: 39, 47: 40, 60: m, 89: E, 102: L, 105: k, 106: C, 109: A, 111: R, 113: 41, 114: _, 115: O, 116: P }, { 10: I, 18: 239 }, { 10: nr, 60: Ht, 84: lr, 92: 240, 105: sn, 107: 241, 108: 242, 109: dt, 110: Ee, 111: Je, 112: bt }, { 10: nr, 60: Ht, 84: lr, 92: 251, 104: [1, 252], 105: sn, 107: 241, 108: 242, 109: dt, 110: Ee, 111: Je, 112: bt }, { 10: nr, 60: Ht, 84: lr, 92: 253, 104: [1, 254], 105: sn, 107: 241, 108: 242, 109: dt, 110: Ee, 111: Je, 112: bt }, { 105: [1, 255] }, { 10: nr, 60: Ht, 84: lr, 92: 256, 105: sn, 107: 241, 108: 242, 109: dt, 110: Ee, 111: Je, 112: bt }, { 44: g, 47: 257, 60: m, 89: E, 102: L, 105: k, 106: C, 109: A, 111: R, 113: 41, 114: _, 115: O, 116: P }, t(Ue, [2, 108]), { 80: [1, 258] }, { 80: [1, 259], 98: [1, 260] }, t(Ue, [2, 116]), t(Ue, [2, 118], { 10: [1, 261] }), t(Ue, [2, 119]), t(Ae, [2, 56]), t(xr, [2, 87]), t(Ae, [2, 57]), { 51: [1, 262], 67: qe, 82: 218, 116: ut, 117: nt, 118: xt }, t(Ae, [2, 64]), t(Ae, [2, 59]), t(Ae, [2, 60]), t(Ae, [2, 61]), { 109: [1, 263] }, t(Ae, [2, 63]), t(Ae, [2, 65]), { 66: [1, 264], 67: qe, 82: 218, 116: ut, 117: nt, 118: xt }, t(Ae, [2, 67]), t(Ae, [2, 68]), t(Ae, [2, 70]), t(Ae, [2, 69]), t(Ae, [2, 71]), t([10, 44, 60, 89, 102, 105, 106, 109, 111, 114, 115, 116], [2, 85]), t(ue, [2, 78]), { 31: [1, 265], 67: qe, 82: 218, 116: ut, 117: nt, 118: xt }, { 6: 11, 7: 12, 8: s, 9: o, 10: l, 11: u, 20: 17, 22: 18, 23: 19, 24: 20, 25: 21, 26: 22, 27: h, 32: [1, 266], 33: 24, 34: d, 36: f, 38: p, 42: 28, 43: 38, 44: g, 45: 39, 47: 40, 60: m, 84: v, 85: y, 86: b, 87: w, 88: T, 89: E, 102: L, 105: k, 106: C, 109: A, 111: R, 113: 41, 114: _, 115: O, 116: P, 121: S, 122: M, 123: N, 124: D }, t(te, [2, 53]), { 43: 267, 44: g, 45: 39, 47: 40, 60: m, 89: E, 102: L, 105: k, 106: C, 109: A, 111: R, 113: 41, 114: _, 115: O, 116: P }, t(Ue, [2, 121], { 106: sr }), t(Ur, [2, 130], { 108: 269, 10: nr, 60: Ht, 84: lr, 105: sn, 109: dt, 110: Ee, 111: Je, 112: bt }), t(cr, [2, 132]), t(cr, [2, 134]), t(cr, [2, 135]), t(cr, [2, 136]), t(cr, [2, 137]), t(cr, [2, 138]), t(cr, [2, 139]), t(cr, [2, 140]), t(cr, [2, 141]), t(Ue, [2, 122], { 106: sr }), { 10: [1, 270] }, t(Ue, [2, 123], { 106: sr }), { 10: [1, 271] }, t(rr, [2, 129]), t(Ue, [2, 105], { 106: sr }), t(Ue, [2, 106], { 113: 112, 44: g, 60: m, 89: E, 102: L, 105: k, 106: C, 109: A, 111: R, 114: _, 115: O, 116: P }), t(Ue, [2, 110]), t(Ue, [2, 112], { 10: [1, 272] }), t(Ue, [2, 113]), { 98: [1, 273] }, { 51: [1, 274] }, { 62: [1, 275] }, { 66: [1, 276] }, { 8: z, 9: F, 11: V, 21: 277 }, t(B, [2, 34]), t(te, [2, 52]), { 10: nr, 60: Ht, 84: lr, 105: sn, 107: 278, 108: 242, 109: dt, 110: Ee, 111: Je, 112: bt }, t(cr, [2, 133]), { 14: q, 44: ae, 60: re, 89: pe, 101: 279, 105: K, 106: Z, 109: X, 111: Y, 114: ee, 115: j, 116: fe, 120: 87 }, { 14: q, 44: ae, 60: re, 89: pe, 101: 280, 105: K, 106: Z, 109: X, 111: Y, 114: ee, 115: j, 116: fe, 120: 87 }, { 98: [1, 281] }, t(Ue, [2, 120]), t(Ae, [2, 58]), { 30: 282, 67: qe, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: xt }, t(Ae, [2, 66]), t(He, a, { 5: 283 }), t(Ur, [2, 131], { 108: 269, 10: nr, 60: Ht, 84: lr, 105: sn, 109: dt, 110: Ee, 111: Je, 112: bt }), t(Ue, [2, 126], { 120: 167, 10: [1, 284], 14: q, 44: ae, 60: re, 89: pe, 105: K, 106: Z, 109: X, 111: Y, 114: ee, 115: j, 116: fe }), t(Ue, [2, 127], { 120: 167, 10: [1, 285], 14: q, 44: ae, 60: re, 89: pe, 105: K, 106: Z, 109: X, 111: Y, 114: ee, 115: j, 116: fe }), t(Ue, [2, 114]), { 31: [1, 286], 67: qe, 82: 218, 116: ut, 117: nt, 118: xt }, { 6: 11, 7: 12, 8: s, 9: o, 10: l, 11: u, 20: 17, 22: 18, 23: 19, 24: 20, 25: 21, 26: 22, 27: h, 32: [1, 287], 33: 24, 34: d, 36: f, 38: p, 42: 28, 43: 38, 44: g, 45: 39, 47: 40, 60: m, 84: v, 85: y, 86: b, 87: w, 88: T, 89: E, 102: L, 105: k, 106: C, 109: A, 111: R, 113: 41, 114: _, 115: O, 116: P, 121: S, 122: M, 123: N, 124: D }, { 10: nr, 60: Ht, 84: lr, 92: 288, 105: sn, 107: 241, 108: 242, 109: dt, 110: Ee, 111: Je, 112: bt }, { 10: nr, 60: Ht, 84: lr, 92: 289, 105: sn, 107: 241, 108: 242, 109: dt, 110: Ee, 111: Je, 112: bt }, t(Ae, [2, 62]), t(B, [2, 33]), t(Ue, [2, 124], { 106: sr }), t(Ue, [2, 125], { 106: sr })],
    defaultActions: {},
    parseError: /* @__PURE__ */ x(function(ft, wt) {
      if (wt.recoverable)
        this.trace(ft);
      else {
        var lt = new Error(ft);
        throw lt.hash = wt, lt;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ x(function(ft) {
      var wt = this, lt = [0], je = [], Kt = [null], de = [], xl = this.table, ve = "", br = 0, Zg = 0, Y7 = 2, Qg = 1, Cj = de.slice.call(arguments, 1), Wn = Object.create(this.lexer), Nc = { yy: {} };
      for (var _b in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, _b) && (Nc.yy[_b] = this.yy[_b]);
      Wn.setInput(ft, Nc.yy), Nc.yy.lexer = Wn, Nc.yy.parser = this, typeof Wn.yylloc > "u" && (Wn.yylloc = {});
      var Lb = Wn.yylloc;
      de.push(Lb);
      var Aj = Wn.options && Wn.options.ranges;
      typeof Nc.yy.parseError == "function" ? this.parseError = Nc.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function _j(ma) {
        lt.length = lt.length - 2 * ma, Kt.length = Kt.length - ma, de.length = de.length - ma;
      }
      x(_j, "popStack");
      function X7() {
        var ma;
        return ma = je.pop() || Wn.lex() || Qg, typeof ma != "number" && (ma instanceof Array && (je = ma, ma = je.pop()), ma = wt.symbols_[ma] || ma), ma;
      }
      x(X7, "lex");
      for (var Qi, Ic, Oa, Rb, ph = {}, Jg, To, j7, e1; ; ) {
        if (Ic = lt[lt.length - 1], this.defaultActions[Ic] ? Oa = this.defaultActions[Ic] : ((Qi === null || typeof Qi > "u") && (Qi = X7()), Oa = xl[Ic] && xl[Ic][Qi]), typeof Oa > "u" || !Oa.length || !Oa[0]) {
          var Mb = "";
          e1 = [];
          for (Jg in xl[Ic])
            this.terminals_[Jg] && Jg > Y7 && e1.push("'" + this.terminals_[Jg] + "'");
          Wn.showPosition ? Mb = "Parse error on line " + (br + 1) + `:
` + Wn.showPosition() + `
Expecting ` + e1.join(", ") + ", got '" + (this.terminals_[Qi] || Qi) + "'" : Mb = "Parse error on line " + (br + 1) + ": Unexpected " + (Qi == Qg ? "end of input" : "'" + (this.terminals_[Qi] || Qi) + "'"), this.parseError(Mb, {
            text: Wn.match,
            token: this.terminals_[Qi] || Qi,
            line: Wn.yylineno,
            loc: Lb,
            expected: e1
          });
        }
        if (Oa[0] instanceof Array && Oa.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Ic + ", token: " + Qi);
        switch (Oa[0]) {
          case 1:
            lt.push(Qi), Kt.push(Wn.yytext), de.push(Wn.yylloc), lt.push(Oa[1]), Qi = null, Zg = Wn.yyleng, ve = Wn.yytext, br = Wn.yylineno, Lb = Wn.yylloc;
            break;
          case 2:
            if (To = this.productions_[Oa[1]][1], ph.$ = Kt[Kt.length - To], ph._$ = {
              first_line: de[de.length - (To || 1)].first_line,
              last_line: de[de.length - 1].last_line,
              first_column: de[de.length - (To || 1)].first_column,
              last_column: de[de.length - 1].last_column
            }, Aj && (ph._$.range = [
              de[de.length - (To || 1)].range[0],
              de[de.length - 1].range[1]
            ]), Rb = this.performAction.apply(ph, [
              ve,
              Zg,
              br,
              Nc.yy,
              Oa[1],
              Kt,
              de
            ].concat(Cj)), typeof Rb < "u")
              return Rb;
            To && (lt = lt.slice(0, -1 * To * 2), Kt = Kt.slice(0, -1 * To), de = de.slice(0, -1 * To)), lt.push(this.productions_[Oa[1]][0]), Kt.push(ph.$), de.push(ph._$), j7 = xl[lt[lt.length - 2]][lt[lt.length - 1]], lt.push(j7);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, gi = /* @__PURE__ */ (function() {
    var wn = {
      EOF: 1,
      parseError: /* @__PURE__ */ x(function(wt, lt) {
        if (this.yy.parser)
          this.yy.parser.parseError(wt, lt);
        else
          throw new Error(wt);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ x(function(ft, wt) {
        return this.yy = wt || this.yy || {}, this._input = ft, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ x(function() {
        var ft = this._input[0];
        this.yytext += ft, this.yyleng++, this.offset++, this.match += ft, this.matched += ft;
        var wt = ft.match(/(?:\r\n?|\n).*/g);
        return wt ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), ft;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ x(function(ft) {
        var wt = ft.length, lt = ft.split(/(?:\r\n?|\n)/g);
        this._input = ft + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - wt), this.offset -= wt;
        var je = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), lt.length - 1 && (this.yylineno -= lt.length - 1);
        var Kt = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lt ? (lt.length === je.length ? this.yylloc.first_column : 0) + je[je.length - lt.length].length - lt[0].length : this.yylloc.first_column - wt
        }, this.options.ranges && (this.yylloc.range = [Kt[0], Kt[0] + this.yyleng - wt]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ x(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ x(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ x(function(ft) {
        this.unput(this.match.slice(ft));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ x(function() {
        var ft = this.matched.substr(0, this.matched.length - this.match.length);
        return (ft.length > 20 ? "..." : "") + ft.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ x(function() {
        var ft = this.match;
        return ft.length < 20 && (ft += this._input.substr(0, 20 - ft.length)), (ft.substr(0, 20) + (ft.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ x(function() {
        var ft = this.pastInput(), wt = new Array(ft.length + 1).join("-");
        return ft + this.upcomingInput() + `
` + wt + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ x(function(ft, wt) {
        var lt, je, Kt;
        if (this.options.backtrack_lexer && (Kt = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (Kt.yylloc.range = this.yylloc.range.slice(0))), je = ft[0].match(/(?:\r\n?|\n).*/g), je && (this.yylineno += je.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: je ? je[je.length - 1].length - je[je.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + ft[0].length
        }, this.yytext += ft[0], this.match += ft[0], this.matches = ft, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(ft[0].length), this.matched += ft[0], lt = this.performAction.call(this, this.yy, this, wt, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), lt)
          return lt;
        if (this._backtrack) {
          for (var de in Kt)
            this[de] = Kt[de];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ x(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var ft, wt, lt, je;
        this._more || (this.yytext = "", this.match = "");
        for (var Kt = this._currentRules(), de = 0; de < Kt.length; de++)
          if (lt = this._input.match(this.rules[Kt[de]]), lt && (!wt || lt[0].length > wt[0].length)) {
            if (wt = lt, je = de, this.options.backtrack_lexer) {
              if (ft = this.test_match(lt, Kt[de]), ft !== !1)
                return ft;
              if (this._backtrack) {
                wt = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return wt ? (ft = this.test_match(wt, Kt[je]), ft !== !1 ? ft : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ x(function() {
        var wt = this.next();
        return wt || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ x(function(wt) {
        this.conditionStack.push(wt);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ x(function() {
        var wt = this.conditionStack.length - 1;
        return wt > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ x(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ x(function(wt) {
        return wt = this.conditionStack.length - 1 - Math.abs(wt || 0), wt >= 0 ? this.conditionStack[wt] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ x(function(wt) {
        this.begin(wt);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ x(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: {},
      performAction: /* @__PURE__ */ x(function(wt, lt, je, Kt) {
        switch (je) {
          case 0:
            return this.begin("acc_title"), 34;
          case 1:
            return this.popState(), "acc_title_value";
          case 2:
            return this.begin("acc_descr"), 36;
          case 3:
            return this.popState(), "acc_descr_value";
          case 4:
            this.begin("acc_descr_multiline");
            break;
          case 5:
            this.popState();
            break;
          case 6:
            return "acc_descr_multiline_value";
          case 7:
            return this.pushState("shapeData"), lt.yytext = "", 40;
          case 8:
            return this.pushState("shapeDataStr"), 40;
          case 9:
            return this.popState(), 40;
          case 10:
            const de = /\n\s*/g;
            return lt.yytext = lt.yytext.replace(de, "<br/>"), 40;
          case 11:
            return 40;
          case 12:
            this.popState();
            break;
          case 13:
            this.begin("callbackname");
            break;
          case 14:
            this.popState();
            break;
          case 15:
            this.popState(), this.begin("callbackargs");
            break;
          case 16:
            return 95;
          case 17:
            this.popState();
            break;
          case 18:
            return 96;
          case 19:
            return "MD_STR";
          case 20:
            this.popState();
            break;
          case 21:
            this.begin("md_string");
            break;
          case 22:
            return "STR";
          case 23:
            this.popState();
            break;
          case 24:
            this.pushState("string");
            break;
          case 25:
            return 84;
          case 26:
            return 102;
          case 27:
            return 85;
          case 28:
            return 104;
          case 29:
            return 86;
          case 30:
            return 87;
          case 31:
            return 97;
          case 32:
            this.begin("click");
            break;
          case 33:
            this.popState();
            break;
          case 34:
            return 88;
          case 35:
            return wt.lex.firstGraph() && this.begin("dir"), 12;
          case 36:
            return wt.lex.firstGraph() && this.begin("dir"), 12;
          case 37:
            return wt.lex.firstGraph() && this.begin("dir"), 12;
          case 38:
            return 27;
          case 39:
            return 32;
          case 40:
            return 98;
          case 41:
            return 98;
          case 42:
            return 98;
          case 43:
            return 98;
          case 44:
            return this.popState(), 13;
          case 45:
            return this.popState(), 14;
          case 46:
            return this.popState(), 14;
          case 47:
            return this.popState(), 14;
          case 48:
            return this.popState(), 14;
          case 49:
            return this.popState(), 14;
          case 50:
            return this.popState(), 14;
          case 51:
            return this.popState(), 14;
          case 52:
            return this.popState(), 14;
          case 53:
            return this.popState(), 14;
          case 54:
            return this.popState(), 14;
          case 55:
            return 121;
          case 56:
            return 122;
          case 57:
            return 123;
          case 58:
            return 124;
          case 59:
            return 78;
          case 60:
            return 105;
          case 61:
            return 111;
          case 62:
            return 46;
          case 63:
            return 60;
          case 64:
            return 44;
          case 65:
            return 8;
          case 66:
            return 106;
          case 67:
            return 115;
          case 68:
            return this.popState(), 77;
          case 69:
            return this.pushState("edgeText"), 75;
          case 70:
            return 119;
          case 71:
            return this.popState(), 77;
          case 72:
            return this.pushState("thickEdgeText"), 75;
          case 73:
            return 119;
          case 74:
            return this.popState(), 77;
          case 75:
            return this.pushState("dottedEdgeText"), 75;
          case 76:
            return 119;
          case 77:
            return 77;
          case 78:
            return this.popState(), 53;
          case 79:
            return "TEXT";
          case 80:
            return this.pushState("ellipseText"), 52;
          case 81:
            return this.popState(), 55;
          case 82:
            return this.pushState("text"), 54;
          case 83:
            return this.popState(), 57;
          case 84:
            return this.pushState("text"), 56;
          case 85:
            return 58;
          case 86:
            return this.pushState("text"), 67;
          case 87:
            return this.popState(), 64;
          case 88:
            return this.pushState("text"), 63;
          case 89:
            return this.popState(), 49;
          case 90:
            return this.pushState("text"), 48;
          case 91:
            return this.popState(), 69;
          case 92:
            return this.popState(), 71;
          case 93:
            return 117;
          case 94:
            return this.pushState("trapText"), 68;
          case 95:
            return this.pushState("trapText"), 70;
          case 96:
            return 118;
          case 97:
            return 67;
          case 98:
            return 90;
          case 99:
            return "SEP";
          case 100:
            return 89;
          case 101:
            return 115;
          case 102:
            return 111;
          case 103:
            return 44;
          case 104:
            return 109;
          case 105:
            return 114;
          case 106:
            return 116;
          case 107:
            return this.popState(), 62;
          case 108:
            return this.pushState("text"), 62;
          case 109:
            return this.popState(), 51;
          case 110:
            return this.pushState("text"), 50;
          case 111:
            return this.popState(), 31;
          case 112:
            return this.pushState("text"), 29;
          case 113:
            return this.popState(), 66;
          case 114:
            return this.pushState("text"), 65;
          case 115:
            return "TEXT";
          case 116:
            return "QUOTE";
          case 117:
            return 9;
          case 118:
            return 10;
          case 119:
            return 11;
        }
      }, "anonymous"),
      rules: [/^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:@\{)/, /^(?:["])/, /^(?:["])/, /^(?:[^\"]+)/, /^(?:[^}^"]+)/, /^(?:\})/, /^(?:call[\s]+)/, /^(?:\([\s]*\))/, /^(?:\()/, /^(?:[^(]*)/, /^(?:\))/, /^(?:[^)]*)/, /^(?:[^`"]+)/, /^(?:[`]["])/, /^(?:["][`])/, /^(?:[^"]+)/, /^(?:["])/, /^(?:["])/, /^(?:style\b)/, /^(?:default\b)/, /^(?:linkStyle\b)/, /^(?:interpolate\b)/, /^(?:classDef\b)/, /^(?:class\b)/, /^(?:href[\s])/, /^(?:click[\s]+)/, /^(?:[\s\n])/, /^(?:[^\s\n]*)/, /^(?:flowchart-elk\b)/, /^(?:graph\b)/, /^(?:flowchart\b)/, /^(?:subgraph\b)/, /^(?:end\b\s*)/, /^(?:_self\b)/, /^(?:_blank\b)/, /^(?:_parent\b)/, /^(?:_top\b)/, /^(?:(\r?\n)*\s*\n)/, /^(?:\s*LR\b)/, /^(?:\s*RL\b)/, /^(?:\s*TB\b)/, /^(?:\s*BT\b)/, /^(?:\s*TD\b)/, /^(?:\s*BR\b)/, /^(?:\s*<)/, /^(?:\s*>)/, /^(?:\s*\^)/, /^(?:\s*v\b)/, /^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:[^\s\"]+@(?=[^\{\"]))/, /^(?:[0-9]+)/, /^(?:#)/, /^(?::::)/, /^(?::)/, /^(?:&)/, /^(?:;)/, /^(?:,)/, /^(?:\*)/, /^(?:\s*[xo<]?--+[-xo>]\s*)/, /^(?:\s*[xo<]?--\s*)/, /^(?:[^-]|-(?!-)+)/, /^(?:\s*[xo<]?==+[=xo>]\s*)/, /^(?:\s*[xo<]?==\s*)/, /^(?:[^=]|=(?!))/, /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/, /^(?:\s*[xo<]?-\.\s*)/, /^(?:[^\.]|\.(?!))/, /^(?:\s*~~[\~]+\s*)/, /^(?:[-/\)][\)])/, /^(?:[^\(\)\[\]\{\}]|!\)+)/, /^(?:\(-)/, /^(?:\]\))/, /^(?:\(\[)/, /^(?:\]\])/, /^(?:\[\[)/, /^(?:\[\|)/, /^(?:>)/, /^(?:\)\])/, /^(?:\[\()/, /^(?:\)\)\))/, /^(?:\(\(\()/, /^(?:[\\(?=\])][\]])/, /^(?:\/(?=\])\])/, /^(?:\/(?!\])|\\(?!\])|[^\\\[\]\(\)\{\}\/]+)/, /^(?:\[\/)/, /^(?:\[\\)/, /^(?:<)/, /^(?:>)/, /^(?:\^)/, /^(?:\\\|)/, /^(?:v\b)/, /^(?:\*)/, /^(?:#)/, /^(?:&)/, /^(?:([A-Za-z0-9!"\#$%&'*+\.`?\\_\/]|-(?=[^\>\-\.])|(?!))+)/, /^(?:-)/, /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/, /^(?:\|)/, /^(?:\|)/, /^(?:\))/, /^(?:\()/, /^(?:\])/, /^(?:\[)/, /^(?:(\}))/, /^(?:\{)/, /^(?:[^\[\]\(\)\{\}\|\"]+)/, /^(?:")/, /^(?:(\r?\n)+)/, /^(?:\s)/, /^(?:$)/],
      conditions: { shapeDataEndBracket: { rules: [21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, shapeDataStr: { rules: [9, 10, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, shapeData: { rules: [8, 11, 12, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, callbackargs: { rules: [17, 18, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, callbackname: { rules: [14, 15, 16, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, href: { rules: [21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, click: { rules: [21, 24, 33, 34, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, dottedEdgeText: { rules: [21, 24, 74, 76, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, thickEdgeText: { rules: [21, 24, 71, 73, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, edgeText: { rules: [21, 24, 68, 70, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, trapText: { rules: [21, 24, 77, 80, 82, 84, 88, 90, 91, 92, 93, 94, 95, 108, 110, 112, 114], inclusive: !1 }, ellipseText: { rules: [21, 24, 77, 78, 79, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, text: { rules: [21, 24, 77, 80, 81, 82, 83, 84, 87, 88, 89, 90, 94, 95, 107, 108, 109, 110, 111, 112, 113, 114, 115], inclusive: !1 }, vertex: { rules: [21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, dir: { rules: [21, 24, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, acc_descr_multiline: { rules: [5, 6, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, acc_descr: { rules: [3, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, acc_title: { rules: [1, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, md_string: { rules: [19, 20, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, string: { rules: [21, 22, 23, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, INITIAL: { rules: [0, 2, 4, 7, 13, 21, 24, 25, 26, 27, 28, 29, 30, 31, 32, 35, 36, 37, 38, 39, 40, 41, 42, 43, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 71, 72, 74, 75, 77, 80, 82, 84, 85, 86, 88, 90, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 110, 112, 114, 116, 117, 118, 119], inclusive: !0 } }
    };
    return wn;
  })();
  Xr.lexer = gi;
  function bn() {
    this.yy = {};
  }
  return x(bn, "Parser"), bn.prototype = Xr, Xr.Parser = bn, new bn();
})();
OT.parser = OT;
var vH = OT, yH = Object.assign({}, vH);
yH.parse = (t) => {
  const e = t.replace(/}\s*\n/g, `}
`);
  return vH.parse(e);
};
var Wwe = yH, Ywe = /* @__PURE__ */ x((t, e) => {
  const r = iE, n = r(t, "r"), i = r(t, "g"), a = r(t, "b");
  return Fl(n, i, a, e);
}, "fade"), Xwe = /* @__PURE__ */ x((t) => `.label {
    font-family: ${t.fontFamily};
    color: ${t.nodeTextColor || t.textColor};
  }
  .cluster-label text {
    fill: ${t.titleColor};
  }
  .cluster-label span {
    color: ${t.titleColor};
  }
  .cluster-label span p {
    background-color: transparent;
  }

  .label text,span {
    fill: ${t.nodeTextColor || t.textColor};
    color: ${t.nodeTextColor || t.textColor};
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${t.mainBkg};
    stroke: ${t.nodeBorder};
    stroke-width: 1px;
  }
  .rough-node .label text , .node .label text, .image-shape .label, .icon-shape .label {
    text-anchor: middle;
  }
  // .flowchart-label .text-outer-tspan {
  //   text-anchor: middle;
  // }
  // .flowchart-label .text-inner-tspan {
  //   text-anchor: start;
  // }

  .node .katex path {
    fill: #000;
    stroke: #000;
    stroke-width: 1px;
  }

  .rough-node .label,.node .label, .image-shape .label, .icon-shape .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }


  .root .anchor path {
    fill: ${t.lineColor} !important;
    stroke-width: 0;
    stroke: ${t.lineColor};
  }

  .arrowheadPath {
    fill: ${t.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${t.lineColor};
    stroke-width: 2.0px;
  }

  .flowchart-link {
    stroke: ${t.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${t.edgeLabelBackground};
    p {
      background-color: ${t.edgeLabelBackground};
    }
    rect {
      opacity: 0.5;
      background-color: ${t.edgeLabelBackground};
      fill: ${t.edgeLabelBackground};
    }
    text-align: center;
  }

  /* For html labels only */
  .labelBkg {
    background-color: ${Ywe(t.edgeLabelBackground, 0.5)};
    // background-color:
  }

  .cluster rect {
    fill: ${t.clusterBkg};
    stroke: ${t.clusterBorder};
    stroke-width: 1px;
  }

  .cluster text {
    fill: ${t.titleColor};
  }

  .cluster span {
    color: ${t.titleColor};
  }
  /* .cluster div {
    color: ${t.titleColor};
  } */

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${t.fontFamily};
    font-size: 12px;
    background: ${t.tertiaryColor};
    border: 1px solid ${t.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .flowchartTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${t.textColor};
  }

  rect.text {
    fill: none;
    stroke-width: 0;
  }

  .icon-shape, .image-shape {
    background-color: ${t.edgeLabelBackground};
    p {
      background-color: ${t.edgeLabelBackground};
      padding: 2px;
    }
    rect {
      opacity: 0.5;
      background-color: ${t.edgeLabelBackground};
      fill: ${t.edgeLabelBackground};
    }
    text-align: center;
  }
  ${Dg()}
`, "getStyles"), jwe = Xwe, Kwe = {
  parser: Wwe,
  get db() {
    return new Vwe();
  },
  renderer: qwe,
  styles: jwe,
  init: /* @__PURE__ */ x((t) => {
    t.flowchart || (t.flowchart = {}), t.layout && rw({ layout: t.layout }), t.flowchart.arrowMarkerAbsolute = t.arrowMarkerAbsolute, rw({ flowchart: { arrowMarkerAbsolute: t.arrowMarkerAbsolute } });
  }, "init")
};
const kS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: Kwe
}, Symbol.toStringTag, { value: "Module" }));
var PT = (function() {
  var t = /* @__PURE__ */ x(function(Y, ee, j, fe) {
    for (j = j || {}, fe = Y.length; fe--; j[Y[fe]] = ee) ;
    return j;
  }, "o"), e = [6, 8, 10, 22, 24, 26, 28, 33, 34, 35, 36, 37, 40, 43, 44, 50], r = [1, 10], n = [1, 11], i = [1, 12], a = [1, 13], s = [1, 20], o = [1, 21], l = [1, 22], u = [1, 23], h = [1, 24], d = [1, 19], f = [1, 25], p = [1, 26], g = [1, 18], m = [1, 33], v = [1, 34], y = [1, 35], b = [1, 36], w = [1, 37], T = [6, 8, 10, 13, 15, 17, 20, 21, 22, 24, 26, 28, 33, 34, 35, 36, 37, 40, 43, 44, 50, 63, 64, 65, 66, 67], E = [1, 42], L = [1, 43], k = [1, 52], C = [40, 50, 68, 69], A = [1, 63], R = [1, 61], _ = [1, 58], O = [1, 62], P = [1, 64], S = [6, 8, 10, 13, 17, 22, 24, 26, 28, 33, 34, 35, 36, 37, 40, 41, 42, 43, 44, 48, 49, 50, 63, 64, 65, 66, 67], M = [63, 64, 65, 66, 67], N = [1, 81], D = [1, 80], I = [1, 78], B = [1, 79], z = [6, 10, 42, 47], F = [6, 10, 13, 41, 42, 47, 48, 49], V = [1, 89], H = [1, 88], J = [1, 87], q = [19, 56], ae = [1, 98], re = [1, 97], pe = [19, 56, 58, 60], K = {
    trace: /* @__PURE__ */ x(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, ER_DIAGRAM: 4, document: 5, EOF: 6, line: 7, SPACE: 8, statement: 9, NEWLINE: 10, entityName: 11, relSpec: 12, COLON: 13, role: 14, STYLE_SEPARATOR: 15, idList: 16, BLOCK_START: 17, attributes: 18, BLOCK_STOP: 19, SQS: 20, SQE: 21, title: 22, title_value: 23, acc_title: 24, acc_title_value: 25, acc_descr: 26, acc_descr_value: 27, acc_descr_multiline_value: 28, direction: 29, classDefStatement: 30, classStatement: 31, styleStatement: 32, direction_tb: 33, direction_bt: 34, direction_rl: 35, direction_lr: 36, CLASSDEF: 37, stylesOpt: 38, separator: 39, UNICODE_TEXT: 40, STYLE_TEXT: 41, COMMA: 42, CLASS: 43, STYLE: 44, style: 45, styleComponent: 46, SEMI: 47, NUM: 48, BRKT: 49, ENTITY_NAME: 50, attribute: 51, attributeType: 52, attributeName: 53, attributeKeyTypeList: 54, attributeComment: 55, ATTRIBUTE_WORD: 56, attributeKeyType: 57, ",": 58, ATTRIBUTE_KEY: 59, COMMENT: 60, cardinality: 61, relType: 62, ZERO_OR_ONE: 63, ZERO_OR_MORE: 64, ONE_OR_MORE: 65, ONLY_ONE: 66, MD_PARENT: 67, NON_IDENTIFYING: 68, IDENTIFYING: 69, WORD: 70, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "ER_DIAGRAM", 6: "EOF", 8: "SPACE", 10: "NEWLINE", 13: "COLON", 15: "STYLE_SEPARATOR", 17: "BLOCK_START", 19: "BLOCK_STOP", 20: "SQS", 21: "SQE", 22: "title", 23: "title_value", 24: "acc_title", 25: "acc_title_value", 26: "acc_descr", 27: "acc_descr_value", 28: "acc_descr_multiline_value", 33: "direction_tb", 34: "direction_bt", 35: "direction_rl", 36: "direction_lr", 37: "CLASSDEF", 40: "UNICODE_TEXT", 41: "STYLE_TEXT", 42: "COMMA", 43: "CLASS", 44: "STYLE", 47: "SEMI", 48: "NUM", 49: "BRKT", 50: "ENTITY_NAME", 56: "ATTRIBUTE_WORD", 58: ",", 59: "ATTRIBUTE_KEY", 60: "COMMENT", 63: "ZERO_OR_ONE", 64: "ZERO_OR_MORE", 65: "ONE_OR_MORE", 66: "ONLY_ONE", 67: "MD_PARENT", 68: "NON_IDENTIFYING", 69: "IDENTIFYING", 70: "WORD" },
    productions_: [0, [3, 3], [5, 0], [5, 2], [7, 2], [7, 1], [7, 1], [7, 1], [9, 5], [9, 9], [9, 7], [9, 7], [9, 4], [9, 6], [9, 3], [9, 5], [9, 1], [9, 3], [9, 7], [9, 9], [9, 6], [9, 8], [9, 4], [9, 6], [9, 2], [9, 2], [9, 2], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [29, 1], [29, 1], [29, 1], [29, 1], [30, 4], [16, 1], [16, 1], [16, 3], [16, 3], [31, 3], [32, 4], [38, 1], [38, 3], [45, 1], [45, 2], [39, 1], [39, 1], [39, 1], [46, 1], [46, 1], [46, 1], [46, 1], [11, 1], [11, 1], [18, 1], [18, 2], [51, 2], [51, 3], [51, 3], [51, 4], [52, 1], [53, 1], [54, 1], [54, 3], [57, 1], [55, 1], [12, 3], [61, 1], [61, 1], [61, 1], [61, 1], [61, 1], [62, 1], [62, 1], [14, 1], [14, 1], [14, 1]],
    performAction: /* @__PURE__ */ x(function(ee, j, fe, te, Ae, W, De) {
      var ue = W.length - 1;
      switch (Ae) {
        case 1:
          break;
        case 2:
          this.$ = [];
          break;
        case 3:
          W[ue - 1].push(W[ue]), this.$ = W[ue - 1];
          break;
        case 4:
        case 5:
          this.$ = W[ue];
          break;
        case 6:
        case 7:
          this.$ = [];
          break;
        case 8:
          te.addEntity(W[ue - 4]), te.addEntity(W[ue - 2]), te.addRelationship(W[ue - 4], W[ue], W[ue - 2], W[ue - 3]);
          break;
        case 9:
          te.addEntity(W[ue - 8]), te.addEntity(W[ue - 4]), te.addRelationship(W[ue - 8], W[ue], W[ue - 4], W[ue - 5]), te.setClass([W[ue - 8]], W[ue - 6]), te.setClass([W[ue - 4]], W[ue - 2]);
          break;
        case 10:
          te.addEntity(W[ue - 6]), te.addEntity(W[ue - 2]), te.addRelationship(W[ue - 6], W[ue], W[ue - 2], W[ue - 3]), te.setClass([W[ue - 6]], W[ue - 4]);
          break;
        case 11:
          te.addEntity(W[ue - 6]), te.addEntity(W[ue - 4]), te.addRelationship(W[ue - 6], W[ue], W[ue - 4], W[ue - 5]), te.setClass([W[ue - 4]], W[ue - 2]);
          break;
        case 12:
          te.addEntity(W[ue - 3]), te.addAttributes(W[ue - 3], W[ue - 1]);
          break;
        case 13:
          te.addEntity(W[ue - 5]), te.addAttributes(W[ue - 5], W[ue - 1]), te.setClass([W[ue - 5]], W[ue - 3]);
          break;
        case 14:
          te.addEntity(W[ue - 2]);
          break;
        case 15:
          te.addEntity(W[ue - 4]), te.setClass([W[ue - 4]], W[ue - 2]);
          break;
        case 16:
          te.addEntity(W[ue]);
          break;
        case 17:
          te.addEntity(W[ue - 2]), te.setClass([W[ue - 2]], W[ue]);
          break;
        case 18:
          te.addEntity(W[ue - 6], W[ue - 4]), te.addAttributes(W[ue - 6], W[ue - 1]);
          break;
        case 19:
          te.addEntity(W[ue - 8], W[ue - 6]), te.addAttributes(W[ue - 8], W[ue - 1]), te.setClass([W[ue - 8]], W[ue - 3]);
          break;
        case 20:
          te.addEntity(W[ue - 5], W[ue - 3]);
          break;
        case 21:
          te.addEntity(W[ue - 7], W[ue - 5]), te.setClass([W[ue - 7]], W[ue - 2]);
          break;
        case 22:
          te.addEntity(W[ue - 3], W[ue - 1]);
          break;
        case 23:
          te.addEntity(W[ue - 5], W[ue - 3]), te.setClass([W[ue - 5]], W[ue]);
          break;
        case 24:
        case 25:
          this.$ = W[ue].trim(), te.setAccTitle(this.$);
          break;
        case 26:
        case 27:
          this.$ = W[ue].trim(), te.setAccDescription(this.$);
          break;
        case 32:
          te.setDirection("TB");
          break;
        case 33:
          te.setDirection("BT");
          break;
        case 34:
          te.setDirection("RL");
          break;
        case 35:
          te.setDirection("LR");
          break;
        case 36:
          this.$ = W[ue - 3], te.addClass(W[ue - 2], W[ue - 1]);
          break;
        case 37:
        case 38:
        case 56:
        case 64:
          this.$ = [W[ue]];
          break;
        case 39:
        case 40:
          this.$ = W[ue - 2].concat([W[ue]]);
          break;
        case 41:
          this.$ = W[ue - 2], te.setClass(W[ue - 1], W[ue]);
          break;
        case 42:
          this.$ = W[ue - 3], te.addCssStyles(W[ue - 2], W[ue - 1]);
          break;
        case 43:
          this.$ = [W[ue]];
          break;
        case 44:
          W[ue - 2].push(W[ue]), this.$ = W[ue - 2];
          break;
        case 46:
          this.$ = W[ue - 1] + W[ue];
          break;
        case 54:
        case 76:
        case 77:
          this.$ = W[ue].replace(/"/g, "");
          break;
        case 55:
        case 78:
          this.$ = W[ue];
          break;
        case 57:
          W[ue].push(W[ue - 1]), this.$ = W[ue];
          break;
        case 58:
          this.$ = { type: W[ue - 1], name: W[ue] };
          break;
        case 59:
          this.$ = { type: W[ue - 2], name: W[ue - 1], keys: W[ue] };
          break;
        case 60:
          this.$ = { type: W[ue - 2], name: W[ue - 1], comment: W[ue] };
          break;
        case 61:
          this.$ = { type: W[ue - 3], name: W[ue - 2], keys: W[ue - 1], comment: W[ue] };
          break;
        case 62:
        case 63:
        case 66:
          this.$ = W[ue];
          break;
        case 65:
          W[ue - 2].push(W[ue]), this.$ = W[ue - 2];
          break;
        case 67:
          this.$ = W[ue].replace(/"/g, "");
          break;
        case 68:
          this.$ = { cardA: W[ue], relType: W[ue - 1], cardB: W[ue - 2] };
          break;
        case 69:
          this.$ = te.Cardinality.ZERO_OR_ONE;
          break;
        case 70:
          this.$ = te.Cardinality.ZERO_OR_MORE;
          break;
        case 71:
          this.$ = te.Cardinality.ONE_OR_MORE;
          break;
        case 72:
          this.$ = te.Cardinality.ONLY_ONE;
          break;
        case 73:
          this.$ = te.Cardinality.MD_PARENT;
          break;
        case 74:
          this.$ = te.Identification.NON_IDENTIFYING;
          break;
        case 75:
          this.$ = te.Identification.IDENTIFYING;
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, t(e, [2, 2], { 5: 3 }), { 6: [1, 4], 7: 5, 8: [1, 6], 9: 7, 10: [1, 8], 11: 9, 22: r, 24: n, 26: i, 28: a, 29: 14, 30: 15, 31: 16, 32: 17, 33: s, 34: o, 35: l, 36: u, 37: h, 40: d, 43: f, 44: p, 50: g }, t(e, [2, 7], { 1: [2, 1] }), t(e, [2, 3]), { 9: 27, 11: 9, 22: r, 24: n, 26: i, 28: a, 29: 14, 30: 15, 31: 16, 32: 17, 33: s, 34: o, 35: l, 36: u, 37: h, 40: d, 43: f, 44: p, 50: g }, t(e, [2, 5]), t(e, [2, 6]), t(e, [2, 16], { 12: 28, 61: 32, 15: [1, 29], 17: [1, 30], 20: [1, 31], 63: m, 64: v, 65: y, 66: b, 67: w }), { 23: [1, 38] }, { 25: [1, 39] }, { 27: [1, 40] }, t(e, [2, 27]), t(e, [2, 28]), t(e, [2, 29]), t(e, [2, 30]), t(e, [2, 31]), t(T, [2, 54]), t(T, [2, 55]), t(e, [2, 32]), t(e, [2, 33]), t(e, [2, 34]), t(e, [2, 35]), { 16: 41, 40: E, 41: L }, { 16: 44, 40: E, 41: L }, { 16: 45, 40: E, 41: L }, t(e, [2, 4]), { 11: 46, 40: d, 50: g }, { 16: 47, 40: E, 41: L }, { 18: 48, 19: [1, 49], 51: 50, 52: 51, 56: k }, { 11: 53, 40: d, 50: g }, { 62: 54, 68: [1, 55], 69: [1, 56] }, t(C, [2, 69]), t(C, [2, 70]), t(C, [2, 71]), t(C, [2, 72]), t(C, [2, 73]), t(e, [2, 24]), t(e, [2, 25]), t(e, [2, 26]), { 13: A, 38: 57, 41: R, 42: _, 45: 59, 46: 60, 48: O, 49: P }, t(S, [2, 37]), t(S, [2, 38]), { 16: 65, 40: E, 41: L, 42: _ }, { 13: A, 38: 66, 41: R, 42: _, 45: 59, 46: 60, 48: O, 49: P }, { 13: [1, 67], 15: [1, 68] }, t(e, [2, 17], { 61: 32, 12: 69, 17: [1, 70], 42: _, 63: m, 64: v, 65: y, 66: b, 67: w }), { 19: [1, 71] }, t(e, [2, 14]), { 18: 72, 19: [2, 56], 51: 50, 52: 51, 56: k }, { 53: 73, 56: [1, 74] }, { 56: [2, 62] }, { 21: [1, 75] }, { 61: 76, 63: m, 64: v, 65: y, 66: b, 67: w }, t(M, [2, 74]), t(M, [2, 75]), { 6: N, 10: D, 39: 77, 42: I, 47: B }, { 40: [1, 82], 41: [1, 83] }, t(z, [2, 43], { 46: 84, 13: A, 41: R, 48: O, 49: P }), t(F, [2, 45]), t(F, [2, 50]), t(F, [2, 51]), t(F, [2, 52]), t(F, [2, 53]), t(e, [2, 41], { 42: _ }), { 6: N, 10: D, 39: 85, 42: I, 47: B }, { 14: 86, 40: V, 50: H, 70: J }, { 16: 90, 40: E, 41: L }, { 11: 91, 40: d, 50: g }, { 18: 92, 19: [1, 93], 51: 50, 52: 51, 56: k }, t(e, [2, 12]), { 19: [2, 57] }, t(q, [2, 58], { 54: 94, 55: 95, 57: 96, 59: ae, 60: re }), t([19, 56, 59, 60], [2, 63]), t(e, [2, 22], { 15: [1, 100], 17: [1, 99] }), t([40, 50], [2, 68]), t(e, [2, 36]), { 13: A, 41: R, 45: 101, 46: 60, 48: O, 49: P }, t(e, [2, 47]), t(e, [2, 48]), t(e, [2, 49]), t(S, [2, 39]), t(S, [2, 40]), t(F, [2, 46]), t(e, [2, 42]), t(e, [2, 8]), t(e, [2, 76]), t(e, [2, 77]), t(e, [2, 78]), { 13: [1, 102], 42: _ }, { 13: [1, 104], 15: [1, 103] }, { 19: [1, 105] }, t(e, [2, 15]), t(q, [2, 59], { 55: 106, 58: [1, 107], 60: re }), t(q, [2, 60]), t(pe, [2, 64]), t(q, [2, 67]), t(pe, [2, 66]), { 18: 108, 19: [1, 109], 51: 50, 52: 51, 56: k }, { 16: 110, 40: E, 41: L }, t(z, [2, 44], { 46: 84, 13: A, 41: R, 48: O, 49: P }), { 14: 111, 40: V, 50: H, 70: J }, { 16: 112, 40: E, 41: L }, { 14: 113, 40: V, 50: H, 70: J }, t(e, [2, 13]), t(q, [2, 61]), { 57: 114, 59: ae }, { 19: [1, 115] }, t(e, [2, 20]), t(e, [2, 23], { 17: [1, 116], 42: _ }), t(e, [2, 11]), { 13: [1, 117], 42: _ }, t(e, [2, 10]), t(pe, [2, 65]), t(e, [2, 18]), { 18: 118, 19: [1, 119], 51: 50, 52: 51, 56: k }, { 14: 120, 40: V, 50: H, 70: J }, { 19: [1, 121] }, t(e, [2, 21]), t(e, [2, 9]), t(e, [2, 19])],
    defaultActions: { 52: [2, 62], 72: [2, 57] },
    parseError: /* @__PURE__ */ x(function(ee, j) {
      if (j.recoverable)
        this.trace(ee);
      else {
        var fe = new Error(ee);
        throw fe.hash = j, fe;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ x(function(ee) {
      var j = this, fe = [0], te = [], Ae = [null], W = [], De = this.table, ue = "", ze = 0, Ge = 0, Ve = 2, ke = 1, Oe = W.slice.call(arguments, 1), Se = Object.create(this.lexer), _e = { yy: {} };
      for (var $e in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, $e) && (_e.yy[$e] = this.yy[$e]);
      Se.setInput(ee, _e.yy), _e.yy.lexer = Se, _e.yy.parser = this, typeof Se.yylloc > "u" && (Se.yylloc = {});
      var me = Se.yylloc;
      W.push(me);
      var Ne = Se.options && Se.options.ranges;
      typeof _e.yy.parseError == "function" ? this.parseError = _e.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Q(We) {
        fe.length = fe.length - 2 * We, Ae.length = Ae.length - We, W.length = W.length - We;
      }
      x(Q, "popStack");
      function ce() {
        var We;
        return We = te.pop() || Se.lex() || ke, typeof We != "number" && (We instanceof Array && (te = We, We = te.pop()), We = j.symbols_[We] || We), We;
      }
      x(ce, "lex");
      for (var $, oe, se, ge, he = {}, be, Ce, Te, Me; ; ) {
        if (oe = fe[fe.length - 1], this.defaultActions[oe] ? se = this.defaultActions[oe] : (($ === null || typeof $ > "u") && ($ = ce()), se = De[oe] && De[oe][$]), typeof se > "u" || !se.length || !se[0]) {
          var Xe = "";
          Me = [];
          for (be in De[oe])
            this.terminals_[be] && be > Ve && Me.push("'" + this.terminals_[be] + "'");
          Se.showPosition ? Xe = "Parse error on line " + (ze + 1) + `:
` + Se.showPosition() + `
Expecting ` + Me.join(", ") + ", got '" + (this.terminals_[$] || $) + "'" : Xe = "Parse error on line " + (ze + 1) + ": Unexpected " + ($ == ke ? "end of input" : "'" + (this.terminals_[$] || $) + "'"), this.parseError(Xe, {
            text: Se.match,
            token: this.terminals_[$] || $,
            line: Se.yylineno,
            loc: me,
            expected: Me
          });
        }
        if (se[0] instanceof Array && se.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + oe + ", token: " + $);
        switch (se[0]) {
          case 1:
            fe.push($), Ae.push(Se.yytext), W.push(Se.yylloc), fe.push(se[1]), $ = null, Ge = Se.yyleng, ue = Se.yytext, ze = Se.yylineno, me = Se.yylloc;
            break;
          case 2:
            if (Ce = this.productions_[se[1]][1], he.$ = Ae[Ae.length - Ce], he._$ = {
              first_line: W[W.length - (Ce || 1)].first_line,
              last_line: W[W.length - 1].last_line,
              first_column: W[W.length - (Ce || 1)].first_column,
              last_column: W[W.length - 1].last_column
            }, Ne && (he._$.range = [
              W[W.length - (Ce || 1)].range[0],
              W[W.length - 1].range[1]
            ]), ge = this.performAction.apply(he, [
              ue,
              Ge,
              ze,
              _e.yy,
              se[1],
              Ae,
              W
            ].concat(Oe)), typeof ge < "u")
              return ge;
            Ce && (fe = fe.slice(0, -1 * Ce * 2), Ae = Ae.slice(0, -1 * Ce), W = W.slice(0, -1 * Ce)), fe.push(this.productions_[se[1]][0]), Ae.push(he.$), W.push(he._$), Te = De[fe[fe.length - 2]][fe[fe.length - 1]], fe.push(Te);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, Z = /* @__PURE__ */ (function() {
    var Y = {
      EOF: 1,
      parseError: /* @__PURE__ */ x(function(j, fe) {
        if (this.yy.parser)
          this.yy.parser.parseError(j, fe);
        else
          throw new Error(j);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ x(function(ee, j) {
        return this.yy = j || this.yy || {}, this._input = ee, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ x(function() {
        var ee = this._input[0];
        this.yytext += ee, this.yyleng++, this.offset++, this.match += ee, this.matched += ee;
        var j = ee.match(/(?:\r\n?|\n).*/g);
        return j ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), ee;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ x(function(ee) {
        var j = ee.length, fe = ee.split(/(?:\r\n?|\n)/g);
        this._input = ee + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - j), this.offset -= j;
        var te = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), fe.length - 1 && (this.yylineno -= fe.length - 1);
        var Ae = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: fe ? (fe.length === te.length ? this.yylloc.first_column : 0) + te[te.length - fe.length].length - fe[0].length : this.yylloc.first_column - j
        }, this.options.ranges && (this.yylloc.range = [Ae[0], Ae[0] + this.yyleng - j]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ x(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ x(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ x(function(ee) {
        this.unput(this.match.slice(ee));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ x(function() {
        var ee = this.matched.substr(0, this.matched.length - this.match.length);
        return (ee.length > 20 ? "..." : "") + ee.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ x(function() {
        var ee = this.match;
        return ee.length < 20 && (ee += this._input.substr(0, 20 - ee.length)), (ee.substr(0, 20) + (ee.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ x(function() {
        var ee = this.pastInput(), j = new Array(ee.length + 1).join("-");
        return ee + this.upcomingInput() + `
` + j + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ x(function(ee, j) {
        var fe, te, Ae;
        if (this.options.backtrack_lexer && (Ae = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (Ae.yylloc.range = this.yylloc.range.slice(0))), te = ee[0].match(/(?:\r\n?|\n).*/g), te && (this.yylineno += te.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: te ? te[te.length - 1].length - te[te.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + ee[0].length
        }, this.yytext += ee[0], this.match += ee[0], this.matches = ee, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(ee[0].length), this.matched += ee[0], fe = this.performAction.call(this, this.yy, this, j, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), fe)
          return fe;
        if (this._backtrack) {
          for (var W in Ae)
            this[W] = Ae[W];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ x(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var ee, j, fe, te;
        this._more || (this.yytext = "", this.match = "");
        for (var Ae = this._currentRules(), W = 0; W < Ae.length; W++)
          if (fe = this._input.match(this.rules[Ae[W]]), fe && (!j || fe[0].length > j[0].length)) {
            if (j = fe, te = W, this.options.backtrack_lexer) {
              if (ee = this.test_match(fe, Ae[W]), ee !== !1)
                return ee;
              if (this._backtrack) {
                j = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return j ? (ee = this.test_match(j, Ae[te]), ee !== !1 ? ee : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ x(function() {
        var j = this.next();
        return j || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ x(function(j) {
        this.conditionStack.push(j);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ x(function() {
        var j = this.conditionStack.length - 1;
        return j > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ x(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ x(function(j) {
        return j = this.conditionStack.length - 1 - Math.abs(j || 0), j >= 0 ? this.conditionStack[j] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ x(function(j) {
        this.begin(j);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ x(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ x(function(j, fe, te, Ae) {
        switch (te) {
          case 0:
            return this.begin("acc_title"), 24;
          case 1:
            return this.popState(), "acc_title_value";
          case 2:
            return this.begin("acc_descr"), 26;
          case 3:
            return this.popState(), "acc_descr_value";
          case 4:
            this.begin("acc_descr_multiline");
            break;
          case 5:
            this.popState();
            break;
          case 6:
            return "acc_descr_multiline_value";
          case 7:
            return 33;
          case 8:
            return 34;
          case 9:
            return 35;
          case 10:
            return 36;
          case 11:
            return 10;
          case 12:
            break;
          case 13:
            return 8;
          case 14:
            return 50;
          case 15:
            return 70;
          case 16:
            return 4;
          case 17:
            return this.begin("block"), 17;
          case 18:
            return 49;
          case 19:
            return 49;
          case 20:
            return 42;
          case 21:
            return 15;
          case 22:
            return 13;
          case 23:
            break;
          case 24:
            return 59;
          case 25:
            return 56;
          case 26:
            return 56;
          case 27:
            return 60;
          case 28:
            break;
          case 29:
            return this.popState(), 19;
          case 30:
            return fe.yytext[0];
          case 31:
            return 20;
          case 32:
            return 21;
          case 33:
            return this.begin("style"), 44;
          case 34:
            return this.popState(), 10;
          case 35:
            break;
          case 36:
            return 13;
          case 37:
            return 42;
          case 38:
            return 49;
          case 39:
            return this.begin("style"), 37;
          case 40:
            return 43;
          case 41:
            return 63;
          case 42:
            return 65;
          case 43:
            return 65;
          case 44:
            return 65;
          case 45:
            return 63;
          case 46:
            return 63;
          case 47:
            return 64;
          case 48:
            return 64;
          case 49:
            return 64;
          case 50:
            return 64;
          case 51:
            return 64;
          case 52:
            return 65;
          case 53:
            return 64;
          case 54:
            return 65;
          case 55:
            return 66;
          case 56:
            return 66;
          case 57:
            return 66;
          case 58:
            return 66;
          case 59:
            return 63;
          case 60:
            return 64;
          case 61:
            return 65;
          case 62:
            return 67;
          case 63:
            return 68;
          case 64:
            return 69;
          case 65:
            return 69;
          case 66:
            return 68;
          case 67:
            return 68;
          case 68:
            return 68;
          case 69:
            return 41;
          case 70:
            return 47;
          case 71:
            return 40;
          case 72:
            return 48;
          case 73:
            return fe.yytext[0];
          case 74:
            return 6;
        }
      }, "anonymous"),
      rules: [/^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:[\s]+)/i, /^(?:"[^"%\r\n\v\b\\]+")/i, /^(?:"[^"]*")/i, /^(?:erDiagram\b)/i, /^(?:\{)/i, /^(?:#)/i, /^(?:#)/i, /^(?:,)/i, /^(?::::)/i, /^(?::)/i, /^(?:\s+)/i, /^(?:\b((?:PK)|(?:FK)|(?:UK))\b)/i, /^(?:([^\s]*)[~].*[~]([^\s]*))/i, /^(?:([\*A-Za-z_\u00C0-\uFFFF][A-Za-z0-9\-\_\[\]\(\)\u00C0-\uFFFF\*]*))/i, /^(?:"[^"]*")/i, /^(?:[\n]+)/i, /^(?:\})/i, /^(?:.)/i, /^(?:\[)/i, /^(?:\])/i, /^(?:style\b)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?::)/i, /^(?:,)/i, /^(?:#)/i, /^(?:classDef\b)/i, /^(?:class\b)/i, /^(?:one or zero\b)/i, /^(?:one or more\b)/i, /^(?:one or many\b)/i, /^(?:1\+)/i, /^(?:\|o\b)/i, /^(?:zero or one\b)/i, /^(?:zero or more\b)/i, /^(?:zero or many\b)/i, /^(?:0\+)/i, /^(?:\}o\b)/i, /^(?:many\(0\))/i, /^(?:many\(1\))/i, /^(?:many\b)/i, /^(?:\}\|)/i, /^(?:one\b)/i, /^(?:only one\b)/i, /^(?:1\b)/i, /^(?:\|\|)/i, /^(?:o\|)/i, /^(?:o\{)/i, /^(?:\|\{)/i, /^(?:\s*u\b)/i, /^(?:\.\.)/i, /^(?:--)/i, /^(?:to\b)/i, /^(?:optionally to\b)/i, /^(?:\.-)/i, /^(?:-\.)/i, /^(?:([^\x00-\x7F]|\w|-|\*)+)/i, /^(?:;)/i, /^(?:([^\x00-\x7F]|\w|-|\*)+)/i, /^(?:[0-9])/i, /^(?:.)/i, /^(?:$)/i],
      conditions: { style: { rules: [34, 35, 36, 37, 38, 69, 70], inclusive: !1 }, acc_descr_multiline: { rules: [5, 6], inclusive: !1 }, acc_descr: { rules: [3], inclusive: !1 }, acc_title: { rules: [1], inclusive: !1 }, block: { rules: [23, 24, 25, 26, 27, 28, 29, 30], inclusive: !1 }, INITIAL: { rules: [0, 2, 4, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 31, 32, 33, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 71, 72, 73, 74], inclusive: !0 } }
    };
    return Y;
  })();
  K.lexer = Z;
  function X() {
    this.yy = {};
  }
  return x(X, "Parser"), X.prototype = K, K.Parser = X, new X();
})();
PT.parser = PT;
var Zwe = PT, Qwe = class {
  constructor() {
    this.entities = /* @__PURE__ */ new Map(), this.relationships = [], this.classes = /* @__PURE__ */ new Map(), this.direction = "TB", this.Cardinality = {
      ZERO_OR_ONE: "ZERO_OR_ONE",
      ZERO_OR_MORE: "ZERO_OR_MORE",
      ONE_OR_MORE: "ONE_OR_MORE",
      ONLY_ONE: "ONLY_ONE",
      MD_PARENT: "MD_PARENT"
    }, this.Identification = {
      NON_IDENTIFYING: "NON_IDENTIFYING",
      IDENTIFYING: "IDENTIFYING"
    }, this.setAccTitle = Cn, this.getAccTitle = Gn, this.setAccDescription = Vn, this.getAccDescription = Un, this.setDiagramTitle = Zn, this.getDiagramTitle = Ln, this.getConfig = /* @__PURE__ */ x(() => we().er, "getConfig"), this.clear(), this.addEntity = this.addEntity.bind(this), this.addAttributes = this.addAttributes.bind(this), this.addRelationship = this.addRelationship.bind(this), this.setDirection = this.setDirection.bind(this), this.addCssStyles = this.addCssStyles.bind(this), this.addClass = this.addClass.bind(this), this.setClass = this.setClass.bind(this), this.setAccTitle = this.setAccTitle.bind(this), this.setAccDescription = this.setAccDescription.bind(this);
  }
  static {
    x(this, "ErDB");
  }
  /**
   * Add entity
   * @param name - The name of the entity
   * @param alias - The alias of the entity
   */
  addEntity(t, e = "") {
    return this.entities.has(t) ? !this.entities.get(t)?.alias && e && (this.entities.get(t).alias = e, ie.info(`Add alias '${e}' to entity '${t}'`)) : (this.entities.set(t, {
      id: `entity-${t}-${this.entities.size}`,
      label: t,
      attributes: [],
      alias: e,
      shape: "erBox",
      look: we().look ?? "default",
      cssClasses: "default",
      cssStyles: []
    }), ie.info("Added new entity :", t)), this.entities.get(t);
  }
  getEntity(t) {
    return this.entities.get(t);
  }
  getEntities() {
    return this.entities;
  }
  getClasses() {
    return this.classes;
  }
  addAttributes(t, e) {
    const r = this.addEntity(t);
    let n;
    for (n = e.length - 1; n >= 0; n--)
      e[n].keys || (e[n].keys = []), e[n].comment || (e[n].comment = ""), r.attributes.push(e[n]), ie.debug("Added attribute ", e[n].name);
  }
  /**
   * Add a relationship
   *
   * @param entA - The first entity in the relationship
   * @param rolA - The role played by the first entity in relation to the second
   * @param entB - The second entity in the relationship
   * @param rSpec - The details of the relationship between the two entities
   */
  addRelationship(t, e, r, n) {
    const i = this.entities.get(t), a = this.entities.get(r);
    if (!i || !a)
      return;
    const s = {
      entityA: i.id,
      roleA: e,
      entityB: a.id,
      relSpec: n
    };
    this.relationships.push(s), ie.debug("Added new relationship :", s);
  }
  getRelationships() {
    return this.relationships;
  }
  getDirection() {
    return this.direction;
  }
  setDirection(t) {
    this.direction = t;
  }
  getCompiledStyles(t) {
    let e = [];
    for (const r of t) {
      const n = this.classes.get(r);
      n?.styles && (e = [...e, ...n.styles ?? []].map((i) => i.trim())), n?.textStyles && (e = [...e, ...n.textStyles ?? []].map((i) => i.trim()));
    }
    return e;
  }
  addCssStyles(t, e) {
    for (const r of t) {
      const n = this.entities.get(r);
      if (!e || !n)
        return;
      for (const i of e)
        n.cssStyles.push(i);
    }
  }
  addClass(t, e) {
    t.forEach((r) => {
      let n = this.classes.get(r);
      n === void 0 && (n = { id: r, styles: [], textStyles: [] }, this.classes.set(r, n)), e && e.forEach(function(i) {
        if (/color/.exec(i)) {
          const a = i.replace("fill", "bgFill");
          n.textStyles.push(a);
        }
        n.styles.push(i);
      });
    });
  }
  setClass(t, e) {
    for (const r of t) {
      const n = this.entities.get(r);
      if (n)
        for (const i of e)
          n.cssClasses += " " + i;
    }
  }
  clear() {
    this.entities = /* @__PURE__ */ new Map(), this.classes = /* @__PURE__ */ new Map(), this.relationships = [], _n();
  }
  getData() {
    const t = [], e = [], r = we();
    for (const i of this.entities.keys()) {
      const a = this.entities.get(i);
      a && (a.cssCompiledStyles = this.getCompiledStyles(a.cssClasses.split(" ")), t.push(a));
    }
    let n = 0;
    for (const i of this.relationships) {
      const a = {
        id: Kh(i.entityA, i.entityB, {
          prefix: "id",
          counter: n++
        }),
        type: "normal",
        curve: "basis",
        start: i.entityA,
        end: i.entityB,
        label: i.roleA,
        labelpos: "c",
        thickness: "normal",
        classes: "relationshipLine",
        arrowTypeStart: i.relSpec.cardB.toLowerCase(),
        arrowTypeEnd: i.relSpec.cardA.toLowerCase(),
        pattern: i.relSpec.relType == "IDENTIFYING" ? "solid" : "dashed",
        look: r.look
      };
      e.push(a);
    }
    return { nodes: t, edges: e, other: {}, config: r, direction: "TB" };
  }
}, xH = {};
A2(xH, {
  draw: () => Jwe
});
var Jwe = /* @__PURE__ */ x(async function(t, e, r, n) {
  ie.info("REF0:"), ie.info("Drawing er diagram (unified)", e);
  const { securityLevel: i, er: a, layout: s } = we(), o = n.db.getData(), l = lf(e, i);
  o.type = n.type, o.layoutAlgorithm = mg(s), o.config.flowchart.nodeSpacing = a?.nodeSpacing || 140, o.config.flowchart.rankSpacing = a?.rankSpacing || 80, o.direction = n.db.getDirection(), o.markers = ["only_one", "zero_or_one", "one_or_more", "zero_or_more"], o.diagramId = e, await Kd(o, l), o.layoutAlgorithm === "elk" && l.select(".edges").lower();
  const u = l.selectAll('[id*="-background"]');
  Array.from(u).length > 0 && u.each(function() {
    const d = Qe(this), p = d.attr("id").replace("-background", ""), g = l.select(`#${CSS.escape(p)}`);
    if (!g.empty()) {
      const m = g.attr("transform");
      d.attr("transform", m);
    }
  });
  const h = 8;
  Zt.insertTitle(
    l,
    "erDiagramTitleText",
    a?.titleTopMargin ?? 25,
    n.db.getDiagramTitle()
  ), rh(l, h, "erDiagram", a?.useMaxWidth ?? !0);
}, "draw"), eTe = /* @__PURE__ */ x((t, e) => {
  const r = iE, n = r(t, "r"), i = r(t, "g"), a = r(t, "b");
  return Fl(n, i, a, e);
}, "fade"), tTe = /* @__PURE__ */ x((t) => `
  .entityBox {
    fill: ${t.mainBkg};
    stroke: ${t.nodeBorder};
  }

  .relationshipLabelBox {
    fill: ${t.tertiaryColor};
    opacity: 0.7;
    background-color: ${t.tertiaryColor};
      rect {
        opacity: 0.5;
      }
  }

  .labelBkg {
    background-color: ${eTe(t.tertiaryColor, 0.5)};
  }

  .edgeLabel .label {
    fill: ${t.nodeBorder};
    font-size: 14px;
  }

  .label {
    font-family: ${t.fontFamily};
    color: ${t.nodeTextColor || t.textColor};
  }

  .edge-pattern-dashed {
    stroke-dasharray: 8,8;
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon
  {
    fill: ${t.mainBkg};
    stroke: ${t.nodeBorder};
    stroke-width: 1px;
  }

  .relationshipLine {
    stroke: ${t.lineColor};
    stroke-width: 1;
    fill: none;
  }

  .marker {
    fill: none !important;
    stroke: ${t.lineColor} !important;
    stroke-width: 1;
  }
`, "getStyles"), rTe = tTe, nTe = {
  parser: Zwe,
  get db() {
    return new Qwe();
  },
  renderer: xH,
  styles: rTe
};
const iTe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: nTe
}, Symbol.toStringTag, { value: "Module" }));
function nh(t, e) {
  t.accDescr && e.setAccDescription?.(t.accDescr), t.accTitle && e.setAccTitle?.(t.accTitle), t.title && e.setDiagramTitle?.(t.title);
}
x(nh, "populateCommonDb");
var bH = class {
  /**
   * @param init - Function that creates the default state.
   */
  constructor(t) {
    this.init = t, this.records = this.init();
  }
  static {
    x(this, "ImperativeState");
  }
  reset() {
    this.records = this.init();
  }
};
function Ti(t) {
  return typeof t == "object" && t !== null && typeof t.$type == "string";
}
function Qs(t) {
  return typeof t == "object" && t !== null && typeof t.$refText == "string";
}
function aTe(t) {
  return typeof t == "object" && t !== null && typeof t.name == "string" && typeof t.type == "string" && typeof t.path == "string";
}
function jm(t) {
  return typeof t == "object" && t !== null && Ti(t.container) && Qs(t.reference) && typeof t.message == "string";
}
class wH {
  constructor() {
    this.subtypes = {}, this.allSubtypes = {};
  }
  isInstance(e, r) {
    return Ti(e) && this.isSubtype(e.$type, r);
  }
  isSubtype(e, r) {
    if (e === r)
      return !0;
    let n = this.subtypes[e];
    n || (n = this.subtypes[e] = {});
    const i = n[r];
    if (i !== void 0)
      return i;
    {
      const a = this.computeIsSubtype(e, r);
      return n[r] = a, a;
    }
  }
  getAllSubTypes(e) {
    const r = this.allSubtypes[e];
    if (r)
      return r;
    {
      const n = this.getAllTypes(), i = [];
      for (const a of n)
        this.isSubtype(a, e) && i.push(a);
      return this.allSubtypes[e] = i, i;
    }
  }
}
function Hp(t) {
  return typeof t == "object" && t !== null && Array.isArray(t.content);
}
function TH(t) {
  return typeof t == "object" && t !== null && typeof t.tokenType == "object";
}
function EH(t) {
  return Hp(t) && typeof t.fullText == "string";
}
class si {
  constructor(e, r) {
    this.startFn = e, this.nextFn = r;
  }
  iterator() {
    const e = {
      state: this.startFn(),
      next: () => this.nextFn(e.state),
      [Symbol.iterator]: () => e
    };
    return e;
  }
  [Symbol.iterator]() {
    return this.iterator();
  }
  isEmpty() {
    return !!this.iterator().next().done;
  }
  count() {
    const e = this.iterator();
    let r = 0, n = e.next();
    for (; !n.done; )
      r++, n = e.next();
    return r;
  }
  toArray() {
    const e = [], r = this.iterator();
    let n;
    do
      n = r.next(), n.value !== void 0 && e.push(n.value);
    while (!n.done);
    return e;
  }
  toSet() {
    return new Set(this);
  }
  toMap(e, r) {
    const n = this.map((i) => [
      e ? e(i) : i,
      r ? r(i) : i
    ]);
    return new Map(n);
  }
  toString() {
    return this.join();
  }
  concat(e) {
    return new si(() => ({ first: this.startFn(), firstDone: !1, iterator: e[Symbol.iterator]() }), (r) => {
      let n;
      if (!r.firstDone) {
        do
          if (n = this.nextFn(r.first), !n.done)
            return n;
        while (!n.done);
        r.firstDone = !0;
      }
      do
        if (n = r.iterator.next(), !n.done)
          return n;
      while (!n.done);
      return ya;
    });
  }
  join(e = ",") {
    const r = this.iterator();
    let n = "", i, a = !1;
    do
      i = r.next(), i.done || (a && (n += e), n += sTe(i.value)), a = !0;
    while (!i.done);
    return n;
  }
  indexOf(e, r = 0) {
    const n = this.iterator();
    let i = 0, a = n.next();
    for (; !a.done; ) {
      if (i >= r && a.value === e)
        return i;
      a = n.next(), i++;
    }
    return -1;
  }
  every(e) {
    const r = this.iterator();
    let n = r.next();
    for (; !n.done; ) {
      if (!e(n.value))
        return !1;
      n = r.next();
    }
    return !0;
  }
  some(e) {
    const r = this.iterator();
    let n = r.next();
    for (; !n.done; ) {
      if (e(n.value))
        return !0;
      n = r.next();
    }
    return !1;
  }
  forEach(e) {
    const r = this.iterator();
    let n = 0, i = r.next();
    for (; !i.done; )
      e(i.value, n), i = r.next(), n++;
  }
  map(e) {
    return new si(this.startFn, (r) => {
      const { done: n, value: i } = this.nextFn(r);
      return n ? ya : { done: !1, value: e(i) };
    });
  }
  filter(e) {
    return new si(this.startFn, (r) => {
      let n;
      do
        if (n = this.nextFn(r), !n.done && e(n.value))
          return n;
      while (!n.done);
      return ya;
    });
  }
  nonNullable() {
    return this.filter((e) => e != null);
  }
  reduce(e, r) {
    const n = this.iterator();
    let i = r, a = n.next();
    for (; !a.done; )
      i === void 0 ? i = a.value : i = e(i, a.value), a = n.next();
    return i;
  }
  reduceRight(e, r) {
    return this.recursiveReduce(this.iterator(), e, r);
  }
  recursiveReduce(e, r, n) {
    const i = e.next();
    if (i.done)
      return n;
    const a = this.recursiveReduce(e, r, n);
    return a === void 0 ? i.value : r(a, i.value);
  }
  find(e) {
    const r = this.iterator();
    let n = r.next();
    for (; !n.done; ) {
      if (e(n.value))
        return n.value;
      n = r.next();
    }
  }
  findIndex(e) {
    const r = this.iterator();
    let n = 0, i = r.next();
    for (; !i.done; ) {
      if (e(i.value))
        return n;
      i = r.next(), n++;
    }
    return -1;
  }
  includes(e) {
    const r = this.iterator();
    let n = r.next();
    for (; !n.done; ) {
      if (n.value === e)
        return !0;
      n = r.next();
    }
    return !1;
  }
  flatMap(e) {
    return new si(() => ({ this: this.startFn() }), (r) => {
      do {
        if (r.iterator) {
          const a = r.iterator.next();
          if (a.done)
            r.iterator = void 0;
          else
            return a;
        }
        const { done: n, value: i } = this.nextFn(r.this);
        if (!n) {
          const a = e(i);
          if (Vy(a))
            r.iterator = a[Symbol.iterator]();
          else
            return { done: !1, value: a };
        }
      } while (r.iterator);
      return ya;
    });
  }
  flat(e) {
    if (e === void 0 && (e = 1), e <= 0)
      return this;
    const r = e > 1 ? this.flat(e - 1) : this;
    return new si(() => ({ this: r.startFn() }), (n) => {
      do {
        if (n.iterator) {
          const s = n.iterator.next();
          if (s.done)
            n.iterator = void 0;
          else
            return s;
        }
        const { done: i, value: a } = r.nextFn(n.this);
        if (!i)
          if (Vy(a))
            n.iterator = a[Symbol.iterator]();
          else
            return { done: !1, value: a };
      } while (n.iterator);
      return ya;
    });
  }
  head() {
    const r = this.iterator().next();
    if (!r.done)
      return r.value;
  }
  tail(e = 1) {
    return new si(() => {
      const r = this.startFn();
      for (let n = 0; n < e; n++)
        if (this.nextFn(r).done)
          return r;
      return r;
    }, this.nextFn);
  }
  limit(e) {
    return new si(() => ({ size: 0, state: this.startFn() }), (r) => (r.size++, r.size > e ? ya : this.nextFn(r.state)));
  }
  distinct(e) {
    return new si(() => ({ set: /* @__PURE__ */ new Set(), internalState: this.startFn() }), (r) => {
      let n;
      do
        if (n = this.nextFn(r.internalState), !n.done) {
          const i = e ? e(n.value) : n.value;
          if (!r.set.has(i))
            return r.set.add(i), n;
        }
      while (!n.done);
      return ya;
    });
  }
  exclude(e, r) {
    const n = /* @__PURE__ */ new Set();
    for (const i of e) {
      const a = r ? r(i) : i;
      n.add(a);
    }
    return this.filter((i) => {
      const a = r ? r(i) : i;
      return !n.has(a);
    });
  }
}
function sTe(t) {
  return typeof t == "string" ? t : typeof t > "u" ? "undefined" : typeof t.toString == "function" ? t.toString() : Object.prototype.toString.call(t);
}
function Vy(t) {
  return !!t && typeof t[Symbol.iterator] == "function";
}
const oTe = new si(() => {
}, () => ya), ya = Object.freeze({ done: !0, value: void 0 });
function oi(...t) {
  if (t.length === 1) {
    const e = t[0];
    if (e instanceof si)
      return e;
    if (Vy(e))
      return new si(() => e[Symbol.iterator](), (r) => r.next());
    if (typeof e.length == "number")
      return new si(() => ({ index: 0 }), (r) => r.index < e.length ? { done: !1, value: e[r.index++] } : ya);
  }
  return t.length > 1 ? new si(() => ({ collIndex: 0, arrIndex: 0 }), (e) => {
    do {
      if (e.iterator) {
        const r = e.iterator.next();
        if (!r.done)
          return r;
        e.iterator = void 0;
      }
      if (e.array) {
        if (e.arrIndex < e.array.length)
          return { done: !1, value: e.array[e.arrIndex++] };
        e.array = void 0, e.arrIndex = 0;
      }
      if (e.collIndex < t.length) {
        const r = t[e.collIndex++];
        Vy(r) ? e.iterator = r[Symbol.iterator]() : r && typeof r.length == "number" && (e.array = r);
      }
    } while (e.iterator || e.array || e.collIndex < t.length);
    return ya;
  }) : oTe;
}
class SS extends si {
  constructor(e, r, n) {
    super(() => ({
      iterators: n?.includeRoot ? [[e][Symbol.iterator]()] : [r(e)[Symbol.iterator]()],
      pruned: !1
    }), (i) => {
      for (i.pruned && (i.iterators.pop(), i.pruned = !1); i.iterators.length > 0; ) {
        const s = i.iterators[i.iterators.length - 1].next();
        if (s.done)
          i.iterators.pop();
        else
          return i.iterators.push(r(s.value)[Symbol.iterator]()), s;
      }
      return ya;
    });
  }
  iterator() {
    const e = {
      state: this.startFn(),
      next: () => this.nextFn(e.state),
      prune: () => {
        e.state.pruned = !0;
      },
      [Symbol.iterator]: () => e
    };
    return e;
  }
}
var BT;
(function(t) {
  function e(a) {
    return a.reduce((s, o) => s + o, 0);
  }
  t.sum = e;
  function r(a) {
    return a.reduce((s, o) => s * o, 0);
  }
  t.product = r;
  function n(a) {
    return a.reduce((s, o) => Math.min(s, o));
  }
  t.min = n;
  function i(a) {
    return a.reduce((s, o) => Math.max(s, o));
  }
  t.max = i;
})(BT || (BT = {}));
function FT(t) {
  return new SS(t, (e) => Hp(e) ? e.content : [], { includeRoot: !0 });
}
function lTe(t, e) {
  for (; t.container; )
    if (t = t.container, t === e)
      return !0;
  return !1;
}
function $T(t) {
  return {
    start: {
      character: t.startColumn - 1,
      line: t.startLine - 1
    },
    end: {
      character: t.endColumn,
      // endColumn uses the correct index
      line: t.endLine - 1
    }
  };
}
function Uy(t) {
  if (!t)
    return;
  const { offset: e, end: r, range: n } = t;
  return {
    range: n,
    offset: e,
    end: r,
    length: r - e
  };
}
var Oo;
(function(t) {
  t[t.Before = 0] = "Before", t[t.After = 1] = "After", t[t.OverlapFront = 2] = "OverlapFront", t[t.OverlapBack = 3] = "OverlapBack", t[t.Inside = 4] = "Inside", t[t.Outside = 5] = "Outside";
})(Oo || (Oo = {}));
function cTe(t, e) {
  if (t.end.line < e.start.line || t.end.line === e.start.line && t.end.character <= e.start.character)
    return Oo.Before;
  if (t.start.line > e.end.line || t.start.line === e.end.line && t.start.character >= e.end.character)
    return Oo.After;
  const r = t.start.line > e.start.line || t.start.line === e.start.line && t.start.character >= e.start.character, n = t.end.line < e.end.line || t.end.line === e.end.line && t.end.character <= e.end.character;
  return r && n ? Oo.Inside : r ? Oo.OverlapBack : n ? Oo.OverlapFront : Oo.Outside;
}
function uTe(t, e) {
  return cTe(t, e) > Oo.After;
}
const hTe = /^[\w\p{L}]$/u;
function dTe(t, e) {
  if (t) {
    const r = fTe(t, !0);
    if (r && PL(r, e))
      return r;
    if (EH(t)) {
      const n = t.content.findIndex((i) => !i.hidden);
      for (let i = n - 1; i >= 0; i--) {
        const a = t.content[i];
        if (PL(a, e))
          return a;
      }
    }
  }
}
function PL(t, e) {
  return TH(t) && e.includes(t.tokenType.name);
}
function fTe(t, e = !0) {
  for (; t.container; ) {
    const r = t.container;
    let n = r.content.indexOf(t);
    for (; n > 0; ) {
      n--;
      const i = r.content[n];
      if (e || !i.hidden)
        return i;
    }
    t = r;
  }
}
class kH extends Error {
  constructor(e, r) {
    super(e ? `${r} at ${e.range.start.line}:${e.range.start.character}` : r);
  }
}
function Og(t) {
  throw new Error("Error! The input value was not handled.");
}
const $1 = "AbstractRule", z1 = "AbstractType", c5 = "Condition", BL = "TypeDefinition", u5 = "ValueLiteral", n0 = "AbstractElement";
function pTe(t) {
  return Rr.isInstance(t, n0);
}
const G1 = "ArrayLiteral", V1 = "ArrayType", i0 = "BooleanLiteral";
function gTe(t) {
  return Rr.isInstance(t, i0);
}
const a0 = "Conjunction";
function mTe(t) {
  return Rr.isInstance(t, a0);
}
const s0 = "Disjunction";
function vTe(t) {
  return Rr.isInstance(t, s0);
}
const U1 = "Grammar", h5 = "GrammarImport", o0 = "InferredType";
function SH(t) {
  return Rr.isInstance(t, o0);
}
const l0 = "Interface";
function CH(t) {
  return Rr.isInstance(t, l0);
}
const d5 = "NamedArgument", c0 = "Negation";
function yTe(t) {
  return Rr.isInstance(t, c0);
}
const H1 = "NumberLiteral", q1 = "Parameter", u0 = "ParameterReference";
function xTe(t) {
  return Rr.isInstance(t, u0);
}
const h0 = "ParserRule";
function rs(t) {
  return Rr.isInstance(t, h0);
}
const W1 = "ReferenceType", Km = "ReturnType";
function bTe(t) {
  return Rr.isInstance(t, Km);
}
const d0 = "SimpleType";
function wTe(t) {
  return Rr.isInstance(t, d0);
}
const Y1 = "StringLiteral", Ih = "TerminalRule";
function ih(t) {
  return Rr.isInstance(t, Ih);
}
const f0 = "Type";
function AH(t) {
  return Rr.isInstance(t, f0);
}
const f5 = "TypeAttribute", X1 = "UnionType", p0 = "Action";
function Hx(t) {
  return Rr.isInstance(t, p0);
}
const g0 = "Alternatives";
function _H(t) {
  return Rr.isInstance(t, g0);
}
const m0 = "Assignment";
function Mu(t) {
  return Rr.isInstance(t, m0);
}
const v0 = "CharacterRange";
function TTe(t) {
  return Rr.isInstance(t, v0);
}
const y0 = "CrossReference";
function CS(t) {
  return Rr.isInstance(t, y0);
}
const x0 = "EndOfFile";
function ETe(t) {
  return Rr.isInstance(t, x0);
}
const b0 = "Group";
function AS(t) {
  return Rr.isInstance(t, b0);
}
const w0 = "Keyword";
function Nu(t) {
  return Rr.isInstance(t, w0);
}
const T0 = "NegatedToken";
function kTe(t) {
  return Rr.isInstance(t, T0);
}
const E0 = "RegexToken";
function STe(t) {
  return Rr.isInstance(t, E0);
}
const k0 = "RuleCall";
function Iu(t) {
  return Rr.isInstance(t, k0);
}
const S0 = "TerminalAlternatives";
function CTe(t) {
  return Rr.isInstance(t, S0);
}
const C0 = "TerminalGroup";
function ATe(t) {
  return Rr.isInstance(t, C0);
}
const A0 = "TerminalRuleCall";
function _Te(t) {
  return Rr.isInstance(t, A0);
}
const _0 = "UnorderedGroup";
function LH(t) {
  return Rr.isInstance(t, _0);
}
const L0 = "UntilToken";
function LTe(t) {
  return Rr.isInstance(t, L0);
}
const R0 = "Wildcard";
function RTe(t) {
  return Rr.isInstance(t, R0);
}
class RH extends wH {
  getAllTypes() {
    return [n0, $1, z1, p0, g0, G1, V1, m0, i0, v0, c5, a0, y0, s0, x0, U1, h5, b0, o0, l0, w0, d5, T0, c0, H1, q1, u0, h0, W1, E0, Km, k0, d0, Y1, S0, C0, Ih, A0, f0, f5, BL, X1, _0, L0, u5, R0];
  }
  computeIsSubtype(e, r) {
    switch (e) {
      case p0:
      case g0:
      case m0:
      case v0:
      case y0:
      case x0:
      case b0:
      case w0:
      case T0:
      case E0:
      case k0:
      case S0:
      case C0:
      case A0:
      case _0:
      case L0:
      case R0:
        return this.isSubtype(n0, r);
      case G1:
      case H1:
      case Y1:
        return this.isSubtype(u5, r);
      case V1:
      case W1:
      case d0:
      case X1:
        return this.isSubtype(BL, r);
      case i0:
        return this.isSubtype(c5, r) || this.isSubtype(u5, r);
      case a0:
      case s0:
      case c0:
      case u0:
        return this.isSubtype(c5, r);
      case o0:
      case l0:
      case f0:
        return this.isSubtype(z1, r);
      case h0:
        return this.isSubtype($1, r) || this.isSubtype(z1, r);
      case Ih:
        return this.isSubtype($1, r);
      default:
        return !1;
    }
  }
  getReferenceType(e) {
    const r = `${e.container.$type}:${e.property}`;
    switch (r) {
      case "Action:type":
      case "CrossReference:type":
      case "Interface:superTypes":
      case "ParserRule:returnType":
      case "SimpleType:typeRef":
        return z1;
      case "Grammar:hiddenTokens":
      case "ParserRule:hiddenTokens":
      case "RuleCall:rule":
        return $1;
      case "Grammar:usedGrammars":
        return U1;
      case "NamedArgument:parameter":
      case "ParameterReference:parameter":
        return q1;
      case "TerminalRuleCall:rule":
        return Ih;
      default:
        throw new Error(`${r} is not a valid reference id.`);
    }
  }
  getTypeMetaData(e) {
    switch (e) {
      case n0:
        return {
          name: n0,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" }
          ]
        };
      case G1:
        return {
          name: G1,
          properties: [
            { name: "elements", defaultValue: [] }
          ]
        };
      case V1:
        return {
          name: V1,
          properties: [
            { name: "elementType" }
          ]
        };
      case i0:
        return {
          name: i0,
          properties: [
            { name: "true", defaultValue: !1 }
          ]
        };
      case a0:
        return {
          name: a0,
          properties: [
            { name: "left" },
            { name: "right" }
          ]
        };
      case s0:
        return {
          name: s0,
          properties: [
            { name: "left" },
            { name: "right" }
          ]
        };
      case U1:
        return {
          name: U1,
          properties: [
            { name: "definesHiddenTokens", defaultValue: !1 },
            { name: "hiddenTokens", defaultValue: [] },
            { name: "imports", defaultValue: [] },
            { name: "interfaces", defaultValue: [] },
            { name: "isDeclared", defaultValue: !1 },
            { name: "name" },
            { name: "rules", defaultValue: [] },
            { name: "types", defaultValue: [] },
            { name: "usedGrammars", defaultValue: [] }
          ]
        };
      case h5:
        return {
          name: h5,
          properties: [
            { name: "path" }
          ]
        };
      case o0:
        return {
          name: o0,
          properties: [
            { name: "name" }
          ]
        };
      case l0:
        return {
          name: l0,
          properties: [
            { name: "attributes", defaultValue: [] },
            { name: "name" },
            { name: "superTypes", defaultValue: [] }
          ]
        };
      case d5:
        return {
          name: d5,
          properties: [
            { name: "calledByName", defaultValue: !1 },
            { name: "parameter" },
            { name: "value" }
          ]
        };
      case c0:
        return {
          name: c0,
          properties: [
            { name: "value" }
          ]
        };
      case H1:
        return {
          name: H1,
          properties: [
            { name: "value" }
          ]
        };
      case q1:
        return {
          name: q1,
          properties: [
            { name: "name" }
          ]
        };
      case u0:
        return {
          name: u0,
          properties: [
            { name: "parameter" }
          ]
        };
      case h0:
        return {
          name: h0,
          properties: [
            { name: "dataType" },
            { name: "definesHiddenTokens", defaultValue: !1 },
            { name: "definition" },
            { name: "entry", defaultValue: !1 },
            { name: "fragment", defaultValue: !1 },
            { name: "hiddenTokens", defaultValue: [] },
            { name: "inferredType" },
            { name: "name" },
            { name: "parameters", defaultValue: [] },
            { name: "returnType" },
            { name: "wildcard", defaultValue: !1 }
          ]
        };
      case W1:
        return {
          name: W1,
          properties: [
            { name: "referenceType" }
          ]
        };
      case Km:
        return {
          name: Km,
          properties: [
            { name: "name" }
          ]
        };
      case d0:
        return {
          name: d0,
          properties: [
            { name: "primitiveType" },
            { name: "stringType" },
            { name: "typeRef" }
          ]
        };
      case Y1:
        return {
          name: Y1,
          properties: [
            { name: "value" }
          ]
        };
      case Ih:
        return {
          name: Ih,
          properties: [
            { name: "definition" },
            { name: "fragment", defaultValue: !1 },
            { name: "hidden", defaultValue: !1 },
            { name: "name" },
            { name: "type" }
          ]
        };
      case f0:
        return {
          name: f0,
          properties: [
            { name: "name" },
            { name: "type" }
          ]
        };
      case f5:
        return {
          name: f5,
          properties: [
            { name: "defaultValue" },
            { name: "isOptional", defaultValue: !1 },
            { name: "name" },
            { name: "type" }
          ]
        };
      case X1:
        return {
          name: X1,
          properties: [
            { name: "types", defaultValue: [] }
          ]
        };
      case p0:
        return {
          name: p0,
          properties: [
            { name: "cardinality" },
            { name: "feature" },
            { name: "inferredType" },
            { name: "lookahead" },
            { name: "operator" },
            { name: "type" }
          ]
        };
      case g0:
        return {
          name: g0,
          properties: [
            { name: "cardinality" },
            { name: "elements", defaultValue: [] },
            { name: "lookahead" }
          ]
        };
      case m0:
        return {
          name: m0,
          properties: [
            { name: "cardinality" },
            { name: "feature" },
            { name: "lookahead" },
            { name: "operator" },
            { name: "terminal" }
          ]
        };
      case v0:
        return {
          name: v0,
          properties: [
            { name: "cardinality" },
            { name: "left" },
            { name: "lookahead" },
            { name: "right" }
          ]
        };
      case y0:
        return {
          name: y0,
          properties: [
            { name: "cardinality" },
            { name: "deprecatedSyntax", defaultValue: !1 },
            { name: "lookahead" },
            { name: "terminal" },
            { name: "type" }
          ]
        };
      case x0:
        return {
          name: x0,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" }
          ]
        };
      case b0:
        return {
          name: b0,
          properties: [
            { name: "cardinality" },
            { name: "elements", defaultValue: [] },
            { name: "guardCondition" },
            { name: "lookahead" }
          ]
        };
      case w0:
        return {
          name: w0,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" },
            { name: "value" }
          ]
        };
      case T0:
        return {
          name: T0,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" },
            { name: "terminal" }
          ]
        };
      case E0:
        return {
          name: E0,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" },
            { name: "regex" }
          ]
        };
      case k0:
        return {
          name: k0,
          properties: [
            { name: "arguments", defaultValue: [] },
            { name: "cardinality" },
            { name: "lookahead" },
            { name: "rule" }
          ]
        };
      case S0:
        return {
          name: S0,
          properties: [
            { name: "cardinality" },
            { name: "elements", defaultValue: [] },
            { name: "lookahead" }
          ]
        };
      case C0:
        return {
          name: C0,
          properties: [
            { name: "cardinality" },
            { name: "elements", defaultValue: [] },
            { name: "lookahead" }
          ]
        };
      case A0:
        return {
          name: A0,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" },
            { name: "rule" }
          ]
        };
      case _0:
        return {
          name: _0,
          properties: [
            { name: "cardinality" },
            { name: "elements", defaultValue: [] },
            { name: "lookahead" }
          ]
        };
      case L0:
        return {
          name: L0,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" },
            { name: "terminal" }
          ]
        };
      case R0:
        return {
          name: R0,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" }
          ]
        };
      default:
        return {
          name: e,
          properties: []
        };
    }
  }
}
const Rr = new RH();
function MTe(t) {
  for (const [e, r] of Object.entries(t))
    e.startsWith("$") || (Array.isArray(r) ? r.forEach((n, i) => {
      Ti(n) && (n.$container = t, n.$containerProperty = e, n.$containerIndex = i);
    }) : Ti(r) && (r.$container = t, r.$containerProperty = e));
}
function qx(t, e) {
  let r = t;
  for (; r; ) {
    if (e(r))
      return r;
    r = r.$container;
  }
}
function nc(t) {
  const r = zT(t).$document;
  if (!r)
    throw new Error("AST node has no document.");
  return r;
}
function zT(t) {
  for (; t.$container; )
    t = t.$container;
  return t;
}
function _S(t, e) {
  if (!t)
    throw new Error("Node must be an AstNode.");
  const r = e?.range;
  return new si(() => ({
    keys: Object.keys(t),
    keyIndex: 0,
    arrayIndex: 0
  }), (n) => {
    for (; n.keyIndex < n.keys.length; ) {
      const i = n.keys[n.keyIndex];
      if (!i.startsWith("$")) {
        const a = t[i];
        if (Ti(a)) {
          if (n.keyIndex++, FL(a, r))
            return { done: !1, value: a };
        } else if (Array.isArray(a)) {
          for (; n.arrayIndex < a.length; ) {
            const s = n.arrayIndex++, o = a[s];
            if (Ti(o) && FL(o, r))
              return { done: !1, value: o };
          }
          n.arrayIndex = 0;
        }
      }
      n.keyIndex++;
    }
    return ya;
  });
}
function Pg(t, e) {
  if (!t)
    throw new Error("Root node must be an AstNode.");
  return new SS(t, (r) => _S(r, e));
}
function ad(t, e) {
  if (!t)
    throw new Error("Root node must be an AstNode.");
  return new SS(t, (r) => _S(r, e), { includeRoot: !0 });
}
function FL(t, e) {
  var r;
  if (!e)
    return !0;
  const n = (r = t.$cstNode) === null || r === void 0 ? void 0 : r.range;
  return n ? uTe(n, e) : !1;
}
function MH(t) {
  return new si(() => ({
    keys: Object.keys(t),
    keyIndex: 0,
    arrayIndex: 0
  }), (e) => {
    for (; e.keyIndex < e.keys.length; ) {
      const r = e.keys[e.keyIndex];
      if (!r.startsWith("$")) {
        const n = t[r];
        if (Qs(n))
          return e.keyIndex++, { done: !1, value: { reference: n, container: t, property: r } };
        if (Array.isArray(n)) {
          for (; e.arrayIndex < n.length; ) {
            const i = e.arrayIndex++, a = n[i];
            if (Qs(a))
              return { done: !1, value: { reference: a, container: t, property: r, index: i } };
          }
          e.arrayIndex = 0;
        }
      }
      e.keyIndex++;
    }
    return ya;
  });
}
function NTe(t, e) {
  const r = t.getTypeMetaData(e.$type), n = e;
  for (const i of r.properties)
    i.defaultValue !== void 0 && n[i.name] === void 0 && (n[i.name] = NH(i.defaultValue));
}
function NH(t) {
  return Array.isArray(t) ? [...t.map(NH)] : t;
}
function Xt(t) {
  return t.charCodeAt(0);
}
function p5(t, e) {
  Array.isArray(t) ? t.forEach(function(r) {
    e.push(r);
  }) : e.push(t);
}
function Ff(t, e) {
  if (t[e] === !0)
    throw "duplicate flag " + e;
  t[e], t[e] = !0;
}
function Ch(t) {
  if (t === void 0)
    throw Error("Internal Error - Should never get here!");
  return !0;
}
function ITe() {
  throw Error("Internal Error - Should never get here!");
}
function $L(t) {
  return t.type === "Character";
}
const Hy = [];
for (let t = Xt("0"); t <= Xt("9"); t++)
  Hy.push(t);
const qy = [Xt("_")].concat(Hy);
for (let t = Xt("a"); t <= Xt("z"); t++)
  qy.push(t);
for (let t = Xt("A"); t <= Xt("Z"); t++)
  qy.push(t);
const zL = [
  Xt(" "),
  Xt("\f"),
  Xt(`
`),
  Xt("\r"),
  Xt("	"),
  Xt("\v"),
  Xt("	"),
  Xt(""),
  Xt(""),
  Xt(""),
  Xt(""),
  Xt(""),
  Xt(""),
  Xt(""),
  Xt(""),
  Xt(""),
  Xt(""),
  Xt(""),
  Xt(""),
  Xt(""),
  Xt("\u2028"),
  Xt("\u2029"),
  Xt(""),
  Xt(""),
  Xt(""),
  Xt("\uFEFF")
], DTe = /[0-9a-fA-F]/, j1 = /[0-9]/, OTe = /[1-9]/;
class IH {
  constructor() {
    this.idx = 0, this.input = "", this.groupIdx = 0;
  }
  saveState() {
    return {
      idx: this.idx,
      input: this.input,
      groupIdx: this.groupIdx
    };
  }
  restoreState(e) {
    this.idx = e.idx, this.input = e.input, this.groupIdx = e.groupIdx;
  }
  pattern(e) {
    this.idx = 0, this.input = e, this.groupIdx = 0, this.consumeChar("/");
    const r = this.disjunction();
    this.consumeChar("/");
    const n = {
      type: "Flags",
      loc: { begin: this.idx, end: e.length },
      global: !1,
      ignoreCase: !1,
      multiLine: !1,
      unicode: !1,
      sticky: !1
    };
    for (; this.isRegExpFlag(); )
      switch (this.popChar()) {
        case "g":
          Ff(n, "global");
          break;
        case "i":
          Ff(n, "ignoreCase");
          break;
        case "m":
          Ff(n, "multiLine");
          break;
        case "u":
          Ff(n, "unicode");
          break;
        case "y":
          Ff(n, "sticky");
          break;
      }
    if (this.idx !== this.input.length)
      throw Error("Redundant input: " + this.input.substring(this.idx));
    return {
      type: "Pattern",
      flags: n,
      value: r,
      loc: this.loc(0)
    };
  }
  disjunction() {
    const e = [], r = this.idx;
    for (e.push(this.alternative()); this.peekChar() === "|"; )
      this.consumeChar("|"), e.push(this.alternative());
    return { type: "Disjunction", value: e, loc: this.loc(r) };
  }
  alternative() {
    const e = [], r = this.idx;
    for (; this.isTerm(); )
      e.push(this.term());
    return { type: "Alternative", value: e, loc: this.loc(r) };
  }
  term() {
    return this.isAssertion() ? this.assertion() : this.atom();
  }
  assertion() {
    const e = this.idx;
    switch (this.popChar()) {
      case "^":
        return {
          type: "StartAnchor",
          loc: this.loc(e)
        };
      case "$":
        return { type: "EndAnchor", loc: this.loc(e) };
      // '\b' or '\B'
      case "\\":
        switch (this.popChar()) {
          case "b":
            return {
              type: "WordBoundary",
              loc: this.loc(e)
            };
          case "B":
            return {
              type: "NonWordBoundary",
              loc: this.loc(e)
            };
        }
        throw Error("Invalid Assertion Escape");
      // '(?=' or '(?!'
      case "(":
        this.consumeChar("?");
        let r;
        switch (this.popChar()) {
          case "=":
            r = "Lookahead";
            break;
          case "!":
            r = "NegativeLookahead";
            break;
        }
        Ch(r);
        const n = this.disjunction();
        return this.consumeChar(")"), {
          type: r,
          value: n,
          loc: this.loc(e)
        };
    }
    return ITe();
  }
  quantifier(e = !1) {
    let r;
    const n = this.idx;
    switch (this.popChar()) {
      case "*":
        r = {
          atLeast: 0,
          atMost: 1 / 0
        };
        break;
      case "+":
        r = {
          atLeast: 1,
          atMost: 1 / 0
        };
        break;
      case "?":
        r = {
          atLeast: 0,
          atMost: 1
        };
        break;
      case "{":
        const i = this.integerIncludingZero();
        switch (this.popChar()) {
          case "}":
            r = {
              atLeast: i,
              atMost: i
            };
            break;
          case ",":
            let a;
            this.isDigit() ? (a = this.integerIncludingZero(), r = {
              atLeast: i,
              atMost: a
            }) : r = {
              atLeast: i,
              atMost: 1 / 0
            }, this.consumeChar("}");
            break;
        }
        if (e === !0 && r === void 0)
          return;
        Ch(r);
        break;
    }
    if (!(e === !0 && r === void 0) && Ch(r))
      return this.peekChar(0) === "?" ? (this.consumeChar("?"), r.greedy = !1) : r.greedy = !0, r.type = "Quantifier", r.loc = this.loc(n), r;
  }
  atom() {
    let e;
    const r = this.idx;
    switch (this.peekChar()) {
      case ".":
        e = this.dotAll();
        break;
      case "\\":
        e = this.atomEscape();
        break;
      case "[":
        e = this.characterClass();
        break;
      case "(":
        e = this.group();
        break;
    }
    if (e === void 0 && this.isPatternCharacter() && (e = this.patternCharacter()), Ch(e))
      return e.loc = this.loc(r), this.isQuantifier() && (e.quantifier = this.quantifier()), e;
  }
  dotAll() {
    return this.consumeChar("."), {
      type: "Set",
      complement: !0,
      value: [Xt(`
`), Xt("\r"), Xt("\u2028"), Xt("\u2029")]
    };
  }
  atomEscape() {
    switch (this.consumeChar("\\"), this.peekChar()) {
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        return this.decimalEscapeAtom();
      case "d":
      case "D":
      case "s":
      case "S":
      case "w":
      case "W":
        return this.characterClassEscape();
      case "f":
      case "n":
      case "r":
      case "t":
      case "v":
        return this.controlEscapeAtom();
      case "c":
        return this.controlLetterEscapeAtom();
      case "0":
        return this.nulCharacterAtom();
      case "x":
        return this.hexEscapeSequenceAtom();
      case "u":
        return this.regExpUnicodeEscapeSequenceAtom();
      default:
        return this.identityEscapeAtom();
    }
  }
  decimalEscapeAtom() {
    return { type: "GroupBackReference", value: this.positiveInteger() };
  }
  characterClassEscape() {
    let e, r = !1;
    switch (this.popChar()) {
      case "d":
        e = Hy;
        break;
      case "D":
        e = Hy, r = !0;
        break;
      case "s":
        e = zL;
        break;
      case "S":
        e = zL, r = !0;
        break;
      case "w":
        e = qy;
        break;
      case "W":
        e = qy, r = !0;
        break;
    }
    if (Ch(e))
      return { type: "Set", value: e, complement: r };
  }
  controlEscapeAtom() {
    let e;
    switch (this.popChar()) {
      case "f":
        e = Xt("\f");
        break;
      case "n":
        e = Xt(`
`);
        break;
      case "r":
        e = Xt("\r");
        break;
      case "t":
        e = Xt("	");
        break;
      case "v":
        e = Xt("\v");
        break;
    }
    if (Ch(e))
      return { type: "Character", value: e };
  }
  controlLetterEscapeAtom() {
    this.consumeChar("c");
    const e = this.popChar();
    if (/[a-zA-Z]/.test(e) === !1)
      throw Error("Invalid ");
    return { type: "Character", value: e.toUpperCase().charCodeAt(0) - 64 };
  }
  nulCharacterAtom() {
    return this.consumeChar("0"), { type: "Character", value: Xt("\0") };
  }
  hexEscapeSequenceAtom() {
    return this.consumeChar("x"), this.parseHexDigits(2);
  }
  regExpUnicodeEscapeSequenceAtom() {
    return this.consumeChar("u"), this.parseHexDigits(4);
  }
  identityEscapeAtom() {
    const e = this.popChar();
    return { type: "Character", value: Xt(e) };
  }
  classPatternCharacterAtom() {
    switch (this.peekChar()) {
      // istanbul ignore next
      case `
`:
      // istanbul ignore next
      case "\r":
      // istanbul ignore next
      case "\u2028":
      // istanbul ignore next
      case "\u2029":
      // istanbul ignore next
      case "\\":
      // istanbul ignore next
      case "]":
        throw Error("TBD");
      default:
        const e = this.popChar();
        return { type: "Character", value: Xt(e) };
    }
  }
  characterClass() {
    const e = [];
    let r = !1;
    for (this.consumeChar("["), this.peekChar(0) === "^" && (this.consumeChar("^"), r = !0); this.isClassAtom(); ) {
      const n = this.classAtom();
      if (n.type, $L(n) && this.isRangeDash()) {
        this.consumeChar("-");
        const i = this.classAtom();
        if (i.type, $L(i)) {
          if (i.value < n.value)
            throw Error("Range out of order in character class");
          e.push({ from: n.value, to: i.value });
        } else
          p5(n.value, e), e.push(Xt("-")), p5(i.value, e);
      } else
        p5(n.value, e);
    }
    return this.consumeChar("]"), { type: "Set", complement: r, value: e };
  }
  classAtom() {
    switch (this.peekChar()) {
      // istanbul ignore next
      case "]":
      // istanbul ignore next
      case `
`:
      // istanbul ignore next
      case "\r":
      // istanbul ignore next
      case "\u2028":
      // istanbul ignore next
      case "\u2029":
        throw Error("TBD");
      case "\\":
        return this.classEscape();
      default:
        return this.classPatternCharacterAtom();
    }
  }
  classEscape() {
    switch (this.consumeChar("\\"), this.peekChar()) {
      // Matches a backspace.
      // (Not to be confused with \b word boundary outside characterClass)
      case "b":
        return this.consumeChar("b"), { type: "Character", value: Xt("\b") };
      case "d":
      case "D":
      case "s":
      case "S":
      case "w":
      case "W":
        return this.characterClassEscape();
      case "f":
      case "n":
      case "r":
      case "t":
      case "v":
        return this.controlEscapeAtom();
      case "c":
        return this.controlLetterEscapeAtom();
      case "0":
        return this.nulCharacterAtom();
      case "x":
        return this.hexEscapeSequenceAtom();
      case "u":
        return this.regExpUnicodeEscapeSequenceAtom();
      default:
        return this.identityEscapeAtom();
    }
  }
  group() {
    let e = !0;
    this.consumeChar("("), this.peekChar(0) === "?" ? (this.consumeChar("?"), this.consumeChar(":"), e = !1) : this.groupIdx++;
    const r = this.disjunction();
    this.consumeChar(")");
    const n = {
      type: "Group",
      capturing: e,
      value: r
    };
    return e && (n.idx = this.groupIdx), n;
  }
  positiveInteger() {
    let e = this.popChar();
    if (OTe.test(e) === !1)
      throw Error("Expecting a positive integer");
    for (; j1.test(this.peekChar(0)); )
      e += this.popChar();
    return parseInt(e, 10);
  }
  integerIncludingZero() {
    let e = this.popChar();
    if (j1.test(e) === !1)
      throw Error("Expecting an integer");
    for (; j1.test(this.peekChar(0)); )
      e += this.popChar();
    return parseInt(e, 10);
  }
  patternCharacter() {
    const e = this.popChar();
    switch (e) {
      // istanbul ignore next
      case `
`:
      // istanbul ignore next
      case "\r":
      // istanbul ignore next
      case "\u2028":
      // istanbul ignore next
      case "\u2029":
      // istanbul ignore next
      case "^":
      // istanbul ignore next
      case "$":
      // istanbul ignore next
      case "\\":
      // istanbul ignore next
      case ".":
      // istanbul ignore next
      case "*":
      // istanbul ignore next
      case "+":
      // istanbul ignore next
      case "?":
      // istanbul ignore next
      case "(":
      // istanbul ignore next
      case ")":
      // istanbul ignore next
      case "[":
      // istanbul ignore next
      case "|":
        throw Error("TBD");
      default:
        return { type: "Character", value: Xt(e) };
    }
  }
  isRegExpFlag() {
    switch (this.peekChar(0)) {
      case "g":
      case "i":
      case "m":
      case "u":
      case "y":
        return !0;
      default:
        return !1;
    }
  }
  isRangeDash() {
    return this.peekChar() === "-" && this.isClassAtom(1);
  }
  isDigit() {
    return j1.test(this.peekChar(0));
  }
  isClassAtom(e = 0) {
    switch (this.peekChar(e)) {
      case "]":
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        return !1;
      default:
        return !0;
    }
  }
  isTerm() {
    return this.isAtom() || this.isAssertion();
  }
  isAtom() {
    if (this.isPatternCharacter())
      return !0;
    switch (this.peekChar(0)) {
      case ".":
      case "\\":
      // atomEscape
      case "[":
      // characterClass
      // TODO: isAtom must be called before isAssertion - disambiguate
      case "(":
        return !0;
      default:
        return !1;
    }
  }
  isAssertion() {
    switch (this.peekChar(0)) {
      case "^":
      case "$":
        return !0;
      // '\b' or '\B'
      case "\\":
        switch (this.peekChar(1)) {
          case "b":
          case "B":
            return !0;
          default:
            return !1;
        }
      // '(?=' or '(?!'
      case "(":
        return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
      default:
        return !1;
    }
  }
  isQuantifier() {
    const e = this.saveState();
    try {
      return this.quantifier(!0) !== void 0;
    } catch {
      return !1;
    } finally {
      this.restoreState(e);
    }
  }
  isPatternCharacter() {
    switch (this.peekChar()) {
      case "^":
      case "$":
      case "\\":
      case ".":
      case "*":
      case "+":
      case "?":
      case "(":
      case ")":
      case "[":
      case "|":
      case "/":
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        return !1;
      default:
        return !0;
    }
  }
  parseHexDigits(e) {
    let r = "";
    for (let i = 0; i < e; i++) {
      const a = this.popChar();
      if (DTe.test(a) === !1)
        throw Error("Expecting a HexDecimal digits");
      r += a;
    }
    return { type: "Character", value: parseInt(r, 16) };
  }
  peekChar(e = 0) {
    return this.input[this.idx + e];
  }
  popChar() {
    const e = this.peekChar(0);
    return this.consumeChar(void 0), e;
  }
  consumeChar(e) {
    if (e !== void 0 && this.input[this.idx] !== e)
      throw Error("Expected: '" + e + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx);
    if (this.idx >= this.input.length)
      throw Error("Unexpected end of input");
    this.idx++;
  }
  loc(e) {
    return { begin: e, end: this.idx };
  }
}
class Wx {
  visitChildren(e) {
    for (const r in e) {
      const n = e[r];
      e.hasOwnProperty(r) && (n.type !== void 0 ? this.visit(n) : Array.isArray(n) && n.forEach((i) => {
        this.visit(i);
      }, this));
    }
  }
  visit(e) {
    switch (e.type) {
      case "Pattern":
        this.visitPattern(e);
        break;
      case "Flags":
        this.visitFlags(e);
        break;
      case "Disjunction":
        this.visitDisjunction(e);
        break;
      case "Alternative":
        this.visitAlternative(e);
        break;
      case "StartAnchor":
        this.visitStartAnchor(e);
        break;
      case "EndAnchor":
        this.visitEndAnchor(e);
        break;
      case "WordBoundary":
        this.visitWordBoundary(e);
        break;
      case "NonWordBoundary":
        this.visitNonWordBoundary(e);
        break;
      case "Lookahead":
        this.visitLookahead(e);
        break;
      case "NegativeLookahead":
        this.visitNegativeLookahead(e);
        break;
      case "Character":
        this.visitCharacter(e);
        break;
      case "Set":
        this.visitSet(e);
        break;
      case "Group":
        this.visitGroup(e);
        break;
      case "GroupBackReference":
        this.visitGroupBackReference(e);
        break;
      case "Quantifier":
        this.visitQuantifier(e);
        break;
    }
    this.visitChildren(e);
  }
  visitPattern(e) {
  }
  visitFlags(e) {
  }
  visitDisjunction(e) {
  }
  visitAlternative(e) {
  }
  // Assertion
  visitStartAnchor(e) {
  }
  visitEndAnchor(e) {
  }
  visitWordBoundary(e) {
  }
  visitNonWordBoundary(e) {
  }
  visitLookahead(e) {
  }
  visitNegativeLookahead(e) {
  }
  // atoms
  visitCharacter(e) {
  }
  visitSet(e) {
  }
  visitGroup(e) {
  }
  visitGroupBackReference(e) {
  }
  visitQuantifier(e) {
  }
}
const PTe = /\r?\n/gm, BTe = new IH();
class FTe extends Wx {
  constructor() {
    super(...arguments), this.isStarting = !0, this.endRegexpStack = [], this.multiline = !1;
  }
  get endRegex() {
    return this.endRegexpStack.join("");
  }
  reset(e) {
    this.multiline = !1, this.regex = e, this.startRegexp = "", this.isStarting = !0, this.endRegexpStack = [];
  }
  visitGroup(e) {
    e.quantifier && (this.isStarting = !1, this.endRegexpStack = []);
  }
  visitCharacter(e) {
    const r = String.fromCharCode(e.value);
    if (!this.multiline && r === `
` && (this.multiline = !0), e.quantifier)
      this.isStarting = !1, this.endRegexpStack = [];
    else {
      const n = Yx(r);
      this.endRegexpStack.push(n), this.isStarting && (this.startRegexp += n);
    }
  }
  visitSet(e) {
    if (!this.multiline) {
      const r = this.regex.substring(e.loc.begin, e.loc.end), n = new RegExp(r);
      this.multiline = !!`
`.match(n);
    }
    if (e.quantifier)
      this.isStarting = !1, this.endRegexpStack = [];
    else {
      const r = this.regex.substring(e.loc.begin, e.loc.end);
      this.endRegexpStack.push(r), this.isStarting && (this.startRegexp += r);
    }
  }
  visitChildren(e) {
    e.type === "Group" && e.quantifier || super.visitChildren(e);
  }
}
const g5 = new FTe();
function $Te(t) {
  try {
    return typeof t == "string" && (t = new RegExp(t)), t = t.toString(), g5.reset(t), g5.visit(BTe.pattern(t)), g5.multiline;
  } catch {
    return !1;
  }
}
const zTe = `\f
\r	\v \u2028\u2029\uFEFF`.split("");
function GT(t) {
  const e = typeof t == "string" ? new RegExp(t) : t;
  return zTe.some((r) => e.test(r));
}
function Yx(t) {
  return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function GTe(t) {
  return Array.prototype.map.call(t, (e) => /\w/.test(e) ? `[${e.toLowerCase()}${e.toUpperCase()}]` : Yx(e)).join("");
}
function VTe(t, e) {
  const r = UTe(t), n = e.match(r);
  return !!n && n[0].length > 0;
}
function UTe(t) {
  typeof t == "string" && (t = new RegExp(t));
  const e = t, r = t.source;
  let n = 0;
  function i() {
    let a = "", s;
    function o(u) {
      a += r.substr(n, u), n += u;
    }
    function l(u) {
      a += "(?:" + r.substr(n, u) + "|$)", n += u;
    }
    for (; n < r.length; )
      switch (r[n]) {
        case "\\":
          switch (r[n + 1]) {
            case "c":
              l(3);
              break;
            case "x":
              l(4);
              break;
            case "u":
              e.unicode ? r[n + 2] === "{" ? l(r.indexOf("}", n) - n + 1) : l(6) : l(2);
              break;
            case "p":
            case "P":
              e.unicode ? l(r.indexOf("}", n) - n + 1) : l(2);
              break;
            case "k":
              l(r.indexOf(">", n) - n + 1);
              break;
            default:
              l(2);
              break;
          }
          break;
        case "[":
          s = /\[(?:\\.|.)*?\]/g, s.lastIndex = n, s = s.exec(r) || [], l(s[0].length);
          break;
        case "|":
        case "^":
        case "$":
        case "*":
        case "+":
        case "?":
          o(1);
          break;
        case "{":
          s = /\{\d+,?\d*\}/g, s.lastIndex = n, s = s.exec(r), s ? o(s[0].length) : l(1);
          break;
        case "(":
          if (r[n + 1] === "?")
            switch (r[n + 2]) {
              case ":":
                a += "(?:", n += 3, a += i() + "|$)";
                break;
              case "=":
                a += "(?=", n += 3, a += i() + ")";
                break;
              case "!":
                s = n, n += 3, i(), a += r.substr(s, n - s);
                break;
              case "<":
                switch (r[n + 3]) {
                  case "=":
                  case "!":
                    s = n, n += 4, i(), a += r.substr(s, n - s);
                    break;
                  default:
                    o(r.indexOf(">", n) - n + 1), a += i() + "|$)";
                    break;
                }
                break;
            }
          else
            o(1), a += i() + "|$)";
          break;
        case ")":
          return ++n, a;
        default:
          l(1);
          break;
      }
    return a;
  }
  return new RegExp(i(), t.flags);
}
function HTe(t) {
  return t.rules.find((e) => rs(e) && e.entry);
}
function qTe(t) {
  return t.rules.filter((e) => ih(e) && e.hidden);
}
function DH(t, e) {
  const r = /* @__PURE__ */ new Set(), n = HTe(t);
  if (!n)
    return new Set(t.rules);
  const i = [n].concat(qTe(t));
  for (const s of i)
    OH(s, r, e);
  const a = /* @__PURE__ */ new Set();
  for (const s of t.rules)
    (r.has(s.name) || ih(s) && s.hidden) && a.add(s);
  return a;
}
function OH(t, e, r) {
  e.add(t.name), Pg(t).forEach((n) => {
    if (Iu(n) || r) {
      const i = n.rule.ref;
      i && !e.has(i.name) && OH(i, e, r);
    }
  });
}
function WTe(t) {
  if (t.terminal)
    return t.terminal;
  if (t.type.ref) {
    const e = BH(t.type.ref);
    return e?.terminal;
  }
}
function YTe(t) {
  return t.hidden && !GT(NS(t));
}
function XTe(t, e) {
  return !t || !e ? [] : LS(t, e, t.astNode, !0);
}
function PH(t, e, r) {
  if (!t || !e)
    return;
  const n = LS(t, e, t.astNode, !0);
  if (n.length !== 0)
    return r !== void 0 ? r = Math.max(0, Math.min(r, n.length - 1)) : r = 0, n[r];
}
function LS(t, e, r, n) {
  if (!n) {
    const i = qx(t.grammarSource, Mu);
    if (i && i.feature === e)
      return [t];
  }
  return Hp(t) && t.astNode === r ? t.content.flatMap((i) => LS(i, e, r, !1)) : [];
}
function jTe(t, e, r) {
  if (!t)
    return;
  const n = KTe(t, e, t?.astNode);
  if (n.length !== 0)
    return r !== void 0 ? r = Math.max(0, Math.min(r, n.length - 1)) : r = 0, n[r];
}
function KTe(t, e, r) {
  if (t.astNode !== r)
    return [];
  if (Nu(t.grammarSource) && t.grammarSource.value === e)
    return [t];
  const n = FT(t).iterator();
  let i;
  const a = [];
  do
    if (i = n.next(), !i.done) {
      const s = i.value;
      s.astNode === r ? Nu(s.grammarSource) && s.grammarSource.value === e && a.push(s) : n.prune();
    }
  while (!i.done);
  return a;
}
function ZTe(t) {
  var e;
  const r = t.astNode;
  for (; r === ((e = t.container) === null || e === void 0 ? void 0 : e.astNode); ) {
    const n = qx(t.grammarSource, Mu);
    if (n)
      return n;
    t = t.container;
  }
}
function BH(t) {
  let e = t;
  return SH(e) && (Hx(e.$container) ? e = e.$container.$container : rs(e.$container) ? e = e.$container : Og(e.$container)), FH(t, e, /* @__PURE__ */ new Map());
}
function FH(t, e, r) {
  var n;
  function i(a, s) {
    let o;
    return qx(a, Mu) || (o = FH(s, s, r)), r.set(t, o), o;
  }
  if (r.has(t))
    return r.get(t);
  r.set(t, void 0);
  for (const a of Pg(e)) {
    if (Mu(a) && a.feature.toLowerCase() === "name")
      return r.set(t, a), a;
    if (Iu(a) && rs(a.rule.ref))
      return i(a, a.rule.ref);
    if (wTe(a) && (!((n = a.typeRef) === null || n === void 0) && n.ref))
      return i(a, a.typeRef.ref);
  }
}
function $H(t) {
  return zH(t, /* @__PURE__ */ new Set());
}
function zH(t, e) {
  if (e.has(t))
    return !0;
  e.add(t);
  for (const r of Pg(t))
    if (Iu(r)) {
      if (!r.rule.ref || rs(r.rule.ref) && !zH(r.rule.ref, e))
        return !1;
    } else {
      if (Mu(r))
        return !1;
      if (Hx(r))
        return !1;
    }
  return !!t.definition;
}
function RS(t) {
  if (t.inferredType)
    return t.inferredType.name;
  if (t.dataType)
    return t.dataType;
  if (t.returnType) {
    const e = t.returnType.ref;
    if (e) {
      if (rs(e))
        return e.name;
      if (CH(e) || AH(e))
        return e.name;
    }
  }
}
function MS(t) {
  var e;
  if (rs(t))
    return $H(t) ? t.name : (e = RS(t)) !== null && e !== void 0 ? e : t.name;
  if (CH(t) || AH(t) || bTe(t))
    return t.name;
  if (Hx(t)) {
    const r = QTe(t);
    if (r)
      return r;
  } else if (SH(t))
    return t.name;
  throw new Error("Cannot get name of Unknown Type");
}
function QTe(t) {
  var e;
  if (t.inferredType)
    return t.inferredType.name;
  if (!((e = t.type) === null || e === void 0) && e.ref)
    return MS(t.type.ref);
}
function JTe(t) {
  var e, r, n;
  return ih(t) ? (r = (e = t.type) === null || e === void 0 ? void 0 : e.name) !== null && r !== void 0 ? r : "string" : (n = RS(t)) !== null && n !== void 0 ? n : t.name;
}
function NS(t) {
  const e = {
    s: !1,
    i: !1,
    u: !1
  }, r = cf(t.definition, e), n = Object.entries(e).filter(([, i]) => i).map(([i]) => i).join("");
  return new RegExp(r, n);
}
const IS = /[\s\S]/.source;
function cf(t, e) {
  if (CTe(t))
    return e6e(t);
  if (ATe(t))
    return t6e(t);
  if (TTe(t))
    return i6e(t);
  if (_Te(t)) {
    const r = t.rule.ref;
    if (!r)
      throw new Error("Missing rule reference.");
    return jo(cf(r.definition), {
      cardinality: t.cardinality,
      lookahead: t.lookahead
    });
  } else {
    if (kTe(t))
      return n6e(t);
    if (LTe(t))
      return r6e(t);
    if (STe(t)) {
      const r = t.regex.lastIndexOf("/"), n = t.regex.substring(1, r), i = t.regex.substring(r + 1);
      return e && (e.i = i.includes("i"), e.s = i.includes("s"), e.u = i.includes("u")), jo(n, {
        cardinality: t.cardinality,
        lookahead: t.lookahead,
        wrap: !1
      });
    } else {
      if (RTe(t))
        return jo(IS, {
          cardinality: t.cardinality,
          lookahead: t.lookahead
        });
      throw new Error(`Invalid terminal element: ${t?.$type}`);
    }
  }
}
function e6e(t) {
  return jo(t.elements.map((e) => cf(e)).join("|"), {
    cardinality: t.cardinality,
    lookahead: t.lookahead
  });
}
function t6e(t) {
  return jo(t.elements.map((e) => cf(e)).join(""), {
    cardinality: t.cardinality,
    lookahead: t.lookahead
  });
}
function r6e(t) {
  return jo(`${IS}*?${cf(t.terminal)}`, {
    cardinality: t.cardinality,
    lookahead: t.lookahead
  });
}
function n6e(t) {
  return jo(`(?!${cf(t.terminal)})${IS}*?`, {
    cardinality: t.cardinality,
    lookahead: t.lookahead
  });
}
function i6e(t) {
  return t.right ? jo(`[${m5(t.left)}-${m5(t.right)}]`, {
    cardinality: t.cardinality,
    lookahead: t.lookahead,
    wrap: !1
  }) : jo(m5(t.left), {
    cardinality: t.cardinality,
    lookahead: t.lookahead,
    wrap: !1
  });
}
function m5(t) {
  return Yx(t.value);
}
function jo(t, e) {
  var r;
  return (e.wrap !== !1 || e.lookahead) && (t = `(${(r = e.lookahead) !== null && r !== void 0 ? r : ""}${t})`), e.cardinality ? `${t}${e.cardinality}` : t;
}
function a6e(t) {
  const e = [], r = t.Grammar;
  for (const n of r.rules)
    ih(n) && YTe(n) && $Te(NS(n)) && e.push(n.name);
  return {
    multilineCommentRules: e,
    nameRegexp: hTe
  };
}
var GH = typeof global == "object" && global && global.Object === Object && global, s6e = typeof self == "object" && self && self.Object === Object && self, vo = GH || s6e || Function("return this")(), ns = vo.Symbol, VH = Object.prototype, o6e = VH.hasOwnProperty, l6e = VH.toString, $f = ns ? ns.toStringTag : void 0;
function c6e(t) {
  var e = o6e.call(t, $f), r = t[$f];
  try {
    t[$f] = void 0;
    var n = !0;
  } catch {
  }
  var i = l6e.call(t);
  return n && (e ? t[$f] = r : delete t[$f]), i;
}
var u6e = Object.prototype, h6e = u6e.toString;
function d6e(t) {
  return h6e.call(t);
}
var f6e = "[object Null]", p6e = "[object Undefined]", GL = ns ? ns.toStringTag : void 0;
function Tc(t) {
  return t == null ? t === void 0 ? p6e : f6e : GL && GL in Object(t) ? c6e(t) : d6e(t);
}
function _s(t) {
  return t != null && typeof t == "object";
}
var g6e = "[object Symbol]";
function Xx(t) {
  return typeof t == "symbol" || _s(t) && Tc(t) == g6e;
}
function jx(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length, i = Array(n); ++r < n; )
    i[r] = e(t[r], r, t);
  return i;
}
var yr = Array.isArray, VL = ns ? ns.prototype : void 0, UL = VL ? VL.toString : void 0;
function UH(t) {
  if (typeof t == "string")
    return t;
  if (yr(t))
    return jx(t, UH) + "";
  if (Xx(t))
    return UL ? UL.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -1 / 0 ? "-0" : e;
}
var m6e = /\s/;
function v6e(t) {
  for (var e = t.length; e-- && m6e.test(t.charAt(e)); )
    ;
  return e;
}
var y6e = /^\s+/;
function x6e(t) {
  return t && t.slice(0, v6e(t) + 1).replace(y6e, "");
}
function is(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var HL = NaN, b6e = /^[-+]0x[0-9a-f]+$/i, w6e = /^0b[01]+$/i, T6e = /^0o[0-7]+$/i, E6e = parseInt;
function k6e(t) {
  if (typeof t == "number")
    return t;
  if (Xx(t))
    return HL;
  if (is(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = is(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = x6e(t);
  var r = w6e.test(t);
  return r || T6e.test(t) ? E6e(t.slice(2), r ? 2 : 8) : b6e.test(t) ? HL : +t;
}
var qL = 1 / 0, S6e = 17976931348623157e292;
function C6e(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = k6e(t), t === qL || t === -qL) {
    var e = t < 0 ? -1 : 1;
    return e * S6e;
  }
  return t === t ? t : 0;
}
function Kx(t) {
  var e = C6e(t), r = e % 1;
  return e === e ? r ? e - r : e : 0;
}
function Nd(t) {
  return t;
}
var A6e = "[object AsyncFunction]", _6e = "[object Function]", L6e = "[object GeneratorFunction]", R6e = "[object Proxy]";
function gl(t) {
  if (!is(t))
    return !1;
  var e = Tc(t);
  return e == _6e || e == L6e || e == A6e || e == R6e;
}
var v5 = vo["__core-js_shared__"], WL = (function() {
  var t = /[^.]+$/.exec(v5 && v5.keys && v5.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
})();
function M6e(t) {
  return !!WL && WL in t;
}
var N6e = Function.prototype, I6e = N6e.toString;
function ah(t) {
  if (t != null) {
    try {
      return I6e.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var D6e = /[\\^$.*+?()[\]{}|]/g, O6e = /^\[object .+?Constructor\]$/, P6e = Function.prototype, B6e = Object.prototype, F6e = P6e.toString, $6e = B6e.hasOwnProperty, z6e = RegExp(
  "^" + F6e.call($6e).replace(D6e, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function G6e(t) {
  if (!is(t) || M6e(t))
    return !1;
  var e = gl(t) ? z6e : O6e;
  return e.test(ah(t));
}
function V6e(t, e) {
  return t?.[e];
}
function sh(t, e) {
  var r = V6e(t, e);
  return G6e(r) ? r : void 0;
}
var VT = sh(vo, "WeakMap"), YL = Object.create, U6e = /* @__PURE__ */ (function() {
  function t() {
  }
  return function(e) {
    if (!is(e))
      return {};
    if (YL)
      return YL(e);
    t.prototype = e;
    var r = new t();
    return t.prototype = void 0, r;
  };
})();
function H6e(t, e, r) {
  switch (r.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, r[0]);
    case 2:
      return t.call(e, r[0], r[1]);
    case 3:
      return t.call(e, r[0], r[1], r[2]);
  }
  return t.apply(e, r);
}
function Nn() {
}
function q6e(t, e) {
  var r = -1, n = t.length;
  for (e || (e = Array(n)); ++r < n; )
    e[r] = t[r];
  return e;
}
var W6e = 800, Y6e = 16, X6e = Date.now;
function j6e(t) {
  var e = 0, r = 0;
  return function() {
    var n = X6e(), i = Y6e - (n - r);
    if (r = n, i > 0) {
      if (++e >= W6e)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
function K6e(t) {
  return function() {
    return t;
  };
}
var Wy = (function() {
  try {
    var t = sh(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
})(), Z6e = Wy ? function(t, e) {
  return Wy(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: K6e(e),
    writable: !0
  });
} : Nd, Q6e = j6e(Z6e);
function HH(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n && e(t[r], r, t) !== !1; )
    ;
  return t;
}
function qH(t, e, r, n) {
  for (var i = t.length, a = r + -1; ++a < i; )
    if (e(t[a], a, t))
      return a;
  return -1;
}
function J6e(t) {
  return t !== t;
}
function eEe(t, e, r) {
  for (var n = r - 1, i = t.length; ++n < i; )
    if (t[n] === e)
      return n;
  return -1;
}
function DS(t, e, r) {
  return e === e ? eEe(t, e, r) : qH(t, J6e, r);
}
function WH(t, e) {
  var r = t == null ? 0 : t.length;
  return !!r && DS(t, e, 0) > -1;
}
var tEe = 9007199254740991, rEe = /^(?:0|[1-9]\d*)$/;
function Zx(t, e) {
  var r = typeof t;
  return e = e ?? tEe, !!e && (r == "number" || r != "symbol" && rEe.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
function OS(t, e, r) {
  e == "__proto__" && Wy ? Wy(t, e, {
    configurable: !0,
    enumerable: !0,
    value: r,
    writable: !0
  }) : t[e] = r;
}
function Bg(t, e) {
  return t === e || t !== t && e !== e;
}
var nEe = Object.prototype, iEe = nEe.hasOwnProperty;
function Qx(t, e, r) {
  var n = t[e];
  (!(iEe.call(t, e) && Bg(n, r)) || r === void 0 && !(e in t)) && OS(t, e, r);
}
function Fg(t, e, r, n) {
  var i = !r;
  r || (r = {});
  for (var a = -1, s = e.length; ++a < s; ) {
    var o = e[a], l = void 0;
    l === void 0 && (l = t[o]), i ? OS(r, o, l) : Qx(r, o, l);
  }
  return r;
}
var XL = Math.max;
function aEe(t, e, r) {
  return e = XL(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var n = arguments, i = -1, a = XL(n.length - e, 0), s = Array(a); ++i < a; )
      s[i] = n[e + i];
    i = -1;
    for (var o = Array(e + 1); ++i < e; )
      o[i] = n[i];
    return o[e] = r(s), H6e(t, this, o);
  };
}
function PS(t, e) {
  return Q6e(aEe(t, e, Nd), t + "");
}
var sEe = 9007199254740991;
function BS(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= sEe;
}
function yo(t) {
  return t != null && BS(t.length) && !gl(t);
}
function YH(t, e, r) {
  if (!is(r))
    return !1;
  var n = typeof e;
  return (n == "number" ? yo(r) && Zx(e, r.length) : n == "string" && e in r) ? Bg(r[e], t) : !1;
}
function oEe(t) {
  return PS(function(e, r) {
    var n = -1, i = r.length, a = i > 1 ? r[i - 1] : void 0, s = i > 2 ? r[2] : void 0;
    for (a = t.length > 3 && typeof a == "function" ? (i--, a) : void 0, s && YH(r[0], r[1], s) && (a = i < 3 ? void 0 : a, i = 1), e = Object(e); ++n < i; ) {
      var o = r[n];
      o && t(e, o, n, a);
    }
    return e;
  });
}
var lEe = Object.prototype;
function $g(t) {
  var e = t && t.constructor, r = typeof e == "function" && e.prototype || lEe;
  return t === r;
}
function cEe(t, e) {
  for (var r = -1, n = Array(t); ++r < t; )
    n[r] = e(r);
  return n;
}
var uEe = "[object Arguments]";
function jL(t) {
  return _s(t) && Tc(t) == uEe;
}
var XH = Object.prototype, hEe = XH.hasOwnProperty, dEe = XH.propertyIsEnumerable, Jx = jL(/* @__PURE__ */ (function() {
  return arguments;
})()) ? jL : function(t) {
  return _s(t) && hEe.call(t, "callee") && !dEe.call(t, "callee");
};
function fEe() {
  return !1;
}
var jH = typeof exports == "object" && exports && !exports.nodeType && exports, KL = jH && typeof module == "object" && module && !module.nodeType && module, pEe = KL && KL.exports === jH, ZL = pEe ? vo.Buffer : void 0, gEe = ZL ? ZL.isBuffer : void 0, qp = gEe || fEe, mEe = "[object Arguments]", vEe = "[object Array]", yEe = "[object Boolean]", xEe = "[object Date]", bEe = "[object Error]", wEe = "[object Function]", TEe = "[object Map]", EEe = "[object Number]", kEe = "[object Object]", SEe = "[object RegExp]", CEe = "[object Set]", AEe = "[object String]", _Ee = "[object WeakMap]", LEe = "[object ArrayBuffer]", REe = "[object DataView]", MEe = "[object Float32Array]", NEe = "[object Float64Array]", IEe = "[object Int8Array]", DEe = "[object Int16Array]", OEe = "[object Int32Array]", PEe = "[object Uint8Array]", BEe = "[object Uint8ClampedArray]", FEe = "[object Uint16Array]", $Ee = "[object Uint32Array]", qr = {};
qr[MEe] = qr[NEe] = qr[IEe] = qr[DEe] = qr[OEe] = qr[PEe] = qr[BEe] = qr[FEe] = qr[$Ee] = !0;
qr[mEe] = qr[vEe] = qr[LEe] = qr[yEe] = qr[REe] = qr[xEe] = qr[bEe] = qr[wEe] = qr[TEe] = qr[EEe] = qr[kEe] = qr[SEe] = qr[CEe] = qr[AEe] = qr[_Ee] = !1;
function zEe(t) {
  return _s(t) && BS(t.length) && !!qr[Tc(t)];
}
function eb(t) {
  return function(e) {
    return t(e);
  };
}
var KH = typeof exports == "object" && exports && !exports.nodeType && exports, np = KH && typeof module == "object" && module && !module.nodeType && module, GEe = np && np.exports === KH, y5 = GEe && GH.process, ic = (function() {
  try {
    var t = np && np.require && np.require("util").types;
    return t || y5 && y5.binding && y5.binding("util");
  } catch {
  }
})(), QL = ic && ic.isTypedArray, FS = QL ? eb(QL) : zEe, VEe = Object.prototype, UEe = VEe.hasOwnProperty;
function ZH(t, e) {
  var r = yr(t), n = !r && Jx(t), i = !r && !n && qp(t), a = !r && !n && !i && FS(t), s = r || n || i || a, o = s ? cEe(t.length, String) : [], l = o.length;
  for (var u in t)
    (e || UEe.call(t, u)) && !(s && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    a && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    Zx(u, l))) && o.push(u);
  return o;
}
function QH(t, e) {
  return function(r) {
    return t(e(r));
  };
}
var HEe = QH(Object.keys, Object), qEe = Object.prototype, WEe = qEe.hasOwnProperty;
function JH(t) {
  if (!$g(t))
    return HEe(t);
  var e = [];
  for (var r in Object(t))
    WEe.call(t, r) && r != "constructor" && e.push(r);
  return e;
}
function as(t) {
  return yo(t) ? ZH(t) : JH(t);
}
var YEe = Object.prototype, XEe = YEe.hasOwnProperty, Aa = oEe(function(t, e) {
  if ($g(e) || yo(e)) {
    Fg(e, as(e), t);
    return;
  }
  for (var r in e)
    XEe.call(e, r) && Qx(t, r, e[r]);
});
function jEe(t) {
  var e = [];
  if (t != null)
    for (var r in Object(t))
      e.push(r);
  return e;
}
var KEe = Object.prototype, ZEe = KEe.hasOwnProperty;
function QEe(t) {
  if (!is(t))
    return jEe(t);
  var e = $g(t), r = [];
  for (var n in t)
    n == "constructor" && (e || !ZEe.call(t, n)) || r.push(n);
  return r;
}
function $S(t) {
  return yo(t) ? ZH(t, !0) : QEe(t);
}
var JEe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, eke = /^\w*$/;
function zS(t, e) {
  if (yr(t))
    return !1;
  var r = typeof t;
  return r == "number" || r == "symbol" || r == "boolean" || t == null || Xx(t) ? !0 : eke.test(t) || !JEe.test(t) || e != null && t in Object(e);
}
var Wp = sh(Object, "create");
function tke() {
  this.__data__ = Wp ? Wp(null) : {}, this.size = 0;
}
function rke(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var nke = "__lodash_hash_undefined__", ike = Object.prototype, ake = ike.hasOwnProperty;
function ske(t) {
  var e = this.__data__;
  if (Wp) {
    var r = e[t];
    return r === nke ? void 0 : r;
  }
  return ake.call(e, t) ? e[t] : void 0;
}
var oke = Object.prototype, lke = oke.hasOwnProperty;
function cke(t) {
  var e = this.__data__;
  return Wp ? e[t] !== void 0 : lke.call(e, t);
}
var uke = "__lodash_hash_undefined__";
function hke(t, e) {
  var r = this.__data__;
  return this.size += this.has(t) ? 0 : 1, r[t] = Wp && e === void 0 ? uke : e, this;
}
function Du(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
Du.prototype.clear = tke;
Du.prototype.delete = rke;
Du.prototype.get = ske;
Du.prototype.has = cke;
Du.prototype.set = hke;
function dke() {
  this.__data__ = [], this.size = 0;
}
function tb(t, e) {
  for (var r = t.length; r--; )
    if (Bg(t[r][0], e))
      return r;
  return -1;
}
var fke = Array.prototype, pke = fke.splice;
function gke(t) {
  var e = this.__data__, r = tb(e, t);
  if (r < 0)
    return !1;
  var n = e.length - 1;
  return r == n ? e.pop() : pke.call(e, r, 1), --this.size, !0;
}
function mke(t) {
  var e = this.__data__, r = tb(e, t);
  return r < 0 ? void 0 : e[r][1];
}
function vke(t) {
  return tb(this.__data__, t) > -1;
}
function yke(t, e) {
  var r = this.__data__, n = tb(r, t);
  return n < 0 ? (++this.size, r.push([t, e])) : r[n][1] = e, this;
}
function ml(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
ml.prototype.clear = dke;
ml.prototype.delete = gke;
ml.prototype.get = mke;
ml.prototype.has = vke;
ml.prototype.set = yke;
var Yp = sh(vo, "Map");
function xke() {
  this.size = 0, this.__data__ = {
    hash: new Du(),
    map: new (Yp || ml)(),
    string: new Du()
  };
}
function bke(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function rb(t, e) {
  var r = t.__data__;
  return bke(e) ? r[typeof e == "string" ? "string" : "hash"] : r.map;
}
function wke(t) {
  var e = rb(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function Tke(t) {
  return rb(this, t).get(t);
}
function Eke(t) {
  return rb(this, t).has(t);
}
function kke(t, e) {
  var r = rb(this, t), n = r.size;
  return r.set(t, e), this.size += r.size == n ? 0 : 1, this;
}
function vl(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
vl.prototype.clear = xke;
vl.prototype.delete = wke;
vl.prototype.get = Tke;
vl.prototype.has = Eke;
vl.prototype.set = kke;
var Ske = "Expected a function";
function GS(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(Ske);
  var r = function() {
    var n = arguments, i = e ? e.apply(this, n) : n[0], a = r.cache;
    if (a.has(i))
      return a.get(i);
    var s = t.apply(this, n);
    return r.cache = a.set(i, s) || a, s;
  };
  return r.cache = new (GS.Cache || vl)(), r;
}
GS.Cache = vl;
var Cke = 500;
function Ake(t) {
  var e = GS(t, function(n) {
    return r.size === Cke && r.clear(), n;
  }), r = e.cache;
  return e;
}
var _ke = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Lke = /\\(\\)?/g, Rke = Ake(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace(_ke, function(r, n, i, a) {
    e.push(i ? a.replace(Lke, "$1") : n || r);
  }), e;
});
function Mke(t) {
  return t == null ? "" : UH(t);
}
function nb(t, e) {
  return yr(t) ? t : zS(t, e) ? [t] : Rke(Mke(t));
}
function zg(t) {
  if (typeof t == "string" || Xx(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -1 / 0 ? "-0" : e;
}
function VS(t, e) {
  e = nb(e, t);
  for (var r = 0, n = e.length; t != null && r < n; )
    t = t[zg(e[r++])];
  return r && r == n ? t : void 0;
}
function Nke(t, e, r) {
  var n = t == null ? void 0 : VS(t, e);
  return n === void 0 ? r : n;
}
function US(t, e) {
  for (var r = -1, n = e.length, i = t.length; ++r < n; )
    t[i + r] = e[r];
  return t;
}
var JL = ns ? ns.isConcatSpreadable : void 0;
function Ike(t) {
  return yr(t) || Jx(t) || !!(JL && t && t[JL]);
}
function HS(t, e, r, n, i) {
  var a = -1, s = t.length;
  for (r || (r = Ike), i || (i = []); ++a < s; ) {
    var o = t[a];
    r(o) ? US(i, o) : n || (i[i.length] = o);
  }
  return i;
}
function Ts(t) {
  var e = t == null ? 0 : t.length;
  return e ? HS(t) : [];
}
var eq = QH(Object.getPrototypeOf, Object);
function tq(t, e, r) {
  var n = -1, i = t.length;
  e < 0 && (e = -e > i ? 0 : i + e), r = r > i ? i : r, r < 0 && (r += i), i = e > r ? 0 : r - e >>> 0, e >>>= 0;
  for (var a = Array(i); ++n < i; )
    a[n] = t[n + e];
  return a;
}
function Dke(t, e, r, n) {
  var i = -1, a = t == null ? 0 : t.length;
  for (n && a && (r = t[++i]); ++i < a; )
    r = e(r, t[i], i, t);
  return r;
}
function Oke() {
  this.__data__ = new ml(), this.size = 0;
}
function Pke(t) {
  var e = this.__data__, r = e.delete(t);
  return this.size = e.size, r;
}
function Bke(t) {
  return this.__data__.get(t);
}
function Fke(t) {
  return this.__data__.has(t);
}
var $ke = 200;
function zke(t, e) {
  var r = this.__data__;
  if (r instanceof ml) {
    var n = r.__data__;
    if (!Yp || n.length < $ke - 1)
      return n.push([t, e]), this.size = ++r.size, this;
    r = this.__data__ = new vl(n);
  }
  return r.set(t, e), this.size = r.size, this;
}
function ro(t) {
  var e = this.__data__ = new ml(t);
  this.size = e.size;
}
ro.prototype.clear = Oke;
ro.prototype.delete = Pke;
ro.prototype.get = Bke;
ro.prototype.has = Fke;
ro.prototype.set = zke;
function Gke(t, e) {
  return t && Fg(e, as(e), t);
}
function Vke(t, e) {
  return t && Fg(e, $S(e), t);
}
var rq = typeof exports == "object" && exports && !exports.nodeType && exports, eR = rq && typeof module == "object" && module && !module.nodeType && module, Uke = eR && eR.exports === rq, tR = Uke ? vo.Buffer : void 0, rR = tR ? tR.allocUnsafe : void 0;
function Hke(t, e) {
  var r = t.length, n = rR ? rR(r) : new t.constructor(r);
  return t.copy(n), n;
}
function qS(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length, i = 0, a = []; ++r < n; ) {
    var s = t[r];
    e(s, r, t) && (a[i++] = s);
  }
  return a;
}
function nq() {
  return [];
}
var qke = Object.prototype, Wke = qke.propertyIsEnumerable, nR = Object.getOwnPropertySymbols, WS = nR ? function(t) {
  return t == null ? [] : (t = Object(t), qS(nR(t), function(e) {
    return Wke.call(t, e);
  }));
} : nq;
function Yke(t, e) {
  return Fg(t, WS(t), e);
}
var Xke = Object.getOwnPropertySymbols, iq = Xke ? function(t) {
  for (var e = []; t; )
    US(e, WS(t)), t = eq(t);
  return e;
} : nq;
function jke(t, e) {
  return Fg(t, iq(t), e);
}
function aq(t, e, r) {
  var n = e(t);
  return yr(t) ? n : US(n, r(t));
}
function UT(t) {
  return aq(t, as, WS);
}
function Kke(t) {
  return aq(t, $S, iq);
}
var HT = sh(vo, "DataView"), qT = sh(vo, "Promise"), sd = sh(vo, "Set"), iR = "[object Map]", Zke = "[object Object]", aR = "[object Promise]", sR = "[object Set]", oR = "[object WeakMap]", lR = "[object DataView]", Qke = ah(HT), Jke = ah(Yp), eSe = ah(qT), tSe = ah(sd), rSe = ah(VT), Ua = Tc;
(HT && Ua(new HT(new ArrayBuffer(1))) != lR || Yp && Ua(new Yp()) != iR || qT && Ua(qT.resolve()) != aR || sd && Ua(new sd()) != sR || VT && Ua(new VT()) != oR) && (Ua = function(t) {
  var e = Tc(t), r = e == Zke ? t.constructor : void 0, n = r ? ah(r) : "";
  if (n)
    switch (n) {
      case Qke:
        return lR;
      case Jke:
        return iR;
      case eSe:
        return aR;
      case tSe:
        return sR;
      case rSe:
        return oR;
    }
  return e;
});
var nSe = Object.prototype, iSe = nSe.hasOwnProperty;
function aSe(t) {
  var e = t.length, r = new t.constructor(e);
  return e && typeof t[0] == "string" && iSe.call(t, "index") && (r.index = t.index, r.input = t.input), r;
}
var Yy = vo.Uint8Array;
function sSe(t) {
  var e = new t.constructor(t.byteLength);
  return new Yy(e).set(new Yy(t)), e;
}
function oSe(t, e) {
  var r = t.buffer;
  return new t.constructor(r, t.byteOffset, t.byteLength);
}
var lSe = /\w*$/;
function cSe(t) {
  var e = new t.constructor(t.source, lSe.exec(t));
  return e.lastIndex = t.lastIndex, e;
}
var cR = ns ? ns.prototype : void 0, uR = cR ? cR.valueOf : void 0;
function uSe(t) {
  return uR ? Object(uR.call(t)) : {};
}
function hSe(t, e) {
  var r = t.buffer;
  return new t.constructor(r, t.byteOffset, t.length);
}
var dSe = "[object Boolean]", fSe = "[object Date]", pSe = "[object Map]", gSe = "[object Number]", mSe = "[object RegExp]", vSe = "[object Set]", ySe = "[object String]", xSe = "[object Symbol]", bSe = "[object ArrayBuffer]", wSe = "[object DataView]", TSe = "[object Float32Array]", ESe = "[object Float64Array]", kSe = "[object Int8Array]", SSe = "[object Int16Array]", CSe = "[object Int32Array]", ASe = "[object Uint8Array]", _Se = "[object Uint8ClampedArray]", LSe = "[object Uint16Array]", RSe = "[object Uint32Array]";
function MSe(t, e, r) {
  var n = t.constructor;
  switch (e) {
    case bSe:
      return sSe(t);
    case dSe:
    case fSe:
      return new n(+t);
    case wSe:
      return oSe(t);
    case TSe:
    case ESe:
    case kSe:
    case SSe:
    case CSe:
    case ASe:
    case _Se:
    case LSe:
    case RSe:
      return hSe(t);
    case pSe:
      return new n();
    case gSe:
    case ySe:
      return new n(t);
    case mSe:
      return cSe(t);
    case vSe:
      return new n();
    case xSe:
      return uSe(t);
  }
}
function NSe(t) {
  return typeof t.constructor == "function" && !$g(t) ? U6e(eq(t)) : {};
}
var ISe = "[object Map]";
function DSe(t) {
  return _s(t) && Ua(t) == ISe;
}
var hR = ic && ic.isMap, OSe = hR ? eb(hR) : DSe, PSe = "[object Set]";
function BSe(t) {
  return _s(t) && Ua(t) == PSe;
}
var dR = ic && ic.isSet, FSe = dR ? eb(dR) : BSe, $Se = 2, sq = "[object Arguments]", zSe = "[object Array]", GSe = "[object Boolean]", VSe = "[object Date]", USe = "[object Error]", oq = "[object Function]", HSe = "[object GeneratorFunction]", qSe = "[object Map]", WSe = "[object Number]", lq = "[object Object]", YSe = "[object RegExp]", XSe = "[object Set]", jSe = "[object String]", KSe = "[object Symbol]", ZSe = "[object WeakMap]", QSe = "[object ArrayBuffer]", JSe = "[object DataView]", e7e = "[object Float32Array]", t7e = "[object Float64Array]", r7e = "[object Int8Array]", n7e = "[object Int16Array]", i7e = "[object Int32Array]", a7e = "[object Uint8Array]", s7e = "[object Uint8ClampedArray]", o7e = "[object Uint16Array]", l7e = "[object Uint32Array]", $r = {};
$r[sq] = $r[zSe] = $r[QSe] = $r[JSe] = $r[GSe] = $r[VSe] = $r[e7e] = $r[t7e] = $r[r7e] = $r[n7e] = $r[i7e] = $r[qSe] = $r[WSe] = $r[lq] = $r[YSe] = $r[XSe] = $r[jSe] = $r[KSe] = $r[a7e] = $r[s7e] = $r[o7e] = $r[l7e] = !0;
$r[USe] = $r[oq] = $r[ZSe] = !1;
function Zm(t, e, r, n, i, a) {
  var s, o = e & $Se;
  if (s !== void 0)
    return s;
  if (!is(t))
    return t;
  var l = yr(t);
  if (l)
    return s = aSe(t), q6e(t, s);
  var u = Ua(t), h = u == oq || u == HSe;
  if (qp(t))
    return Hke(t);
  if (u == lq || u == sq || h && !i)
    return s = h ? {} : NSe(t), o ? jke(t, Vke(s, t)) : Yke(t, Gke(s, t));
  if (!$r[u])
    return i ? t : {};
  s = MSe(t, u), a || (a = new ro());
  var d = a.get(t);
  if (d)
    return d;
  a.set(t, s), FSe(t) ? t.forEach(function(g) {
    s.add(Zm(g, e, r, g, t, a));
  }) : OSe(t) && t.forEach(function(g, m) {
    s.set(m, Zm(g, e, r, m, t, a));
  });
  var f = UT, p = l ? void 0 : f(t);
  return HH(p || t, function(g, m) {
    p && (m = g, g = t[m]), Qx(s, m, Zm(g, e, r, m, t, a));
  }), s;
}
var c7e = 4;
function di(t) {
  return Zm(t, c7e);
}
function Gg(t) {
  for (var e = -1, r = t == null ? 0 : t.length, n = 0, i = []; ++e < r; ) {
    var a = t[e];
    a && (i[n++] = a);
  }
  return i;
}
var u7e = "__lodash_hash_undefined__";
function h7e(t) {
  return this.__data__.set(t, u7e), this;
}
function d7e(t) {
  return this.__data__.has(t);
}
function Id(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.__data__ = new vl(); ++e < r; )
    this.add(t[e]);
}
Id.prototype.add = Id.prototype.push = h7e;
Id.prototype.has = d7e;
function cq(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n; )
    if (e(t[r], r, t))
      return !0;
  return !1;
}
function YS(t, e) {
  return t.has(e);
}
var f7e = 1, p7e = 2;
function uq(t, e, r, n, i, a) {
  var s = r & f7e, o = t.length, l = e.length;
  if (o != l && !(s && l > o))
    return !1;
  var u = a.get(t), h = a.get(e);
  if (u && h)
    return u == e && h == t;
  var d = -1, f = !0, p = r & p7e ? new Id() : void 0;
  for (a.set(t, e), a.set(e, t); ++d < o; ) {
    var g = t[d], m = e[d];
    if (n)
      var v = s ? n(m, g, d, e, t, a) : n(g, m, d, t, e, a);
    if (v !== void 0) {
      if (v)
        continue;
      f = !1;
      break;
    }
    if (p) {
      if (!cq(e, function(y, b) {
        if (!YS(p, b) && (g === y || i(g, y, r, n, a)))
          return p.push(b);
      })) {
        f = !1;
        break;
      }
    } else if (!(g === m || i(g, m, r, n, a))) {
      f = !1;
      break;
    }
  }
  return a.delete(t), a.delete(e), f;
}
function g7e(t) {
  var e = -1, r = Array(t.size);
  return t.forEach(function(n, i) {
    r[++e] = [i, n];
  }), r;
}
function XS(t) {
  var e = -1, r = Array(t.size);
  return t.forEach(function(n) {
    r[++e] = n;
  }), r;
}
var m7e = 1, v7e = 2, y7e = "[object Boolean]", x7e = "[object Date]", b7e = "[object Error]", w7e = "[object Map]", T7e = "[object Number]", E7e = "[object RegExp]", k7e = "[object Set]", S7e = "[object String]", C7e = "[object Symbol]", A7e = "[object ArrayBuffer]", _7e = "[object DataView]", fR = ns ? ns.prototype : void 0, x5 = fR ? fR.valueOf : void 0;
function L7e(t, e, r, n, i, a, s) {
  switch (r) {
    case _7e:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case A7e:
      return !(t.byteLength != e.byteLength || !a(new Yy(t), new Yy(e)));
    case y7e:
    case x7e:
    case T7e:
      return Bg(+t, +e);
    case b7e:
      return t.name == e.name && t.message == e.message;
    case E7e:
    case S7e:
      return t == e + "";
    case w7e:
      var o = g7e;
    case k7e:
      var l = n & m7e;
      if (o || (o = XS), t.size != e.size && !l)
        return !1;
      var u = s.get(t);
      if (u)
        return u == e;
      n |= v7e, s.set(t, e);
      var h = uq(o(t), o(e), n, i, a, s);
      return s.delete(t), h;
    case C7e:
      if (x5)
        return x5.call(t) == x5.call(e);
  }
  return !1;
}
var R7e = 1, M7e = Object.prototype, N7e = M7e.hasOwnProperty;
function I7e(t, e, r, n, i, a) {
  var s = r & R7e, o = UT(t), l = o.length, u = UT(e), h = u.length;
  if (l != h && !s)
    return !1;
  for (var d = l; d--; ) {
    var f = o[d];
    if (!(s ? f in e : N7e.call(e, f)))
      return !1;
  }
  var p = a.get(t), g = a.get(e);
  if (p && g)
    return p == e && g == t;
  var m = !0;
  a.set(t, e), a.set(e, t);
  for (var v = s; ++d < l; ) {
    f = o[d];
    var y = t[f], b = e[f];
    if (n)
      var w = s ? n(b, y, f, e, t, a) : n(y, b, f, t, e, a);
    if (!(w === void 0 ? y === b || i(y, b, r, n, a) : w)) {
      m = !1;
      break;
    }
    v || (v = f == "constructor");
  }
  if (m && !v) {
    var T = t.constructor, E = e.constructor;
    T != E && "constructor" in t && "constructor" in e && !(typeof T == "function" && T instanceof T && typeof E == "function" && E instanceof E) && (m = !1);
  }
  return a.delete(t), a.delete(e), m;
}
var D7e = 1, pR = "[object Arguments]", gR = "[object Array]", K1 = "[object Object]", O7e = Object.prototype, mR = O7e.hasOwnProperty;
function P7e(t, e, r, n, i, a) {
  var s = yr(t), o = yr(e), l = s ? gR : Ua(t), u = o ? gR : Ua(e);
  l = l == pR ? K1 : l, u = u == pR ? K1 : u;
  var h = l == K1, d = u == K1, f = l == u;
  if (f && qp(t)) {
    if (!qp(e))
      return !1;
    s = !0, h = !1;
  }
  if (f && !h)
    return a || (a = new ro()), s || FS(t) ? uq(t, e, r, n, i, a) : L7e(t, e, l, r, n, i, a);
  if (!(r & D7e)) {
    var p = h && mR.call(t, "__wrapped__"), g = d && mR.call(e, "__wrapped__");
    if (p || g) {
      var m = p ? t.value() : t, v = g ? e.value() : e;
      return a || (a = new ro()), i(m, v, r, n, a);
    }
  }
  return f ? (a || (a = new ro()), I7e(t, e, r, n, i, a)) : !1;
}
function jS(t, e, r, n, i) {
  return t === e ? !0 : t == null || e == null || !_s(t) && !_s(e) ? t !== t && e !== e : P7e(t, e, r, n, jS, i);
}
var B7e = 1, F7e = 2;
function $7e(t, e, r, n) {
  var i = r.length, a = i;
  if (t == null)
    return !a;
  for (t = Object(t); i--; ) {
    var s = r[i];
    if (s[2] ? s[1] !== t[s[0]] : !(s[0] in t))
      return !1;
  }
  for (; ++i < a; ) {
    s = r[i];
    var o = s[0], l = t[o], u = s[1];
    if (s[2]) {
      if (l === void 0 && !(o in t))
        return !1;
    } else {
      var h = new ro(), d;
      if (!(d === void 0 ? jS(u, l, B7e | F7e, n, h) : d))
        return !1;
    }
  }
  return !0;
}
function hq(t) {
  return t === t && !is(t);
}
function z7e(t) {
  for (var e = as(t), r = e.length; r--; ) {
    var n = e[r], i = t[n];
    e[r] = [n, i, hq(i)];
  }
  return e;
}
function dq(t, e) {
  return function(r) {
    return r == null ? !1 : r[t] === e && (e !== void 0 || t in Object(r));
  };
}
function G7e(t) {
  var e = z7e(t);
  return e.length == 1 && e[0][2] ? dq(e[0][0], e[0][1]) : function(r) {
    return r === t || $7e(r, t, e);
  };
}
function V7e(t, e) {
  return t != null && e in Object(t);
}
function fq(t, e, r) {
  e = nb(e, t);
  for (var n = -1, i = e.length, a = !1; ++n < i; ) {
    var s = zg(e[n]);
    if (!(a = t != null && r(t, s)))
      break;
    t = t[s];
  }
  return a || ++n != i ? a : (i = t == null ? 0 : t.length, !!i && BS(i) && Zx(s, i) && (yr(t) || Jx(t)));
}
function U7e(t, e) {
  return t != null && fq(t, e, V7e);
}
var H7e = 1, q7e = 2;
function W7e(t, e) {
  return zS(t) && hq(e) ? dq(zg(t), e) : function(r) {
    var n = Nke(r, t);
    return n === void 0 && n === e ? U7e(r, t) : jS(e, n, H7e | q7e);
  };
}
function Y7e(t) {
  return function(e) {
    return e?.[t];
  };
}
function X7e(t) {
  return function(e) {
    return VS(e, t);
  };
}
function j7e(t) {
  return zS(t) ? Y7e(zg(t)) : X7e(t);
}
function xo(t) {
  return typeof t == "function" ? t : t == null ? Nd : typeof t == "object" ? yr(t) ? W7e(t[0], t[1]) : G7e(t) : j7e(t);
}
function K7e(t, e, r, n) {
  for (var i = -1, a = t == null ? 0 : t.length; ++i < a; ) {
    var s = t[i];
    e(n, s, r(s), t);
  }
  return n;
}
function Z7e(t) {
  return function(e, r, n) {
    for (var i = -1, a = Object(e), s = n(e), o = s.length; o--; ) {
      var l = s[++i];
      if (r(a[l], l, a) === !1)
        break;
    }
    return e;
  };
}
var Q7e = Z7e();
function J7e(t, e) {
  return t && Q7e(t, e, as);
}
function eCe(t, e) {
  return function(r, n) {
    if (r == null)
      return r;
    if (!yo(r))
      return t(r, n);
    for (var i = r.length, a = -1, s = Object(r); ++a < i && n(s[a], a, s) !== !1; )
      ;
    return r;
  };
}
var oh = eCe(J7e);
function tCe(t, e, r, n) {
  return oh(t, function(i, a, s) {
    e(n, i, r(i), s);
  }), n;
}
function rCe(t, e) {
  return function(r, n) {
    var i = yr(r) ? K7e : tCe, a = e ? e() : {};
    return i(r, t, xo(n), a);
  };
}
var pq = Object.prototype, nCe = pq.hasOwnProperty, KS = PS(function(t, e) {
  t = Object(t);
  var r = -1, n = e.length, i = n > 2 ? e[2] : void 0;
  for (i && YH(e[0], e[1], i) && (n = 1); ++r < n; )
    for (var a = e[r], s = $S(a), o = -1, l = s.length; ++o < l; ) {
      var u = s[o], h = t[u];
      (h === void 0 || Bg(h, pq[u]) && !nCe.call(t, u)) && (t[u] = a[u]);
    }
  return t;
});
function vR(t) {
  return _s(t) && yo(t);
}
var iCe = 200;
function aCe(t, e, r, n) {
  var i = -1, a = WH, s = !0, o = t.length, l = [], u = e.length;
  if (!o)
    return l;
  e.length >= iCe && (a = YS, s = !1, e = new Id(e));
  e:
    for (; ++i < o; ) {
      var h = t[i], d = h;
      if (h = h !== 0 ? h : 0, s && d === d) {
        for (var f = u; f--; )
          if (e[f] === d)
            continue e;
        l.push(h);
      } else a(e, d, n) || l.push(h);
    }
  return l;
}
var ib = PS(function(t, e) {
  return vR(t) ? aCe(t, HS(e, 1, vR, !0)) : [];
});
function Dd(t) {
  var e = t == null ? 0 : t.length;
  return e ? t[e - 1] : void 0;
}
function ii(t, e, r) {
  var n = t == null ? 0 : t.length;
  return n ? (e = e === void 0 ? 1 : Kx(e), tq(t, e < 0 ? 0 : e, n)) : [];
}
function Xp(t, e, r) {
  var n = t == null ? 0 : t.length;
  return n ? (e = e === void 0 ? 1 : Kx(e), e = n - e, tq(t, 0, e < 0 ? 0 : e)) : [];
}
function sCe(t) {
  return typeof t == "function" ? t : Nd;
}
function Wt(t, e) {
  var r = yr(t) ? HH : oh;
  return r(t, sCe(e));
}
function oCe(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n; )
    if (!e(t[r], r, t))
      return !1;
  return !0;
}
function lCe(t, e) {
  var r = !0;
  return oh(t, function(n, i, a) {
    return r = !!e(n, i, a), r;
  }), r;
}
function Es(t, e, r) {
  var n = yr(t) ? oCe : lCe;
  return n(t, xo(e));
}
function gq(t, e) {
  var r = [];
  return oh(t, function(n, i, a) {
    e(n, i, a) && r.push(n);
  }), r;
}
function ss(t, e) {
  var r = yr(t) ? qS : gq;
  return r(t, xo(e));
}
function cCe(t) {
  return function(e, r, n) {
    var i = Object(e);
    if (!yo(e)) {
      var a = xo(r);
      e = as(e), r = function(o) {
        return a(i[o], o, i);
      };
    }
    var s = t(e, r, n);
    return s > -1 ? i[a ? e[s] : s] : void 0;
  };
}
var uCe = Math.max;
function hCe(t, e, r) {
  var n = t == null ? 0 : t.length;
  if (!n)
    return -1;
  var i = r == null ? 0 : Kx(r);
  return i < 0 && (i = uCe(n + i, 0)), qH(t, xo(e), i);
}
var Od = cCe(hCe);
function Ls(t) {
  return t && t.length ? t[0] : void 0;
}
function dCe(t, e) {
  var r = -1, n = yo(t) ? Array(t.length) : [];
  return oh(t, function(i, a, s) {
    n[++r] = e(i, a, s);
  }), n;
}
function Ot(t, e) {
  var r = yr(t) ? jx : dCe;
  return r(t, xo(e));
}
function Ka(t, e) {
  return HS(Ot(t, e));
}
var fCe = Object.prototype, pCe = fCe.hasOwnProperty, gCe = rCe(function(t, e, r) {
  pCe.call(t, r) ? t[r].push(e) : OS(t, r, [e]);
}), mCe = Object.prototype, vCe = mCe.hasOwnProperty;
function yCe(t, e) {
  return t != null && vCe.call(t, e);
}
function Vt(t, e) {
  return t != null && fq(t, e, yCe);
}
var xCe = "[object String]";
function ua(t) {
  return typeof t == "string" || !yr(t) && _s(t) && Tc(t) == xCe;
}
function bCe(t, e) {
  return jx(e, function(r) {
    return t[r];
  });
}
function On(t) {
  return t == null ? [] : bCe(t, as(t));
}
var wCe = Math.max;
function Zi(t, e, r, n) {
  t = yo(t) ? t : On(t), r = r ? Kx(r) : 0;
  var i = t.length;
  return r < 0 && (r = wCe(i + r, 0)), ua(t) ? r <= i && t.indexOf(e, r) > -1 : !!i && DS(t, e, r) > -1;
}
function yR(t, e, r) {
  var n = t == null ? 0 : t.length;
  if (!n)
    return -1;
  var i = 0;
  return DS(t, e, i);
}
var TCe = "[object Map]", ECe = "[object Set]", kCe = Object.prototype, SCe = kCe.hasOwnProperty;
function zr(t) {
  if (t == null)
    return !0;
  if (yo(t) && (yr(t) || typeof t == "string" || typeof t.splice == "function" || qp(t) || FS(t) || Jx(t)))
    return !t.length;
  var e = Ua(t);
  if (e == TCe || e == ECe)
    return !t.size;
  if ($g(t))
    return !JH(t).length;
  for (var r in t)
    if (SCe.call(t, r))
      return !1;
  return !0;
}
var CCe = "[object RegExp]";
function ACe(t) {
  return _s(t) && Tc(t) == CCe;
}
var xR = ic && ic.isRegExp, al = xR ? eb(xR) : ACe;
function sl(t) {
  return t === void 0;
}
var _Ce = "Expected a function";
function LCe(t) {
  if (typeof t != "function")
    throw new TypeError(_Ce);
  return function() {
    var e = arguments;
    switch (e.length) {
      case 0:
        return !t.call(this);
      case 1:
        return !t.call(this, e[0]);
      case 2:
        return !t.call(this, e[0], e[1]);
      case 3:
        return !t.call(this, e[0], e[1], e[2]);
    }
    return !t.apply(this, e);
  };
}
function RCe(t, e, r, n) {
  if (!is(t))
    return t;
  e = nb(e, t);
  for (var i = -1, a = e.length, s = a - 1, o = t; o != null && ++i < a; ) {
    var l = zg(e[i]), u = r;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return t;
    if (i != s) {
      var h = o[l];
      u = void 0, u === void 0 && (u = is(h) ? h : Zx(e[i + 1]) ? [] : {});
    }
    Qx(o, l, u), o = o[l];
  }
  return t;
}
function MCe(t, e, r) {
  for (var n = -1, i = e.length, a = {}; ++n < i; ) {
    var s = e[n], o = VS(t, s);
    r(o, s) && RCe(a, nb(s, t), o);
  }
  return a;
}
function Ms(t, e) {
  if (t == null)
    return {};
  var r = jx(Kke(t), function(n) {
    return [n];
  });
  return e = xo(e), MCe(t, r, function(n, i) {
    return e(n, i[0]);
  });
}
function NCe(t, e, r, n, i) {
  return i(t, function(a, s, o) {
    r = n ? (n = !1, a) : e(r, a, s, o);
  }), r;
}
function _a(t, e, r) {
  var n = yr(t) ? Dke : NCe, i = arguments.length < 3;
  return n(t, xo(e), r, i, oh);
}
function ab(t, e) {
  var r = yr(t) ? qS : gq;
  return r(t, LCe(xo(e)));
}
function ICe(t, e) {
  var r;
  return oh(t, function(n, i, a) {
    return r = e(n, i, a), !r;
  }), !!r;
}
function mq(t, e, r) {
  var n = yr(t) ? cq : ICe;
  return n(t, xo(e));
}
var DCe = 1 / 0, OCe = sd && 1 / XS(new sd([, -0]))[1] == DCe ? function(t) {
  return new sd(t);
} : Nn, PCe = 200;
function BCe(t, e, r) {
  var n = -1, i = WH, a = t.length, s = !0, o = [], l = o;
  if (a >= PCe) {
    var u = OCe(t);
    if (u)
      return XS(u);
    s = !1, i = YS, l = new Id();
  } else
    l = o;
  e:
    for (; ++n < a; ) {
      var h = t[n], d = h;
      if (h = h !== 0 ? h : 0, s && d === d) {
        for (var f = l.length; f--; )
          if (l[f] === d)
            continue e;
        o.push(h);
      } else i(l, d, r) || (l !== o && l.push(d), o.push(h));
    }
  return o;
}
function ZS(t) {
  return t && t.length ? BCe(t) : [];
}
function WT(t) {
  console && console.error && console.error(`Error: ${t}`);
}
function vq(t) {
  console && console.warn && console.warn(`Warning: ${t}`);
}
function yq(t) {
  const e = (/* @__PURE__ */ new Date()).getTime(), r = t();
  return { time: (/* @__PURE__ */ new Date()).getTime() - e, value: r };
}
function xq(t) {
  function e() {
  }
  e.prototype = t;
  const r = new e();
  function n() {
    return typeof r.bar;
  }
  return n(), n(), t;
}
function FCe(t) {
  return $Ce(t) ? t.LABEL : t.name;
}
function $Ce(t) {
  return ua(t.LABEL) && t.LABEL !== "";
}
class bo {
  get definition() {
    return this._definition;
  }
  set definition(e) {
    this._definition = e;
  }
  constructor(e) {
    this._definition = e;
  }
  accept(e) {
    e.visit(this), Wt(this.definition, (r) => {
      r.accept(e);
    });
  }
}
class Wi extends bo {
  constructor(e) {
    super([]), this.idx = 1, Aa(this, Ms(e, (r) => r !== void 0));
  }
  set definition(e) {
  }
  get definition() {
    return this.referencedRule !== void 0 ? this.referencedRule.definition : [];
  }
  accept(e) {
    e.visit(this);
  }
}
class uf extends bo {
  constructor(e) {
    super(e.definition), this.orgText = "", Aa(this, Ms(e, (r) => r !== void 0));
  }
}
class ha extends bo {
  constructor(e) {
    super(e.definition), this.ignoreAmbiguities = !1, Aa(this, Ms(e, (r) => r !== void 0));
  }
}
let hi = class extends bo {
  constructor(e) {
    super(e.definition), this.idx = 1, Aa(this, Ms(e, (r) => r !== void 0));
  }
};
class Na extends bo {
  constructor(e) {
    super(e.definition), this.idx = 1, Aa(this, Ms(e, (r) => r !== void 0));
  }
}
class Ia extends bo {
  constructor(e) {
    super(e.definition), this.idx = 1, Aa(this, Ms(e, (r) => r !== void 0));
  }
}
class ln extends bo {
  constructor(e) {
    super(e.definition), this.idx = 1, Aa(this, Ms(e, (r) => r !== void 0));
  }
}
class pa extends bo {
  constructor(e) {
    super(e.definition), this.idx = 1, Aa(this, Ms(e, (r) => r !== void 0));
  }
}
class ga extends bo {
  get definition() {
    return this._definition;
  }
  set definition(e) {
    this._definition = e;
  }
  constructor(e) {
    super(e.definition), this.idx = 1, this.ignoreAmbiguities = !1, this.hasPredicates = !1, Aa(this, Ms(e, (r) => r !== void 0));
  }
}
class Yr {
  constructor(e) {
    this.idx = 1, Aa(this, Ms(e, (r) => r !== void 0));
  }
  accept(e) {
    e.visit(this);
  }
}
function zCe(t) {
  return Ot(t, Qm);
}
function Qm(t) {
  function e(r) {
    return Ot(r, Qm);
  }
  if (t instanceof Wi) {
    const r = {
      type: "NonTerminal",
      name: t.nonTerminalName,
      idx: t.idx
    };
    return ua(t.label) && (r.label = t.label), r;
  } else {
    if (t instanceof ha)
      return {
        type: "Alternative",
        definition: e(t.definition)
      };
    if (t instanceof hi)
      return {
        type: "Option",
        idx: t.idx,
        definition: e(t.definition)
      };
    if (t instanceof Na)
      return {
        type: "RepetitionMandatory",
        idx: t.idx,
        definition: e(t.definition)
      };
    if (t instanceof Ia)
      return {
        type: "RepetitionMandatoryWithSeparator",
        idx: t.idx,
        separator: Qm(new Yr({ terminalType: t.separator })),
        definition: e(t.definition)
      };
    if (t instanceof pa)
      return {
        type: "RepetitionWithSeparator",
        idx: t.idx,
        separator: Qm(new Yr({ terminalType: t.separator })),
        definition: e(t.definition)
      };
    if (t instanceof ln)
      return {
        type: "Repetition",
        idx: t.idx,
        definition: e(t.definition)
      };
    if (t instanceof ga)
      return {
        type: "Alternation",
        idx: t.idx,
        definition: e(t.definition)
      };
    if (t instanceof Yr) {
      const r = {
        type: "Terminal",
        name: t.terminalType.name,
        label: FCe(t.terminalType),
        idx: t.idx
      };
      ua(t.label) && (r.terminalLabel = t.label);
      const n = t.terminalType.PATTERN;
      return t.terminalType.PATTERN && (r.pattern = al(n) ? n.source : n), r;
    } else {
      if (t instanceof uf)
        return {
          type: "Rule",
          name: t.name,
          orgText: t.orgText,
          definition: e(t.definition)
        };
      throw Error("non exhaustive match");
    }
  }
}
class hf {
  visit(e) {
    const r = e;
    switch (r.constructor) {
      case Wi:
        return this.visitNonTerminal(r);
      case ha:
        return this.visitAlternative(r);
      case hi:
        return this.visitOption(r);
      case Na:
        return this.visitRepetitionMandatory(r);
      case Ia:
        return this.visitRepetitionMandatoryWithSeparator(r);
      case pa:
        return this.visitRepetitionWithSeparator(r);
      case ln:
        return this.visitRepetition(r);
      case ga:
        return this.visitAlternation(r);
      case Yr:
        return this.visitTerminal(r);
      case uf:
        return this.visitRule(r);
      /* c8 ignore next 2 */
      default:
        throw Error("non exhaustive match");
    }
  }
  /* c8 ignore next */
  visitNonTerminal(e) {
  }
  /* c8 ignore next */
  visitAlternative(e) {
  }
  /* c8 ignore next */
  visitOption(e) {
  }
  /* c8 ignore next */
  visitRepetition(e) {
  }
  /* c8 ignore next */
  visitRepetitionMandatory(e) {
  }
  /* c8 ignore next 3 */
  visitRepetitionMandatoryWithSeparator(e) {
  }
  /* c8 ignore next */
  visitRepetitionWithSeparator(e) {
  }
  /* c8 ignore next */
  visitAlternation(e) {
  }
  /* c8 ignore next */
  visitTerminal(e) {
  }
  /* c8 ignore next */
  visitRule(e) {
  }
}
function GCe(t) {
  return t instanceof ha || t instanceof hi || t instanceof ln || t instanceof Na || t instanceof Ia || t instanceof pa || t instanceof Yr || t instanceof uf;
}
function Xy(t, e = []) {
  return t instanceof hi || t instanceof ln || t instanceof pa ? !0 : t instanceof ga ? mq(t.definition, (n) => Xy(n, e)) : t instanceof Wi && Zi(e, t) ? !1 : t instanceof bo ? (t instanceof Wi && e.push(t), Es(t.definition, (n) => Xy(n, e))) : !1;
}
function VCe(t) {
  return t instanceof ga;
}
function Ws(t) {
  if (t instanceof Wi)
    return "SUBRULE";
  if (t instanceof hi)
    return "OPTION";
  if (t instanceof ga)
    return "OR";
  if (t instanceof Na)
    return "AT_LEAST_ONE";
  if (t instanceof Ia)
    return "AT_LEAST_ONE_SEP";
  if (t instanceof pa)
    return "MANY_SEP";
  if (t instanceof ln)
    return "MANY";
  if (t instanceof Yr)
    return "CONSUME";
  throw Error("non exhaustive match");
}
class sb {
  walk(e, r = []) {
    Wt(e.definition, (n, i) => {
      const a = ii(e.definition, i + 1);
      if (n instanceof Wi)
        this.walkProdRef(n, a, r);
      else if (n instanceof Yr)
        this.walkTerminal(n, a, r);
      else if (n instanceof ha)
        this.walkFlat(n, a, r);
      else if (n instanceof hi)
        this.walkOption(n, a, r);
      else if (n instanceof Na)
        this.walkAtLeastOne(n, a, r);
      else if (n instanceof Ia)
        this.walkAtLeastOneSep(n, a, r);
      else if (n instanceof pa)
        this.walkManySep(n, a, r);
      else if (n instanceof ln)
        this.walkMany(n, a, r);
      else if (n instanceof ga)
        this.walkOr(n, a, r);
      else
        throw Error("non exhaustive match");
    });
  }
  walkTerminal(e, r, n) {
  }
  walkProdRef(e, r, n) {
  }
  walkFlat(e, r, n) {
    const i = r.concat(n);
    this.walk(e, i);
  }
  walkOption(e, r, n) {
    const i = r.concat(n);
    this.walk(e, i);
  }
  walkAtLeastOne(e, r, n) {
    const i = [
      new hi({ definition: e.definition })
    ].concat(r, n);
    this.walk(e, i);
  }
  walkAtLeastOneSep(e, r, n) {
    const i = bR(e, r, n);
    this.walk(e, i);
  }
  walkMany(e, r, n) {
    const i = [
      new hi({ definition: e.definition })
    ].concat(r, n);
    this.walk(e, i);
  }
  walkManySep(e, r, n) {
    const i = bR(e, r, n);
    this.walk(e, i);
  }
  walkOr(e, r, n) {
    const i = r.concat(n);
    Wt(e.definition, (a) => {
      const s = new ha({ definition: [a] });
      this.walk(s, i);
    });
  }
}
function bR(t, e, r) {
  return [
    new hi({
      definition: [
        new Yr({ terminalType: t.separator })
      ].concat(t.definition)
    })
  ].concat(e, r);
}
function Vg(t) {
  if (t instanceof Wi)
    return Vg(t.referencedRule);
  if (t instanceof Yr)
    return qCe(t);
  if (GCe(t))
    return UCe(t);
  if (VCe(t))
    return HCe(t);
  throw Error("non exhaustive match");
}
function UCe(t) {
  let e = [];
  const r = t.definition;
  let n = 0, i = r.length > n, a, s = !0;
  for (; i && s; )
    a = r[n], s = Xy(a), e = e.concat(Vg(a)), n = n + 1, i = r.length > n;
  return ZS(e);
}
function HCe(t) {
  const e = Ot(t.definition, (r) => Vg(r));
  return ZS(Ts(e));
}
function qCe(t) {
  return [t.terminalType];
}
const bq = "_~IN~_";
class WCe extends sb {
  constructor(e) {
    super(), this.topProd = e, this.follows = {};
  }
  startWalking() {
    return this.walk(this.topProd), this.follows;
  }
  walkTerminal(e, r, n) {
  }
  walkProdRef(e, r, n) {
    const i = XCe(e.referencedRule, e.idx) + this.topProd.name, a = r.concat(n), s = new ha({ definition: a }), o = Vg(s);
    this.follows[i] = o;
  }
}
function YCe(t) {
  const e = {};
  return Wt(t, (r) => {
    const n = new WCe(r).startWalking();
    Aa(e, n);
  }), e;
}
function XCe(t, e) {
  return t.name + e + bq;
}
let Jm = {};
const jCe = new IH();
function ob(t) {
  const e = t.toString();
  if (Jm.hasOwnProperty(e))
    return Jm[e];
  {
    const r = jCe.pattern(e);
    return Jm[e] = r, r;
  }
}
function KCe() {
  Jm = {};
}
const wq = "Complement Sets are not supported for first char optimization", jy = `Unable to use "first char" lexer optimizations:
`;
function ZCe(t, e = !1) {
  try {
    const r = ob(t);
    return YT(r.value, {}, r.flags.ignoreCase);
  } catch (r) {
    if (r.message === wq)
      e && vq(`${jy}	Unable to optimize: < ${t.toString()} >
	Complement Sets cannot be automatically optimized.
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);
    else {
      let n = "";
      e && (n = `
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.`), WT(`${jy}
	Failed parsing: < ${t.toString()} >
	Using the @chevrotain/regexp-to-ast library
	Please open an issue at: https://github.com/chevrotain/chevrotain/issues` + n);
    }
  }
  return [];
}
function YT(t, e, r) {
  switch (t.type) {
    case "Disjunction":
      for (let i = 0; i < t.value.length; i++)
        YT(t.value[i], e, r);
      break;
    case "Alternative":
      const n = t.value;
      for (let i = 0; i < n.length; i++) {
        const a = n[i];
        switch (a.type) {
          case "EndAnchor":
          // A group back reference cannot affect potential starting char.
          // because if a back reference is the first production than automatically
          // the group being referenced has had to come BEFORE so its codes have already been added
          case "GroupBackReference":
          // assertions do not affect potential starting codes
          case "Lookahead":
          case "NegativeLookahead":
          case "StartAnchor":
          case "WordBoundary":
          case "NonWordBoundary":
            continue;
        }
        const s = a;
        switch (s.type) {
          case "Character":
            Z1(s.value, e, r);
            break;
          case "Set":
            if (s.complement === !0)
              throw Error(wq);
            Wt(s.value, (l) => {
              if (typeof l == "number")
                Z1(l, e, r);
              else {
                const u = l;
                if (r === !0)
                  for (let h = u.from; h <= u.to; h++)
                    Z1(h, e, r);
                else {
                  for (let h = u.from; h <= u.to && h < N0; h++)
                    Z1(h, e, r);
                  if (u.to >= N0) {
                    const h = u.from >= N0 ? u.from : N0, d = u.to, f = ac(h), p = ac(d);
                    for (let g = f; g <= p; g++)
                      e[g] = g;
                  }
                }
              }
            });
            break;
          case "Group":
            YT(s.value, e, r);
            break;
          /* istanbul ignore next */
          default:
            throw Error("Non Exhaustive Match");
        }
        const o = s.quantifier !== void 0 && s.quantifier.atLeast === 0;
        if (
          // A group may be optional due to empty contents /(?:)/
          // or if everything inside it is optional /((a)?)/
          s.type === "Group" && XT(s) === !1 || // If this term is not a group it may only be optional if it has an optional quantifier
          s.type !== "Group" && o === !1
        )
          break;
      }
      break;
    /* istanbul ignore next */
    default:
      throw Error("non exhaustive match!");
  }
  return On(e);
}
function Z1(t, e, r) {
  const n = ac(t);
  e[n] = n, r === !0 && QCe(t, e);
}
function QCe(t, e) {
  const r = String.fromCharCode(t), n = r.toUpperCase();
  if (n !== r) {
    const i = ac(n.charCodeAt(0));
    e[i] = i;
  } else {
    const i = r.toLowerCase();
    if (i !== r) {
      const a = ac(i.charCodeAt(0));
      e[a] = a;
    }
  }
}
function wR(t, e) {
  return Od(t.value, (r) => {
    if (typeof r == "number")
      return Zi(e, r);
    {
      const n = r;
      return Od(e, (i) => n.from <= i && i <= n.to) !== void 0;
    }
  });
}
function XT(t) {
  const e = t.quantifier;
  return e && e.atLeast === 0 ? !0 : t.value ? yr(t.value) ? Es(t.value, XT) : XT(t.value) : !1;
}
class JCe extends Wx {
  constructor(e) {
    super(), this.targetCharCodes = e, this.found = !1;
  }
  visitChildren(e) {
    if (this.found !== !0) {
      switch (e.type) {
        case "Lookahead":
          this.visitLookahead(e);
          return;
        case "NegativeLookahead":
          this.visitNegativeLookahead(e);
          return;
      }
      super.visitChildren(e);
    }
  }
  visitCharacter(e) {
    Zi(this.targetCharCodes, e.value) && (this.found = !0);
  }
  visitSet(e) {
    e.complement ? wR(e, this.targetCharCodes) === void 0 && (this.found = !0) : wR(e, this.targetCharCodes) !== void 0 && (this.found = !0);
  }
}
function QS(t, e) {
  if (e instanceof RegExp) {
    const r = ob(e), n = new JCe(t);
    return n.visit(r), n.found;
  } else
    return Od(e, (r) => Zi(t, r.charCodeAt(0))) !== void 0;
}
const Ou = "PATTERN", M0 = "defaultMode", Q1 = "modes";
let Tq = typeof new RegExp("(?:)").sticky == "boolean";
function e8e(t, e) {
  e = KS(e, {
    useSticky: Tq,
    debug: !1,
    safeMode: !1,
    positionTracking: "full",
    lineTerminatorCharacters: ["\r", `
`],
    tracer: (b, w) => w()
  });
  const r = e.tracer;
  r("initCharCodeToOptimizedIndexMap", () => {
    E8e();
  });
  let n;
  r("Reject Lexer.NA", () => {
    n = ab(t, (b) => b[Ou] === la.NA);
  });
  let i = !1, a;
  r("Transform Patterns", () => {
    i = !1, a = Ot(n, (b) => {
      const w = b[Ou];
      if (al(w)) {
        const T = w.source;
        return T.length === 1 && // only these regExp meta characters which can appear in a length one regExp
        T !== "^" && T !== "$" && T !== "." && !w.ignoreCase ? T : T.length === 2 && T[0] === "\\" && // not a meta character
        !Zi([
          "d",
          "D",
          "s",
          "S",
          "t",
          "r",
          "n",
          "t",
          "0",
          "c",
          "b",
          "B",
          "f",
          "v",
          "w",
          "W"
        ], T[1]) ? T[1] : e.useSticky ? ER(w) : TR(w);
      } else {
        if (gl(w))
          return i = !0, { exec: w };
        if (typeof w == "object")
          return i = !0, w;
        if (typeof w == "string") {
          if (w.length === 1)
            return w;
          {
            const T = w.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&"), E = new RegExp(T);
            return e.useSticky ? ER(E) : TR(E);
          }
        } else
          throw Error("non exhaustive match");
      }
    });
  });
  let s, o, l, u, h;
  r("misc mapping", () => {
    s = Ot(n, (b) => b.tokenTypeIdx), o = Ot(n, (b) => {
      const w = b.GROUP;
      if (w !== la.SKIPPED) {
        if (ua(w))
          return w;
        if (sl(w))
          return !1;
        throw Error("non exhaustive match");
      }
    }), l = Ot(n, (b) => {
      const w = b.LONGER_ALT;
      if (w)
        return yr(w) ? Ot(w, (E) => yR(n, E)) : [yR(n, w)];
    }), u = Ot(n, (b) => b.PUSH_MODE), h = Ot(n, (b) => Vt(b, "POP_MODE"));
  });
  let d;
  r("Line Terminator Handling", () => {
    const b = Sq(e.lineTerminatorCharacters);
    d = Ot(n, (w) => !1), e.positionTracking !== "onlyOffset" && (d = Ot(n, (w) => Vt(w, "LINE_BREAKS") ? !!w.LINE_BREAKS : kq(w, b) === !1 && QS(b, w.PATTERN)));
  });
  let f, p, g, m;
  r("Misc Mapping #2", () => {
    f = Ot(n, Eq), p = Ot(a, b8e), g = _a(n, (b, w) => {
      const T = w.GROUP;
      return ua(T) && T !== la.SKIPPED && (b[T] = []), b;
    }, {}), m = Ot(a, (b, w) => ({
      pattern: a[w],
      longerAlt: l[w],
      canLineTerminator: d[w],
      isCustom: f[w],
      short: p[w],
      group: o[w],
      push: u[w],
      pop: h[w],
      tokenTypeIdx: s[w],
      tokenType: n[w]
    }));
  });
  let v = !0, y = [];
  return e.safeMode || r("First Char Optimization", () => {
    y = _a(n, (b, w, T) => {
      if (typeof w.PATTERN == "string") {
        const E = w.PATTERN.charCodeAt(0), L = ac(E);
        b5(b, L, m[T]);
      } else if (yr(w.START_CHARS_HINT)) {
        let E;
        Wt(w.START_CHARS_HINT, (L) => {
          const k = typeof L == "string" ? L.charCodeAt(0) : L, C = ac(k);
          E !== C && (E = C, b5(b, C, m[T]));
        });
      } else if (al(w.PATTERN))
        if (w.PATTERN.unicode)
          v = !1, e.ensureOptimizations && WT(`${jy}	Unable to analyze < ${w.PATTERN.toString()} > pattern.
	The regexp unicode flag is not currently supported by the regexp-to-ast library.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);
        else {
          const E = ZCe(w.PATTERN, e.ensureOptimizations);
          zr(E) && (v = !1), Wt(E, (L) => {
            b5(b, L, m[T]);
          });
        }
      else
        e.ensureOptimizations && WT(`${jy}	TokenType: <${w.name}> is using a custom token pattern without providing <start_chars_hint> parameter.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`), v = !1;
      return b;
    }, []);
  }), {
    emptyGroups: g,
    patternIdxToConfig: m,
    charCodeToPatternIdxToConfig: y,
    hasCustom: i,
    canBeOptimized: v
  };
}
function t8e(t, e) {
  let r = [];
  const n = n8e(t);
  r = r.concat(n.errors);
  const i = i8e(n.valid), a = i.valid;
  return r = r.concat(i.errors), r = r.concat(r8e(a)), r = r.concat(d8e(a)), r = r.concat(f8e(a, e)), r = r.concat(p8e(a)), r;
}
function r8e(t) {
  let e = [];
  const r = ss(t, (n) => al(n[Ou]));
  return e = e.concat(s8e(r)), e = e.concat(c8e(r)), e = e.concat(u8e(r)), e = e.concat(h8e(r)), e = e.concat(o8e(r)), e;
}
function n8e(t) {
  const e = ss(t, (i) => !Vt(i, Ou)), r = Ot(e, (i) => ({
    message: "Token Type: ->" + i.name + "<- missing static 'PATTERN' property",
    type: cn.MISSING_PATTERN,
    tokenTypes: [i]
  })), n = ib(t, e);
  return { errors: r, valid: n };
}
function i8e(t) {
  const e = ss(t, (i) => {
    const a = i[Ou];
    return !al(a) && !gl(a) && !Vt(a, "exec") && !ua(a);
  }), r = Ot(e, (i) => ({
    message: "Token Type: ->" + i.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
    type: cn.INVALID_PATTERN,
    tokenTypes: [i]
  })), n = ib(t, e);
  return { errors: r, valid: n };
}
const a8e = /[^\\][$]/;
function s8e(t) {
  class e extends Wx {
    constructor() {
      super(...arguments), this.found = !1;
    }
    visitEndAnchor(a) {
      this.found = !0;
    }
  }
  const r = ss(t, (i) => {
    const a = i.PATTERN;
    try {
      const s = ob(a), o = new e();
      return o.visit(s), o.found;
    } catch {
      return a8e.test(a.source);
    }
  });
  return Ot(r, (i) => ({
    message: `Unexpected RegExp Anchor Error:
	Token Type: ->` + i.name + `<- static 'PATTERN' cannot contain end of input anchor '$'
	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
    type: cn.EOI_ANCHOR_FOUND,
    tokenTypes: [i]
  }));
}
function o8e(t) {
  const e = ss(t, (n) => n.PATTERN.test(""));
  return Ot(e, (n) => ({
    message: "Token Type: ->" + n.name + "<- static 'PATTERN' must not match an empty string",
    type: cn.EMPTY_MATCH_PATTERN,
    tokenTypes: [n]
  }));
}
const l8e = /[^\\[][\^]|^\^/;
function c8e(t) {
  class e extends Wx {
    constructor() {
      super(...arguments), this.found = !1;
    }
    visitStartAnchor(a) {
      this.found = !0;
    }
  }
  const r = ss(t, (i) => {
    const a = i.PATTERN;
    try {
      const s = ob(a), o = new e();
      return o.visit(s), o.found;
    } catch {
      return l8e.test(a.source);
    }
  });
  return Ot(r, (i) => ({
    message: `Unexpected RegExp Anchor Error:
	Token Type: ->` + i.name + `<- static 'PATTERN' cannot contain start of input anchor '^'
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
    type: cn.SOI_ANCHOR_FOUND,
    tokenTypes: [i]
  }));
}
function u8e(t) {
  const e = ss(t, (n) => {
    const i = n[Ou];
    return i instanceof RegExp && (i.multiline || i.global);
  });
  return Ot(e, (n) => ({
    message: "Token Type: ->" + n.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
    type: cn.UNSUPPORTED_FLAGS_FOUND,
    tokenTypes: [n]
  }));
}
function h8e(t) {
  const e = [];
  let r = Ot(t, (a) => _a(t, (s, o) => (a.PATTERN.source === o.PATTERN.source && !Zi(e, o) && o.PATTERN !== la.NA && (e.push(o), s.push(o)), s), []));
  r = Gg(r);
  const n = ss(r, (a) => a.length > 1);
  return Ot(n, (a) => {
    const s = Ot(a, (l) => l.name);
    return {
      message: `The same RegExp pattern ->${Ls(a).PATTERN}<-has been used in all of the following Token Types: ${s.join(", ")} <-`,
      type: cn.DUPLICATE_PATTERNS_FOUND,
      tokenTypes: a
    };
  });
}
function d8e(t) {
  const e = ss(t, (n) => {
    if (!Vt(n, "GROUP"))
      return !1;
    const i = n.GROUP;
    return i !== la.SKIPPED && i !== la.NA && !ua(i);
  });
  return Ot(e, (n) => ({
    message: "Token Type: ->" + n.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
    type: cn.INVALID_GROUP_TYPE_FOUND,
    tokenTypes: [n]
  }));
}
function f8e(t, e) {
  const r = ss(t, (i) => i.PUSH_MODE !== void 0 && !Zi(e, i.PUSH_MODE));
  return Ot(r, (i) => ({
    message: `Token Type: ->${i.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${i.PUSH_MODE}<-which does not exist`,
    type: cn.PUSH_MODE_DOES_NOT_EXIST,
    tokenTypes: [i]
  }));
}
function p8e(t) {
  const e = [], r = _a(t, (n, i, a) => {
    const s = i.PATTERN;
    return s === la.NA || (ua(s) ? n.push({ str: s, idx: a, tokenType: i }) : al(s) && m8e(s) && n.push({ str: s.source, idx: a, tokenType: i })), n;
  }, []);
  return Wt(t, (n, i) => {
    Wt(r, ({ str: a, idx: s, tokenType: o }) => {
      if (i < s && g8e(a, n.PATTERN)) {
        const l = `Token: ->${o.name}<- can never be matched.
Because it appears AFTER the Token Type ->${n.name}<-in the lexer's definition.
See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;
        e.push({
          message: l,
          type: cn.UNREACHABLE_PATTERN,
          tokenTypes: [n, o]
        });
      }
    });
  }), e;
}
function g8e(t, e) {
  if (al(e)) {
    const r = e.exec(t);
    return r !== null && r.index === 0;
  } else {
    if (gl(e))
      return e(t, 0, [], {});
    if (Vt(e, "exec"))
      return e.exec(t, 0, [], {});
    if (typeof e == "string")
      return e === t;
    throw Error("non exhaustive match");
  }
}
function m8e(t) {
  return Od([
    ".",
    "\\",
    "[",
    "]",
    "|",
    "^",
    "$",
    "(",
    ")",
    "?",
    "*",
    "+",
    "{"
  ], (r) => t.source.indexOf(r) !== -1) === void 0;
}
function TR(t) {
  const e = t.ignoreCase ? "i" : "";
  return new RegExp(`^(?:${t.source})`, e);
}
function ER(t) {
  const e = t.ignoreCase ? "iy" : "y";
  return new RegExp(`${t.source}`, e);
}
function v8e(t, e, r) {
  const n = [];
  return Vt(t, M0) || n.push({
    message: "A MultiMode Lexer cannot be initialized without a <" + M0 + `> property in its definition
`,
    type: cn.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
  }), Vt(t, Q1) || n.push({
    message: "A MultiMode Lexer cannot be initialized without a <" + Q1 + `> property in its definition
`,
    type: cn.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
  }), Vt(t, Q1) && Vt(t, M0) && !Vt(t.modes, t.defaultMode) && n.push({
    message: `A MultiMode Lexer cannot be initialized with a ${M0}: <${t.defaultMode}>which does not exist
`,
    type: cn.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
  }), Vt(t, Q1) && Wt(t.modes, (i, a) => {
    Wt(i, (s, o) => {
      if (sl(s))
        n.push({
          message: `A Lexer cannot be initialized using an undefined Token Type. Mode:<${a}> at index: <${o}>
`,
          type: cn.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
        });
      else if (Vt(s, "LONGER_ALT")) {
        const l = yr(s.LONGER_ALT) ? s.LONGER_ALT : [s.LONGER_ALT];
        Wt(l, (u) => {
          !sl(u) && !Zi(i, u) && n.push({
            message: `A MultiMode Lexer cannot be initialized with a longer_alt <${u.name}> on token <${s.name}> outside of mode <${a}>
`,
            type: cn.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE
          });
        });
      }
    });
  }), n;
}
function y8e(t, e, r) {
  const n = [];
  let i = !1;
  const a = Gg(Ts(On(t.modes))), s = ab(a, (l) => l[Ou] === la.NA), o = Sq(r);
  return e && Wt(s, (l) => {
    const u = kq(l, o);
    if (u !== !1) {
      const d = {
        message: T8e(l, u),
        type: u.issue,
        tokenType: l
      };
      n.push(d);
    } else
      Vt(l, "LINE_BREAKS") ? l.LINE_BREAKS === !0 && (i = !0) : QS(o, l.PATTERN) && (i = !0);
  }), e && !i && n.push({
    message: `Warning: No LINE_BREAKS Found.
	This Lexer has been defined to track line and column information,
	But none of the Token Types can be identified as matching a line terminator.
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS 
	for details.`,
    type: cn.NO_LINE_BREAKS_FLAGS
  }), n;
}
function x8e(t) {
  const e = {}, r = as(t);
  return Wt(r, (n) => {
    const i = t[n];
    if (yr(i))
      e[n] = [];
    else
      throw Error("non exhaustive match");
  }), e;
}
function Eq(t) {
  const e = t.PATTERN;
  if (al(e))
    return !1;
  if (gl(e))
    return !0;
  if (Vt(e, "exec"))
    return !0;
  if (ua(e))
    return !1;
  throw Error("non exhaustive match");
}
function b8e(t) {
  return ua(t) && t.length === 1 ? t.charCodeAt(0) : !1;
}
const w8e = {
  // implements /\n|\r\n?/g.test
  test: function(t) {
    const e = t.length;
    for (let r = this.lastIndex; r < e; r++) {
      const n = t.charCodeAt(r);
      if (n === 10)
        return this.lastIndex = r + 1, !0;
      if (n === 13)
        return t.charCodeAt(r + 1) === 10 ? this.lastIndex = r + 2 : this.lastIndex = r + 1, !0;
    }
    return !1;
  },
  lastIndex: 0
};
function kq(t, e) {
  if (Vt(t, "LINE_BREAKS"))
    return !1;
  if (al(t.PATTERN)) {
    try {
      QS(e, t.PATTERN);
    } catch (r) {
      return {
        issue: cn.IDENTIFY_TERMINATOR,
        errMsg: r.message
      };
    }
    return !1;
  } else {
    if (ua(t.PATTERN))
      return !1;
    if (Eq(t))
      return { issue: cn.CUSTOM_LINE_BREAK };
    throw Error("non exhaustive match");
  }
}
function T8e(t, e) {
  if (e.issue === cn.IDENTIFY_TERMINATOR)
    return `Warning: unable to identify line terminator usage in pattern.
	The problem is in the <${t.name}> Token Type
	 Root cause: ${e.errMsg}.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR`;
  if (e.issue === cn.CUSTOM_LINE_BREAK)
    return `Warning: A Custom Token Pattern should specify the <line_breaks> option.
	The problem is in the <${t.name}> Token Type
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK`;
  throw Error("non exhaustive match");
}
function Sq(t) {
  return Ot(t, (r) => ua(r) ? r.charCodeAt(0) : r);
}
function b5(t, e, r) {
  t[e] === void 0 ? t[e] = [r] : t[e].push(r);
}
const N0 = 256;
let ev = [];
function ac(t) {
  return t < N0 ? t : ev[t];
}
function E8e() {
  if (zr(ev)) {
    ev = new Array(65536);
    for (let t = 0; t < 65536; t++)
      ev[t] = t > 255 ? 255 + ~~(t / 255) : t;
  }
}
function Ug(t, e) {
  const r = t.tokenTypeIdx;
  return r === e.tokenTypeIdx ? !0 : e.isParent === !0 && e.categoryMatchesMap[r] === !0;
}
function Ky(t, e) {
  return t.tokenTypeIdx === e.tokenTypeIdx;
}
let kR = 1;
const Cq = {};
function Hg(t) {
  const e = k8e(t);
  S8e(e), A8e(e), C8e(e), Wt(e, (r) => {
    r.isParent = r.categoryMatches.length > 0;
  });
}
function k8e(t) {
  let e = di(t), r = t, n = !0;
  for (; n; ) {
    r = Gg(Ts(Ot(r, (a) => a.CATEGORIES)));
    const i = ib(r, e);
    e = e.concat(i), zr(i) ? n = !1 : r = i;
  }
  return e;
}
function S8e(t) {
  Wt(t, (e) => {
    _q(e) || (Cq[kR] = e, e.tokenTypeIdx = kR++), SR(e) && !yr(e.CATEGORIES) && (e.CATEGORIES = [e.CATEGORIES]), SR(e) || (e.CATEGORIES = []), _8e(e) || (e.categoryMatches = []), L8e(e) || (e.categoryMatchesMap = {});
  });
}
function C8e(t) {
  Wt(t, (e) => {
    e.categoryMatches = [], Wt(e.categoryMatchesMap, (r, n) => {
      e.categoryMatches.push(Cq[n].tokenTypeIdx);
    });
  });
}
function A8e(t) {
  Wt(t, (e) => {
    Aq([], e);
  });
}
function Aq(t, e) {
  Wt(t, (r) => {
    e.categoryMatchesMap[r.tokenTypeIdx] = !0;
  }), Wt(e.CATEGORIES, (r) => {
    const n = t.concat(e);
    Zi(n, r) || Aq(n, r);
  });
}
function _q(t) {
  return Vt(t, "tokenTypeIdx");
}
function SR(t) {
  return Vt(t, "CATEGORIES");
}
function _8e(t) {
  return Vt(t, "categoryMatches");
}
function L8e(t) {
  return Vt(t, "categoryMatchesMap");
}
function R8e(t) {
  return Vt(t, "tokenTypeIdx");
}
const jT = {
  buildUnableToPopLexerModeMessage(t) {
    return `Unable to pop Lexer Mode after encountering Token ->${t.image}<- The Mode Stack is empty`;
  },
  buildUnexpectedCharactersMessage(t, e, r, n, i) {
    return `unexpected character: ->${t.charAt(e)}<- at offset: ${e}, skipped ${r} characters.`;
  }
};
var cn;
(function(t) {
  t[t.MISSING_PATTERN = 0] = "MISSING_PATTERN", t[t.INVALID_PATTERN = 1] = "INVALID_PATTERN", t[t.EOI_ANCHOR_FOUND = 2] = "EOI_ANCHOR_FOUND", t[t.UNSUPPORTED_FLAGS_FOUND = 3] = "UNSUPPORTED_FLAGS_FOUND", t[t.DUPLICATE_PATTERNS_FOUND = 4] = "DUPLICATE_PATTERNS_FOUND", t[t.INVALID_GROUP_TYPE_FOUND = 5] = "INVALID_GROUP_TYPE_FOUND", t[t.PUSH_MODE_DOES_NOT_EXIST = 6] = "PUSH_MODE_DOES_NOT_EXIST", t[t.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE", t[t.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY", t[t.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST", t[t.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED", t[t.SOI_ANCHOR_FOUND = 11] = "SOI_ANCHOR_FOUND", t[t.EMPTY_MATCH_PATTERN = 12] = "EMPTY_MATCH_PATTERN", t[t.NO_LINE_BREAKS_FLAGS = 13] = "NO_LINE_BREAKS_FLAGS", t[t.UNREACHABLE_PATTERN = 14] = "UNREACHABLE_PATTERN", t[t.IDENTIFY_TERMINATOR = 15] = "IDENTIFY_TERMINATOR", t[t.CUSTOM_LINE_BREAK = 16] = "CUSTOM_LINE_BREAK", t[t.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE = 17] = "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE";
})(cn || (cn = {}));
const I0 = {
  deferDefinitionErrorsHandling: !1,
  positionTracking: "full",
  lineTerminatorsPattern: /\n|\r\n?/g,
  lineTerminatorCharacters: [`
`, "\r"],
  ensureOptimizations: !1,
  safeMode: !1,
  errorMessageProvider: jT,
  traceInitPerf: !1,
  skipValidations: !1,
  recoveryEnabled: !0
};
Object.freeze(I0);
class la {
  constructor(e, r = I0) {
    if (this.lexerDefinition = e, this.lexerDefinitionErrors = [], this.lexerDefinitionWarning = [], this.patternIdxToConfig = {}, this.charCodeToPatternIdxToConfig = {}, this.modes = [], this.emptyGroups = {}, this.trackStartLines = !0, this.trackEndLines = !0, this.hasCustom = !1, this.canModeBeOptimized = {}, this.TRACE_INIT = (i, a) => {
      if (this.traceInitPerf === !0) {
        this.traceInitIndent++;
        const s = new Array(this.traceInitIndent + 1).join("	");
        this.traceInitIndent < this.traceInitMaxIdent && console.log(`${s}--> <${i}>`);
        const { time: o, value: l } = yq(a), u = o > 10 ? console.warn : console.log;
        return this.traceInitIndent < this.traceInitMaxIdent && u(`${s}<-- <${i}> time: ${o}ms`), this.traceInitIndent--, l;
      } else
        return a();
    }, typeof r == "boolean")
      throw Error(`The second argument to the Lexer constructor is now an ILexerConfig Object.
a boolean 2nd argument is no longer supported`);
    this.config = Aa({}, I0, r);
    const n = this.config.traceInitPerf;
    n === !0 ? (this.traceInitMaxIdent = 1 / 0, this.traceInitPerf = !0) : typeof n == "number" && (this.traceInitMaxIdent = n, this.traceInitPerf = !0), this.traceInitIndent = -1, this.TRACE_INIT("Lexer Constructor", () => {
      let i, a = !0;
      this.TRACE_INIT("Lexer Config handling", () => {
        if (this.config.lineTerminatorsPattern === I0.lineTerminatorsPattern)
          this.config.lineTerminatorsPattern = w8e;
        else if (this.config.lineTerminatorCharacters === I0.lineTerminatorCharacters)
          throw Error(`Error: Missing <lineTerminatorCharacters> property on the Lexer config.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS`);
        if (r.safeMode && r.ensureOptimizations)
          throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
        this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking), this.trackEndLines = /full/i.test(this.config.positionTracking), yr(e) ? i = {
          modes: { defaultMode: di(e) },
          defaultMode: M0
        } : (a = !1, i = di(e));
      }), this.config.skipValidations === !1 && (this.TRACE_INIT("performRuntimeChecks", () => {
        this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(v8e(i, this.trackStartLines, this.config.lineTerminatorCharacters));
      }), this.TRACE_INIT("performWarningRuntimeChecks", () => {
        this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(y8e(i, this.trackStartLines, this.config.lineTerminatorCharacters));
      })), i.modes = i.modes ? i.modes : {}, Wt(i.modes, (o, l) => {
        i.modes[l] = ab(o, (u) => sl(u));
      });
      const s = as(i.modes);
      if (Wt(i.modes, (o, l) => {
        this.TRACE_INIT(`Mode: <${l}> processing`, () => {
          if (this.modes.push(l), this.config.skipValidations === !1 && this.TRACE_INIT("validatePatterns", () => {
            this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(t8e(o, s));
          }), zr(this.lexerDefinitionErrors)) {
            Hg(o);
            let u;
            this.TRACE_INIT("analyzeTokenTypes", () => {
              u = e8e(o, {
                lineTerminatorCharacters: this.config.lineTerminatorCharacters,
                positionTracking: r.positionTracking,
                ensureOptimizations: r.ensureOptimizations,
                safeMode: r.safeMode,
                tracer: this.TRACE_INIT
              });
            }), this.patternIdxToConfig[l] = u.patternIdxToConfig, this.charCodeToPatternIdxToConfig[l] = u.charCodeToPatternIdxToConfig, this.emptyGroups = Aa({}, this.emptyGroups, u.emptyGroups), this.hasCustom = u.hasCustom || this.hasCustom, this.canModeBeOptimized[l] = u.canBeOptimized;
          }
        });
      }), this.defaultMode = i.defaultMode, !zr(this.lexerDefinitionErrors) && !this.config.deferDefinitionErrorsHandling) {
        const l = Ot(this.lexerDefinitionErrors, (u) => u.message).join(`-----------------------
`);
        throw new Error(`Errors detected in definition of Lexer:
` + l);
      }
      Wt(this.lexerDefinitionWarning, (o) => {
        vq(o.message);
      }), this.TRACE_INIT("Choosing sub-methods implementations", () => {
        if (Tq ? (this.chopInput = Nd, this.match = this.matchWithTest) : (this.updateLastIndex = Nn, this.match = this.matchWithExec), a && (this.handleModes = Nn), this.trackStartLines === !1 && (this.computeNewColumn = Nd), this.trackEndLines === !1 && (this.updateTokenEndLineColumnLocation = Nn), /full/i.test(this.config.positionTracking))
          this.createTokenInstance = this.createFullToken;
        else if (/onlyStart/i.test(this.config.positionTracking))
          this.createTokenInstance = this.createStartOnlyToken;
        else if (/onlyOffset/i.test(this.config.positionTracking))
          this.createTokenInstance = this.createOffsetOnlyToken;
        else
          throw Error(`Invalid <positionTracking> config option: "${this.config.positionTracking}"`);
        this.hasCustom ? (this.addToken = this.addTokenUsingPush, this.handlePayload = this.handlePayloadWithCustom) : (this.addToken = this.addTokenUsingMemberAccess, this.handlePayload = this.handlePayloadNoCustom);
      }), this.TRACE_INIT("Failed Optimization Warnings", () => {
        const o = _a(this.canModeBeOptimized, (l, u, h) => (u === !1 && l.push(h), l), []);
        if (r.ensureOptimizations && !zr(o))
          throw Error(`Lexer Modes: < ${o.join(", ")} > cannot be optimized.
	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.
	 Or inspect the console log for details on how to resolve these issues.`);
      }), this.TRACE_INIT("clearRegExpParserCache", () => {
        KCe();
      }), this.TRACE_INIT("toFastProperties", () => {
        xq(this);
      });
    });
  }
  tokenize(e, r = this.defaultMode) {
    if (!zr(this.lexerDefinitionErrors)) {
      const i = Ot(this.lexerDefinitionErrors, (a) => a.message).join(`-----------------------
`);
      throw new Error(`Unable to Tokenize because Errors detected in definition of Lexer:
` + i);
    }
    return this.tokenizeInternal(e, r);
  }
  // There is quite a bit of duplication between this and "tokenizeInternalLazy"
  // This is intentional due to performance considerations.
  // this method also used quite a bit of `!` none null assertions because it is too optimized
  // for `tsc` to always understand it is "safe"
  tokenizeInternal(e, r) {
    let n, i, a, s, o, l, u, h, d, f, p, g, m, v, y;
    const b = e, w = b.length;
    let T = 0, E = 0;
    const L = this.hasCustom ? 0 : Math.floor(e.length / 10), k = new Array(L), C = [];
    let A = this.trackStartLines ? 1 : void 0, R = this.trackStartLines ? 1 : void 0;
    const _ = x8e(this.emptyGroups), O = this.trackStartLines, P = this.config.lineTerminatorsPattern;
    let S = 0, M = [], N = [];
    const D = [], I = [];
    Object.freeze(I);
    let B;
    function z() {
      return M;
    }
    function F(ae) {
      const re = ac(ae), pe = N[re];
      return pe === void 0 ? I : pe;
    }
    const V = (ae) => {
      if (D.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"
      // So no error should occur.
      ae.tokenType.PUSH_MODE === void 0) {
        const re = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(ae);
        C.push({
          offset: ae.startOffset,
          line: ae.startLine,
          column: ae.startColumn,
          length: ae.image.length,
          message: re
        });
      } else {
        D.pop();
        const re = Dd(D);
        M = this.patternIdxToConfig[re], N = this.charCodeToPatternIdxToConfig[re], S = M.length;
        const pe = this.canModeBeOptimized[re] && this.config.safeMode === !1;
        N && pe ? B = F : B = z;
      }
    };
    function H(ae) {
      D.push(ae), N = this.charCodeToPatternIdxToConfig[ae], M = this.patternIdxToConfig[ae], S = M.length, S = M.length;
      const re = this.canModeBeOptimized[ae] && this.config.safeMode === !1;
      N && re ? B = F : B = z;
    }
    H.call(this, r);
    let J;
    const q = this.config.recoveryEnabled;
    for (; T < w; ) {
      l = null;
      const ae = b.charCodeAt(T), re = B(ae), pe = re.length;
      for (n = 0; n < pe; n++) {
        J = re[n];
        const K = J.pattern;
        u = null;
        const Z = J.short;
        if (Z !== !1 ? ae === Z && (l = K) : J.isCustom === !0 ? (y = K.exec(b, T, k, _), y !== null ? (l = y[0], y.payload !== void 0 && (u = y.payload)) : l = null) : (this.updateLastIndex(K, T), l = this.match(K, e, T)), l !== null) {
          if (o = J.longerAlt, o !== void 0) {
            const X = o.length;
            for (a = 0; a < X; a++) {
              const Y = M[o[a]], ee = Y.pattern;
              if (h = null, Y.isCustom === !0 ? (y = ee.exec(b, T, k, _), y !== null ? (s = y[0], y.payload !== void 0 && (h = y.payload)) : s = null) : (this.updateLastIndex(ee, T), s = this.match(ee, e, T)), s && s.length > l.length) {
                l = s, u = h, J = Y;
                break;
              }
            }
          }
          break;
        }
      }
      if (l !== null) {
        if (d = l.length, f = J.group, f !== void 0 && (p = J.tokenTypeIdx, g = this.createTokenInstance(l, T, p, J.tokenType, A, R, d), this.handlePayload(g, u), f === !1 ? E = this.addToken(k, E, g) : _[f].push(g)), e = this.chopInput(e, d), T = T + d, R = this.computeNewColumn(R, d), O === !0 && J.canLineTerminator === !0) {
          let K = 0, Z, X;
          P.lastIndex = 0;
          do
            Z = P.test(l), Z === !0 && (X = P.lastIndex - 1, K++);
          while (Z === !0);
          K !== 0 && (A = A + K, R = d - X, this.updateTokenEndLineColumnLocation(g, f, X, K, A, R, d));
        }
        this.handleModes(J, V, H, g);
      } else {
        const K = T, Z = A, X = R;
        let Y = q === !1;
        for (; Y === !1 && T < w; )
          for (e = this.chopInput(e, 1), T++, i = 0; i < S; i++) {
            const ee = M[i], j = ee.pattern, fe = ee.short;
            if (fe !== !1 ? b.charCodeAt(T) === fe && (Y = !0) : ee.isCustom === !0 ? Y = j.exec(b, T, k, _) !== null : (this.updateLastIndex(j, T), Y = j.exec(e) !== null), Y === !0)
              break;
          }
        if (m = T - K, R = this.computeNewColumn(R, m), v = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(b, K, m, Z, X), C.push({
          offset: K,
          line: Z,
          column: X,
          length: m,
          message: v
        }), q === !1)
          break;
      }
    }
    return this.hasCustom || (k.length = E), {
      tokens: k,
      groups: _,
      errors: C
    };
  }
  handleModes(e, r, n, i) {
    if (e.pop === !0) {
      const a = e.push;
      r(i), a !== void 0 && n.call(this, a);
    } else e.push !== void 0 && n.call(this, e.push);
  }
  chopInput(e, r) {
    return e.substring(r);
  }
  updateLastIndex(e, r) {
    e.lastIndex = r;
  }
  // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler
  updateTokenEndLineColumnLocation(e, r, n, i, a, s, o) {
    let l, u;
    r !== void 0 && (l = n === o - 1, u = l ? -1 : 0, i === 1 && l === !0 || (e.endLine = a + u, e.endColumn = s - 1 + -u));
  }
  computeNewColumn(e, r) {
    return e + r;
  }
  createOffsetOnlyToken(e, r, n, i) {
    return {
      image: e,
      startOffset: r,
      tokenTypeIdx: n,
      tokenType: i
    };
  }
  createStartOnlyToken(e, r, n, i, a, s) {
    return {
      image: e,
      startOffset: r,
      startLine: a,
      startColumn: s,
      tokenTypeIdx: n,
      tokenType: i
    };
  }
  createFullToken(e, r, n, i, a, s, o) {
    return {
      image: e,
      startOffset: r,
      endOffset: r + o - 1,
      startLine: a,
      endLine: a,
      startColumn: s,
      endColumn: s + o - 1,
      tokenTypeIdx: n,
      tokenType: i
    };
  }
  addTokenUsingPush(e, r, n) {
    return e.push(n), r;
  }
  addTokenUsingMemberAccess(e, r, n) {
    return e[r] = n, r++, r;
  }
  handlePayloadNoCustom(e, r) {
  }
  handlePayloadWithCustom(e, r) {
    r !== null && (e.payload = r);
  }
  matchWithTest(e, r, n) {
    return e.test(r) === !0 ? r.substring(n, e.lastIndex) : null;
  }
  matchWithExec(e, r) {
    const n = e.exec(r);
    return n !== null ? n[0] : null;
  }
}
la.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
la.NA = /NOT_APPLICABLE/;
function od(t) {
  return Lq(t) ? t.LABEL : t.name;
}
function Lq(t) {
  return ua(t.LABEL) && t.LABEL !== "";
}
const M8e = "parent", CR = "categories", AR = "label", _R = "group", LR = "push_mode", RR = "pop_mode", MR = "longer_alt", NR = "line_breaks", IR = "start_chars_hint";
function Rq(t) {
  return N8e(t);
}
function N8e(t) {
  const e = t.pattern, r = {};
  if (r.name = t.name, sl(e) || (r.PATTERN = e), Vt(t, M8e))
    throw `The parent property is no longer supported.
See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.`;
  return Vt(t, CR) && (r.CATEGORIES = t[CR]), Hg([r]), Vt(t, AR) && (r.LABEL = t[AR]), Vt(t, _R) && (r.GROUP = t[_R]), Vt(t, RR) && (r.POP_MODE = t[RR]), Vt(t, LR) && (r.PUSH_MODE = t[LR]), Vt(t, MR) && (r.LONGER_ALT = t[MR]), Vt(t, NR) && (r.LINE_BREAKS = t[NR]), Vt(t, IR) && (r.START_CHARS_HINT = t[IR]), r;
}
const sc = Rq({ name: "EOF", pattern: la.NA });
Hg([sc]);
function JS(t, e, r, n, i, a, s, o) {
  return {
    image: e,
    startOffset: r,
    endOffset: n,
    startLine: i,
    endLine: a,
    startColumn: s,
    endColumn: o,
    tokenTypeIdx: t.tokenTypeIdx,
    tokenType: t
  };
}
function Mq(t, e) {
  return Ug(t, e);
}
const Hh = {
  buildMismatchTokenMessage({ expected: t, actual: e, previous: r, ruleName: n }) {
    return `Expecting ${Lq(t) ? `--> ${od(t)} <--` : `token of type --> ${t.name} <--`} but found --> '${e.image}' <--`;
  },
  buildNotAllInputParsedMessage({ firstRedundant: t, ruleName: e }) {
    return "Redundant input, expecting EOF but found: " + t.image;
  },
  buildNoViableAltMessage({ expectedPathsPerAlt: t, actual: e, previous: r, customUserDescription: n, ruleName: i }) {
    const a = "Expecting: ", o = `
but found: '` + Ls(e).image + "'";
    if (n)
      return a + n + o;
    {
      const l = _a(t, (f, p) => f.concat(p), []), u = Ot(l, (f) => `[${Ot(f, (p) => od(p)).join(", ")}]`), d = `one of these possible Token sequences:
${Ot(u, (f, p) => `  ${p + 1}. ${f}`).join(`
`)}`;
      return a + d + o;
    }
  },
  buildEarlyExitMessage({ expectedIterationPaths: t, actual: e, customUserDescription: r, ruleName: n }) {
    const i = "Expecting: ", s = `
but found: '` + Ls(e).image + "'";
    if (r)
      return i + r + s;
    {
      const l = `expecting at least one iteration which starts with one of these possible Token sequences::
  <${Ot(t, (u) => `[${Ot(u, (h) => od(h)).join(",")}]`).join(" ,")}>`;
      return i + l + s;
    }
  }
};
Object.freeze(Hh);
const I8e = {
  buildRuleNotFoundError(t, e) {
    return "Invalid grammar, reference to a rule which is not defined: ->" + e.nonTerminalName + `<-
inside top level rule: ->` + t.name + "<-";
  }
}, lu = {
  buildDuplicateFoundError(t, e) {
    function r(h) {
      return h instanceof Yr ? h.terminalType.name : h instanceof Wi ? h.nonTerminalName : "";
    }
    const n = t.name, i = Ls(e), a = i.idx, s = Ws(i), o = r(i), l = a > 0;
    let u = `->${s}${l ? a : ""}<- ${o ? `with argument: ->${o}<-` : ""}
                  appears more than once (${e.length} times) in the top level rule: ->${n}<-.                  
                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES 
                  `;
    return u = u.replace(/[ \t]+/g, " "), u = u.replace(/\s\s+/g, `
`), u;
  },
  buildNamespaceConflictError(t) {
    return `Namespace conflict found in grammar.
The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${t.name}>.
To resolve this make sure each Terminal and Non-Terminal names are unique
This is easy to accomplish by using the convention that Terminal names start with an uppercase letter
and Non-Terminal names start with a lower case letter.`;
  },
  buildAlternationPrefixAmbiguityError(t) {
    const e = Ot(t.prefixPath, (i) => od(i)).join(", "), r = t.alternation.idx === 0 ? "" : t.alternation.idx;
    return `Ambiguous alternatives: <${t.ambiguityIndices.join(" ,")}> due to common lookahead prefix
in <OR${r}> inside <${t.topLevelRule.name}> Rule,
<${e}> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX
For Further details.`;
  },
  buildAlternationAmbiguityError(t) {
    const e = Ot(t.prefixPath, (i) => od(i)).join(", "), r = t.alternation.idx === 0 ? "" : t.alternation.idx;
    let n = `Ambiguous Alternatives Detected: <${t.ambiguityIndices.join(" ,")}> in <OR${r}> inside <${t.topLevelRule.name}> Rule,
<${e}> may appears as a prefix path in all these alternatives.
`;
    return n = n + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`, n;
  },
  buildEmptyRepetitionError(t) {
    let e = Ws(t.repetition);
    return t.repetition.idx !== 0 && (e += t.repetition.idx), `The repetition <${e}> within Rule <${t.topLevelRule.name}> can never consume any tokens.
This could lead to an infinite loop.`;
  },
  // TODO: remove - `errors_public` from nyc.config.js exclude
  //       once this method is fully removed from this file
  buildTokenNameError(t) {
    return "deprecated";
  },
  buildEmptyAlternationError(t) {
    return `Ambiguous empty alternative: <${t.emptyChoiceIdx + 1}> in <OR${t.alternation.idx}> inside <${t.topLevelRule.name}> Rule.
Only the last alternative may be an empty alternative.`;
  },
  buildTooManyAlternativesError(t) {
    return `An Alternation cannot have more than 256 alternatives:
<OR${t.alternation.idx}> inside <${t.topLevelRule.name}> Rule.
 has ${t.alternation.definition.length + 1} alternatives.`;
  },
  buildLeftRecursionError(t) {
    const e = t.topLevelRule.name, r = Ot(t.leftRecursionPath, (a) => a.name), n = `${e} --> ${r.concat([e]).join(" --> ")}`;
    return `Left Recursion found in grammar.
rule: <${e}> can be invoked from itself (directly or indirectly)
without consuming any Tokens. The grammar path that causes this is: 
 ${n}
 To fix this refactor your grammar to remove the left recursion.
see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;
  },
  // TODO: remove - `errors_public` from nyc.config.js exclude
  //       once this method is fully removed from this file
  buildInvalidRuleNameError(t) {
    return "deprecated";
  },
  buildDuplicateRuleNameError(t) {
    let e;
    return t.topLevelRule instanceof uf ? e = t.topLevelRule.name : e = t.topLevelRule, `Duplicate definition, rule: ->${e}<- is already defined in the grammar: ->${t.grammarName}<-`;
  }
};
function D8e(t, e) {
  const r = new O8e(t, e);
  return r.resolveRefs(), r.errors;
}
class O8e extends hf {
  constructor(e, r) {
    super(), this.nameToTopRule = e, this.errMsgProvider = r, this.errors = [];
  }
  resolveRefs() {
    Wt(On(this.nameToTopRule), (e) => {
      this.currTopLevel = e, e.accept(this);
    });
  }
  visitNonTerminal(e) {
    const r = this.nameToTopRule[e.nonTerminalName];
    if (r)
      e.referencedRule = r;
    else {
      const n = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, e);
      this.errors.push({
        message: n,
        type: Yi.UNRESOLVED_SUBRULE_REF,
        ruleName: this.currTopLevel.name,
        unresolvedRefName: e.nonTerminalName
      });
    }
  }
}
class P8e extends sb {
  constructor(e, r) {
    super(), this.topProd = e, this.path = r, this.possibleTokTypes = [], this.nextProductionName = "", this.nextProductionOccurrence = 0, this.found = !1, this.isAtEndOfPath = !1;
  }
  startWalking() {
    if (this.found = !1, this.path.ruleStack[0] !== this.topProd.name)
      throw Error("The path does not start with the walker's top Rule!");
    return this.ruleStack = di(this.path.ruleStack).reverse(), this.occurrenceStack = di(this.path.occurrenceStack).reverse(), this.ruleStack.pop(), this.occurrenceStack.pop(), this.updateExpectedNext(), this.walk(this.topProd), this.possibleTokTypes;
  }
  walk(e, r = []) {
    this.found || super.walk(e, r);
  }
  walkProdRef(e, r, n) {
    if (e.referencedRule.name === this.nextProductionName && e.idx === this.nextProductionOccurrence) {
      const i = r.concat(n);
      this.updateExpectedNext(), this.walk(e.referencedRule, i);
    }
  }
  updateExpectedNext() {
    zr(this.ruleStack) ? (this.nextProductionName = "", this.nextProductionOccurrence = 0, this.isAtEndOfPath = !0) : (this.nextProductionName = this.ruleStack.pop(), this.nextProductionOccurrence = this.occurrenceStack.pop());
  }
}
class B8e extends P8e {
  constructor(e, r) {
    super(e, r), this.path = r, this.nextTerminalName = "", this.nextTerminalOccurrence = 0, this.nextTerminalName = this.path.lastTok.name, this.nextTerminalOccurrence = this.path.lastTokOccurrence;
  }
  walkTerminal(e, r, n) {
    if (this.isAtEndOfPath && e.terminalType.name === this.nextTerminalName && e.idx === this.nextTerminalOccurrence && !this.found) {
      const i = r.concat(n), a = new ha({ definition: i });
      this.possibleTokTypes = Vg(a), this.found = !0;
    }
  }
}
class lb extends sb {
  constructor(e, r) {
    super(), this.topRule = e, this.occurrence = r, this.result = {
      token: void 0,
      occurrence: void 0,
      isEndOfRule: void 0
    };
  }
  startWalking() {
    return this.walk(this.topRule), this.result;
  }
}
class F8e extends lb {
  walkMany(e, r, n) {
    if (e.idx === this.occurrence) {
      const i = Ls(r.concat(n));
      this.result.isEndOfRule = i === void 0, i instanceof Yr && (this.result.token = i.terminalType, this.result.occurrence = i.idx);
    } else
      super.walkMany(e, r, n);
  }
}
class DR extends lb {
  walkManySep(e, r, n) {
    if (e.idx === this.occurrence) {
      const i = Ls(r.concat(n));
      this.result.isEndOfRule = i === void 0, i instanceof Yr && (this.result.token = i.terminalType, this.result.occurrence = i.idx);
    } else
      super.walkManySep(e, r, n);
  }
}
class $8e extends lb {
  walkAtLeastOne(e, r, n) {
    if (e.idx === this.occurrence) {
      const i = Ls(r.concat(n));
      this.result.isEndOfRule = i === void 0, i instanceof Yr && (this.result.token = i.terminalType, this.result.occurrence = i.idx);
    } else
      super.walkAtLeastOne(e, r, n);
  }
}
class OR extends lb {
  walkAtLeastOneSep(e, r, n) {
    if (e.idx === this.occurrence) {
      const i = Ls(r.concat(n));
      this.result.isEndOfRule = i === void 0, i instanceof Yr && (this.result.token = i.terminalType, this.result.occurrence = i.idx);
    } else
      super.walkAtLeastOneSep(e, r, n);
  }
}
function KT(t, e, r = []) {
  r = di(r);
  let n = [], i = 0;
  function a(o) {
    return o.concat(ii(t, i + 1));
  }
  function s(o) {
    const l = KT(a(o), e, r);
    return n.concat(l);
  }
  for (; r.length < e && i < t.length; ) {
    const o = t[i];
    if (o instanceof ha)
      return s(o.definition);
    if (o instanceof Wi)
      return s(o.definition);
    if (o instanceof hi)
      n = s(o.definition);
    else if (o instanceof Na) {
      const l = o.definition.concat([
        new ln({
          definition: o.definition
        })
      ]);
      return s(l);
    } else if (o instanceof Ia) {
      const l = [
        new ha({ definition: o.definition }),
        new ln({
          definition: [new Yr({ terminalType: o.separator })].concat(o.definition)
        })
      ];
      return s(l);
    } else if (o instanceof pa) {
      const l = o.definition.concat([
        new ln({
          definition: [new Yr({ terminalType: o.separator })].concat(o.definition)
        })
      ]);
      n = s(l);
    } else if (o instanceof ln) {
      const l = o.definition.concat([
        new ln({
          definition: o.definition
        })
      ]);
      n = s(l);
    } else {
      if (o instanceof ga)
        return Wt(o.definition, (l) => {
          zr(l.definition) === !1 && (n = s(l.definition));
        }), n;
      if (o instanceof Yr)
        r.push(o.terminalType);
      else
        throw Error("non exhaustive match");
    }
    i++;
  }
  return n.push({
    partialPath: r,
    suffixDef: ii(t, i)
  }), n;
}
function Nq(t, e, r, n) {
  const i = "EXIT_NONE_TERMINAL", a = [i], s = "EXIT_ALTERNATIVE";
  let o = !1;
  const l = e.length, u = l - n - 1, h = [], d = [];
  for (d.push({
    idx: -1,
    def: t,
    ruleStack: [],
    occurrenceStack: []
  }); !zr(d); ) {
    const f = d.pop();
    if (f === s) {
      o && Dd(d).idx <= u && d.pop();
      continue;
    }
    const p = f.def, g = f.idx, m = f.ruleStack, v = f.occurrenceStack;
    if (zr(p))
      continue;
    const y = p[0];
    if (y === i) {
      const b = {
        idx: g,
        def: ii(p),
        ruleStack: Xp(m),
        occurrenceStack: Xp(v)
      };
      d.push(b);
    } else if (y instanceof Yr)
      if (g < l - 1) {
        const b = g + 1, w = e[b];
        if (r(w, y.terminalType)) {
          const T = {
            idx: b,
            def: ii(p),
            ruleStack: m,
            occurrenceStack: v
          };
          d.push(T);
        }
      } else if (g === l - 1)
        h.push({
          nextTokenType: y.terminalType,
          nextTokenOccurrence: y.idx,
          ruleStack: m,
          occurrenceStack: v
        }), o = !0;
      else
        throw Error("non exhaustive match");
    else if (y instanceof Wi) {
      const b = di(m);
      b.push(y.nonTerminalName);
      const w = di(v);
      w.push(y.idx);
      const T = {
        idx: g,
        def: y.definition.concat(a, ii(p)),
        ruleStack: b,
        occurrenceStack: w
      };
      d.push(T);
    } else if (y instanceof hi) {
      const b = {
        idx: g,
        def: ii(p),
        ruleStack: m,
        occurrenceStack: v
      };
      d.push(b), d.push(s);
      const w = {
        idx: g,
        def: y.definition.concat(ii(p)),
        ruleStack: m,
        occurrenceStack: v
      };
      d.push(w);
    } else if (y instanceof Na) {
      const b = new ln({
        definition: y.definition,
        idx: y.idx
      }), w = y.definition.concat([b], ii(p)), T = {
        idx: g,
        def: w,
        ruleStack: m,
        occurrenceStack: v
      };
      d.push(T);
    } else if (y instanceof Ia) {
      const b = new Yr({
        terminalType: y.separator
      }), w = new ln({
        definition: [b].concat(y.definition),
        idx: y.idx
      }), T = y.definition.concat([w], ii(p)), E = {
        idx: g,
        def: T,
        ruleStack: m,
        occurrenceStack: v
      };
      d.push(E);
    } else if (y instanceof pa) {
      const b = {
        idx: g,
        def: ii(p),
        ruleStack: m,
        occurrenceStack: v
      };
      d.push(b), d.push(s);
      const w = new Yr({
        terminalType: y.separator
      }), T = new ln({
        definition: [w].concat(y.definition),
        idx: y.idx
      }), E = y.definition.concat([T], ii(p)), L = {
        idx: g,
        def: E,
        ruleStack: m,
        occurrenceStack: v
      };
      d.push(L);
    } else if (y instanceof ln) {
      const b = {
        idx: g,
        def: ii(p),
        ruleStack: m,
        occurrenceStack: v
      };
      d.push(b), d.push(s);
      const w = new ln({
        definition: y.definition,
        idx: y.idx
      }), T = y.definition.concat([w], ii(p)), E = {
        idx: g,
        def: T,
        ruleStack: m,
        occurrenceStack: v
      };
      d.push(E);
    } else if (y instanceof ga)
      for (let b = y.definition.length - 1; b >= 0; b--) {
        const w = y.definition[b], T = {
          idx: g,
          def: w.definition.concat(ii(p)),
          ruleStack: m,
          occurrenceStack: v
        };
        d.push(T), d.push(s);
      }
    else if (y instanceof ha)
      d.push({
        idx: g,
        def: y.definition.concat(ii(p)),
        ruleStack: m,
        occurrenceStack: v
      });
    else if (y instanceof uf)
      d.push(z8e(y, g, m, v));
    else
      throw Error("non exhaustive match");
  }
  return h;
}
function z8e(t, e, r, n) {
  const i = di(r);
  i.push(t.name);
  const a = di(n);
  return a.push(1), {
    idx: e,
    def: t.definition,
    ruleStack: i,
    occurrenceStack: a
  };
}
var rn;
(function(t) {
  t[t.OPTION = 0] = "OPTION", t[t.REPETITION = 1] = "REPETITION", t[t.REPETITION_MANDATORY = 2] = "REPETITION_MANDATORY", t[t.REPETITION_MANDATORY_WITH_SEPARATOR = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR", t[t.REPETITION_WITH_SEPARATOR = 4] = "REPETITION_WITH_SEPARATOR", t[t.ALTERNATION = 5] = "ALTERNATION";
})(rn || (rn = {}));
function e7(t) {
  if (t instanceof hi || t === "Option")
    return rn.OPTION;
  if (t instanceof ln || t === "Repetition")
    return rn.REPETITION;
  if (t instanceof Na || t === "RepetitionMandatory")
    return rn.REPETITION_MANDATORY;
  if (t instanceof Ia || t === "RepetitionMandatoryWithSeparator")
    return rn.REPETITION_MANDATORY_WITH_SEPARATOR;
  if (t instanceof pa || t === "RepetitionWithSeparator")
    return rn.REPETITION_WITH_SEPARATOR;
  if (t instanceof ga || t === "Alternation")
    return rn.ALTERNATION;
  throw Error("non exhaustive match");
}
function PR(t) {
  const { occurrence: e, rule: r, prodType: n, maxLookahead: i } = t, a = e7(n);
  return a === rn.ALTERNATION ? cb(e, r, i) : ub(e, r, a, i);
}
function G8e(t, e, r, n, i, a) {
  const s = cb(t, e, r), o = Oq(s) ? Ky : Ug;
  return a(s, n, o, i);
}
function V8e(t, e, r, n, i, a) {
  const s = ub(t, e, i, r), o = Oq(s) ? Ky : Ug;
  return a(s[0], o, n);
}
function U8e(t, e, r, n) {
  const i = t.length, a = Es(t, (s) => Es(s, (o) => o.length === 1));
  if (e)
    return function(s) {
      const o = Ot(s, (l) => l.GATE);
      for (let l = 0; l < i; l++) {
        const u = t[l], h = u.length, d = o[l];
        if (!(d !== void 0 && d.call(this) === !1))
          e: for (let f = 0; f < h; f++) {
            const p = u[f], g = p.length;
            for (let m = 0; m < g; m++) {
              const v = this.LA(m + 1);
              if (r(v, p[m]) === !1)
                continue e;
            }
            return l;
          }
      }
    };
  if (a && !n) {
    const s = Ot(t, (l) => Ts(l)), o = _a(s, (l, u, h) => (Wt(u, (d) => {
      Vt(l, d.tokenTypeIdx) || (l[d.tokenTypeIdx] = h), Wt(d.categoryMatches, (f) => {
        Vt(l, f) || (l[f] = h);
      });
    }), l), {});
    return function() {
      const l = this.LA(1);
      return o[l.tokenTypeIdx];
    };
  } else
    return function() {
      for (let s = 0; s < i; s++) {
        const o = t[s], l = o.length;
        e: for (let u = 0; u < l; u++) {
          const h = o[u], d = h.length;
          for (let f = 0; f < d; f++) {
            const p = this.LA(f + 1);
            if (r(p, h[f]) === !1)
              continue e;
          }
          return s;
        }
      }
    };
}
function H8e(t, e, r) {
  const n = Es(t, (a) => a.length === 1), i = t.length;
  if (n && !r) {
    const a = Ts(t);
    if (a.length === 1 && zr(a[0].categoryMatches)) {
      const o = a[0].tokenTypeIdx;
      return function() {
        return this.LA(1).tokenTypeIdx === o;
      };
    } else {
      const s = _a(a, (o, l, u) => (o[l.tokenTypeIdx] = !0, Wt(l.categoryMatches, (h) => {
        o[h] = !0;
      }), o), []);
      return function() {
        const o = this.LA(1);
        return s[o.tokenTypeIdx] === !0;
      };
    }
  } else
    return function() {
      e: for (let a = 0; a < i; a++) {
        const s = t[a], o = s.length;
        for (let l = 0; l < o; l++) {
          const u = this.LA(l + 1);
          if (e(u, s[l]) === !1)
            continue e;
        }
        return !0;
      }
      return !1;
    };
}
class q8e extends sb {
  constructor(e, r, n) {
    super(), this.topProd = e, this.targetOccurrence = r, this.targetProdType = n;
  }
  startWalking() {
    return this.walk(this.topProd), this.restDef;
  }
  checkIsTarget(e, r, n, i) {
    return e.idx === this.targetOccurrence && this.targetProdType === r ? (this.restDef = n.concat(i), !0) : !1;
  }
  walkOption(e, r, n) {
    this.checkIsTarget(e, rn.OPTION, r, n) || super.walkOption(e, r, n);
  }
  walkAtLeastOne(e, r, n) {
    this.checkIsTarget(e, rn.REPETITION_MANDATORY, r, n) || super.walkOption(e, r, n);
  }
  walkAtLeastOneSep(e, r, n) {
    this.checkIsTarget(e, rn.REPETITION_MANDATORY_WITH_SEPARATOR, r, n) || super.walkOption(e, r, n);
  }
  walkMany(e, r, n) {
    this.checkIsTarget(e, rn.REPETITION, r, n) || super.walkOption(e, r, n);
  }
  walkManySep(e, r, n) {
    this.checkIsTarget(e, rn.REPETITION_WITH_SEPARATOR, r, n) || super.walkOption(e, r, n);
  }
}
class Iq extends hf {
  constructor(e, r, n) {
    super(), this.targetOccurrence = e, this.targetProdType = r, this.targetRef = n, this.result = [];
  }
  checkIsTarget(e, r) {
    e.idx === this.targetOccurrence && this.targetProdType === r && (this.targetRef === void 0 || e === this.targetRef) && (this.result = e.definition);
  }
  visitOption(e) {
    this.checkIsTarget(e, rn.OPTION);
  }
  visitRepetition(e) {
    this.checkIsTarget(e, rn.REPETITION);
  }
  visitRepetitionMandatory(e) {
    this.checkIsTarget(e, rn.REPETITION_MANDATORY);
  }
  visitRepetitionMandatoryWithSeparator(e) {
    this.checkIsTarget(e, rn.REPETITION_MANDATORY_WITH_SEPARATOR);
  }
  visitRepetitionWithSeparator(e) {
    this.checkIsTarget(e, rn.REPETITION_WITH_SEPARATOR);
  }
  visitAlternation(e) {
    this.checkIsTarget(e, rn.ALTERNATION);
  }
}
function BR(t) {
  const e = new Array(t);
  for (let r = 0; r < t; r++)
    e[r] = [];
  return e;
}
function w5(t) {
  let e = [""];
  for (let r = 0; r < t.length; r++) {
    const n = t[r], i = [];
    for (let a = 0; a < e.length; a++) {
      const s = e[a];
      i.push(s + "_" + n.tokenTypeIdx);
      for (let o = 0; o < n.categoryMatches.length; o++) {
        const l = "_" + n.categoryMatches[o];
        i.push(s + l);
      }
    }
    e = i;
  }
  return e;
}
function W8e(t, e, r) {
  for (let n = 0; n < t.length; n++) {
    if (n === r)
      continue;
    const i = t[n];
    for (let a = 0; a < e.length; a++) {
      const s = e[a];
      if (i[s] === !0)
        return !1;
    }
  }
  return !0;
}
function Dq(t, e) {
  const r = Ot(t, (s) => KT([s], 1)), n = BR(r.length), i = Ot(r, (s) => {
    const o = {};
    return Wt(s, (l) => {
      const u = w5(l.partialPath);
      Wt(u, (h) => {
        o[h] = !0;
      });
    }), o;
  });
  let a = r;
  for (let s = 1; s <= e; s++) {
    const o = a;
    a = BR(o.length);
    for (let l = 0; l < o.length; l++) {
      const u = o[l];
      for (let h = 0; h < u.length; h++) {
        const d = u[h].partialPath, f = u[h].suffixDef, p = w5(d);
        if (W8e(i, p, l) || zr(f) || d.length === e) {
          const m = n[l];
          if (ZT(m, d) === !1) {
            m.push(d);
            for (let v = 0; v < p.length; v++) {
              const y = p[v];
              i[l][y] = !0;
            }
          }
        } else {
          const m = KT(f, s + 1, d);
          a[l] = a[l].concat(m), Wt(m, (v) => {
            const y = w5(v.partialPath);
            Wt(y, (b) => {
              i[l][b] = !0;
            });
          });
        }
      }
    }
  }
  return n;
}
function cb(t, e, r, n) {
  const i = new Iq(t, rn.ALTERNATION, n);
  return e.accept(i), Dq(i.result, r);
}
function ub(t, e, r, n) {
  const i = new Iq(t, r);
  e.accept(i);
  const a = i.result, o = new q8e(e, t, r).startWalking(), l = new ha({ definition: a }), u = new ha({ definition: o });
  return Dq([l, u], n);
}
function ZT(t, e) {
  e: for (let r = 0; r < t.length; r++) {
    const n = t[r];
    if (n.length === e.length) {
      for (let i = 0; i < n.length; i++) {
        const a = e[i], s = n[i];
        if ((a === s || s.categoryMatchesMap[a.tokenTypeIdx] !== void 0) === !1)
          continue e;
      }
      return !0;
    }
  }
  return !1;
}
function Y8e(t, e) {
  return t.length < e.length && Es(t, (r, n) => {
    const i = e[n];
    return r === i || i.categoryMatchesMap[r.tokenTypeIdx];
  });
}
function Oq(t) {
  return Es(t, (e) => Es(e, (r) => Es(r, (n) => zr(n.categoryMatches))));
}
function X8e(t) {
  const e = t.lookaheadStrategy.validate({
    rules: t.rules,
    tokenTypes: t.tokenTypes,
    grammarName: t.grammarName
  });
  return Ot(e, (r) => Object.assign({ type: Yi.CUSTOM_LOOKAHEAD_VALIDATION }, r));
}
function j8e(t, e, r, n) {
  const i = Ka(t, (l) => K8e(l, r)), a = lAe(t, e, r), s = Ka(t, (l) => iAe(l, r)), o = Ka(t, (l) => J8e(l, t, n, r));
  return i.concat(a, s, o);
}
function K8e(t, e) {
  const r = new Q8e();
  t.accept(r);
  const n = r.allProductions, i = gCe(n, Z8e), a = Ms(i, (o) => o.length > 1);
  return Ot(On(a), (o) => {
    const l = Ls(o), u = e.buildDuplicateFoundError(t, o), h = Ws(l), d = {
      message: u,
      type: Yi.DUPLICATE_PRODUCTIONS,
      ruleName: t.name,
      dslName: h,
      occurrence: l.idx
    }, f = Pq(l);
    return f && (d.parameter = f), d;
  });
}
function Z8e(t) {
  return `${Ws(t)}_#_${t.idx}_#_${Pq(t)}`;
}
function Pq(t) {
  return t instanceof Yr ? t.terminalType.name : t instanceof Wi ? t.nonTerminalName : "";
}
class Q8e extends hf {
  constructor() {
    super(...arguments), this.allProductions = [];
  }
  visitNonTerminal(e) {
    this.allProductions.push(e);
  }
  visitOption(e) {
    this.allProductions.push(e);
  }
  visitRepetitionWithSeparator(e) {
    this.allProductions.push(e);
  }
  visitRepetitionMandatory(e) {
    this.allProductions.push(e);
  }
  visitRepetitionMandatoryWithSeparator(e) {
    this.allProductions.push(e);
  }
  visitRepetition(e) {
    this.allProductions.push(e);
  }
  visitAlternation(e) {
    this.allProductions.push(e);
  }
  visitTerminal(e) {
    this.allProductions.push(e);
  }
}
function J8e(t, e, r, n) {
  const i = [];
  if (_a(e, (s, o) => o.name === t.name ? s + 1 : s, 0) > 1) {
    const s = n.buildDuplicateRuleNameError({
      topLevelRule: t,
      grammarName: r
    });
    i.push({
      message: s,
      type: Yi.DUPLICATE_RULE_NAME,
      ruleName: t.name
    });
  }
  return i;
}
function eAe(t, e, r) {
  const n = [];
  let i;
  return Zi(e, t) || (i = `Invalid rule override, rule: ->${t}<- cannot be overridden in the grammar: ->${r}<-as it is not defined in any of the super grammars `, n.push({
    message: i,
    type: Yi.INVALID_RULE_OVERRIDE,
    ruleName: t
  })), n;
}
function Bq(t, e, r, n = []) {
  const i = [], a = tv(e.definition);
  if (zr(a))
    return [];
  {
    const s = t.name;
    Zi(a, t) && i.push({
      message: r.buildLeftRecursionError({
        topLevelRule: t,
        leftRecursionPath: n
      }),
      type: Yi.LEFT_RECURSION,
      ruleName: s
    });
    const l = ib(a, n.concat([t])), u = Ka(l, (h) => {
      const d = di(n);
      return d.push(h), Bq(t, h, r, d);
    });
    return i.concat(u);
  }
}
function tv(t) {
  let e = [];
  if (zr(t))
    return e;
  const r = Ls(t);
  if (r instanceof Wi)
    e.push(r.referencedRule);
  else if (r instanceof ha || r instanceof hi || r instanceof Na || r instanceof Ia || r instanceof pa || r instanceof ln)
    e = e.concat(tv(r.definition));
  else if (r instanceof ga)
    e = Ts(Ot(r.definition, (a) => tv(a.definition)));
  else if (!(r instanceof Yr)) throw Error("non exhaustive match");
  const n = Xy(r), i = t.length > 1;
  if (n && i) {
    const a = ii(t);
    return e.concat(tv(a));
  } else
    return e;
}
class t7 extends hf {
  constructor() {
    super(...arguments), this.alternations = [];
  }
  visitAlternation(e) {
    this.alternations.push(e);
  }
}
function tAe(t, e) {
  const r = new t7();
  t.accept(r);
  const n = r.alternations;
  return Ka(n, (a) => {
    const s = Xp(a.definition);
    return Ka(s, (o, l) => {
      const u = Nq([o], [], Ug, 1);
      return zr(u) ? [
        {
          message: e.buildEmptyAlternationError({
            topLevelRule: t,
            alternation: a,
            emptyChoiceIdx: l
          }),
          type: Yi.NONE_LAST_EMPTY_ALT,
          ruleName: t.name,
          occurrence: a.idx,
          alternative: l + 1
        }
      ] : [];
    });
  });
}
function rAe(t, e, r) {
  const n = new t7();
  t.accept(n);
  let i = n.alternations;
  return i = ab(i, (s) => s.ignoreAmbiguities === !0), Ka(i, (s) => {
    const o = s.idx, l = s.maxLookahead || e, u = cb(o, t, l, s), h = sAe(u, s, t, r), d = oAe(u, s, t, r);
    return h.concat(d);
  });
}
class nAe extends hf {
  constructor() {
    super(...arguments), this.allProductions = [];
  }
  visitRepetitionWithSeparator(e) {
    this.allProductions.push(e);
  }
  visitRepetitionMandatory(e) {
    this.allProductions.push(e);
  }
  visitRepetitionMandatoryWithSeparator(e) {
    this.allProductions.push(e);
  }
  visitRepetition(e) {
    this.allProductions.push(e);
  }
}
function iAe(t, e) {
  const r = new t7();
  t.accept(r);
  const n = r.alternations;
  return Ka(n, (a) => a.definition.length > 255 ? [
    {
      message: e.buildTooManyAlternativesError({
        topLevelRule: t,
        alternation: a
      }),
      type: Yi.TOO_MANY_ALTS,
      ruleName: t.name,
      occurrence: a.idx
    }
  ] : []);
}
function aAe(t, e, r) {
  const n = [];
  return Wt(t, (i) => {
    const a = new nAe();
    i.accept(a);
    const s = a.allProductions;
    Wt(s, (o) => {
      const l = e7(o), u = o.maxLookahead || e, h = o.idx, f = ub(h, i, l, u)[0];
      if (zr(Ts(f))) {
        const p = r.buildEmptyRepetitionError({
          topLevelRule: i,
          repetition: o
        });
        n.push({
          message: p,
          type: Yi.NO_NON_EMPTY_LOOKAHEAD,
          ruleName: i.name
        });
      }
    });
  }), n;
}
function sAe(t, e, r, n) {
  const i = [], a = _a(t, (o, l, u) => (e.definition[u].ignoreAmbiguities === !0 || Wt(l, (h) => {
    const d = [u];
    Wt(t, (f, p) => {
      u !== p && ZT(f, h) && // ignore (skip) ambiguities with this "other" alternative
      e.definition[p].ignoreAmbiguities !== !0 && d.push(p);
    }), d.length > 1 && !ZT(i, h) && (i.push(h), o.push({
      alts: d,
      path: h
    }));
  }), o), []);
  return Ot(a, (o) => {
    const l = Ot(o.alts, (h) => h + 1);
    return {
      message: n.buildAlternationAmbiguityError({
        topLevelRule: r,
        alternation: e,
        ambiguityIndices: l,
        prefixPath: o.path
      }),
      type: Yi.AMBIGUOUS_ALTS,
      ruleName: r.name,
      occurrence: e.idx,
      alternatives: o.alts
    };
  });
}
function oAe(t, e, r, n) {
  const i = _a(t, (s, o, l) => {
    const u = Ot(o, (h) => ({ idx: l, path: h }));
    return s.concat(u);
  }, []);
  return Gg(Ka(i, (s) => {
    if (e.definition[s.idx].ignoreAmbiguities === !0)
      return [];
    const l = s.idx, u = s.path, h = ss(i, (f) => (
      // ignore (skip) ambiguities with this "other" alternative
      e.definition[f.idx].ignoreAmbiguities !== !0 && f.idx < l && // checking for strict prefix because identical lookaheads
      // will be be detected using a different validation.
      Y8e(f.path, u)
    ));
    return Ot(h, (f) => {
      const p = [f.idx + 1, l + 1], g = e.idx === 0 ? "" : e.idx;
      return {
        message: n.buildAlternationPrefixAmbiguityError({
          topLevelRule: r,
          alternation: e,
          ambiguityIndices: p,
          prefixPath: f.path
        }),
        type: Yi.AMBIGUOUS_PREFIX_ALTS,
        ruleName: r.name,
        occurrence: g,
        alternatives: p
      };
    });
  }));
}
function lAe(t, e, r) {
  const n = [], i = Ot(e, (a) => a.name);
  return Wt(t, (a) => {
    const s = a.name;
    if (Zi(i, s)) {
      const o = r.buildNamespaceConflictError(a);
      n.push({
        message: o,
        type: Yi.CONFLICT_TOKENS_RULES_NAMESPACE,
        ruleName: s
      });
    }
  }), n;
}
function cAe(t) {
  const e = KS(t, {
    errMsgProvider: I8e
  }), r = {};
  return Wt(t.rules, (n) => {
    r[n.name] = n;
  }), D8e(r, e.errMsgProvider);
}
function uAe(t) {
  return t = KS(t, {
    errMsgProvider: lu
  }), j8e(t.rules, t.tokenTypes, t.errMsgProvider, t.grammarName);
}
const Fq = "MismatchedTokenException", $q = "NoViableAltException", zq = "EarlyExitException", Gq = "NotAllInputParsedException", Vq = [
  Fq,
  $q,
  zq,
  Gq
];
Object.freeze(Vq);
function Zy(t) {
  return Zi(Vq, t.name);
}
class hb extends Error {
  constructor(e, r) {
    super(e), this.token = r, this.resyncedTokens = [], Object.setPrototypeOf(this, new.target.prototype), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
  }
}
class Uq extends hb {
  constructor(e, r, n) {
    super(e, r), this.previousToken = n, this.name = Fq;
  }
}
class hAe extends hb {
  constructor(e, r, n) {
    super(e, r), this.previousToken = n, this.name = $q;
  }
}
class dAe extends hb {
  constructor(e, r) {
    super(e, r), this.name = Gq;
  }
}
class fAe extends hb {
  constructor(e, r, n) {
    super(e, r), this.previousToken = n, this.name = zq;
  }
}
const T5 = {}, Hq = "InRuleRecoveryException";
class pAe extends Error {
  constructor(e) {
    super(e), this.name = Hq;
  }
}
class gAe {
  initRecoverable(e) {
    this.firstAfterRepMap = {}, this.resyncFollows = {}, this.recoveryEnabled = Vt(e, "recoveryEnabled") ? e.recoveryEnabled : ol.recoveryEnabled, this.recoveryEnabled && (this.attemptInRepetitionRecovery = mAe);
  }
  getTokenToInsert(e) {
    const r = JS(e, "", NaN, NaN, NaN, NaN, NaN, NaN);
    return r.isInsertedInRecovery = !0, r;
  }
  canTokenTypeBeInsertedInRecovery(e) {
    return !0;
  }
  canTokenTypeBeDeletedInRecovery(e) {
    return !0;
  }
  tryInRepetitionRecovery(e, r, n, i) {
    const a = this.findReSyncTokenType(), s = this.exportLexerState(), o = [];
    let l = !1;
    const u = this.LA(1);
    let h = this.LA(1);
    const d = () => {
      const f = this.LA(0), p = this.errorMessageProvider.buildMismatchTokenMessage({
        expected: i,
        actual: u,
        previous: f,
        ruleName: this.getCurrRuleFullName()
      }), g = new Uq(p, u, this.LA(0));
      g.resyncedTokens = Xp(o), this.SAVE_ERROR(g);
    };
    for (; !l; )
      if (this.tokenMatcher(h, i)) {
        d();
        return;
      } else if (n.call(this)) {
        d(), e.apply(this, r);
        return;
      } else this.tokenMatcher(h, a) ? l = !0 : (h = this.SKIP_TOKEN(), this.addToResyncTokens(h, o));
    this.importLexerState(s);
  }
  shouldInRepetitionRecoveryBeTried(e, r, n) {
    return !(n === !1 || this.tokenMatcher(this.LA(1), e) || this.isBackTracking() || this.canPerformInRuleRecovery(e, this.getFollowsForInRuleRecovery(e, r)));
  }
  // Error Recovery functionality
  getFollowsForInRuleRecovery(e, r) {
    const n = this.getCurrentGrammarPath(e, r);
    return this.getNextPossibleTokenTypes(n);
  }
  tryInRuleRecovery(e, r) {
    if (this.canRecoverWithSingleTokenInsertion(e, r))
      return this.getTokenToInsert(e);
    if (this.canRecoverWithSingleTokenDeletion(e)) {
      const n = this.SKIP_TOKEN();
      return this.consumeToken(), n;
    }
    throw new pAe("sad sad panda");
  }
  canPerformInRuleRecovery(e, r) {
    return this.canRecoverWithSingleTokenInsertion(e, r) || this.canRecoverWithSingleTokenDeletion(e);
  }
  canRecoverWithSingleTokenInsertion(e, r) {
    if (!this.canTokenTypeBeInsertedInRecovery(e) || zr(r))
      return !1;
    const n = this.LA(1);
    return Od(r, (a) => this.tokenMatcher(n, a)) !== void 0;
  }
  canRecoverWithSingleTokenDeletion(e) {
    return this.canTokenTypeBeDeletedInRecovery(e) ? this.tokenMatcher(this.LA(2), e) : !1;
  }
  isInCurrentRuleReSyncSet(e) {
    const r = this.getCurrFollowKey(), n = this.getFollowSetFromFollowKey(r);
    return Zi(n, e);
  }
  findReSyncTokenType() {
    const e = this.flattenFollowSet();
    let r = this.LA(1), n = 2;
    for (; ; ) {
      const i = Od(e, (a) => Mq(r, a));
      if (i !== void 0)
        return i;
      r = this.LA(n), n++;
    }
  }
  getCurrFollowKey() {
    if (this.RULE_STACK.length === 1)
      return T5;
    const e = this.getLastExplicitRuleShortName(), r = this.getLastExplicitRuleOccurrenceIndex(), n = this.getPreviousExplicitRuleShortName();
    return {
      ruleName: this.shortRuleNameToFullName(e),
      idxInCallingRule: r,
      inRule: this.shortRuleNameToFullName(n)
    };
  }
  buildFullFollowKeyStack() {
    const e = this.RULE_STACK, r = this.RULE_OCCURRENCE_STACK;
    return Ot(e, (n, i) => i === 0 ? T5 : {
      ruleName: this.shortRuleNameToFullName(n),
      idxInCallingRule: r[i],
      inRule: this.shortRuleNameToFullName(e[i - 1])
    });
  }
  flattenFollowSet() {
    const e = Ot(this.buildFullFollowKeyStack(), (r) => this.getFollowSetFromFollowKey(r));
    return Ts(e);
  }
  getFollowSetFromFollowKey(e) {
    if (e === T5)
      return [sc];
    const r = e.ruleName + e.idxInCallingRule + bq + e.inRule;
    return this.resyncFollows[r];
  }
  // It does not make any sense to include a virtual EOF token in the list of resynced tokens
  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)
  addToResyncTokens(e, r) {
    return this.tokenMatcher(e, sc) || r.push(e), r;
  }
  reSyncTo(e) {
    const r = [];
    let n = this.LA(1);
    for (; this.tokenMatcher(n, e) === !1; )
      n = this.SKIP_TOKEN(), this.addToResyncTokens(n, r);
    return Xp(r);
  }
  attemptInRepetitionRecovery(e, r, n, i, a, s, o) {
  }
  getCurrentGrammarPath(e, r) {
    const n = this.getHumanReadableRuleStack(), i = di(this.RULE_OCCURRENCE_STACK);
    return {
      ruleStack: n,
      occurrenceStack: i,
      lastTok: e,
      lastTokOccurrence: r
    };
  }
  getHumanReadableRuleStack() {
    return Ot(this.RULE_STACK, (e) => this.shortRuleNameToFullName(e));
  }
}
function mAe(t, e, r, n, i, a, s) {
  const o = this.getKeyForAutomaticLookahead(n, i);
  let l = this.firstAfterRepMap[o];
  if (l === void 0) {
    const f = this.getCurrRuleFullName(), p = this.getGAstProductions()[f];
    l = new a(p, i).startWalking(), this.firstAfterRepMap[o] = l;
  }
  let u = l.token, h = l.occurrence;
  const d = l.isEndOfRule;
  this.RULE_STACK.length === 1 && d && u === void 0 && (u = sc, h = 1), !(u === void 0 || h === void 0) && this.shouldInRepetitionRecoveryBeTried(u, h, s) && this.tryInRepetitionRecovery(t, e, r, u);
}
const vAe = 4, Ec = 8, qq = 1 << Ec, Wq = 2 << Ec, QT = 3 << Ec, JT = 4 << Ec, e6 = 5 << Ec, rv = 6 << Ec;
function E5(t, e, r) {
  return r | e | t;
}
class r7 {
  constructor(e) {
    var r;
    this.maxLookahead = (r = e?.maxLookahead) !== null && r !== void 0 ? r : ol.maxLookahead;
  }
  validate(e) {
    const r = this.validateNoLeftRecursion(e.rules);
    if (zr(r)) {
      const n = this.validateEmptyOrAlternatives(e.rules), i = this.validateAmbiguousAlternationAlternatives(e.rules, this.maxLookahead), a = this.validateSomeNonEmptyLookaheadPath(e.rules, this.maxLookahead);
      return [
        ...r,
        ...n,
        ...i,
        ...a
      ];
    }
    return r;
  }
  validateNoLeftRecursion(e) {
    return Ka(e, (r) => Bq(r, r, lu));
  }
  validateEmptyOrAlternatives(e) {
    return Ka(e, (r) => tAe(r, lu));
  }
  validateAmbiguousAlternationAlternatives(e, r) {
    return Ka(e, (n) => rAe(n, r, lu));
  }
  validateSomeNonEmptyLookaheadPath(e, r) {
    return aAe(e, r, lu);
  }
  buildLookaheadForAlternation(e) {
    return G8e(e.prodOccurrence, e.rule, e.maxLookahead, e.hasPredicates, e.dynamicTokensEnabled, U8e);
  }
  buildLookaheadForOptional(e) {
    return V8e(e.prodOccurrence, e.rule, e.maxLookahead, e.dynamicTokensEnabled, e7(e.prodType), H8e);
  }
}
class yAe {
  initLooksAhead(e) {
    this.dynamicTokensEnabled = Vt(e, "dynamicTokensEnabled") ? e.dynamicTokensEnabled : ol.dynamicTokensEnabled, this.maxLookahead = Vt(e, "maxLookahead") ? e.maxLookahead : ol.maxLookahead, this.lookaheadStrategy = Vt(e, "lookaheadStrategy") ? e.lookaheadStrategy : new r7({ maxLookahead: this.maxLookahead }), this.lookAheadFuncsCache = /* @__PURE__ */ new Map();
  }
  preComputeLookaheadFunctions(e) {
    Wt(e, (r) => {
      this.TRACE_INIT(`${r.name} Rule Lookahead`, () => {
        const { alternation: n, repetition: i, option: a, repetitionMandatory: s, repetitionMandatoryWithSeparator: o, repetitionWithSeparator: l } = bAe(r);
        Wt(n, (u) => {
          const h = u.idx === 0 ? "" : u.idx;
          this.TRACE_INIT(`${Ws(u)}${h}`, () => {
            const d = this.lookaheadStrategy.buildLookaheadForAlternation({
              prodOccurrence: u.idx,
              rule: r,
              maxLookahead: u.maxLookahead || this.maxLookahead,
              hasPredicates: u.hasPredicates,
              dynamicTokensEnabled: this.dynamicTokensEnabled
            }), f = E5(this.fullRuleNameToShort[r.name], qq, u.idx);
            this.setLaFuncCache(f, d);
          });
        }), Wt(i, (u) => {
          this.computeLookaheadFunc(r, u.idx, QT, "Repetition", u.maxLookahead, Ws(u));
        }), Wt(a, (u) => {
          this.computeLookaheadFunc(r, u.idx, Wq, "Option", u.maxLookahead, Ws(u));
        }), Wt(s, (u) => {
          this.computeLookaheadFunc(r, u.idx, JT, "RepetitionMandatory", u.maxLookahead, Ws(u));
        }), Wt(o, (u) => {
          this.computeLookaheadFunc(r, u.idx, rv, "RepetitionMandatoryWithSeparator", u.maxLookahead, Ws(u));
        }), Wt(l, (u) => {
          this.computeLookaheadFunc(r, u.idx, e6, "RepetitionWithSeparator", u.maxLookahead, Ws(u));
        });
      });
    });
  }
  computeLookaheadFunc(e, r, n, i, a, s) {
    this.TRACE_INIT(`${s}${r === 0 ? "" : r}`, () => {
      const o = this.lookaheadStrategy.buildLookaheadForOptional({
        prodOccurrence: r,
        rule: e,
        maxLookahead: a || this.maxLookahead,
        dynamicTokensEnabled: this.dynamicTokensEnabled,
        prodType: i
      }), l = E5(this.fullRuleNameToShort[e.name], n, r);
      this.setLaFuncCache(l, o);
    });
  }
  // this actually returns a number, but it is always used as a string (object prop key)
  getKeyForAutomaticLookahead(e, r) {
    const n = this.getLastExplicitRuleShortName();
    return E5(n, e, r);
  }
  getLaFuncFromCache(e) {
    return this.lookAheadFuncsCache.get(e);
  }
  /* istanbul ignore next */
  setLaFuncCache(e, r) {
    this.lookAheadFuncsCache.set(e, r);
  }
}
class xAe extends hf {
  constructor() {
    super(...arguments), this.dslMethods = {
      option: [],
      alternation: [],
      repetition: [],
      repetitionWithSeparator: [],
      repetitionMandatory: [],
      repetitionMandatoryWithSeparator: []
    };
  }
  reset() {
    this.dslMethods = {
      option: [],
      alternation: [],
      repetition: [],
      repetitionWithSeparator: [],
      repetitionMandatory: [],
      repetitionMandatoryWithSeparator: []
    };
  }
  visitOption(e) {
    this.dslMethods.option.push(e);
  }
  visitRepetitionWithSeparator(e) {
    this.dslMethods.repetitionWithSeparator.push(e);
  }
  visitRepetitionMandatory(e) {
    this.dslMethods.repetitionMandatory.push(e);
  }
  visitRepetitionMandatoryWithSeparator(e) {
    this.dslMethods.repetitionMandatoryWithSeparator.push(e);
  }
  visitRepetition(e) {
    this.dslMethods.repetition.push(e);
  }
  visitAlternation(e) {
    this.dslMethods.alternation.push(e);
  }
}
const J1 = new xAe();
function bAe(t) {
  J1.reset(), t.accept(J1);
  const e = J1.dslMethods;
  return J1.reset(), e;
}
function FR(t, e) {
  isNaN(t.startOffset) === !0 ? (t.startOffset = e.startOffset, t.endOffset = e.endOffset) : t.endOffset < e.endOffset && (t.endOffset = e.endOffset);
}
function $R(t, e) {
  isNaN(t.startOffset) === !0 ? (t.startOffset = e.startOffset, t.startColumn = e.startColumn, t.startLine = e.startLine, t.endOffset = e.endOffset, t.endColumn = e.endColumn, t.endLine = e.endLine) : t.endOffset < e.endOffset && (t.endOffset = e.endOffset, t.endColumn = e.endColumn, t.endLine = e.endLine);
}
function wAe(t, e, r) {
  t.children[r] === void 0 ? t.children[r] = [e] : t.children[r].push(e);
}
function TAe(t, e, r) {
  t.children[e] === void 0 ? t.children[e] = [r] : t.children[e].push(r);
}
const EAe = "name";
function Yq(t, e) {
  Object.defineProperty(t, EAe, {
    enumerable: !1,
    configurable: !0,
    writable: !1,
    value: e
  });
}
function kAe(t, e) {
  const r = as(t), n = r.length;
  for (let i = 0; i < n; i++) {
    const a = r[i], s = t[a], o = s.length;
    for (let l = 0; l < o; l++) {
      const u = s[l];
      u.tokenTypeIdx === void 0 && this[u.name](u.children, e);
    }
  }
}
function SAe(t, e) {
  const r = function() {
  };
  Yq(r, t + "BaseSemantics");
  const n = {
    visit: function(i, a) {
      if (yr(i) && (i = i[0]), !sl(i))
        return this[i.name](i.children, a);
    },
    validateVisitor: function() {
      const i = AAe(this, e);
      if (!zr(i)) {
        const a = Ot(i, (s) => s.msg);
        throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:
	${a.join(`

`).replace(/\n/g, `
	`)}`);
      }
    }
  };
  return r.prototype = n, r.prototype.constructor = r, r._RULE_NAMES = e, r;
}
function CAe(t, e, r) {
  const n = function() {
  };
  Yq(n, t + "BaseSemanticsWithDefaults");
  const i = Object.create(r.prototype);
  return Wt(e, (a) => {
    i[a] = kAe;
  }), n.prototype = i, n.prototype.constructor = n, n;
}
var t6;
(function(t) {
  t[t.REDUNDANT_METHOD = 0] = "REDUNDANT_METHOD", t[t.MISSING_METHOD = 1] = "MISSING_METHOD";
})(t6 || (t6 = {}));
function AAe(t, e) {
  return _Ae(t, e);
}
function _Ae(t, e) {
  const r = ss(e, (i) => gl(t[i]) === !1), n = Ot(r, (i) => ({
    msg: `Missing visitor method: <${i}> on ${t.constructor.name} CST Visitor.`,
    type: t6.MISSING_METHOD,
    methodName: i
  }));
  return Gg(n);
}
class LAe {
  initTreeBuilder(e) {
    if (this.CST_STACK = [], this.outputCst = e.outputCst, this.nodeLocationTracking = Vt(e, "nodeLocationTracking") ? e.nodeLocationTracking : ol.nodeLocationTracking, !this.outputCst)
      this.cstInvocationStateUpdate = Nn, this.cstFinallyStateUpdate = Nn, this.cstPostTerminal = Nn, this.cstPostNonTerminal = Nn, this.cstPostRule = Nn;
    else if (/full/i.test(this.nodeLocationTracking))
      this.recoveryEnabled ? (this.setNodeLocationFromToken = $R, this.setNodeLocationFromNode = $R, this.cstPostRule = Nn, this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery) : (this.setNodeLocationFromToken = Nn, this.setNodeLocationFromNode = Nn, this.cstPostRule = this.cstPostRuleFull, this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular);
    else if (/onlyOffset/i.test(this.nodeLocationTracking))
      this.recoveryEnabled ? (this.setNodeLocationFromToken = FR, this.setNodeLocationFromNode = FR, this.cstPostRule = Nn, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery) : (this.setNodeLocationFromToken = Nn, this.setNodeLocationFromNode = Nn, this.cstPostRule = this.cstPostRuleOnlyOffset, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular);
    else if (/none/i.test(this.nodeLocationTracking))
      this.setNodeLocationFromToken = Nn, this.setNodeLocationFromNode = Nn, this.cstPostRule = Nn, this.setInitialNodeLocation = Nn;
    else
      throw Error(`Invalid <nodeLocationTracking> config option: "${e.nodeLocationTracking}"`);
  }
  setInitialNodeLocationOnlyOffsetRecovery(e) {
    e.location = {
      startOffset: NaN,
      endOffset: NaN
    };
  }
  setInitialNodeLocationOnlyOffsetRegular(e) {
    e.location = {
      // without error recovery the starting Location of a new CstNode is guaranteed
      // To be the next Token's startOffset (for valid inputs).
      // For invalid inputs there won't be any CSTOutput so this potential
      // inaccuracy does not matter
      startOffset: this.LA(1).startOffset,
      endOffset: NaN
    };
  }
  setInitialNodeLocationFullRecovery(e) {
    e.location = {
      startOffset: NaN,
      startLine: NaN,
      startColumn: NaN,
      endOffset: NaN,
      endLine: NaN,
      endColumn: NaN
    };
  }
  /**
       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work
  
       * @param cstNode
       */
  setInitialNodeLocationFullRegular(e) {
    const r = this.LA(1);
    e.location = {
      startOffset: r.startOffset,
      startLine: r.startLine,
      startColumn: r.startColumn,
      endOffset: NaN,
      endLine: NaN,
      endColumn: NaN
    };
  }
  cstInvocationStateUpdate(e) {
    const r = {
      name: e,
      children: /* @__PURE__ */ Object.create(null)
    };
    this.setInitialNodeLocation(r), this.CST_STACK.push(r);
  }
  cstFinallyStateUpdate() {
    this.CST_STACK.pop();
  }
  cstPostRuleFull(e) {
    const r = this.LA(0), n = e.location;
    n.startOffset <= r.startOffset ? (n.endOffset = r.endOffset, n.endLine = r.endLine, n.endColumn = r.endColumn) : (n.startOffset = NaN, n.startLine = NaN, n.startColumn = NaN);
  }
  cstPostRuleOnlyOffset(e) {
    const r = this.LA(0), n = e.location;
    n.startOffset <= r.startOffset ? n.endOffset = r.endOffset : n.startOffset = NaN;
  }
  cstPostTerminal(e, r) {
    const n = this.CST_STACK[this.CST_STACK.length - 1];
    wAe(n, r, e), this.setNodeLocationFromToken(n.location, r);
  }
  cstPostNonTerminal(e, r) {
    const n = this.CST_STACK[this.CST_STACK.length - 1];
    TAe(n, r, e), this.setNodeLocationFromNode(n.location, e.location);
  }
  getBaseCstVisitorConstructor() {
    if (sl(this.baseCstVisitorConstructor)) {
      const e = SAe(this.className, as(this.gastProductionsCache));
      return this.baseCstVisitorConstructor = e, e;
    }
    return this.baseCstVisitorConstructor;
  }
  getBaseCstVisitorConstructorWithDefaults() {
    if (sl(this.baseCstVisitorWithDefaultsConstructor)) {
      const e = CAe(this.className, as(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
      return this.baseCstVisitorWithDefaultsConstructor = e, e;
    }
    return this.baseCstVisitorWithDefaultsConstructor;
  }
  getLastExplicitRuleShortName() {
    const e = this.RULE_STACK;
    return e[e.length - 1];
  }
  getPreviousExplicitRuleShortName() {
    const e = this.RULE_STACK;
    return e[e.length - 2];
  }
  getLastExplicitRuleOccurrenceIndex() {
    const e = this.RULE_OCCURRENCE_STACK;
    return e[e.length - 1];
  }
}
class RAe {
  initLexerAdapter() {
    this.tokVector = [], this.tokVectorLength = 0, this.currIdx = -1;
  }
  set input(e) {
    if (this.selfAnalysisDone !== !0)
      throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
    this.reset(), this.tokVector = e, this.tokVectorLength = e.length;
  }
  get input() {
    return this.tokVector;
  }
  // skips a token and returns the next token
  SKIP_TOKEN() {
    return this.currIdx <= this.tokVector.length - 2 ? (this.consumeToken(), this.LA(1)) : Jy;
  }
  // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers
  // or lexers dependent on parser context.
  LA(e) {
    const r = this.currIdx + e;
    return r < 0 || this.tokVectorLength <= r ? Jy : this.tokVector[r];
  }
  consumeToken() {
    this.currIdx++;
  }
  exportLexerState() {
    return this.currIdx;
  }
  importLexerState(e) {
    this.currIdx = e;
  }
  resetLexerState() {
    this.currIdx = -1;
  }
  moveToTerminatedState() {
    this.currIdx = this.tokVector.length - 1;
  }
  getLexerPosition() {
    return this.exportLexerState();
  }
}
class MAe {
  ACTION(e) {
    return e.call(this);
  }
  consume(e, r, n) {
    return this.consumeInternal(r, e, n);
  }
  subrule(e, r, n) {
    return this.subruleInternal(r, e, n);
  }
  option(e, r) {
    return this.optionInternal(r, e);
  }
  or(e, r) {
    return this.orInternal(r, e);
  }
  many(e, r) {
    return this.manyInternal(e, r);
  }
  atLeastOne(e, r) {
    return this.atLeastOneInternal(e, r);
  }
  CONSUME(e, r) {
    return this.consumeInternal(e, 0, r);
  }
  CONSUME1(e, r) {
    return this.consumeInternal(e, 1, r);
  }
  CONSUME2(e, r) {
    return this.consumeInternal(e, 2, r);
  }
  CONSUME3(e, r) {
    return this.consumeInternal(e, 3, r);
  }
  CONSUME4(e, r) {
    return this.consumeInternal(e, 4, r);
  }
  CONSUME5(e, r) {
    return this.consumeInternal(e, 5, r);
  }
  CONSUME6(e, r) {
    return this.consumeInternal(e, 6, r);
  }
  CONSUME7(e, r) {
    return this.consumeInternal(e, 7, r);
  }
  CONSUME8(e, r) {
    return this.consumeInternal(e, 8, r);
  }
  CONSUME9(e, r) {
    return this.consumeInternal(e, 9, r);
  }
  SUBRULE(e, r) {
    return this.subruleInternal(e, 0, r);
  }
  SUBRULE1(e, r) {
    return this.subruleInternal(e, 1, r);
  }
  SUBRULE2(e, r) {
    return this.subruleInternal(e, 2, r);
  }
  SUBRULE3(e, r) {
    return this.subruleInternal(e, 3, r);
  }
  SUBRULE4(e, r) {
    return this.subruleInternal(e, 4, r);
  }
  SUBRULE5(e, r) {
    return this.subruleInternal(e, 5, r);
  }
  SUBRULE6(e, r) {
    return this.subruleInternal(e, 6, r);
  }
  SUBRULE7(e, r) {
    return this.subruleInternal(e, 7, r);
  }
  SUBRULE8(e, r) {
    return this.subruleInternal(e, 8, r);
  }
  SUBRULE9(e, r) {
    return this.subruleInternal(e, 9, r);
  }
  OPTION(e) {
    return this.optionInternal(e, 0);
  }
  OPTION1(e) {
    return this.optionInternal(e, 1);
  }
  OPTION2(e) {
    return this.optionInternal(e, 2);
  }
  OPTION3(e) {
    return this.optionInternal(e, 3);
  }
  OPTION4(e) {
    return this.optionInternal(e, 4);
  }
  OPTION5(e) {
    return this.optionInternal(e, 5);
  }
  OPTION6(e) {
    return this.optionInternal(e, 6);
  }
  OPTION7(e) {
    return this.optionInternal(e, 7);
  }
  OPTION8(e) {
    return this.optionInternal(e, 8);
  }
  OPTION9(e) {
    return this.optionInternal(e, 9);
  }
  OR(e) {
    return this.orInternal(e, 0);
  }
  OR1(e) {
    return this.orInternal(e, 1);
  }
  OR2(e) {
    return this.orInternal(e, 2);
  }
  OR3(e) {
    return this.orInternal(e, 3);
  }
  OR4(e) {
    return this.orInternal(e, 4);
  }
  OR5(e) {
    return this.orInternal(e, 5);
  }
  OR6(e) {
    return this.orInternal(e, 6);
  }
  OR7(e) {
    return this.orInternal(e, 7);
  }
  OR8(e) {
    return this.orInternal(e, 8);
  }
  OR9(e) {
    return this.orInternal(e, 9);
  }
  MANY(e) {
    this.manyInternal(0, e);
  }
  MANY1(e) {
    this.manyInternal(1, e);
  }
  MANY2(e) {
    this.manyInternal(2, e);
  }
  MANY3(e) {
    this.manyInternal(3, e);
  }
  MANY4(e) {
    this.manyInternal(4, e);
  }
  MANY5(e) {
    this.manyInternal(5, e);
  }
  MANY6(e) {
    this.manyInternal(6, e);
  }
  MANY7(e) {
    this.manyInternal(7, e);
  }
  MANY8(e) {
    this.manyInternal(8, e);
  }
  MANY9(e) {
    this.manyInternal(9, e);
  }
  MANY_SEP(e) {
    this.manySepFirstInternal(0, e);
  }
  MANY_SEP1(e) {
    this.manySepFirstInternal(1, e);
  }
  MANY_SEP2(e) {
    this.manySepFirstInternal(2, e);
  }
  MANY_SEP3(e) {
    this.manySepFirstInternal(3, e);
  }
  MANY_SEP4(e) {
    this.manySepFirstInternal(4, e);
  }
  MANY_SEP5(e) {
    this.manySepFirstInternal(5, e);
  }
  MANY_SEP6(e) {
    this.manySepFirstInternal(6, e);
  }
  MANY_SEP7(e) {
    this.manySepFirstInternal(7, e);
  }
  MANY_SEP8(e) {
    this.manySepFirstInternal(8, e);
  }
  MANY_SEP9(e) {
    this.manySepFirstInternal(9, e);
  }
  AT_LEAST_ONE(e) {
    this.atLeastOneInternal(0, e);
  }
  AT_LEAST_ONE1(e) {
    return this.atLeastOneInternal(1, e);
  }
  AT_LEAST_ONE2(e) {
    this.atLeastOneInternal(2, e);
  }
  AT_LEAST_ONE3(e) {
    this.atLeastOneInternal(3, e);
  }
  AT_LEAST_ONE4(e) {
    this.atLeastOneInternal(4, e);
  }
  AT_LEAST_ONE5(e) {
    this.atLeastOneInternal(5, e);
  }
  AT_LEAST_ONE6(e) {
    this.atLeastOneInternal(6, e);
  }
  AT_LEAST_ONE7(e) {
    this.atLeastOneInternal(7, e);
  }
  AT_LEAST_ONE8(e) {
    this.atLeastOneInternal(8, e);
  }
  AT_LEAST_ONE9(e) {
    this.atLeastOneInternal(9, e);
  }
  AT_LEAST_ONE_SEP(e) {
    this.atLeastOneSepFirstInternal(0, e);
  }
  AT_LEAST_ONE_SEP1(e) {
    this.atLeastOneSepFirstInternal(1, e);
  }
  AT_LEAST_ONE_SEP2(e) {
    this.atLeastOneSepFirstInternal(2, e);
  }
  AT_LEAST_ONE_SEP3(e) {
    this.atLeastOneSepFirstInternal(3, e);
  }
  AT_LEAST_ONE_SEP4(e) {
    this.atLeastOneSepFirstInternal(4, e);
  }
  AT_LEAST_ONE_SEP5(e) {
    this.atLeastOneSepFirstInternal(5, e);
  }
  AT_LEAST_ONE_SEP6(e) {
    this.atLeastOneSepFirstInternal(6, e);
  }
  AT_LEAST_ONE_SEP7(e) {
    this.atLeastOneSepFirstInternal(7, e);
  }
  AT_LEAST_ONE_SEP8(e) {
    this.atLeastOneSepFirstInternal(8, e);
  }
  AT_LEAST_ONE_SEP9(e) {
    this.atLeastOneSepFirstInternal(9, e);
  }
  RULE(e, r, n = e2) {
    if (Zi(this.definedRulesNames, e)) {
      const s = {
        message: lu.buildDuplicateRuleNameError({
          topLevelRule: e,
          grammarName: this.className
        }),
        type: Yi.DUPLICATE_RULE_NAME,
        ruleName: e
      };
      this.definitionErrors.push(s);
    }
    this.definedRulesNames.push(e);
    const i = this.defineRule(e, r, n);
    return this[e] = i, i;
  }
  OVERRIDE_RULE(e, r, n = e2) {
    const i = eAe(e, this.definedRulesNames, this.className);
    this.definitionErrors = this.definitionErrors.concat(i);
    const a = this.defineRule(e, r, n);
    return this[e] = a, a;
  }
  BACKTRACK(e, r) {
    return function() {
      this.isBackTrackingStack.push(1);
      const n = this.saveRecogState();
      try {
        return e.apply(this, r), !0;
      } catch (i) {
        if (Zy(i))
          return !1;
        throw i;
      } finally {
        this.reloadRecogState(n), this.isBackTrackingStack.pop();
      }
    };
  }
  // GAST export APIs
  getGAstProductions() {
    return this.gastProductionsCache;
  }
  getSerializedGastProductions() {
    return zCe(On(this.gastProductionsCache));
  }
}
class NAe {
  initRecognizerEngine(e, r) {
    if (this.className = this.constructor.name, this.shortRuleNameToFull = {}, this.fullRuleNameToShort = {}, this.ruleShortNameIdx = 256, this.tokenMatcher = Ky, this.subruleIdx = 0, this.definedRulesNames = [], this.tokensMap = {}, this.isBackTrackingStack = [], this.RULE_STACK = [], this.RULE_OCCURRENCE_STACK = [], this.gastProductionsCache = {}, Vt(r, "serializedGrammar"))
      throw Error(`The Parser's configuration can no longer contain a <serializedGrammar> property.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0
	For Further details.`);
    if (yr(e)) {
      if (zr(e))
        throw Error(`A Token Vocabulary cannot be empty.
	Note that the first argument for the parser constructor
	is no longer a Token vector (since v4.0).`);
      if (typeof e[0].startOffset == "number")
        throw Error(`The Parser constructor no longer accepts a token vector as the first argument.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0
	For Further details.`);
    }
    if (yr(e))
      this.tokensMap = _a(e, (a, s) => (a[s.name] = s, a), {});
    else if (Vt(e, "modes") && Es(Ts(On(e.modes)), R8e)) {
      const a = Ts(On(e.modes)), s = ZS(a);
      this.tokensMap = _a(s, (o, l) => (o[l.name] = l, o), {});
    } else if (is(e))
      this.tokensMap = di(e);
    else
      throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
    this.tokensMap.EOF = sc;
    const n = Vt(e, "modes") ? Ts(On(e.modes)) : On(e), i = Es(n, (a) => zr(a.categoryMatches));
    this.tokenMatcher = i ? Ky : Ug, Hg(On(this.tokensMap));
  }
  defineRule(e, r, n) {
    if (this.selfAnalysisDone)
      throw Error(`Grammar rule <${e}> may not be defined after the 'performSelfAnalysis' method has been called'
Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);
    const i = Vt(n, "resyncEnabled") ? n.resyncEnabled : e2.resyncEnabled, a = Vt(n, "recoveryValueFunc") ? n.recoveryValueFunc : e2.recoveryValueFunc, s = this.ruleShortNameIdx << vAe + Ec;
    this.ruleShortNameIdx++, this.shortRuleNameToFull[s] = e, this.fullRuleNameToShort[e] = s;
    let o;
    return this.outputCst === !0 ? o = function(...h) {
      try {
        this.ruleInvocationStateUpdate(s, e, this.subruleIdx), r.apply(this, h);
        const d = this.CST_STACK[this.CST_STACK.length - 1];
        return this.cstPostRule(d), d;
      } catch (d) {
        return this.invokeRuleCatch(d, i, a);
      } finally {
        this.ruleFinallyStateUpdate();
      }
    } : o = function(...h) {
      try {
        return this.ruleInvocationStateUpdate(s, e, this.subruleIdx), r.apply(this, h);
      } catch (d) {
        return this.invokeRuleCatch(d, i, a);
      } finally {
        this.ruleFinallyStateUpdate();
      }
    }, Object.assign(o, { ruleName: e, originalGrammarAction: r });
  }
  invokeRuleCatch(e, r, n) {
    const i = this.RULE_STACK.length === 1, a = r && !this.isBackTracking() && this.recoveryEnabled;
    if (Zy(e)) {
      const s = e;
      if (a) {
        const o = this.findReSyncTokenType();
        if (this.isInCurrentRuleReSyncSet(o))
          if (s.resyncedTokens = this.reSyncTo(o), this.outputCst) {
            const l = this.CST_STACK[this.CST_STACK.length - 1];
            return l.recoveredNode = !0, l;
          } else
            return n(e);
        else {
          if (this.outputCst) {
            const l = this.CST_STACK[this.CST_STACK.length - 1];
            l.recoveredNode = !0, s.partialCstResult = l;
          }
          throw s;
        }
      } else {
        if (i)
          return this.moveToTerminatedState(), n(e);
        throw s;
      }
    } else
      throw e;
  }
  // Implementation of parsing DSL
  optionInternal(e, r) {
    const n = this.getKeyForAutomaticLookahead(Wq, r);
    return this.optionInternalLogic(e, r, n);
  }
  optionInternalLogic(e, r, n) {
    let i = this.getLaFuncFromCache(n), a;
    if (typeof e != "function") {
      a = e.DEF;
      const s = e.GATE;
      if (s !== void 0) {
        const o = i;
        i = () => s.call(this) && o.call(this);
      }
    } else
      a = e;
    if (i.call(this) === !0)
      return a.call(this);
  }
  atLeastOneInternal(e, r) {
    const n = this.getKeyForAutomaticLookahead(JT, e);
    return this.atLeastOneInternalLogic(e, r, n);
  }
  atLeastOneInternalLogic(e, r, n) {
    let i = this.getLaFuncFromCache(n), a;
    if (typeof r != "function") {
      a = r.DEF;
      const s = r.GATE;
      if (s !== void 0) {
        const o = i;
        i = () => s.call(this) && o.call(this);
      }
    } else
      a = r;
    if (i.call(this) === !0) {
      let s = this.doSingleRepetition(a);
      for (; i.call(this) === !0 && s === !0; )
        s = this.doSingleRepetition(a);
    } else
      throw this.raiseEarlyExitException(e, rn.REPETITION_MANDATORY, r.ERR_MSG);
    this.attemptInRepetitionRecovery(this.atLeastOneInternal, [e, r], i, JT, e, $8e);
  }
  atLeastOneSepFirstInternal(e, r) {
    const n = this.getKeyForAutomaticLookahead(rv, e);
    this.atLeastOneSepFirstInternalLogic(e, r, n);
  }
  atLeastOneSepFirstInternalLogic(e, r, n) {
    const i = r.DEF, a = r.SEP;
    if (this.getLaFuncFromCache(n).call(this) === !0) {
      i.call(this);
      const o = () => this.tokenMatcher(this.LA(1), a);
      for (; this.tokenMatcher(this.LA(1), a) === !0; )
        this.CONSUME(a), i.call(this);
      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
        e,
        a,
        o,
        i,
        OR
      ], o, rv, e, OR);
    } else
      throw this.raiseEarlyExitException(e, rn.REPETITION_MANDATORY_WITH_SEPARATOR, r.ERR_MSG);
  }
  manyInternal(e, r) {
    const n = this.getKeyForAutomaticLookahead(QT, e);
    return this.manyInternalLogic(e, r, n);
  }
  manyInternalLogic(e, r, n) {
    let i = this.getLaFuncFromCache(n), a;
    if (typeof r != "function") {
      a = r.DEF;
      const o = r.GATE;
      if (o !== void 0) {
        const l = i;
        i = () => o.call(this) && l.call(this);
      }
    } else
      a = r;
    let s = !0;
    for (; i.call(this) === !0 && s === !0; )
      s = this.doSingleRepetition(a);
    this.attemptInRepetitionRecovery(
      this.manyInternal,
      [e, r],
      i,
      QT,
      e,
      F8e,
      // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"
      // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]
      // An infinite loop cannot occur as:
      // - Either the lookahead is guaranteed to consume something (Single Token Separator)
      // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).
      s
    );
  }
  manySepFirstInternal(e, r) {
    const n = this.getKeyForAutomaticLookahead(e6, e);
    this.manySepFirstInternalLogic(e, r, n);
  }
  manySepFirstInternalLogic(e, r, n) {
    const i = r.DEF, a = r.SEP;
    if (this.getLaFuncFromCache(n).call(this) === !0) {
      i.call(this);
      const o = () => this.tokenMatcher(this.LA(1), a);
      for (; this.tokenMatcher(this.LA(1), a) === !0; )
        this.CONSUME(a), i.call(this);
      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
        e,
        a,
        o,
        i,
        DR
      ], o, e6, e, DR);
    }
  }
  repetitionSepSecondInternal(e, r, n, i, a) {
    for (; n(); )
      this.CONSUME(r), i.call(this);
    this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
      e,
      r,
      n,
      i,
      a
    ], n, rv, e, a);
  }
  doSingleRepetition(e) {
    const r = this.getLexerPosition();
    return e.call(this), this.getLexerPosition() > r;
  }
  orInternal(e, r) {
    const n = this.getKeyForAutomaticLookahead(qq, r), i = yr(e) ? e : e.DEF, s = this.getLaFuncFromCache(n).call(this, i);
    if (s !== void 0)
      return i[s].ALT.call(this);
    this.raiseNoAltException(r, e.ERR_MSG);
  }
  ruleFinallyStateUpdate() {
    if (this.RULE_STACK.pop(), this.RULE_OCCURRENCE_STACK.pop(), this.cstFinallyStateUpdate(), this.RULE_STACK.length === 0 && this.isAtEndOfInput() === !1) {
      const e = this.LA(1), r = this.errorMessageProvider.buildNotAllInputParsedMessage({
        firstRedundant: e,
        ruleName: this.getCurrRuleFullName()
      });
      this.SAVE_ERROR(new dAe(r, e));
    }
  }
  subruleInternal(e, r, n) {
    let i;
    try {
      const a = n !== void 0 ? n.ARGS : void 0;
      return this.subruleIdx = r, i = e.apply(this, a), this.cstPostNonTerminal(i, n !== void 0 && n.LABEL !== void 0 ? n.LABEL : e.ruleName), i;
    } catch (a) {
      throw this.subruleInternalError(a, n, e.ruleName);
    }
  }
  subruleInternalError(e, r, n) {
    throw Zy(e) && e.partialCstResult !== void 0 && (this.cstPostNonTerminal(e.partialCstResult, r !== void 0 && r.LABEL !== void 0 ? r.LABEL : n), delete e.partialCstResult), e;
  }
  consumeInternal(e, r, n) {
    let i;
    try {
      const a = this.LA(1);
      this.tokenMatcher(a, e) === !0 ? (this.consumeToken(), i = a) : this.consumeInternalError(e, a, n);
    } catch (a) {
      i = this.consumeInternalRecovery(e, r, a);
    }
    return this.cstPostTerminal(n !== void 0 && n.LABEL !== void 0 ? n.LABEL : e.name, i), i;
  }
  consumeInternalError(e, r, n) {
    let i;
    const a = this.LA(0);
    throw n !== void 0 && n.ERR_MSG ? i = n.ERR_MSG : i = this.errorMessageProvider.buildMismatchTokenMessage({
      expected: e,
      actual: r,
      previous: a,
      ruleName: this.getCurrRuleFullName()
    }), this.SAVE_ERROR(new Uq(i, r, a));
  }
  consumeInternalRecovery(e, r, n) {
    if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?
    n.name === "MismatchedTokenException" && !this.isBackTracking()) {
      const i = this.getFollowsForInRuleRecovery(e, r);
      try {
        return this.tryInRuleRecovery(e, i);
      } catch (a) {
        throw a.name === Hq ? n : a;
      }
    } else
      throw n;
  }
  saveRecogState() {
    const e = this.errors, r = di(this.RULE_STACK);
    return {
      errors: e,
      lexerState: this.exportLexerState(),
      RULE_STACK: r,
      CST_STACK: this.CST_STACK
    };
  }
  reloadRecogState(e) {
    this.errors = e.errors, this.importLexerState(e.lexerState), this.RULE_STACK = e.RULE_STACK;
  }
  ruleInvocationStateUpdate(e, r, n) {
    this.RULE_OCCURRENCE_STACK.push(n), this.RULE_STACK.push(e), this.cstInvocationStateUpdate(r);
  }
  isBackTracking() {
    return this.isBackTrackingStack.length !== 0;
  }
  getCurrRuleFullName() {
    const e = this.getLastExplicitRuleShortName();
    return this.shortRuleNameToFull[e];
  }
  shortRuleNameToFullName(e) {
    return this.shortRuleNameToFull[e];
  }
  isAtEndOfInput() {
    return this.tokenMatcher(this.LA(1), sc);
  }
  reset() {
    this.resetLexerState(), this.subruleIdx = 0, this.isBackTrackingStack = [], this.errors = [], this.RULE_STACK = [], this.CST_STACK = [], this.RULE_OCCURRENCE_STACK = [];
  }
}
class IAe {
  initErrorHandler(e) {
    this._errors = [], this.errorMessageProvider = Vt(e, "errorMessageProvider") ? e.errorMessageProvider : ol.errorMessageProvider;
  }
  SAVE_ERROR(e) {
    if (Zy(e))
      return e.context = {
        ruleStack: this.getHumanReadableRuleStack(),
        ruleOccurrenceStack: di(this.RULE_OCCURRENCE_STACK)
      }, this._errors.push(e), e;
    throw Error("Trying to save an Error which is not a RecognitionException");
  }
  get errors() {
    return di(this._errors);
  }
  set errors(e) {
    this._errors = e;
  }
  // TODO: consider caching the error message computed information
  raiseEarlyExitException(e, r, n) {
    const i = this.getCurrRuleFullName(), a = this.getGAstProductions()[i], o = ub(e, a, r, this.maxLookahead)[0], l = [];
    for (let h = 1; h <= this.maxLookahead; h++)
      l.push(this.LA(h));
    const u = this.errorMessageProvider.buildEarlyExitMessage({
      expectedIterationPaths: o,
      actual: l,
      previous: this.LA(0),
      customUserDescription: n,
      ruleName: i
    });
    throw this.SAVE_ERROR(new fAe(u, this.LA(1), this.LA(0)));
  }
  // TODO: consider caching the error message computed information
  raiseNoAltException(e, r) {
    const n = this.getCurrRuleFullName(), i = this.getGAstProductions()[n], a = cb(e, i, this.maxLookahead), s = [];
    for (let u = 1; u <= this.maxLookahead; u++)
      s.push(this.LA(u));
    const o = this.LA(0), l = this.errorMessageProvider.buildNoViableAltMessage({
      expectedPathsPerAlt: a,
      actual: s,
      previous: o,
      customUserDescription: r,
      ruleName: this.getCurrRuleFullName()
    });
    throw this.SAVE_ERROR(new hAe(l, this.LA(1), o));
  }
}
class DAe {
  initContentAssist() {
  }
  computeContentAssist(e, r) {
    const n = this.gastProductionsCache[e];
    if (sl(n))
      throw Error(`Rule ->${e}<- does not exist in this grammar.`);
    return Nq([n], r, this.tokenMatcher, this.maxLookahead);
  }
  // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...
  // TODO: should this be more explicitly part of the public API?
  getNextPossibleTokenTypes(e) {
    const r = Ls(e.ruleStack), i = this.getGAstProductions()[r];
    return new B8e(i, e).startWalking();
  }
}
const db = {
  description: "This Object indicates the Parser is during Recording Phase"
};
Object.freeze(db);
const zR = !0, GR = Math.pow(2, Ec) - 1, Xq = Rq({ name: "RECORDING_PHASE_TOKEN", pattern: la.NA });
Hg([Xq]);
const jq = JS(
  Xq,
  `This IToken indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,
  // Using "-1" instead of NaN (as in EOF) because an actual number is less likely to
  // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
);
Object.freeze(jq);
const OAe = {
  name: `This CSTNode indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,
  children: {}
};
class PAe {
  initGastRecorder(e) {
    this.recordingProdStack = [], this.RECORDING_PHASE = !1;
  }
  enableRecording() {
    this.RECORDING_PHASE = !0, this.TRACE_INIT("Enable Recording", () => {
      for (let e = 0; e < 10; e++) {
        const r = e > 0 ? e : "";
        this[`CONSUME${r}`] = function(n, i) {
          return this.consumeInternalRecord(n, e, i);
        }, this[`SUBRULE${r}`] = function(n, i) {
          return this.subruleInternalRecord(n, e, i);
        }, this[`OPTION${r}`] = function(n) {
          return this.optionInternalRecord(n, e);
        }, this[`OR${r}`] = function(n) {
          return this.orInternalRecord(n, e);
        }, this[`MANY${r}`] = function(n) {
          this.manyInternalRecord(e, n);
        }, this[`MANY_SEP${r}`] = function(n) {
          this.manySepFirstInternalRecord(e, n);
        }, this[`AT_LEAST_ONE${r}`] = function(n) {
          this.atLeastOneInternalRecord(e, n);
        }, this[`AT_LEAST_ONE_SEP${r}`] = function(n) {
          this.atLeastOneSepFirstInternalRecord(e, n);
        };
      }
      this.consume = function(e, r, n) {
        return this.consumeInternalRecord(r, e, n);
      }, this.subrule = function(e, r, n) {
        return this.subruleInternalRecord(r, e, n);
      }, this.option = function(e, r) {
        return this.optionInternalRecord(r, e);
      }, this.or = function(e, r) {
        return this.orInternalRecord(r, e);
      }, this.many = function(e, r) {
        this.manyInternalRecord(e, r);
      }, this.atLeastOne = function(e, r) {
        this.atLeastOneInternalRecord(e, r);
      }, this.ACTION = this.ACTION_RECORD, this.BACKTRACK = this.BACKTRACK_RECORD, this.LA = this.LA_RECORD;
    });
  }
  disableRecording() {
    this.RECORDING_PHASE = !1, this.TRACE_INIT("Deleting Recording methods", () => {
      const e = this;
      for (let r = 0; r < 10; r++) {
        const n = r > 0 ? r : "";
        delete e[`CONSUME${n}`], delete e[`SUBRULE${n}`], delete e[`OPTION${n}`], delete e[`OR${n}`], delete e[`MANY${n}`], delete e[`MANY_SEP${n}`], delete e[`AT_LEAST_ONE${n}`], delete e[`AT_LEAST_ONE_SEP${n}`];
      }
      delete e.consume, delete e.subrule, delete e.option, delete e.or, delete e.many, delete e.atLeastOne, delete e.ACTION, delete e.BACKTRACK, delete e.LA;
    });
  }
  //   Parser methods are called inside an ACTION?
  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?
  // @ts-expect-error -- noop place holder
  ACTION_RECORD(e) {
  }
  // Executing backtracking logic will break our recording logic assumptions
  BACKTRACK_RECORD(e, r) {
    return () => !0;
  }
  // LA is part of the official API and may be used for custom lookahead logic
  // by end users who may forget to wrap it in ACTION or inside a GATE
  LA_RECORD(e) {
    return Jy;
  }
  topLevelRuleRecord(e, r) {
    try {
      const n = new uf({ definition: [], name: e });
      return n.name = e, this.recordingProdStack.push(n), r.call(this), this.recordingProdStack.pop(), n;
    } catch (n) {
      if (n.KNOWN_RECORDER_ERROR !== !0)
        try {
          n.message = n.message + `
	 This error was thrown during the "grammar recording phase" For more info see:
	https://chevrotain.io/docs/guide/internals.html#grammar-recording`;
        } catch {
          throw n;
        }
      throw n;
    }
  }
  // Implementation of parsing DSL
  optionInternalRecord(e, r) {
    return zf.call(this, hi, e, r);
  }
  atLeastOneInternalRecord(e, r) {
    zf.call(this, Na, r, e);
  }
  atLeastOneSepFirstInternalRecord(e, r) {
    zf.call(this, Ia, r, e, zR);
  }
  manyInternalRecord(e, r) {
    zf.call(this, ln, r, e);
  }
  manySepFirstInternalRecord(e, r) {
    zf.call(this, pa, r, e, zR);
  }
  orInternalRecord(e, r) {
    return BAe.call(this, e, r);
  }
  subruleInternalRecord(e, r, n) {
    if (Qy(r), !e || Vt(e, "ruleName") === !1) {
      const o = new Error(`<SUBRULE${VR(r)}> argument is invalid expecting a Parser method reference but got: <${JSON.stringify(e)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);
      throw o.KNOWN_RECORDER_ERROR = !0, o;
    }
    const i = Dd(this.recordingProdStack), a = e.ruleName, s = new Wi({
      idx: r,
      nonTerminalName: a,
      label: n?.LABEL,
      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created
      referencedRule: void 0
    });
    return i.definition.push(s), this.outputCst ? OAe : db;
  }
  consumeInternalRecord(e, r, n) {
    if (Qy(r), !_q(e)) {
      const s = new Error(`<CONSUME${VR(r)}> argument is invalid expecting a TokenType reference but got: <${JSON.stringify(e)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);
      throw s.KNOWN_RECORDER_ERROR = !0, s;
    }
    const i = Dd(this.recordingProdStack), a = new Yr({
      idx: r,
      terminalType: e,
      label: n?.LABEL
    });
    return i.definition.push(a), jq;
  }
}
function zf(t, e, r, n = !1) {
  Qy(r);
  const i = Dd(this.recordingProdStack), a = gl(e) ? e : e.DEF, s = new t({ definition: [], idx: r });
  return n && (s.separator = e.SEP), Vt(e, "MAX_LOOKAHEAD") && (s.maxLookahead = e.MAX_LOOKAHEAD), this.recordingProdStack.push(s), a.call(this), i.definition.push(s), this.recordingProdStack.pop(), db;
}
function BAe(t, e) {
  Qy(e);
  const r = Dd(this.recordingProdStack), n = yr(t) === !1, i = n === !1 ? t : t.DEF, a = new ga({
    definition: [],
    idx: e,
    ignoreAmbiguities: n && t.IGNORE_AMBIGUITIES === !0
  });
  Vt(t, "MAX_LOOKAHEAD") && (a.maxLookahead = t.MAX_LOOKAHEAD);
  const s = mq(i, (o) => gl(o.GATE));
  return a.hasPredicates = s, r.definition.push(a), Wt(i, (o) => {
    const l = new ha({ definition: [] });
    a.definition.push(l), Vt(o, "IGNORE_AMBIGUITIES") ? l.ignoreAmbiguities = o.IGNORE_AMBIGUITIES : Vt(o, "GATE") && (l.ignoreAmbiguities = !0), this.recordingProdStack.push(l), o.ALT.call(this), this.recordingProdStack.pop();
  }), db;
}
function VR(t) {
  return t === 0 ? "" : `${t}`;
}
function Qy(t) {
  if (t < 0 || t > GR) {
    const e = new Error(
      // The stack trace will contain all the needed details
      `Invalid DSL Method idx value: <${t}>
	Idx value must be a none negative value smaller than ${GR + 1}`
    );
    throw e.KNOWN_RECORDER_ERROR = !0, e;
  }
}
class FAe {
  initPerformanceTracer(e) {
    if (Vt(e, "traceInitPerf")) {
      const r = e.traceInitPerf, n = typeof r == "number";
      this.traceInitMaxIdent = n ? r : 1 / 0, this.traceInitPerf = n ? r > 0 : r;
    } else
      this.traceInitMaxIdent = 0, this.traceInitPerf = ol.traceInitPerf;
    this.traceInitIndent = -1;
  }
  TRACE_INIT(e, r) {
    if (this.traceInitPerf === !0) {
      this.traceInitIndent++;
      const n = new Array(this.traceInitIndent + 1).join("	");
      this.traceInitIndent < this.traceInitMaxIdent && console.log(`${n}--> <${e}>`);
      const { time: i, value: a } = yq(r), s = i > 10 ? console.warn : console.log;
      return this.traceInitIndent < this.traceInitMaxIdent && s(`${n}<-- <${e}> time: ${i}ms`), this.traceInitIndent--, a;
    } else
      return r();
  }
}
function $Ae(t, e) {
  e.forEach((r) => {
    const n = r.prototype;
    Object.getOwnPropertyNames(n).forEach((i) => {
      if (i === "constructor")
        return;
      const a = Object.getOwnPropertyDescriptor(n, i);
      a && (a.get || a.set) ? Object.defineProperty(t.prototype, i, a) : t.prototype[i] = r.prototype[i];
    });
  });
}
const Jy = JS(sc, "", NaN, NaN, NaN, NaN, NaN, NaN);
Object.freeze(Jy);
const ol = Object.freeze({
  recoveryEnabled: !1,
  maxLookahead: 3,
  dynamicTokensEnabled: !1,
  outputCst: !0,
  errorMessageProvider: Hh,
  nodeLocationTracking: "none",
  traceInitPerf: !1,
  skipValidations: !1
}), e2 = Object.freeze({
  recoveryValueFunc: () => {
  },
  resyncEnabled: !0
});
var Yi;
(function(t) {
  t[t.INVALID_RULE_NAME = 0] = "INVALID_RULE_NAME", t[t.DUPLICATE_RULE_NAME = 1] = "DUPLICATE_RULE_NAME", t[t.INVALID_RULE_OVERRIDE = 2] = "INVALID_RULE_OVERRIDE", t[t.DUPLICATE_PRODUCTIONS = 3] = "DUPLICATE_PRODUCTIONS", t[t.UNRESOLVED_SUBRULE_REF = 4] = "UNRESOLVED_SUBRULE_REF", t[t.LEFT_RECURSION = 5] = "LEFT_RECURSION", t[t.NONE_LAST_EMPTY_ALT = 6] = "NONE_LAST_EMPTY_ALT", t[t.AMBIGUOUS_ALTS = 7] = "AMBIGUOUS_ALTS", t[t.CONFLICT_TOKENS_RULES_NAMESPACE = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE", t[t.INVALID_TOKEN_NAME = 9] = "INVALID_TOKEN_NAME", t[t.NO_NON_EMPTY_LOOKAHEAD = 10] = "NO_NON_EMPTY_LOOKAHEAD", t[t.AMBIGUOUS_PREFIX_ALTS = 11] = "AMBIGUOUS_PREFIX_ALTS", t[t.TOO_MANY_ALTS = 12] = "TOO_MANY_ALTS", t[t.CUSTOM_LOOKAHEAD_VALIDATION = 13] = "CUSTOM_LOOKAHEAD_VALIDATION";
})(Yi || (Yi = {}));
function UR(t = void 0) {
  return function() {
    return t;
  };
}
class qg {
  /**
   *  @deprecated use the **instance** method with the same name instead
   */
  static performSelfAnalysis(e) {
    throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.");
  }
  performSelfAnalysis() {
    this.TRACE_INIT("performSelfAnalysis", () => {
      let e;
      this.selfAnalysisDone = !0;
      const r = this.className;
      this.TRACE_INIT("toFastProps", () => {
        xq(this);
      }), this.TRACE_INIT("Grammar Recording", () => {
        try {
          this.enableRecording(), Wt(this.definedRulesNames, (i) => {
            const s = this[i].originalGrammarAction;
            let o;
            this.TRACE_INIT(`${i} Rule`, () => {
              o = this.topLevelRuleRecord(i, s);
            }), this.gastProductionsCache[i] = o;
          });
        } finally {
          this.disableRecording();
        }
      });
      let n = [];
      if (this.TRACE_INIT("Grammar Resolving", () => {
        n = cAe({
          rules: On(this.gastProductionsCache)
        }), this.definitionErrors = this.definitionErrors.concat(n);
      }), this.TRACE_INIT("Grammar Validations", () => {
        if (zr(n) && this.skipValidations === !1) {
          const i = uAe({
            rules: On(this.gastProductionsCache),
            tokenTypes: On(this.tokensMap),
            errMsgProvider: lu,
            grammarName: r
          }), a = X8e({
            lookaheadStrategy: this.lookaheadStrategy,
            rules: On(this.gastProductionsCache),
            tokenTypes: On(this.tokensMap),
            grammarName: r
          });
          this.definitionErrors = this.definitionErrors.concat(i, a);
        }
      }), zr(this.definitionErrors) && (this.recoveryEnabled && this.TRACE_INIT("computeAllProdsFollows", () => {
        const i = YCe(On(this.gastProductionsCache));
        this.resyncFollows = i;
      }), this.TRACE_INIT("ComputeLookaheadFunctions", () => {
        var i, a;
        (a = (i = this.lookaheadStrategy).initialize) === null || a === void 0 || a.call(i, {
          rules: On(this.gastProductionsCache)
        }), this.preComputeLookaheadFunctions(On(this.gastProductionsCache));
      })), !qg.DEFER_DEFINITION_ERRORS_HANDLING && !zr(this.definitionErrors))
        throw e = Ot(this.definitionErrors, (i) => i.message), new Error(`Parser Definition Errors detected:
 ${e.join(`
-------------------------------
`)}`);
    });
  }
  constructor(e, r) {
    this.definitionErrors = [], this.selfAnalysisDone = !1;
    const n = this;
    if (n.initErrorHandler(r), n.initLexerAdapter(), n.initLooksAhead(r), n.initRecognizerEngine(e, r), n.initRecoverable(r), n.initTreeBuilder(r), n.initContentAssist(), n.initGastRecorder(r), n.initPerformanceTracer(r), Vt(r, "ignoredIssues"))
      throw new Error(`The <ignoredIssues> IParserConfig property has been deprecated.
	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.
	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES
	For further details.`);
    this.skipValidations = Vt(r, "skipValidations") ? r.skipValidations : ol.skipValidations;
  }
}
qg.DEFER_DEFINITION_ERRORS_HANDLING = !1;
$Ae(qg, [
  gAe,
  yAe,
  LAe,
  RAe,
  NAe,
  MAe,
  IAe,
  DAe,
  PAe,
  FAe
]);
class zAe extends qg {
  constructor(e, r = ol) {
    const n = di(r);
    n.outputCst = !1, super(e, n);
  }
}
function Pd(t, e, r) {
  return `${t.name}_${e}_${r}`;
}
const oc = 1, GAe = 2, Kq = 4, Zq = 5, Wg = 7, VAe = 8, UAe = 9, HAe = 10, qAe = 11, Qq = 12;
class n7 {
  constructor(e) {
    this.target = e;
  }
  isEpsilon() {
    return !1;
  }
}
class i7 extends n7 {
  constructor(e, r) {
    super(e), this.tokenType = r;
  }
}
class Jq extends n7 {
  constructor(e) {
    super(e);
  }
  isEpsilon() {
    return !0;
  }
}
class a7 extends n7 {
  constructor(e, r, n) {
    super(e), this.rule = r, this.followState = n;
  }
  isEpsilon() {
    return !0;
  }
}
function WAe(t) {
  const e = {
    decisionMap: {},
    decisionStates: [],
    ruleToStartState: /* @__PURE__ */ new Map(),
    ruleToStopState: /* @__PURE__ */ new Map(),
    states: []
  };
  YAe(e, t);
  const r = t.length;
  for (let n = 0; n < r; n++) {
    const i = t[n], a = lh(e, i, i);
    a !== void 0 && i_e(e, i, a);
  }
  return e;
}
function YAe(t, e) {
  const r = e.length;
  for (let n = 0; n < r; n++) {
    const i = e[n], a = Kn(t, i, void 0, {
      type: GAe
    }), s = Kn(t, i, void 0, {
      type: Wg
    });
    a.stop = s, t.ruleToStartState.set(i, a), t.ruleToStopState.set(i, s);
  }
}
function eW(t, e, r) {
  return r instanceof Yr ? s7(t, e, r.terminalType, r) : r instanceof Wi ? n_e(t, e, r) : r instanceof ga ? QAe(t, e, r) : r instanceof hi ? JAe(t, e, r) : r instanceof ln ? XAe(t, e, r) : r instanceof pa ? jAe(t, e, r) : r instanceof Na ? KAe(t, e, r) : r instanceof Ia ? ZAe(t, e, r) : lh(t, e, r);
}
function XAe(t, e, r) {
  const n = Kn(t, e, r, {
    type: Zq
  });
  kc(t, n);
  const i = df(t, e, n, r, lh(t, e, r));
  return rW(t, e, r, i);
}
function jAe(t, e, r) {
  const n = Kn(t, e, r, {
    type: Zq
  });
  kc(t, n);
  const i = df(t, e, n, r, lh(t, e, r)), a = s7(t, e, r.separator, r);
  return rW(t, e, r, i, a);
}
function KAe(t, e, r) {
  const n = Kn(t, e, r, {
    type: Kq
  });
  kc(t, n);
  const i = df(t, e, n, r, lh(t, e, r));
  return tW(t, e, r, i);
}
function ZAe(t, e, r) {
  const n = Kn(t, e, r, {
    type: Kq
  });
  kc(t, n);
  const i = df(t, e, n, r, lh(t, e, r)), a = s7(t, e, r.separator, r);
  return tW(t, e, r, i, a);
}
function QAe(t, e, r) {
  const n = Kn(t, e, r, {
    type: oc
  });
  kc(t, n);
  const i = Ir(r.definition, (s) => eW(t, e, s));
  return df(t, e, n, r, ...i);
}
function JAe(t, e, r) {
  const n = Kn(t, e, r, {
    type: oc
  });
  kc(t, n);
  const i = df(t, e, n, r, lh(t, e, r));
  return e_e(t, e, r, i);
}
function lh(t, e, r) {
  const n = js(Ir(r.definition, (i) => eW(t, e, i)), (i) => i !== void 0);
  return n.length === 1 ? n[0] : n.length === 0 ? void 0 : r_e(t, n);
}
function tW(t, e, r, n, i) {
  const a = n.left, s = n.right, o = Kn(t, e, r, {
    type: qAe
  });
  kc(t, o);
  const l = Kn(t, e, r, {
    type: Qq
  });
  return a.loopback = o, l.loopback = o, t.decisionMap[Pd(e, i ? "RepetitionMandatoryWithSeparator" : "RepetitionMandatory", r.idx)] = o, kn(s, o), i === void 0 ? (kn(o, a), kn(o, l)) : (kn(o, l), kn(o, i.left), kn(i.right, a)), {
    left: a,
    right: l
  };
}
function rW(t, e, r, n, i) {
  const a = n.left, s = n.right, o = Kn(t, e, r, {
    type: HAe
  });
  kc(t, o);
  const l = Kn(t, e, r, {
    type: Qq
  }), u = Kn(t, e, r, {
    type: UAe
  });
  return o.loopback = u, l.loopback = u, kn(o, a), kn(o, l), kn(s, u), i !== void 0 ? (kn(u, l), kn(u, i.left), kn(i.right, a)) : kn(u, o), t.decisionMap[Pd(e, i ? "RepetitionWithSeparator" : "Repetition", r.idx)] = o, {
    left: o,
    right: l
  };
}
function e_e(t, e, r, n) {
  const i = n.left, a = n.right;
  return kn(i, a), t.decisionMap[Pd(e, "Option", r.idx)] = i, n;
}
function kc(t, e) {
  return t.decisionStates.push(e), e.decision = t.decisionStates.length - 1, e.decision;
}
function df(t, e, r, n, ...i) {
  const a = Kn(t, e, n, {
    type: VAe,
    start: r
  });
  r.end = a;
  for (const o of i)
    o !== void 0 ? (kn(r, o.left), kn(o.right, a)) : kn(r, a);
  const s = {
    left: r,
    right: a
  };
  return t.decisionMap[Pd(e, t_e(n), n.idx)] = r, s;
}
function t_e(t) {
  if (t instanceof ga)
    return "Alternation";
  if (t instanceof hi)
    return "Option";
  if (t instanceof ln)
    return "Repetition";
  if (t instanceof pa)
    return "RepetitionWithSeparator";
  if (t instanceof Na)
    return "RepetitionMandatory";
  if (t instanceof Ia)
    return "RepetitionMandatoryWithSeparator";
  throw new Error("Invalid production type encountered");
}
function r_e(t, e) {
  const r = e.length;
  for (let a = 0; a < r - 1; a++) {
    const s = e[a];
    let o;
    s.left.transitions.length === 1 && (o = s.left.transitions[0]);
    const l = o instanceof a7, u = o, h = e[a + 1].left;
    s.left.type === oc && s.right.type === oc && o !== void 0 && (l && u.followState === s.right || o.target === s.right) ? (l ? u.followState = h : o.target = h, a_e(t, s.right)) : kn(s.right, h);
  }
  const n = e[0], i = e[r - 1];
  return {
    left: n.left,
    right: i.right
  };
}
function s7(t, e, r, n) {
  const i = Kn(t, e, n, {
    type: oc
  }), a = Kn(t, e, n, {
    type: oc
  });
  return o7(i, new i7(a, r)), {
    left: i,
    right: a
  };
}
function n_e(t, e, r) {
  const n = r.referencedRule, i = t.ruleToStartState.get(n), a = Kn(t, e, r, {
    type: oc
  }), s = Kn(t, e, r, {
    type: oc
  }), o = new a7(i, n, s);
  return o7(a, o), {
    left: a,
    right: s
  };
}
function i_e(t, e, r) {
  const n = t.ruleToStartState.get(e);
  kn(n, r.left);
  const i = t.ruleToStopState.get(e);
  return kn(r.right, i), {
    left: n,
    right: i
  };
}
function kn(t, e) {
  const r = new Jq(e);
  o7(t, r);
}
function Kn(t, e, r, n) {
  const i = Object.assign({
    atn: t,
    production: r,
    epsilonOnlyTransitions: !1,
    rule: e,
    transitions: [],
    nextTokenWithinRule: [],
    stateNumber: t.states.length
  }, n);
  return t.states.push(i), i;
}
function o7(t, e) {
  t.transitions.length === 0 && (t.epsilonOnlyTransitions = e.isEpsilon()), t.transitions.push(e);
}
function a_e(t, e) {
  t.states.splice(t.states.indexOf(e), 1);
}
const t2 = {};
class r6 {
  constructor() {
    this.map = {}, this.configs = [];
  }
  get size() {
    return this.configs.length;
  }
  finalize() {
    this.map = {};
  }
  add(e) {
    const r = nW(e);
    r in this.map || (this.map[r] = this.configs.length, this.configs.push(e));
  }
  get elements() {
    return this.configs;
  }
  get alts() {
    return Ir(this.configs, (e) => e.alt);
  }
  get key() {
    let e = "";
    for (const r in this.map)
      e += r + ":";
    return e;
  }
}
function nW(t, e = !0) {
  return `${e ? `a${t.alt}` : ""}s${t.state.stateNumber}:${t.stack.map((r) => r.stateNumber.toString()).join("_")}`;
}
function s_e(t, e) {
  const r = {};
  return (n) => {
    const i = n.toString();
    let a = r[i];
    return a !== void 0 || (a = {
      atnStartState: t,
      decision: e,
      states: {}
    }, r[i] = a), a;
  };
}
class iW {
  constructor() {
    this.predicates = [];
  }
  is(e) {
    return e >= this.predicates.length || this.predicates[e];
  }
  set(e, r) {
    this.predicates[e] = r;
  }
  toString() {
    let e = "";
    const r = this.predicates.length;
    for (let n = 0; n < r; n++)
      e += this.predicates[n] === !0 ? "1" : "0";
    return e;
  }
}
const HR = new iW();
class o_e extends r7 {
  constructor(e) {
    var r;
    super(), this.logging = (r = e?.logging) !== null && r !== void 0 ? r : ((n) => console.log(n));
  }
  initialize(e) {
    this.atn = WAe(e.rules), this.dfas = l_e(this.atn);
  }
  validateAmbiguousAlternationAlternatives() {
    return [];
  }
  validateEmptyOrAlternatives() {
    return [];
  }
  buildLookaheadForAlternation(e) {
    const { prodOccurrence: r, rule: n, hasPredicates: i, dynamicTokensEnabled: a } = e, s = this.dfas, o = this.logging, l = Pd(n, "Alternation", r), h = this.atn.decisionMap[l].decision, d = Ir(PR({
      maxLookahead: 1,
      occurrence: r,
      prodType: "Alternation",
      rule: n
    }), (f) => Ir(f, (p) => p[0]));
    if (qR(d, !1) && !a) {
      const f = Su(d, (p, g, m) => (Ye(g, (v) => {
        v && (p[v.tokenTypeIdx] = m, Ye(v.categoryMatches, (y) => {
          p[y] = m;
        }));
      }), p), {});
      return i ? function(p) {
        var g;
        const m = this.LA(1), v = f[m.tokenTypeIdx];
        if (p !== void 0 && v !== void 0) {
          const y = (g = p[v]) === null || g === void 0 ? void 0 : g.GATE;
          if (y !== void 0 && y.call(this) === !1)
            return;
        }
        return v;
      } : function() {
        const p = this.LA(1);
        return f[p.tokenTypeIdx];
      };
    } else return i ? function(f) {
      const p = new iW(), g = f === void 0 ? 0 : f.length;
      for (let v = 0; v < g; v++) {
        const y = f?.[v].GATE;
        p.set(v, y === void 0 || y.call(this));
      }
      const m = k5.call(this, s, h, p, o);
      return typeof m == "number" ? m : void 0;
    } : function() {
      const f = k5.call(this, s, h, HR, o);
      return typeof f == "number" ? f : void 0;
    };
  }
  buildLookaheadForOptional(e) {
    const { prodOccurrence: r, rule: n, prodType: i, dynamicTokensEnabled: a } = e, s = this.dfas, o = this.logging, l = Pd(n, i, r), h = this.atn.decisionMap[l].decision, d = Ir(PR({
      maxLookahead: 1,
      occurrence: r,
      prodType: i,
      rule: n
    }), (f) => Ir(f, (p) => p[0]));
    if (qR(d) && d[0][0] && !a) {
      const f = d[0], p = Qu(f);
      if (p.length === 1 && Ap(p[0].categoryMatches)) {
        const m = p[0].tokenTypeIdx;
        return function() {
          return this.LA(1).tokenTypeIdx === m;
        };
      } else {
        const g = Su(p, (m, v) => (v !== void 0 && (m[v.tokenTypeIdx] = !0, Ye(v.categoryMatches, (y) => {
          m[y] = !0;
        })), m), {});
        return function() {
          const m = this.LA(1);
          return g[m.tokenTypeIdx] === !0;
        };
      }
    }
    return function() {
      const f = k5.call(this, s, h, HR, o);
      return typeof f == "object" ? !1 : f === 0;
    };
  }
}
function qR(t, e = !0) {
  const r = /* @__PURE__ */ new Set();
  for (const n of t) {
    const i = /* @__PURE__ */ new Set();
    for (const a of n) {
      if (a === void 0) {
        if (e)
          break;
        return !1;
      }
      const s = [a.tokenTypeIdx].concat(a.categoryMatches);
      for (const o of s)
        if (r.has(o)) {
          if (!i.has(o))
            return !1;
        } else
          r.add(o), i.add(o);
    }
  }
  return !0;
}
function l_e(t) {
  const e = t.decisionStates.length, r = Array(e);
  for (let n = 0; n < e; n++)
    r[n] = s_e(t.decisionStates[n], n);
  return r;
}
function k5(t, e, r, n) {
  const i = t[e](r);
  let a = i.start;
  if (a === void 0) {
    const o = x_e(i.atnStartState);
    a = sW(i, aW(o)), i.start = a;
  }
  return c_e.apply(this, [i, a, r, n]);
}
function c_e(t, e, r, n) {
  let i = e, a = 1;
  const s = [];
  let o = this.LA(a++);
  for (; ; ) {
    let l = g_e(i, o);
    if (l === void 0 && (l = u_e.apply(this, [t, i, o, a, r, n])), l === t2)
      return p_e(s, i, o);
    if (l.isAcceptState === !0)
      return l.prediction;
    i = l, s.push(o), o = this.LA(a++);
  }
}
function u_e(t, e, r, n, i, a) {
  const s = m_e(e.configs, r, i);
  if (s.size === 0)
    return WR(t, e, r, t2), t2;
  let o = aW(s);
  const l = y_e(s, i);
  if (l !== void 0)
    o.isAcceptState = !0, o.prediction = l, o.configs.uniqueAlt = l;
  else if (E_e(s)) {
    const u = Ad(s.alts);
    o.isAcceptState = !0, o.prediction = u, o.configs.uniqueAlt = u, h_e.apply(this, [t, n, s.alts, a]);
  }
  return o = WR(t, e, r, o), o;
}
function h_e(t, e, r, n) {
  const i = [];
  for (let u = 1; u <= e; u++)
    i.push(this.LA(u).tokenType);
  const a = t.atnStartState, s = a.rule, o = a.production, l = d_e({
    topLevelRule: s,
    ambiguityIndices: r,
    production: o,
    prefixPath: i
  });
  n(l);
}
function d_e(t) {
  const e = Ir(t.prefixPath, (i) => od(i)).join(", "), r = t.production.idx === 0 ? "" : t.production.idx;
  let n = `Ambiguous Alternatives Detected: <${t.ambiguityIndices.join(", ")}> in <${f_e(t.production)}${r}> inside <${t.topLevelRule.name}> Rule,
<${e}> may appears as a prefix path in all these alternatives.
`;
  return n = n + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`, n;
}
function f_e(t) {
  if (t instanceof Wi)
    return "SUBRULE";
  if (t instanceof hi)
    return "OPTION";
  if (t instanceof ga)
    return "OR";
  if (t instanceof Na)
    return "AT_LEAST_ONE";
  if (t instanceof Ia)
    return "AT_LEAST_ONE_SEP";
  if (t instanceof pa)
    return "MANY_SEP";
  if (t instanceof ln)
    return "MANY";
  if (t instanceof Yr)
    return "CONSUME";
  throw Error("non exhaustive match");
}
function p_e(t, e, r) {
  const n = R1e(e.configs.elements, (a) => a.state.transitions), i = eme(n.filter((a) => a instanceof i7).map((a) => a.tokenType), (a) => a.tokenTypeIdx);
  return {
    actualToken: r,
    possibleTokenTypes: i,
    tokenPath: t
  };
}
function g_e(t, e) {
  return t.edges[e.tokenTypeIdx];
}
function m_e(t, e, r) {
  const n = new r6(), i = [];
  for (const s of t.elements) {
    if (r.is(s.alt) === !1)
      continue;
    if (s.state.type === Wg) {
      i.push(s);
      continue;
    }
    const o = s.state.transitions.length;
    for (let l = 0; l < o; l++) {
      const u = s.state.transitions[l], h = v_e(u, e);
      h !== void 0 && n.add({
        state: h,
        alt: s.alt,
        stack: s.stack
      });
    }
  }
  let a;
  if (i.length === 0 && n.size === 1 && (a = n), a === void 0) {
    a = new r6();
    for (const s of n.elements)
      r2(s, a);
  }
  if (i.length > 0 && !w_e(a))
    for (const s of i)
      a.add(s);
  return a;
}
function v_e(t, e) {
  if (t instanceof i7 && Mq(e, t.tokenType))
    return t.target;
}
function y_e(t, e) {
  let r;
  for (const n of t.elements)
    if (e.is(n.alt) === !0) {
      if (r === void 0)
        r = n.alt;
      else if (r !== n.alt)
        return;
    }
  return r;
}
function aW(t) {
  return {
    configs: t,
    edges: {},
    isAcceptState: !1,
    prediction: -1
  };
}
function WR(t, e, r, n) {
  return n = sW(t, n), e.edges[r.tokenTypeIdx] = n, n;
}
function sW(t, e) {
  if (e === t2)
    return e;
  const r = e.configs.key, n = t.states[r];
  return n !== void 0 ? n : (e.configs.finalize(), t.states[r] = e, e);
}
function x_e(t) {
  const e = new r6(), r = t.transitions.length;
  for (let n = 0; n < r; n++) {
    const a = {
      state: t.transitions[n].target,
      alt: n,
      stack: []
    };
    r2(a, e);
  }
  return e;
}
function r2(t, e) {
  const r = t.state;
  if (r.type === Wg) {
    if (t.stack.length > 0) {
      const i = [...t.stack], s = {
        state: i.pop(),
        alt: t.alt,
        stack: i
      };
      r2(s, e);
    } else
      e.add(t);
    return;
  }
  r.epsilonOnlyTransitions || e.add(t);
  const n = r.transitions.length;
  for (let i = 0; i < n; i++) {
    const a = r.transitions[i], s = b_e(t, a);
    s !== void 0 && r2(s, e);
  }
}
function b_e(t, e) {
  if (e instanceof Jq)
    return {
      state: e.target,
      alt: t.alt,
      stack: t.stack
    };
  if (e instanceof a7) {
    const r = [...t.stack, e.followState];
    return {
      state: e.target,
      alt: t.alt,
      stack: r
    };
  }
}
function w_e(t) {
  for (const e of t.elements)
    if (e.state.type === Wg)
      return !0;
  return !1;
}
function T_e(t) {
  for (const e of t.elements)
    if (e.state.type !== Wg)
      return !1;
  return !0;
}
function E_e(t) {
  if (T_e(t))
    return !0;
  const e = k_e(t.elements);
  return S_e(e) && !C_e(e);
}
function k_e(t) {
  const e = /* @__PURE__ */ new Map();
  for (const r of t) {
    const n = nW(r, !1);
    let i = e.get(n);
    i === void 0 && (i = {}, e.set(n, i)), i[r.alt] = !0;
  }
  return e;
}
function S_e(t) {
  for (const e of Array.from(t.values()))
    if (Object.keys(e).length > 1)
      return !0;
  return !1;
}
function C_e(t) {
  for (const e of Array.from(t.values()))
    if (Object.keys(e).length === 1)
      return !0;
  return !1;
}
var YR;
(function(t) {
  function e(r) {
    return typeof r == "string";
  }
  t.is = e;
})(YR || (YR = {}));
var n6;
(function(t) {
  function e(r) {
    return typeof r == "string";
  }
  t.is = e;
})(n6 || (n6 = {}));
var XR;
(function(t) {
  t.MIN_VALUE = -2147483648, t.MAX_VALUE = 2147483647;
  function e(r) {
    return typeof r == "number" && t.MIN_VALUE <= r && r <= t.MAX_VALUE;
  }
  t.is = e;
})(XR || (XR = {}));
var n2;
(function(t) {
  t.MIN_VALUE = 0, t.MAX_VALUE = 2147483647;
  function e(r) {
    return typeof r == "number" && t.MIN_VALUE <= r && r <= t.MAX_VALUE;
  }
  t.is = e;
})(n2 || (n2 = {}));
var Sr;
(function(t) {
  function e(n, i) {
    return n === Number.MAX_VALUE && (n = n2.MAX_VALUE), i === Number.MAX_VALUE && (i = n2.MAX_VALUE), { line: n, character: i };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.objectLiteral(i) && Fe.uinteger(i.line) && Fe.uinteger(i.character);
  }
  t.is = r;
})(Sr || (Sr = {}));
var fr;
(function(t) {
  function e(n, i, a, s) {
    if (Fe.uinteger(n) && Fe.uinteger(i) && Fe.uinteger(a) && Fe.uinteger(s))
      return { start: Sr.create(n, i), end: Sr.create(a, s) };
    if (Sr.is(n) && Sr.is(i))
      return { start: n, end: i };
    throw new Error(`Range#create called with invalid arguments[${n}, ${i}, ${a}, ${s}]`);
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.objectLiteral(i) && Sr.is(i.start) && Sr.is(i.end);
  }
  t.is = r;
})(fr || (fr = {}));
var i2;
(function(t) {
  function e(n, i) {
    return { uri: n, range: i };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.objectLiteral(i) && fr.is(i.range) && (Fe.string(i.uri) || Fe.undefined(i.uri));
  }
  t.is = r;
})(i2 || (i2 = {}));
var jR;
(function(t) {
  function e(n, i, a, s) {
    return { targetUri: n, targetRange: i, targetSelectionRange: a, originSelectionRange: s };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.objectLiteral(i) && fr.is(i.targetRange) && Fe.string(i.targetUri) && fr.is(i.targetSelectionRange) && (fr.is(i.originSelectionRange) || Fe.undefined(i.originSelectionRange));
  }
  t.is = r;
})(jR || (jR = {}));
var i6;
(function(t) {
  function e(n, i, a, s) {
    return {
      red: n,
      green: i,
      blue: a,
      alpha: s
    };
  }
  t.create = e;
  function r(n) {
    const i = n;
    return Fe.objectLiteral(i) && Fe.numberRange(i.red, 0, 1) && Fe.numberRange(i.green, 0, 1) && Fe.numberRange(i.blue, 0, 1) && Fe.numberRange(i.alpha, 0, 1);
  }
  t.is = r;
})(i6 || (i6 = {}));
var KR;
(function(t) {
  function e(n, i) {
    return {
      range: n,
      color: i
    };
  }
  t.create = e;
  function r(n) {
    const i = n;
    return Fe.objectLiteral(i) && fr.is(i.range) && i6.is(i.color);
  }
  t.is = r;
})(KR || (KR = {}));
var ZR;
(function(t) {
  function e(n, i, a) {
    return {
      label: n,
      textEdit: i,
      additionalTextEdits: a
    };
  }
  t.create = e;
  function r(n) {
    const i = n;
    return Fe.objectLiteral(i) && Fe.string(i.label) && (Fe.undefined(i.textEdit) || Fd.is(i)) && (Fe.undefined(i.additionalTextEdits) || Fe.typedArray(i.additionalTextEdits, Fd.is));
  }
  t.is = r;
})(ZR || (ZR = {}));
var QR;
(function(t) {
  t.Comment = "comment", t.Imports = "imports", t.Region = "region";
})(QR || (QR = {}));
var JR;
(function(t) {
  function e(n, i, a, s, o, l) {
    const u = {
      startLine: n,
      endLine: i
    };
    return Fe.defined(a) && (u.startCharacter = a), Fe.defined(s) && (u.endCharacter = s), Fe.defined(o) && (u.kind = o), Fe.defined(l) && (u.collapsedText = l), u;
  }
  t.create = e;
  function r(n) {
    const i = n;
    return Fe.objectLiteral(i) && Fe.uinteger(i.startLine) && Fe.uinteger(i.startLine) && (Fe.undefined(i.startCharacter) || Fe.uinteger(i.startCharacter)) && (Fe.undefined(i.endCharacter) || Fe.uinteger(i.endCharacter)) && (Fe.undefined(i.kind) || Fe.string(i.kind));
  }
  t.is = r;
})(JR || (JR = {}));
var a6;
(function(t) {
  function e(n, i) {
    return {
      location: n,
      message: i
    };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && i2.is(i.location) && Fe.string(i.message);
  }
  t.is = r;
})(a6 || (a6 = {}));
var eM;
(function(t) {
  t.Error = 1, t.Warning = 2, t.Information = 3, t.Hint = 4;
})(eM || (eM = {}));
var tM;
(function(t) {
  t.Unnecessary = 1, t.Deprecated = 2;
})(tM || (tM = {}));
var rM;
(function(t) {
  function e(r) {
    const n = r;
    return Fe.objectLiteral(n) && Fe.string(n.href);
  }
  t.is = e;
})(rM || (rM = {}));
var a2;
(function(t) {
  function e(n, i, a, s, o, l) {
    let u = { range: n, message: i };
    return Fe.defined(a) && (u.severity = a), Fe.defined(s) && (u.code = s), Fe.defined(o) && (u.source = o), Fe.defined(l) && (u.relatedInformation = l), u;
  }
  t.create = e;
  function r(n) {
    var i;
    let a = n;
    return Fe.defined(a) && fr.is(a.range) && Fe.string(a.message) && (Fe.number(a.severity) || Fe.undefined(a.severity)) && (Fe.integer(a.code) || Fe.string(a.code) || Fe.undefined(a.code)) && (Fe.undefined(a.codeDescription) || Fe.string((i = a.codeDescription) === null || i === void 0 ? void 0 : i.href)) && (Fe.string(a.source) || Fe.undefined(a.source)) && (Fe.undefined(a.relatedInformation) || Fe.typedArray(a.relatedInformation, a6.is));
  }
  t.is = r;
})(a2 || (a2 = {}));
var Bd;
(function(t) {
  function e(n, i, ...a) {
    let s = { title: n, command: i };
    return Fe.defined(a) && a.length > 0 && (s.arguments = a), s;
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && Fe.string(i.title) && Fe.string(i.command);
  }
  t.is = r;
})(Bd || (Bd = {}));
var Fd;
(function(t) {
  function e(a, s) {
    return { range: a, newText: s };
  }
  t.replace = e;
  function r(a, s) {
    return { range: { start: a, end: a }, newText: s };
  }
  t.insert = r;
  function n(a) {
    return { range: a, newText: "" };
  }
  t.del = n;
  function i(a) {
    const s = a;
    return Fe.objectLiteral(s) && Fe.string(s.newText) && fr.is(s.range);
  }
  t.is = i;
})(Fd || (Fd = {}));
var s6;
(function(t) {
  function e(n, i, a) {
    const s = { label: n };
    return i !== void 0 && (s.needsConfirmation = i), a !== void 0 && (s.description = a), s;
  }
  t.create = e;
  function r(n) {
    const i = n;
    return Fe.objectLiteral(i) && Fe.string(i.label) && (Fe.boolean(i.needsConfirmation) || i.needsConfirmation === void 0) && (Fe.string(i.description) || i.description === void 0);
  }
  t.is = r;
})(s6 || (s6 = {}));
var $d;
(function(t) {
  function e(r) {
    const n = r;
    return Fe.string(n);
  }
  t.is = e;
})($d || ($d = {}));
var nM;
(function(t) {
  function e(a, s, o) {
    return { range: a, newText: s, annotationId: o };
  }
  t.replace = e;
  function r(a, s, o) {
    return { range: { start: a, end: a }, newText: s, annotationId: o };
  }
  t.insert = r;
  function n(a, s) {
    return { range: a, newText: "", annotationId: s };
  }
  t.del = n;
  function i(a) {
    const s = a;
    return Fd.is(s) && (s6.is(s.annotationId) || $d.is(s.annotationId));
  }
  t.is = i;
})(nM || (nM = {}));
var o6;
(function(t) {
  function e(n, i) {
    return { textDocument: n, edits: i };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && d6.is(i.textDocument) && Array.isArray(i.edits);
  }
  t.is = r;
})(o6 || (o6 = {}));
var l6;
(function(t) {
  function e(n, i, a) {
    let s = {
      kind: "create",
      uri: n
    };
    return i !== void 0 && (i.overwrite !== void 0 || i.ignoreIfExists !== void 0) && (s.options = i), a !== void 0 && (s.annotationId = a), s;
  }
  t.create = e;
  function r(n) {
    let i = n;
    return i && i.kind === "create" && Fe.string(i.uri) && (i.options === void 0 || (i.options.overwrite === void 0 || Fe.boolean(i.options.overwrite)) && (i.options.ignoreIfExists === void 0 || Fe.boolean(i.options.ignoreIfExists))) && (i.annotationId === void 0 || $d.is(i.annotationId));
  }
  t.is = r;
})(l6 || (l6 = {}));
var c6;
(function(t) {
  function e(n, i, a, s) {
    let o = {
      kind: "rename",
      oldUri: n,
      newUri: i
    };
    return a !== void 0 && (a.overwrite !== void 0 || a.ignoreIfExists !== void 0) && (o.options = a), s !== void 0 && (o.annotationId = s), o;
  }
  t.create = e;
  function r(n) {
    let i = n;
    return i && i.kind === "rename" && Fe.string(i.oldUri) && Fe.string(i.newUri) && (i.options === void 0 || (i.options.overwrite === void 0 || Fe.boolean(i.options.overwrite)) && (i.options.ignoreIfExists === void 0 || Fe.boolean(i.options.ignoreIfExists))) && (i.annotationId === void 0 || $d.is(i.annotationId));
  }
  t.is = r;
})(c6 || (c6 = {}));
var u6;
(function(t) {
  function e(n, i, a) {
    let s = {
      kind: "delete",
      uri: n
    };
    return i !== void 0 && (i.recursive !== void 0 || i.ignoreIfNotExists !== void 0) && (s.options = i), a !== void 0 && (s.annotationId = a), s;
  }
  t.create = e;
  function r(n) {
    let i = n;
    return i && i.kind === "delete" && Fe.string(i.uri) && (i.options === void 0 || (i.options.recursive === void 0 || Fe.boolean(i.options.recursive)) && (i.options.ignoreIfNotExists === void 0 || Fe.boolean(i.options.ignoreIfNotExists))) && (i.annotationId === void 0 || $d.is(i.annotationId));
  }
  t.is = r;
})(u6 || (u6 = {}));
var h6;
(function(t) {
  function e(r) {
    let n = r;
    return n && (n.changes !== void 0 || n.documentChanges !== void 0) && (n.documentChanges === void 0 || n.documentChanges.every((i) => Fe.string(i.kind) ? l6.is(i) || c6.is(i) || u6.is(i) : o6.is(i)));
  }
  t.is = e;
})(h6 || (h6 = {}));
var iM;
(function(t) {
  function e(n) {
    return { uri: n };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && Fe.string(i.uri);
  }
  t.is = r;
})(iM || (iM = {}));
var aM;
(function(t) {
  function e(n, i) {
    return { uri: n, version: i };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && Fe.string(i.uri) && Fe.integer(i.version);
  }
  t.is = r;
})(aM || (aM = {}));
var d6;
(function(t) {
  function e(n, i) {
    return { uri: n, version: i };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && Fe.string(i.uri) && (i.version === null || Fe.integer(i.version));
  }
  t.is = r;
})(d6 || (d6 = {}));
var sM;
(function(t) {
  function e(n, i, a, s) {
    return { uri: n, languageId: i, version: a, text: s };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && Fe.string(i.uri) && Fe.string(i.languageId) && Fe.integer(i.version) && Fe.string(i.text);
  }
  t.is = r;
})(sM || (sM = {}));
var f6;
(function(t) {
  t.PlainText = "plaintext", t.Markdown = "markdown";
  function e(r) {
    const n = r;
    return n === t.PlainText || n === t.Markdown;
  }
  t.is = e;
})(f6 || (f6 = {}));
var jp;
(function(t) {
  function e(r) {
    const n = r;
    return Fe.objectLiteral(r) && f6.is(n.kind) && Fe.string(n.value);
  }
  t.is = e;
})(jp || (jp = {}));
var oM;
(function(t) {
  t.Text = 1, t.Method = 2, t.Function = 3, t.Constructor = 4, t.Field = 5, t.Variable = 6, t.Class = 7, t.Interface = 8, t.Module = 9, t.Property = 10, t.Unit = 11, t.Value = 12, t.Enum = 13, t.Keyword = 14, t.Snippet = 15, t.Color = 16, t.File = 17, t.Reference = 18, t.Folder = 19, t.EnumMember = 20, t.Constant = 21, t.Struct = 22, t.Event = 23, t.Operator = 24, t.TypeParameter = 25;
})(oM || (oM = {}));
var lM;
(function(t) {
  t.PlainText = 1, t.Snippet = 2;
})(lM || (lM = {}));
var cM;
(function(t) {
  t.Deprecated = 1;
})(cM || (cM = {}));
var uM;
(function(t) {
  function e(n, i, a) {
    return { newText: n, insert: i, replace: a };
  }
  t.create = e;
  function r(n) {
    const i = n;
    return i && Fe.string(i.newText) && fr.is(i.insert) && fr.is(i.replace);
  }
  t.is = r;
})(uM || (uM = {}));
var hM;
(function(t) {
  t.asIs = 1, t.adjustIndentation = 2;
})(hM || (hM = {}));
var dM;
(function(t) {
  function e(r) {
    const n = r;
    return n && (Fe.string(n.detail) || n.detail === void 0) && (Fe.string(n.description) || n.description === void 0);
  }
  t.is = e;
})(dM || (dM = {}));
var fM;
(function(t) {
  function e(r) {
    return { label: r };
  }
  t.create = e;
})(fM || (fM = {}));
var pM;
(function(t) {
  function e(r, n) {
    return { items: r || [], isIncomplete: !!n };
  }
  t.create = e;
})(pM || (pM = {}));
var s2;
(function(t) {
  function e(n) {
    return n.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
  }
  t.fromPlainText = e;
  function r(n) {
    const i = n;
    return Fe.string(i) || Fe.objectLiteral(i) && Fe.string(i.language) && Fe.string(i.value);
  }
  t.is = r;
})(s2 || (s2 = {}));
var gM;
(function(t) {
  function e(r) {
    let n = r;
    return !!n && Fe.objectLiteral(n) && (jp.is(n.contents) || s2.is(n.contents) || Fe.typedArray(n.contents, s2.is)) && (r.range === void 0 || fr.is(r.range));
  }
  t.is = e;
})(gM || (gM = {}));
var mM;
(function(t) {
  function e(r, n) {
    return n ? { label: r, documentation: n } : { label: r };
  }
  t.create = e;
})(mM || (mM = {}));
var vM;
(function(t) {
  function e(r, n, ...i) {
    let a = { label: r };
    return Fe.defined(n) && (a.documentation = n), Fe.defined(i) ? a.parameters = i : a.parameters = [], a;
  }
  t.create = e;
})(vM || (vM = {}));
var yM;
(function(t) {
  t.Text = 1, t.Read = 2, t.Write = 3;
})(yM || (yM = {}));
var xM;
(function(t) {
  function e(r, n) {
    let i = { range: r };
    return Fe.number(n) && (i.kind = n), i;
  }
  t.create = e;
})(xM || (xM = {}));
var bM;
(function(t) {
  t.File = 1, t.Module = 2, t.Namespace = 3, t.Package = 4, t.Class = 5, t.Method = 6, t.Property = 7, t.Field = 8, t.Constructor = 9, t.Enum = 10, t.Interface = 11, t.Function = 12, t.Variable = 13, t.Constant = 14, t.String = 15, t.Number = 16, t.Boolean = 17, t.Array = 18, t.Object = 19, t.Key = 20, t.Null = 21, t.EnumMember = 22, t.Struct = 23, t.Event = 24, t.Operator = 25, t.TypeParameter = 26;
})(bM || (bM = {}));
var wM;
(function(t) {
  t.Deprecated = 1;
})(wM || (wM = {}));
var TM;
(function(t) {
  function e(r, n, i, a, s) {
    let o = {
      name: r,
      kind: n,
      location: { uri: a, range: i }
    };
    return s && (o.containerName = s), o;
  }
  t.create = e;
})(TM || (TM = {}));
var EM;
(function(t) {
  function e(r, n, i, a) {
    return a !== void 0 ? { name: r, kind: n, location: { uri: i, range: a } } : { name: r, kind: n, location: { uri: i } };
  }
  t.create = e;
})(EM || (EM = {}));
var kM;
(function(t) {
  function e(n, i, a, s, o, l) {
    let u = {
      name: n,
      detail: i,
      kind: a,
      range: s,
      selectionRange: o
    };
    return l !== void 0 && (u.children = l), u;
  }
  t.create = e;
  function r(n) {
    let i = n;
    return i && Fe.string(i.name) && Fe.number(i.kind) && fr.is(i.range) && fr.is(i.selectionRange) && (i.detail === void 0 || Fe.string(i.detail)) && (i.deprecated === void 0 || Fe.boolean(i.deprecated)) && (i.children === void 0 || Array.isArray(i.children)) && (i.tags === void 0 || Array.isArray(i.tags));
  }
  t.is = r;
})(kM || (kM = {}));
var SM;
(function(t) {
  t.Empty = "", t.QuickFix = "quickfix", t.Refactor = "refactor", t.RefactorExtract = "refactor.extract", t.RefactorInline = "refactor.inline", t.RefactorRewrite = "refactor.rewrite", t.Source = "source", t.SourceOrganizeImports = "source.organizeImports", t.SourceFixAll = "source.fixAll";
})(SM || (SM = {}));
var o2;
(function(t) {
  t.Invoked = 1, t.Automatic = 2;
})(o2 || (o2 = {}));
var CM;
(function(t) {
  function e(n, i, a) {
    let s = { diagnostics: n };
    return i != null && (s.only = i), a != null && (s.triggerKind = a), s;
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && Fe.typedArray(i.diagnostics, a2.is) && (i.only === void 0 || Fe.typedArray(i.only, Fe.string)) && (i.triggerKind === void 0 || i.triggerKind === o2.Invoked || i.triggerKind === o2.Automatic);
  }
  t.is = r;
})(CM || (CM = {}));
var AM;
(function(t) {
  function e(n, i, a) {
    let s = { title: n }, o = !0;
    return typeof i == "string" ? (o = !1, s.kind = i) : Bd.is(i) ? s.command = i : s.edit = i, o && a !== void 0 && (s.kind = a), s;
  }
  t.create = e;
  function r(n) {
    let i = n;
    return i && Fe.string(i.title) && (i.diagnostics === void 0 || Fe.typedArray(i.diagnostics, a2.is)) && (i.kind === void 0 || Fe.string(i.kind)) && (i.edit !== void 0 || i.command !== void 0) && (i.command === void 0 || Bd.is(i.command)) && (i.isPreferred === void 0 || Fe.boolean(i.isPreferred)) && (i.edit === void 0 || h6.is(i.edit));
  }
  t.is = r;
})(AM || (AM = {}));
var _M;
(function(t) {
  function e(n, i) {
    let a = { range: n };
    return Fe.defined(i) && (a.data = i), a;
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && fr.is(i.range) && (Fe.undefined(i.command) || Bd.is(i.command));
  }
  t.is = r;
})(_M || (_M = {}));
var LM;
(function(t) {
  function e(n, i) {
    return { tabSize: n, insertSpaces: i };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && Fe.uinteger(i.tabSize) && Fe.boolean(i.insertSpaces);
  }
  t.is = r;
})(LM || (LM = {}));
var RM;
(function(t) {
  function e(n, i, a) {
    return { range: n, target: i, data: a };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && fr.is(i.range) && (Fe.undefined(i.target) || Fe.string(i.target));
  }
  t.is = r;
})(RM || (RM = {}));
var MM;
(function(t) {
  function e(n, i) {
    return { range: n, parent: i };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.objectLiteral(i) && fr.is(i.range) && (i.parent === void 0 || t.is(i.parent));
  }
  t.is = r;
})(MM || (MM = {}));
var NM;
(function(t) {
  t.namespace = "namespace", t.type = "type", t.class = "class", t.enum = "enum", t.interface = "interface", t.struct = "struct", t.typeParameter = "typeParameter", t.parameter = "parameter", t.variable = "variable", t.property = "property", t.enumMember = "enumMember", t.event = "event", t.function = "function", t.method = "method", t.macro = "macro", t.keyword = "keyword", t.modifier = "modifier", t.comment = "comment", t.string = "string", t.number = "number", t.regexp = "regexp", t.operator = "operator", t.decorator = "decorator";
})(NM || (NM = {}));
var IM;
(function(t) {
  t.declaration = "declaration", t.definition = "definition", t.readonly = "readonly", t.static = "static", t.deprecated = "deprecated", t.abstract = "abstract", t.async = "async", t.modification = "modification", t.documentation = "documentation", t.defaultLibrary = "defaultLibrary";
})(IM || (IM = {}));
var DM;
(function(t) {
  function e(r) {
    const n = r;
    return Fe.objectLiteral(n) && (n.resultId === void 0 || typeof n.resultId == "string") && Array.isArray(n.data) && (n.data.length === 0 || typeof n.data[0] == "number");
  }
  t.is = e;
})(DM || (DM = {}));
var OM;
(function(t) {
  function e(n, i) {
    return { range: n, text: i };
  }
  t.create = e;
  function r(n) {
    const i = n;
    return i != null && fr.is(i.range) && Fe.string(i.text);
  }
  t.is = r;
})(OM || (OM = {}));
var PM;
(function(t) {
  function e(n, i, a) {
    return { range: n, variableName: i, caseSensitiveLookup: a };
  }
  t.create = e;
  function r(n) {
    const i = n;
    return i != null && fr.is(i.range) && Fe.boolean(i.caseSensitiveLookup) && (Fe.string(i.variableName) || i.variableName === void 0);
  }
  t.is = r;
})(PM || (PM = {}));
var BM;
(function(t) {
  function e(n, i) {
    return { range: n, expression: i };
  }
  t.create = e;
  function r(n) {
    const i = n;
    return i != null && fr.is(i.range) && (Fe.string(i.expression) || i.expression === void 0);
  }
  t.is = r;
})(BM || (BM = {}));
var FM;
(function(t) {
  function e(n, i) {
    return { frameId: n, stoppedLocation: i };
  }
  t.create = e;
  function r(n) {
    const i = n;
    return Fe.defined(i) && fr.is(n.stoppedLocation);
  }
  t.is = r;
})(FM || (FM = {}));
var p6;
(function(t) {
  t.Type = 1, t.Parameter = 2;
  function e(r) {
    return r === 1 || r === 2;
  }
  t.is = e;
})(p6 || (p6 = {}));
var g6;
(function(t) {
  function e(n) {
    return { value: n };
  }
  t.create = e;
  function r(n) {
    const i = n;
    return Fe.objectLiteral(i) && (i.tooltip === void 0 || Fe.string(i.tooltip) || jp.is(i.tooltip)) && (i.location === void 0 || i2.is(i.location)) && (i.command === void 0 || Bd.is(i.command));
  }
  t.is = r;
})(g6 || (g6 = {}));
var $M;
(function(t) {
  function e(n, i, a) {
    const s = { position: n, label: i };
    return a !== void 0 && (s.kind = a), s;
  }
  t.create = e;
  function r(n) {
    const i = n;
    return Fe.objectLiteral(i) && Sr.is(i.position) && (Fe.string(i.label) || Fe.typedArray(i.label, g6.is)) && (i.kind === void 0 || p6.is(i.kind)) && i.textEdits === void 0 || Fe.typedArray(i.textEdits, Fd.is) && (i.tooltip === void 0 || Fe.string(i.tooltip) || jp.is(i.tooltip)) && (i.paddingLeft === void 0 || Fe.boolean(i.paddingLeft)) && (i.paddingRight === void 0 || Fe.boolean(i.paddingRight));
  }
  t.is = r;
})($M || ($M = {}));
var zM;
(function(t) {
  function e(r) {
    return { kind: "snippet", value: r };
  }
  t.createSnippet = e;
})(zM || (zM = {}));
var GM;
(function(t) {
  function e(r, n, i, a) {
    return { insertText: r, filterText: n, range: i, command: a };
  }
  t.create = e;
})(GM || (GM = {}));
var VM;
(function(t) {
  function e(r) {
    return { items: r };
  }
  t.create = e;
})(VM || (VM = {}));
var UM;
(function(t) {
  t.Invoked = 0, t.Automatic = 1;
})(UM || (UM = {}));
var HM;
(function(t) {
  function e(r, n) {
    return { range: r, text: n };
  }
  t.create = e;
})(HM || (HM = {}));
var qM;
(function(t) {
  function e(r, n) {
    return { triggerKind: r, selectedCompletionInfo: n };
  }
  t.create = e;
})(qM || (qM = {}));
var WM;
(function(t) {
  function e(r) {
    const n = r;
    return Fe.objectLiteral(n) && n6.is(n.uri) && Fe.string(n.name);
  }
  t.is = e;
})(WM || (WM = {}));
var YM;
(function(t) {
  function e(a, s, o, l) {
    return new A_e(a, s, o, l);
  }
  t.create = e;
  function r(a) {
    let s = a;
    return !!(Fe.defined(s) && Fe.string(s.uri) && (Fe.undefined(s.languageId) || Fe.string(s.languageId)) && Fe.uinteger(s.lineCount) && Fe.func(s.getText) && Fe.func(s.positionAt) && Fe.func(s.offsetAt));
  }
  t.is = r;
  function n(a, s) {
    let o = a.getText(), l = i(s, (h, d) => {
      let f = h.range.start.line - d.range.start.line;
      return f === 0 ? h.range.start.character - d.range.start.character : f;
    }), u = o.length;
    for (let h = l.length - 1; h >= 0; h--) {
      let d = l[h], f = a.offsetAt(d.range.start), p = a.offsetAt(d.range.end);
      if (p <= u)
        o = o.substring(0, f) + d.newText + o.substring(p, o.length);
      else
        throw new Error("Overlapping edit");
      u = f;
    }
    return o;
  }
  t.applyEdits = n;
  function i(a, s) {
    if (a.length <= 1)
      return a;
    const o = a.length / 2 | 0, l = a.slice(0, o), u = a.slice(o);
    i(l, s), i(u, s);
    let h = 0, d = 0, f = 0;
    for (; h < l.length && d < u.length; )
      s(l[h], u[d]) <= 0 ? a[f++] = l[h++] : a[f++] = u[d++];
    for (; h < l.length; )
      a[f++] = l[h++];
    for (; d < u.length; )
      a[f++] = u[d++];
    return a;
  }
})(YM || (YM = {}));
let A_e = class {
  constructor(e, r, n, i) {
    this._uri = e, this._languageId = r, this._version = n, this._content = i, this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(e) {
    if (e) {
      let r = this.offsetAt(e.start), n = this.offsetAt(e.end);
      return this._content.substring(r, n);
    }
    return this._content;
  }
  update(e, r) {
    this._content = e.text, this._version = r, this._lineOffsets = void 0;
  }
  getLineOffsets() {
    if (this._lineOffsets === void 0) {
      let e = [], r = this._content, n = !0;
      for (let i = 0; i < r.length; i++) {
        n && (e.push(i), n = !1);
        let a = r.charAt(i);
        n = a === "\r" || a === `
`, a === "\r" && i + 1 < r.length && r.charAt(i + 1) === `
` && i++;
      }
      n && r.length > 0 && e.push(r.length), this._lineOffsets = e;
    }
    return this._lineOffsets;
  }
  positionAt(e) {
    e = Math.max(Math.min(e, this._content.length), 0);
    let r = this.getLineOffsets(), n = 0, i = r.length;
    if (i === 0)
      return Sr.create(0, e);
    for (; n < i; ) {
      let s = Math.floor((n + i) / 2);
      r[s] > e ? i = s : n = s + 1;
    }
    let a = n - 1;
    return Sr.create(a, e - r[a]);
  }
  offsetAt(e) {
    let r = this.getLineOffsets();
    if (e.line >= r.length)
      return this._content.length;
    if (e.line < 0)
      return 0;
    let n = r[e.line], i = e.line + 1 < r.length ? r[e.line + 1] : this._content.length;
    return Math.max(Math.min(n + e.character, i), n);
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
};
var Fe;
(function(t) {
  const e = Object.prototype.toString;
  function r(p) {
    return typeof p < "u";
  }
  t.defined = r;
  function n(p) {
    return typeof p > "u";
  }
  t.undefined = n;
  function i(p) {
    return p === !0 || p === !1;
  }
  t.boolean = i;
  function a(p) {
    return e.call(p) === "[object String]";
  }
  t.string = a;
  function s(p) {
    return e.call(p) === "[object Number]";
  }
  t.number = s;
  function o(p, g, m) {
    return e.call(p) === "[object Number]" && g <= p && p <= m;
  }
  t.numberRange = o;
  function l(p) {
    return e.call(p) === "[object Number]" && -2147483648 <= p && p <= 2147483647;
  }
  t.integer = l;
  function u(p) {
    return e.call(p) === "[object Number]" && 0 <= p && p <= 2147483647;
  }
  t.uinteger = u;
  function h(p) {
    return e.call(p) === "[object Function]";
  }
  t.func = h;
  function d(p) {
    return p !== null && typeof p == "object";
  }
  t.objectLiteral = d;
  function f(p, g) {
    return Array.isArray(p) && p.every(g);
  }
  t.typedArray = f;
})(Fe || (Fe = {}));
class __e {
  constructor() {
    this.nodeStack = [];
  }
  get current() {
    var e;
    return (e = this.nodeStack[this.nodeStack.length - 1]) !== null && e !== void 0 ? e : this.rootNode;
  }
  buildRootNode(e) {
    return this.rootNode = new lW(e), this.rootNode.root = this.rootNode, this.nodeStack = [this.rootNode], this.rootNode;
  }
  buildCompositeNode(e) {
    const r = new l7();
    return r.grammarSource = e, r.root = this.rootNode, this.current.content.push(r), this.nodeStack.push(r), r;
  }
  buildLeafNode(e, r) {
    const n = new m6(e.startOffset, e.image.length, $T(e), e.tokenType, !r);
    return n.grammarSource = r, n.root = this.rootNode, this.current.content.push(n), n;
  }
  removeNode(e) {
    const r = e.container;
    if (r) {
      const n = r.content.indexOf(e);
      n >= 0 && r.content.splice(n, 1);
    }
  }
  addHiddenNodes(e) {
    const r = [];
    for (const a of e) {
      const s = new m6(a.startOffset, a.image.length, $T(a), a.tokenType, !0);
      s.root = this.rootNode, r.push(s);
    }
    let n = this.current, i = !1;
    if (n.content.length > 0) {
      n.content.push(...r);
      return;
    }
    for (; n.container; ) {
      const a = n.container.content.indexOf(n);
      if (a > 0) {
        n.container.content.splice(a, 0, ...r), i = !0;
        break;
      }
      n = n.container;
    }
    i || this.rootNode.content.unshift(...r);
  }
  construct(e) {
    const r = this.current;
    typeof e.$type == "string" && (this.current.astNode = e), e.$cstNode = r;
    const n = this.nodeStack.pop();
    n?.content.length === 0 && this.removeNode(n);
  }
}
class oW {
  /** @deprecated use `container` instead. */
  get parent() {
    return this.container;
  }
  /** @deprecated use `grammarSource` instead. */
  get feature() {
    return this.grammarSource;
  }
  get hidden() {
    return !1;
  }
  get astNode() {
    var e, r;
    const n = typeof ((e = this._astNode) === null || e === void 0 ? void 0 : e.$type) == "string" ? this._astNode : (r = this.container) === null || r === void 0 ? void 0 : r.astNode;
    if (!n)
      throw new Error("This node has no associated AST element");
    return n;
  }
  set astNode(e) {
    this._astNode = e;
  }
  /** @deprecated use `astNode` instead. */
  get element() {
    return this.astNode;
  }
  get text() {
    return this.root.fullText.substring(this.offset, this.end);
  }
}
class m6 extends oW {
  get offset() {
    return this._offset;
  }
  get length() {
    return this._length;
  }
  get end() {
    return this._offset + this._length;
  }
  get hidden() {
    return this._hidden;
  }
  get tokenType() {
    return this._tokenType;
  }
  get range() {
    return this._range;
  }
  constructor(e, r, n, i, a = !1) {
    super(), this._hidden = a, this._offset = e, this._tokenType = i, this._length = r, this._range = n;
  }
}
class l7 extends oW {
  constructor() {
    super(...arguments), this.content = new c7(this);
  }
  /** @deprecated use `content` instead. */
  get children() {
    return this.content;
  }
  get offset() {
    var e, r;
    return (r = (e = this.firstNonHiddenNode) === null || e === void 0 ? void 0 : e.offset) !== null && r !== void 0 ? r : 0;
  }
  get length() {
    return this.end - this.offset;
  }
  get end() {
    var e, r;
    return (r = (e = this.lastNonHiddenNode) === null || e === void 0 ? void 0 : e.end) !== null && r !== void 0 ? r : 0;
  }
  get range() {
    const e = this.firstNonHiddenNode, r = this.lastNonHiddenNode;
    if (e && r) {
      if (this._rangeCache === void 0) {
        const { range: n } = e, { range: i } = r;
        this._rangeCache = { start: n.start, end: i.end.line < n.start.line ? n.start : i.end };
      }
      return this._rangeCache;
    } else
      return { start: Sr.create(0, 0), end: Sr.create(0, 0) };
  }
  get firstNonHiddenNode() {
    for (const e of this.content)
      if (!e.hidden)
        return e;
    return this.content[0];
  }
  get lastNonHiddenNode() {
    for (let e = this.content.length - 1; e >= 0; e--) {
      const r = this.content[e];
      if (!r.hidden)
        return r;
    }
    return this.content[this.content.length - 1];
  }
}
class c7 extends Array {
  constructor(e) {
    super(), this.parent = e, Object.setPrototypeOf(this, c7.prototype);
  }
  push(...e) {
    return this.addParents(e), super.push(...e);
  }
  unshift(...e) {
    return this.addParents(e), super.unshift(...e);
  }
  splice(e, r, ...n) {
    return this.addParents(n), super.splice(e, r, ...n);
  }
  addParents(e) {
    for (const r of e)
      r.container = this.parent;
  }
}
class lW extends l7 {
  get text() {
    return this._text.substring(this.offset, this.end);
  }
  get fullText() {
    return this._text;
  }
  constructor(e) {
    super(), this._text = "", this._text = e ?? "";
  }
}
const v6 = /* @__PURE__ */ Symbol("Datatype");
function S5(t) {
  return t.$type === v6;
}
const XM = "", cW = (t) => t.endsWith(XM) ? t : t + XM;
class uW {
  constructor(e) {
    this._unorderedGroups = /* @__PURE__ */ new Map(), this.allRules = /* @__PURE__ */ new Map(), this.lexer = e.parser.Lexer;
    const r = this.lexer.definition, n = e.LanguageMetaData.mode === "production";
    this.wrapper = new I_e(r, Object.assign(Object.assign({}, e.parser.ParserConfig), { skipValidations: n, errorMessageProvider: e.parser.ParserErrorMessageProvider }));
  }
  alternatives(e, r) {
    this.wrapper.wrapOr(e, r);
  }
  optional(e, r) {
    this.wrapper.wrapOption(e, r);
  }
  many(e, r) {
    this.wrapper.wrapMany(e, r);
  }
  atLeastOne(e, r) {
    this.wrapper.wrapAtLeastOne(e, r);
  }
  getRule(e) {
    return this.allRules.get(e);
  }
  isRecording() {
    return this.wrapper.IS_RECORDING;
  }
  get unorderedGroups() {
    return this._unorderedGroups;
  }
  getRuleStack() {
    return this.wrapper.RULE_STACK;
  }
  finalize() {
    this.wrapper.wrapSelfAnalysis();
  }
}
class L_e extends uW {
  get current() {
    return this.stack[this.stack.length - 1];
  }
  constructor(e) {
    super(e), this.nodeBuilder = new __e(), this.stack = [], this.assignmentMap = /* @__PURE__ */ new Map(), this.linker = e.references.Linker, this.converter = e.parser.ValueConverter, this.astReflection = e.shared.AstReflection;
  }
  rule(e, r) {
    const n = this.computeRuleType(e), i = this.wrapper.DEFINE_RULE(cW(e.name), this.startImplementation(n, r).bind(this));
    return this.allRules.set(e.name, i), e.entry && (this.mainRule = i), i;
  }
  computeRuleType(e) {
    if (!e.fragment) {
      if ($H(e))
        return v6;
      {
        const r = RS(e);
        return r ?? e.name;
      }
    }
  }
  parse(e, r = {}) {
    this.nodeBuilder.buildRootNode(e);
    const n = this.lexerResult = this.lexer.tokenize(e);
    this.wrapper.input = n.tokens;
    const i = r.rule ? this.allRules.get(r.rule) : this.mainRule;
    if (!i)
      throw new Error(r.rule ? `No rule found with name '${r.rule}'` : "No main rule available.");
    const a = i.call(this.wrapper, {});
    return this.nodeBuilder.addHiddenNodes(n.hidden), this.unorderedGroups.clear(), this.lexerResult = void 0, {
      value: a,
      lexerErrors: n.errors,
      lexerReport: n.report,
      parserErrors: this.wrapper.errors
    };
  }
  startImplementation(e, r) {
    return (n) => {
      const i = !this.isRecording() && e !== void 0;
      if (i) {
        const s = { $type: e };
        this.stack.push(s), e === v6 && (s.value = "");
      }
      let a;
      try {
        a = r(n);
      } catch {
        a = void 0;
      }
      return a === void 0 && i && (a = this.construct()), a;
    };
  }
  extractHiddenTokens(e) {
    const r = this.lexerResult.hidden;
    if (!r.length)
      return [];
    const n = e.startOffset;
    for (let i = 0; i < r.length; i++)
      if (r[i].startOffset > n)
        return r.splice(0, i);
    return r.splice(0, r.length);
  }
  consume(e, r, n) {
    const i = this.wrapper.wrapConsume(e, r);
    if (!this.isRecording() && this.isValidToken(i)) {
      const a = this.extractHiddenTokens(i);
      this.nodeBuilder.addHiddenNodes(a);
      const s = this.nodeBuilder.buildLeafNode(i, n), { assignment: o, isCrossRef: l } = this.getAssignment(n), u = this.current;
      if (o) {
        const h = Nu(n) ? i.image : this.converter.convert(i.image, s);
        this.assign(o.operator, o.feature, h, s, l);
      } else if (S5(u)) {
        let h = i.image;
        Nu(n) || (h = this.converter.convert(h, s).toString()), u.value += h;
      }
    }
  }
  /**
   * Most consumed parser tokens are valid. However there are two cases in which they are not valid:
   *
   * 1. They were inserted during error recovery by the parser. These tokens don't really exist and should not be further processed
   * 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.
   */
  isValidToken(e) {
    return !e.isInsertedInRecovery && !isNaN(e.startOffset) && typeof e.endOffset == "number" && !isNaN(e.endOffset);
  }
  subrule(e, r, n, i, a) {
    let s;
    !this.isRecording() && !n && (s = this.nodeBuilder.buildCompositeNode(i));
    const o = this.wrapper.wrapSubrule(e, r, a);
    !this.isRecording() && s && s.length > 0 && this.performSubruleAssignment(o, i, s);
  }
  performSubruleAssignment(e, r, n) {
    const { assignment: i, isCrossRef: a } = this.getAssignment(r);
    if (i)
      this.assign(i.operator, i.feature, e, n, a);
    else if (!i) {
      const s = this.current;
      if (S5(s))
        s.value += e.toString();
      else if (typeof e == "object" && e) {
        const l = this.assignWithoutOverride(e, s);
        this.stack.pop(), this.stack.push(l);
      }
    }
  }
  action(e, r) {
    if (!this.isRecording()) {
      let n = this.current;
      if (r.feature && r.operator) {
        n = this.construct(), this.nodeBuilder.removeNode(n.$cstNode), this.nodeBuilder.buildCompositeNode(r).content.push(n.$cstNode);
        const a = { $type: e };
        this.stack.push(a), this.assign(r.operator, r.feature, n, n.$cstNode, !1);
      } else
        n.$type = e;
    }
  }
  construct() {
    if (this.isRecording())
      return;
    const e = this.current;
    return MTe(e), this.nodeBuilder.construct(e), this.stack.pop(), S5(e) ? this.converter.convert(e.value, e.$cstNode) : (NTe(this.astReflection, e), e);
  }
  getAssignment(e) {
    if (!this.assignmentMap.has(e)) {
      const r = qx(e, Mu);
      this.assignmentMap.set(e, {
        assignment: r,
        isCrossRef: r ? CS(r.terminal) : !1
      });
    }
    return this.assignmentMap.get(e);
  }
  assign(e, r, n, i, a) {
    const s = this.current;
    let o;
    switch (a && typeof n == "string" ? o = this.linker.buildReference(s, r, i, n) : o = n, e) {
      case "=": {
        s[r] = o;
        break;
      }
      case "?=": {
        s[r] = !0;
        break;
      }
      case "+=":
        Array.isArray(s[r]) || (s[r] = []), s[r].push(o);
    }
  }
  assignWithoutOverride(e, r) {
    for (const [i, a] of Object.entries(r)) {
      const s = e[i];
      s === void 0 ? e[i] = a : Array.isArray(s) && Array.isArray(a) && (a.push(...s), e[i] = a);
    }
    const n = e.$cstNode;
    return n && (n.astNode = void 0, e.$cstNode = void 0), e;
  }
  get definitionErrors() {
    return this.wrapper.definitionErrors;
  }
}
class R_e {
  buildMismatchTokenMessage(e) {
    return Hh.buildMismatchTokenMessage(e);
  }
  buildNotAllInputParsedMessage(e) {
    return Hh.buildNotAllInputParsedMessage(e);
  }
  buildNoViableAltMessage(e) {
    return Hh.buildNoViableAltMessage(e);
  }
  buildEarlyExitMessage(e) {
    return Hh.buildEarlyExitMessage(e);
  }
}
class hW extends R_e {
  buildMismatchTokenMessage({ expected: e, actual: r }) {
    return `Expecting ${e.LABEL ? "`" + e.LABEL + "`" : e.name.endsWith(":KW") ? `keyword '${e.name.substring(0, e.name.length - 3)}'` : `token of type '${e.name}'`} but found \`${r.image}\`.`;
  }
  buildNotAllInputParsedMessage({ firstRedundant: e }) {
    return `Expecting end of file but found \`${e.image}\`.`;
  }
}
class M_e extends uW {
  constructor() {
    super(...arguments), this.tokens = [], this.elementStack = [], this.lastElementStack = [], this.nextTokenIndex = 0, this.stackSize = 0;
  }
  action() {
  }
  construct() {
  }
  parse(e) {
    this.resetState();
    const r = this.lexer.tokenize(e, { mode: "partial" });
    return this.tokens = r.tokens, this.wrapper.input = [...this.tokens], this.mainRule.call(this.wrapper, {}), this.unorderedGroups.clear(), {
      tokens: this.tokens,
      elementStack: [...this.lastElementStack],
      tokenIndex: this.nextTokenIndex
    };
  }
  rule(e, r) {
    const n = this.wrapper.DEFINE_RULE(cW(e.name), this.startImplementation(r).bind(this));
    return this.allRules.set(e.name, n), e.entry && (this.mainRule = n), n;
  }
  resetState() {
    this.elementStack = [], this.lastElementStack = [], this.nextTokenIndex = 0, this.stackSize = 0;
  }
  startImplementation(e) {
    return (r) => {
      const n = this.keepStackSize();
      try {
        e(r);
      } finally {
        this.resetStackSize(n);
      }
    };
  }
  removeUnexpectedElements() {
    this.elementStack.splice(this.stackSize);
  }
  keepStackSize() {
    const e = this.elementStack.length;
    return this.stackSize = e, e;
  }
  resetStackSize(e) {
    this.removeUnexpectedElements(), this.stackSize = e;
  }
  consume(e, r, n) {
    this.wrapper.wrapConsume(e, r), this.isRecording() || (this.lastElementStack = [...this.elementStack, n], this.nextTokenIndex = this.currIdx + 1);
  }
  subrule(e, r, n, i, a) {
    this.before(i), this.wrapper.wrapSubrule(e, r, a), this.after(i);
  }
  before(e) {
    this.isRecording() || this.elementStack.push(e);
  }
  after(e) {
    if (!this.isRecording()) {
      const r = this.elementStack.lastIndexOf(e);
      r >= 0 && this.elementStack.splice(r);
    }
  }
  get currIdx() {
    return this.wrapper.currIdx;
  }
}
const N_e = {
  recoveryEnabled: !0,
  nodeLocationTracking: "full",
  skipValidations: !0,
  errorMessageProvider: new hW()
};
class I_e extends zAe {
  constructor(e, r) {
    const n = r && "maxLookahead" in r;
    super(e, Object.assign(Object.assign(Object.assign({}, N_e), { lookaheadStrategy: n ? new r7({ maxLookahead: r.maxLookahead }) : new o_e({
      // If validations are skipped, don't log the lookahead warnings
      logging: r.skipValidations ? () => {
      } : void 0
    }) }), r));
  }
  get IS_RECORDING() {
    return this.RECORDING_PHASE;
  }
  DEFINE_RULE(e, r) {
    return this.RULE(e, r);
  }
  wrapSelfAnalysis() {
    this.performSelfAnalysis();
  }
  wrapConsume(e, r) {
    return this.consume(e, r);
  }
  wrapSubrule(e, r, n) {
    return this.subrule(e, r, {
      ARGS: [n]
    });
  }
  wrapOr(e, r) {
    this.or(e, r);
  }
  wrapOption(e, r) {
    this.option(e, r);
  }
  wrapMany(e, r) {
    this.many(e, r);
  }
  wrapAtLeastOne(e, r) {
    this.atLeastOne(e, r);
  }
}
function dW(t, e, r) {
  return D_e({
    parser: e,
    tokens: r,
    ruleNames: /* @__PURE__ */ new Map()
  }, t), e;
}
function D_e(t, e) {
  const r = DH(e, !1), n = oi(e.rules).filter(rs).filter((i) => r.has(i));
  for (const i of n) {
    const a = Object.assign(Object.assign({}, t), { consume: 1, optional: 1, subrule: 1, many: 1, or: 1 });
    t.parser.rule(i, Pu(a, i.definition));
  }
}
function Pu(t, e, r = !1) {
  let n;
  if (Nu(e))
    n = G_e(t, e);
  else if (Hx(e))
    n = O_e(t, e);
  else if (Mu(e))
    n = Pu(t, e.terminal);
  else if (CS(e))
    n = fW(t, e);
  else if (Iu(e))
    n = P_e(t, e);
  else if (_H(e))
    n = F_e(t, e);
  else if (LH(e))
    n = $_e(t, e);
  else if (AS(e))
    n = z_e(t, e);
  else if (ETe(e)) {
    const i = t.consume++;
    n = () => t.parser.consume(i, sc, e);
  } else
    throw new kH(e.$cstNode, `Unexpected element type: ${e.$type}`);
  return pW(t, r ? void 0 : l2(e), n, e.cardinality);
}
function O_e(t, e) {
  const r = MS(e);
  return () => t.parser.action(r, e);
}
function P_e(t, e) {
  const r = e.rule.ref;
  if (rs(r)) {
    const n = t.subrule++, i = r.fragment, a = e.arguments.length > 0 ? B_e(r, e.arguments) : () => ({});
    return (s) => t.parser.subrule(n, gW(t, r), i, e, a(s));
  } else if (ih(r)) {
    const n = t.consume++, i = y6(t, r.name);
    return () => t.parser.consume(n, i, e);
  } else if (r)
    Og();
  else
    throw new kH(e.$cstNode, `Undefined rule: ${e.rule.$refText}`);
}
function B_e(t, e) {
  const r = e.map((n) => Bo(n.value));
  return (n) => {
    const i = {};
    for (let a = 0; a < r.length; a++) {
      const s = t.parameters[a], o = r[a];
      i[s.name] = o(n);
    }
    return i;
  };
}
function Bo(t) {
  if (vTe(t)) {
    const e = Bo(t.left), r = Bo(t.right);
    return (n) => e(n) || r(n);
  } else if (mTe(t)) {
    const e = Bo(t.left), r = Bo(t.right);
    return (n) => e(n) && r(n);
  } else if (yTe(t)) {
    const e = Bo(t.value);
    return (r) => !e(r);
  } else if (xTe(t)) {
    const e = t.parameter.ref.name;
    return (r) => r !== void 0 && r[e] === !0;
  } else if (gTe(t)) {
    const e = !!t.true;
    return () => e;
  }
  Og();
}
function F_e(t, e) {
  if (e.elements.length === 1)
    return Pu(t, e.elements[0]);
  {
    const r = [];
    for (const i of e.elements) {
      const a = {
        // Since we handle the guard condition in the alternative already
        // We can ignore the group guard condition inside
        ALT: Pu(t, i, !0)
      }, s = l2(i);
      s && (a.GATE = Bo(s)), r.push(a);
    }
    const n = t.or++;
    return (i) => t.parser.alternatives(n, r.map((a) => {
      const s = {
        ALT: () => a.ALT(i)
      }, o = a.GATE;
      return o && (s.GATE = () => o(i)), s;
    }));
  }
}
function $_e(t, e) {
  if (e.elements.length === 1)
    return Pu(t, e.elements[0]);
  const r = [];
  for (const o of e.elements) {
    const l = {
      // Since we handle the guard condition in the alternative already
      // We can ignore the group guard condition inside
      ALT: Pu(t, o, !0)
    }, u = l2(o);
    u && (l.GATE = Bo(u)), r.push(l);
  }
  const n = t.or++, i = (o, l) => {
    const u = l.getRuleStack().join("-");
    return `uGroup_${o}_${u}`;
  }, a = (o) => t.parser.alternatives(n, r.map((l, u) => {
    const h = { ALT: () => !0 }, d = t.parser;
    h.ALT = () => {
      if (l.ALT(o), !d.isRecording()) {
        const p = i(n, d);
        d.unorderedGroups.get(p) || d.unorderedGroups.set(p, []);
        const g = d.unorderedGroups.get(p);
        typeof g?.[u] > "u" && (g[u] = !0);
      }
    };
    const f = l.GATE;
    return f ? h.GATE = () => f(o) : h.GATE = () => {
      const p = d.unorderedGroups.get(i(n, d));
      return !p?.[u];
    }, h;
  })), s = pW(t, l2(e), a, "*");
  return (o) => {
    s(o), t.parser.isRecording() || t.parser.unorderedGroups.delete(i(n, t.parser));
  };
}
function z_e(t, e) {
  const r = e.elements.map((n) => Pu(t, n));
  return (n) => r.forEach((i) => i(n));
}
function l2(t) {
  if (AS(t))
    return t.guardCondition;
}
function fW(t, e, r = e.terminal) {
  if (r)
    if (Iu(r) && rs(r.rule.ref)) {
      const n = r.rule.ref, i = t.subrule++;
      return (a) => t.parser.subrule(i, gW(t, n), !1, e, a);
    } else if (Iu(r) && ih(r.rule.ref)) {
      const n = t.consume++, i = y6(t, r.rule.ref.name);
      return () => t.parser.consume(n, i, e);
    } else if (Nu(r)) {
      const n = t.consume++, i = y6(t, r.value);
      return () => t.parser.consume(n, i, e);
    } else
      throw new Error("Could not build cross reference parser");
  else {
    if (!e.type.ref)
      throw new Error("Could not resolve reference to type: " + e.type.$refText);
    const n = BH(e.type.ref), i = n?.terminal;
    if (!i)
      throw new Error("Could not find name assignment for type: " + MS(e.type.ref));
    return fW(t, e, i);
  }
}
function G_e(t, e) {
  const r = t.consume++, n = t.tokens[e.value];
  if (!n)
    throw new Error("Could not find token for keyword: " + e.value);
  return () => t.parser.consume(r, n, e);
}
function pW(t, e, r, n) {
  const i = e && Bo(e);
  if (!n)
    if (i) {
      const a = t.or++;
      return (s) => t.parser.alternatives(a, [
        {
          ALT: () => r(s),
          GATE: () => i(s)
        },
        {
          ALT: UR(),
          GATE: () => !i(s)
        }
      ]);
    } else
      return r;
  if (n === "*") {
    const a = t.many++;
    return (s) => t.parser.many(a, {
      DEF: () => r(s),
      GATE: i ? () => i(s) : void 0
    });
  } else if (n === "+") {
    const a = t.many++;
    if (i) {
      const s = t.or++;
      return (o) => t.parser.alternatives(s, [
        {
          ALT: () => t.parser.atLeastOne(a, {
            DEF: () => r(o)
          }),
          GATE: () => i(o)
        },
        {
          ALT: UR(),
          GATE: () => !i(o)
        }
      ]);
    } else
      return (s) => t.parser.atLeastOne(a, {
        DEF: () => r(s)
      });
  } else if (n === "?") {
    const a = t.optional++;
    return (s) => t.parser.optional(a, {
      DEF: () => r(s),
      GATE: i ? () => i(s) : void 0
    });
  } else
    Og();
}
function gW(t, e) {
  const r = V_e(t, e), n = t.parser.getRule(r);
  if (!n)
    throw new Error(`Rule "${r}" not found."`);
  return n;
}
function V_e(t, e) {
  if (rs(e))
    return e.name;
  if (t.ruleNames.has(e))
    return t.ruleNames.get(e);
  {
    let r = e, n = r.$container, i = e.$type;
    for (; !rs(n); )
      (AS(n) || _H(n) || LH(n)) && (i = n.elements.indexOf(r).toString() + ":" + i), r = n, n = n.$container;
    return i = n.name + ":" + i, t.ruleNames.set(e, i), i;
  }
}
function y6(t, e) {
  const r = t.tokens[e];
  if (!r)
    throw new Error(`Token "${e}" not found."`);
  return r;
}
function U_e(t) {
  const e = t.Grammar, r = t.parser.Lexer, n = new M_e(t);
  return dW(e, n, r.definition), n.finalize(), n;
}
function H_e(t) {
  const e = q_e(t);
  return e.finalize(), e;
}
function q_e(t) {
  const e = t.Grammar, r = t.parser.Lexer, n = new L_e(t);
  return dW(e, n, r.definition);
}
class mW {
  constructor() {
    this.diagnostics = [];
  }
  buildTokens(e, r) {
    const n = oi(DH(e, !1)), i = this.buildTerminalTokens(n), a = this.buildKeywordTokens(n, i, r);
    return i.forEach((s) => {
      const o = s.PATTERN;
      typeof o == "object" && o && "test" in o && GT(o) ? a.unshift(s) : a.push(s);
    }), a;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  flushLexingReport(e) {
    return { diagnostics: this.popDiagnostics() };
  }
  popDiagnostics() {
    const e = [...this.diagnostics];
    return this.diagnostics = [], e;
  }
  buildTerminalTokens(e) {
    return e.filter(ih).filter((r) => !r.fragment).map((r) => this.buildTerminalToken(r)).toArray();
  }
  buildTerminalToken(e) {
    const r = NS(e), n = this.requiresCustomPattern(r) ? this.regexPatternFunction(r) : r, i = {
      name: e.name,
      PATTERN: n
    };
    return typeof n == "function" && (i.LINE_BREAKS = !0), e.hidden && (i.GROUP = GT(r) ? la.SKIPPED : "hidden"), i;
  }
  requiresCustomPattern(e) {
    return e.flags.includes("u") || e.flags.includes("s") ? !0 : !!(e.source.includes("?<=") || e.source.includes("?<!"));
  }
  regexPatternFunction(e) {
    const r = new RegExp(e, e.flags + "y");
    return (n, i) => (r.lastIndex = i, r.exec(n));
  }
  buildKeywordTokens(e, r, n) {
    return e.filter(rs).flatMap((i) => Pg(i).filter(Nu)).distinct((i) => i.value).toArray().sort((i, a) => a.value.length - i.value.length).map((i) => this.buildKeywordToken(i, r, !!n?.caseInsensitive));
  }
  buildKeywordToken(e, r, n) {
    const i = this.buildKeywordPattern(e, n), a = {
      name: e.value,
      PATTERN: i,
      LONGER_ALT: this.findLongerAlt(e, r)
    };
    return typeof i == "function" && (a.LINE_BREAKS = !0), a;
  }
  buildKeywordPattern(e, r) {
    return r ? new RegExp(GTe(e.value)) : e.value;
  }
  findLongerAlt(e, r) {
    return r.reduce((n, i) => {
      const a = i?.PATTERN;
      return a?.source && VTe("^" + a.source + "$", e.value) && n.push(i), n;
    }, []);
  }
}
class vW {
  convert(e, r) {
    let n = r.grammarSource;
    if (CS(n) && (n = WTe(n)), Iu(n)) {
      const i = n.rule.ref;
      if (!i)
        throw new Error("This cst node was not parsed by a rule.");
      return this.runConverter(i, e, r);
    }
    return e;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  runConverter(e, r, n) {
    var i;
    switch (e.name.toUpperCase()) {
      case "INT":
        return Mo.convertInt(r);
      case "STRING":
        return Mo.convertString(r);
      case "ID":
        return Mo.convertID(r);
    }
    switch ((i = JTe(e)) === null || i === void 0 ? void 0 : i.toLowerCase()) {
      case "number":
        return Mo.convertNumber(r);
      case "boolean":
        return Mo.convertBoolean(r);
      case "bigint":
        return Mo.convertBigint(r);
      case "date":
        return Mo.convertDate(r);
      default:
        return r;
    }
  }
}
var Mo;
(function(t) {
  function e(u) {
    let h = "";
    for (let d = 1; d < u.length - 1; d++) {
      const f = u.charAt(d);
      if (f === "\\") {
        const p = u.charAt(++d);
        h += r(p);
      } else
        h += f;
    }
    return h;
  }
  t.convertString = e;
  function r(u) {
    switch (u) {
      case "b":
        return "\b";
      case "f":
        return "\f";
      case "n":
        return `
`;
      case "r":
        return "\r";
      case "t":
        return "	";
      case "v":
        return "\v";
      case "0":
        return "\0";
      default:
        return u;
    }
  }
  function n(u) {
    return u.charAt(0) === "^" ? u.substring(1) : u;
  }
  t.convertID = n;
  function i(u) {
    return parseInt(u);
  }
  t.convertInt = i;
  function a(u) {
    return BigInt(u);
  }
  t.convertBigint = a;
  function s(u) {
    return new Date(u);
  }
  t.convertDate = s;
  function o(u) {
    return Number(u);
  }
  t.convertNumber = o;
  function l(u) {
    return u.toLowerCase() === "true";
  }
  t.convertBoolean = l;
})(Mo || (Mo = {}));
var Gc = {}, em = {}, jM;
function yW() {
  if (jM) return em;
  jM = 1, Object.defineProperty(em, "__esModule", { value: !0 });
  let t;
  function e() {
    if (t === void 0)
      throw new Error("No runtime abstraction layer installed");
    return t;
  }
  return (function(r) {
    function n(i) {
      if (i === void 0)
        throw new Error("No runtime abstraction layer provided");
      t = i;
    }
    r.install = n;
  })(e || (e = {})), em.default = e, em;
}
var ti = {}, KM;
function W_e() {
  if (KM) return ti;
  KM = 1, Object.defineProperty(ti, "__esModule", { value: !0 }), ti.stringArray = ti.array = ti.func = ti.error = ti.number = ti.string = ti.boolean = void 0;
  function t(o) {
    return o === !0 || o === !1;
  }
  ti.boolean = t;
  function e(o) {
    return typeof o == "string" || o instanceof String;
  }
  ti.string = e;
  function r(o) {
    return typeof o == "number" || o instanceof Number;
  }
  ti.number = r;
  function n(o) {
    return o instanceof Error;
  }
  ti.error = n;
  function i(o) {
    return typeof o == "function";
  }
  ti.func = i;
  function a(o) {
    return Array.isArray(o);
  }
  ti.array = a;
  function s(o) {
    return a(o) && o.every((l) => e(l));
  }
  return ti.stringArray = s, ti;
}
var Vc = {}, ZM;
function xW() {
  if (ZM) return Vc;
  ZM = 1, Object.defineProperty(Vc, "__esModule", { value: !0 }), Vc.Emitter = Vc.Event = void 0;
  const t = yW();
  var e;
  (function(i) {
    const a = { dispose() {
    } };
    i.None = function() {
      return a;
    };
  })(e || (Vc.Event = e = {}));
  class r {
    add(a, s = null, o) {
      this._callbacks || (this._callbacks = [], this._contexts = []), this._callbacks.push(a), this._contexts.push(s), Array.isArray(o) && o.push({ dispose: () => this.remove(a, s) });
    }
    remove(a, s = null) {
      if (!this._callbacks)
        return;
      let o = !1;
      for (let l = 0, u = this._callbacks.length; l < u; l++)
        if (this._callbacks[l] === a)
          if (this._contexts[l] === s) {
            this._callbacks.splice(l, 1), this._contexts.splice(l, 1);
            return;
          } else
            o = !0;
      if (o)
        throw new Error("When adding a listener with a context, you should remove it with the same context");
    }
    invoke(...a) {
      if (!this._callbacks)
        return [];
      const s = [], o = this._callbacks.slice(0), l = this._contexts.slice(0);
      for (let u = 0, h = o.length; u < h; u++)
        try {
          s.push(o[u].apply(l[u], a));
        } catch (d) {
          (0, t.default)().console.error(d);
        }
      return s;
    }
    isEmpty() {
      return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
      this._callbacks = void 0, this._contexts = void 0;
    }
  }
  class n {
    constructor(a) {
      this._options = a;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
      return this._event || (this._event = (a, s, o) => {
        this._callbacks || (this._callbacks = new r()), this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty() && this._options.onFirstListenerAdd(this), this._callbacks.add(a, s);
        const l = {
          dispose: () => {
            this._callbacks && (this._callbacks.remove(a, s), l.dispose = n._noop, this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty() && this._options.onLastListenerRemove(this));
          }
        };
        return Array.isArray(o) && o.push(l), l;
      }), this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(a) {
      this._callbacks && this._callbacks.invoke.call(this._callbacks, a);
    }
    dispose() {
      this._callbacks && (this._callbacks.dispose(), this._callbacks = void 0);
    }
  }
  return Vc.Emitter = n, n._noop = function() {
  }, Vc;
}
var QM;
function Y_e() {
  if (QM) return Gc;
  QM = 1, Object.defineProperty(Gc, "__esModule", { value: !0 }), Gc.CancellationTokenSource = Gc.CancellationToken = void 0;
  const t = yW(), e = W_e(), r = xW();
  var n;
  (function(o) {
    o.None = Object.freeze({
      isCancellationRequested: !1,
      onCancellationRequested: r.Event.None
    }), o.Cancelled = Object.freeze({
      isCancellationRequested: !0,
      onCancellationRequested: r.Event.None
    });
    function l(u) {
      const h = u;
      return h && (h === o.None || h === o.Cancelled || e.boolean(h.isCancellationRequested) && !!h.onCancellationRequested);
    }
    o.is = l;
  })(n || (Gc.CancellationToken = n = {}));
  const i = Object.freeze(function(o, l) {
    const u = (0, t.default)().timer.setTimeout(o.bind(l), 0);
    return { dispose() {
      u.dispose();
    } };
  });
  class a {
    constructor() {
      this._isCancelled = !1;
    }
    cancel() {
      this._isCancelled || (this._isCancelled = !0, this._emitter && (this._emitter.fire(void 0), this.dispose()));
    }
    get isCancellationRequested() {
      return this._isCancelled;
    }
    get onCancellationRequested() {
      return this._isCancelled ? i : (this._emitter || (this._emitter = new r.Emitter()), this._emitter.event);
    }
    dispose() {
      this._emitter && (this._emitter.dispose(), this._emitter = void 0);
    }
  }
  class s {
    get token() {
      return this._token || (this._token = new a()), this._token;
    }
    cancel() {
      this._token ? this._token.cancel() : this._token = n.Cancelled;
    }
    dispose() {
      this._token ? this._token instanceof a && this._token.dispose() : this._token = n.None;
    }
  }
  return Gc.CancellationTokenSource = s, Gc;
}
var nn = Y_e();
function X_e() {
  return new Promise((t) => {
    typeof setImmediate > "u" ? setTimeout(t, 0) : setImmediate(t);
  });
}
let nv = 0, j_e = 10;
function K_e() {
  return nv = performance.now(), new nn.CancellationTokenSource();
}
const c2 = /* @__PURE__ */ Symbol("OperationCancelled");
function fb(t) {
  return t === c2;
}
async function Ta(t) {
  if (t === nn.CancellationToken.None)
    return;
  const e = performance.now();
  if (e - nv >= j_e && (nv = e, await X_e(), nv = performance.now()), t.isCancellationRequested)
    throw c2;
}
class u7 {
  constructor() {
    this.promise = new Promise((e, r) => {
      this.resolve = (n) => (e(n), this), this.reject = (n) => (r(n), this);
    });
  }
}
class Kp {
  constructor(e, r, n, i) {
    this._uri = e, this._languageId = r, this._version = n, this._content = i, this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(e) {
    if (e) {
      const r = this.offsetAt(e.start), n = this.offsetAt(e.end);
      return this._content.substring(r, n);
    }
    return this._content;
  }
  update(e, r) {
    for (const n of e)
      if (Kp.isIncremental(n)) {
        const i = wW(n.range), a = this.offsetAt(i.start), s = this.offsetAt(i.end);
        this._content = this._content.substring(0, a) + n.text + this._content.substring(s, this._content.length);
        const o = Math.max(i.start.line, 0), l = Math.max(i.end.line, 0);
        let u = this._lineOffsets;
        const h = JM(n.text, !1, a);
        if (l - o === h.length)
          for (let f = 0, p = h.length; f < p; f++)
            u[f + o + 1] = h[f];
        else
          h.length < 1e4 ? u.splice(o + 1, l - o, ...h) : this._lineOffsets = u = u.slice(0, o + 1).concat(h, u.slice(l + 1));
        const d = n.text.length - (s - a);
        if (d !== 0)
          for (let f = o + 1 + h.length, p = u.length; f < p; f++)
            u[f] = u[f] + d;
      } else if (Kp.isFull(n))
        this._content = n.text, this._lineOffsets = void 0;
      else
        throw new Error("Unknown change event received");
    this._version = r;
  }
  getLineOffsets() {
    return this._lineOffsets === void 0 && (this._lineOffsets = JM(this._content, !0)), this._lineOffsets;
  }
  positionAt(e) {
    e = Math.max(Math.min(e, this._content.length), 0);
    const r = this.getLineOffsets();
    let n = 0, i = r.length;
    if (i === 0)
      return { line: 0, character: e };
    for (; n < i; ) {
      const s = Math.floor((n + i) / 2);
      r[s] > e ? i = s : n = s + 1;
    }
    const a = n - 1;
    return e = this.ensureBeforeEOL(e, r[a]), { line: a, character: e - r[a] };
  }
  offsetAt(e) {
    const r = this.getLineOffsets();
    if (e.line >= r.length)
      return this._content.length;
    if (e.line < 0)
      return 0;
    const n = r[e.line];
    if (e.character <= 0)
      return n;
    const i = e.line + 1 < r.length ? r[e.line + 1] : this._content.length, a = Math.min(n + e.character, i);
    return this.ensureBeforeEOL(a, n);
  }
  ensureBeforeEOL(e, r) {
    for (; e > r && bW(this._content.charCodeAt(e - 1)); )
      e--;
    return e;
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
  static isIncremental(e) {
    const r = e;
    return r != null && typeof r.text == "string" && r.range !== void 0 && (r.rangeLength === void 0 || typeof r.rangeLength == "number");
  }
  static isFull(e) {
    const r = e;
    return r != null && typeof r.text == "string" && r.range === void 0 && r.rangeLength === void 0;
  }
}
var x6;
(function(t) {
  function e(i, a, s, o) {
    return new Kp(i, a, s, o);
  }
  t.create = e;
  function r(i, a, s) {
    if (i instanceof Kp)
      return i.update(a, s), i;
    throw new Error("TextDocument.update: document must be created by TextDocument.create");
  }
  t.update = r;
  function n(i, a) {
    const s = i.getText(), o = b6(a.map(Z_e), (h, d) => {
      const f = h.range.start.line - d.range.start.line;
      return f === 0 ? h.range.start.character - d.range.start.character : f;
    });
    let l = 0;
    const u = [];
    for (const h of o) {
      const d = i.offsetAt(h.range.start);
      if (d < l)
        throw new Error("Overlapping edit");
      d > l && u.push(s.substring(l, d)), h.newText.length && u.push(h.newText), l = i.offsetAt(h.range.end);
    }
    return u.push(s.substr(l)), u.join("");
  }
  t.applyEdits = n;
})(x6 || (x6 = {}));
function b6(t, e) {
  if (t.length <= 1)
    return t;
  const r = t.length / 2 | 0, n = t.slice(0, r), i = t.slice(r);
  b6(n, e), b6(i, e);
  let a = 0, s = 0, o = 0;
  for (; a < n.length && s < i.length; )
    e(n[a], i[s]) <= 0 ? t[o++] = n[a++] : t[o++] = i[s++];
  for (; a < n.length; )
    t[o++] = n[a++];
  for (; s < i.length; )
    t[o++] = i[s++];
  return t;
}
function JM(t, e, r = 0) {
  const n = e ? [r] : [];
  for (let i = 0; i < t.length; i++) {
    const a = t.charCodeAt(i);
    bW(a) && (a === 13 && i + 1 < t.length && t.charCodeAt(i + 1) === 10 && i++, n.push(r + i + 1));
  }
  return n;
}
function bW(t) {
  return t === 13 || t === 10;
}
function wW(t) {
  const e = t.start, r = t.end;
  return e.line > r.line || e.line === r.line && e.character > r.character ? { start: r, end: e } : t;
}
function Z_e(t) {
  const e = wW(t.range);
  return e !== t.range ? { newText: t.newText, range: e } : t;
}
var TW;
(() => {
  var t = { 470: (i) => {
    function a(l) {
      if (typeof l != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(l));
    }
    function s(l, u) {
      for (var h, d = "", f = 0, p = -1, g = 0, m = 0; m <= l.length; ++m) {
        if (m < l.length) h = l.charCodeAt(m);
        else {
          if (h === 47) break;
          h = 47;
        }
        if (h === 47) {
          if (!(p === m - 1 || g === 1)) if (p !== m - 1 && g === 2) {
            if (d.length < 2 || f !== 2 || d.charCodeAt(d.length - 1) !== 46 || d.charCodeAt(d.length - 2) !== 46) {
              if (d.length > 2) {
                var v = d.lastIndexOf("/");
                if (v !== d.length - 1) {
                  v === -1 ? (d = "", f = 0) : f = (d = d.slice(0, v)).length - 1 - d.lastIndexOf("/"), p = m, g = 0;
                  continue;
                }
              } else if (d.length === 2 || d.length === 1) {
                d = "", f = 0, p = m, g = 0;
                continue;
              }
            }
            u && (d.length > 0 ? d += "/.." : d = "..", f = 2);
          } else d.length > 0 ? d += "/" + l.slice(p + 1, m) : d = l.slice(p + 1, m), f = m - p - 1;
          p = m, g = 0;
        } else h === 46 && g !== -1 ? ++g : g = -1;
      }
      return d;
    }
    var o = { resolve: function() {
      for (var l, u = "", h = !1, d = arguments.length - 1; d >= -1 && !h; d--) {
        var f;
        d >= 0 ? f = arguments[d] : (l === void 0 && (l = process.cwd()), f = l), a(f), f.length !== 0 && (u = f + "/" + u, h = f.charCodeAt(0) === 47);
      }
      return u = s(u, !h), h ? u.length > 0 ? "/" + u : "/" : u.length > 0 ? u : ".";
    }, normalize: function(l) {
      if (a(l), l.length === 0) return ".";
      var u = l.charCodeAt(0) === 47, h = l.charCodeAt(l.length - 1) === 47;
      return (l = s(l, !u)).length !== 0 || u || (l = "."), l.length > 0 && h && (l += "/"), u ? "/" + l : l;
    }, isAbsolute: function(l) {
      return a(l), l.length > 0 && l.charCodeAt(0) === 47;
    }, join: function() {
      if (arguments.length === 0) return ".";
      for (var l, u = 0; u < arguments.length; ++u) {
        var h = arguments[u];
        a(h), h.length > 0 && (l === void 0 ? l = h : l += "/" + h);
      }
      return l === void 0 ? "." : o.normalize(l);
    }, relative: function(l, u) {
      if (a(l), a(u), l === u || (l = o.resolve(l)) === (u = o.resolve(u))) return "";
      for (var h = 1; h < l.length && l.charCodeAt(h) === 47; ++h) ;
      for (var d = l.length, f = d - h, p = 1; p < u.length && u.charCodeAt(p) === 47; ++p) ;
      for (var g = u.length - p, m = f < g ? f : g, v = -1, y = 0; y <= m; ++y) {
        if (y === m) {
          if (g > m) {
            if (u.charCodeAt(p + y) === 47) return u.slice(p + y + 1);
            if (y === 0) return u.slice(p + y);
          } else f > m && (l.charCodeAt(h + y) === 47 ? v = y : y === 0 && (v = 0));
          break;
        }
        var b = l.charCodeAt(h + y);
        if (b !== u.charCodeAt(p + y)) break;
        b === 47 && (v = y);
      }
      var w = "";
      for (y = h + v + 1; y <= d; ++y) y !== d && l.charCodeAt(y) !== 47 || (w.length === 0 ? w += ".." : w += "/..");
      return w.length > 0 ? w + u.slice(p + v) : (p += v, u.charCodeAt(p) === 47 && ++p, u.slice(p));
    }, _makeLong: function(l) {
      return l;
    }, dirname: function(l) {
      if (a(l), l.length === 0) return ".";
      for (var u = l.charCodeAt(0), h = u === 47, d = -1, f = !0, p = l.length - 1; p >= 1; --p) if ((u = l.charCodeAt(p)) === 47) {
        if (!f) {
          d = p;
          break;
        }
      } else f = !1;
      return d === -1 ? h ? "/" : "." : h && d === 1 ? "//" : l.slice(0, d);
    }, basename: function(l, u) {
      if (u !== void 0 && typeof u != "string") throw new TypeError('"ext" argument must be a string');
      a(l);
      var h, d = 0, f = -1, p = !0;
      if (u !== void 0 && u.length > 0 && u.length <= l.length) {
        if (u.length === l.length && u === l) return "";
        var g = u.length - 1, m = -1;
        for (h = l.length - 1; h >= 0; --h) {
          var v = l.charCodeAt(h);
          if (v === 47) {
            if (!p) {
              d = h + 1;
              break;
            }
          } else m === -1 && (p = !1, m = h + 1), g >= 0 && (v === u.charCodeAt(g) ? --g == -1 && (f = h) : (g = -1, f = m));
        }
        return d === f ? f = m : f === -1 && (f = l.length), l.slice(d, f);
      }
      for (h = l.length - 1; h >= 0; --h) if (l.charCodeAt(h) === 47) {
        if (!p) {
          d = h + 1;
          break;
        }
      } else f === -1 && (p = !1, f = h + 1);
      return f === -1 ? "" : l.slice(d, f);
    }, extname: function(l) {
      a(l);
      for (var u = -1, h = 0, d = -1, f = !0, p = 0, g = l.length - 1; g >= 0; --g) {
        var m = l.charCodeAt(g);
        if (m !== 47) d === -1 && (f = !1, d = g + 1), m === 46 ? u === -1 ? u = g : p !== 1 && (p = 1) : u !== -1 && (p = -1);
        else if (!f) {
          h = g + 1;
          break;
        }
      }
      return u === -1 || d === -1 || p === 0 || p === 1 && u === d - 1 && u === h + 1 ? "" : l.slice(u, d);
    }, format: function(l) {
      if (l === null || typeof l != "object") throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof l);
      return (function(u, h) {
        var d = h.dir || h.root, f = h.base || (h.name || "") + (h.ext || "");
        return d ? d === h.root ? d + f : d + "/" + f : f;
      })(0, l);
    }, parse: function(l) {
      a(l);
      var u = { root: "", dir: "", base: "", ext: "", name: "" };
      if (l.length === 0) return u;
      var h, d = l.charCodeAt(0), f = d === 47;
      f ? (u.root = "/", h = 1) : h = 0;
      for (var p = -1, g = 0, m = -1, v = !0, y = l.length - 1, b = 0; y >= h; --y) if ((d = l.charCodeAt(y)) !== 47) m === -1 && (v = !1, m = y + 1), d === 46 ? p === -1 ? p = y : b !== 1 && (b = 1) : p !== -1 && (b = -1);
      else if (!v) {
        g = y + 1;
        break;
      }
      return p === -1 || m === -1 || b === 0 || b === 1 && p === m - 1 && p === g + 1 ? m !== -1 && (u.base = u.name = g === 0 && f ? l.slice(1, m) : l.slice(g, m)) : (g === 0 && f ? (u.name = l.slice(1, p), u.base = l.slice(1, m)) : (u.name = l.slice(g, p), u.base = l.slice(g, m)), u.ext = l.slice(p, m)), g > 0 ? u.dir = l.slice(0, g - 1) : f && (u.dir = "/"), u;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    o.posix = o, i.exports = o;
  } }, e = {};
  function r(i) {
    var a = e[i];
    if (a !== void 0) return a.exports;
    var s = e[i] = { exports: {} };
    return t[i](s, s.exports, r), s.exports;
  }
  r.d = (i, a) => {
    for (var s in a) r.o(a, s) && !r.o(i, s) && Object.defineProperty(i, s, { enumerable: !0, get: a[s] });
  }, r.o = (i, a) => Object.prototype.hasOwnProperty.call(i, a), r.r = (i) => {
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(i, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(i, "__esModule", { value: !0 });
  };
  var n = {};
  (() => {
    let i;
    r.r(n), r.d(n, { URI: () => f, Utils: () => R }), typeof process == "object" ? i = process.platform === "win32" : typeof navigator == "object" && (i = navigator.userAgent.indexOf("Windows") >= 0);
    const a = /^\w[\w\d+.-]*$/, s = /^\//, o = /^\/\//;
    function l(_, O) {
      if (!_.scheme && O) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${_.authority}", path: "${_.path}", query: "${_.query}", fragment: "${_.fragment}"}`);
      if (_.scheme && !a.test(_.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
      if (_.path) {
        if (_.authority) {
          if (!s.test(_.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
        } else if (o.test(_.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
    const u = "", h = "/", d = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    class f {
      static isUri(O) {
        return O instanceof f || !!O && typeof O.authority == "string" && typeof O.fragment == "string" && typeof O.path == "string" && typeof O.query == "string" && typeof O.scheme == "string" && typeof O.fsPath == "string" && typeof O.with == "function" && typeof O.toString == "function";
      }
      scheme;
      authority;
      path;
      query;
      fragment;
      constructor(O, P, S, M, N, D = !1) {
        typeof O == "object" ? (this.scheme = O.scheme || u, this.authority = O.authority || u, this.path = O.path || u, this.query = O.query || u, this.fragment = O.fragment || u) : (this.scheme = /* @__PURE__ */ (function(I, B) {
          return I || B ? I : "file";
        })(O, D), this.authority = P || u, this.path = (function(I, B) {
          switch (I) {
            case "https":
            case "http":
            case "file":
              B ? B[0] !== h && (B = h + B) : B = h;
          }
          return B;
        })(this.scheme, S || u), this.query = M || u, this.fragment = N || u, l(this, D));
      }
      get fsPath() {
        return b(this);
      }
      with(O) {
        if (!O) return this;
        let { scheme: P, authority: S, path: M, query: N, fragment: D } = O;
        return P === void 0 ? P = this.scheme : P === null && (P = u), S === void 0 ? S = this.authority : S === null && (S = u), M === void 0 ? M = this.path : M === null && (M = u), N === void 0 ? N = this.query : N === null && (N = u), D === void 0 ? D = this.fragment : D === null && (D = u), P === this.scheme && S === this.authority && M === this.path && N === this.query && D === this.fragment ? this : new g(P, S, M, N, D);
      }
      static parse(O, P = !1) {
        const S = d.exec(O);
        return S ? new g(S[2] || u, L(S[4] || u), L(S[5] || u), L(S[7] || u), L(S[9] || u), P) : new g(u, u, u, u, u);
      }
      static file(O) {
        let P = u;
        if (i && (O = O.replace(/\\/g, h)), O[0] === h && O[1] === h) {
          const S = O.indexOf(h, 2);
          S === -1 ? (P = O.substring(2), O = h) : (P = O.substring(2, S), O = O.substring(S) || h);
        }
        return new g("file", P, O, u, u);
      }
      static from(O) {
        const P = new g(O.scheme, O.authority, O.path, O.query, O.fragment);
        return l(P, !0), P;
      }
      toString(O = !1) {
        return w(this, O);
      }
      toJSON() {
        return this;
      }
      static revive(O) {
        if (O) {
          if (O instanceof f) return O;
          {
            const P = new g(O);
            return P._formatted = O.external, P._fsPath = O._sep === p ? O.fsPath : null, P;
          }
        }
        return O;
      }
    }
    const p = i ? 1 : void 0;
    class g extends f {
      _formatted = null;
      _fsPath = null;
      get fsPath() {
        return this._fsPath || (this._fsPath = b(this)), this._fsPath;
      }
      toString(O = !1) {
        return O ? w(this, !0) : (this._formatted || (this._formatted = w(this, !1)), this._formatted);
      }
      toJSON() {
        const O = { $mid: 1 };
        return this._fsPath && (O.fsPath = this._fsPath, O._sep = p), this._formatted && (O.external = this._formatted), this.path && (O.path = this.path), this.scheme && (O.scheme = this.scheme), this.authority && (O.authority = this.authority), this.query && (O.query = this.query), this.fragment && (O.fragment = this.fragment), O;
      }
    }
    const m = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
    function v(_, O, P) {
      let S, M = -1;
      for (let N = 0; N < _.length; N++) {
        const D = _.charCodeAt(N);
        if (D >= 97 && D <= 122 || D >= 65 && D <= 90 || D >= 48 && D <= 57 || D === 45 || D === 46 || D === 95 || D === 126 || O && D === 47 || P && D === 91 || P && D === 93 || P && D === 58) M !== -1 && (S += encodeURIComponent(_.substring(M, N)), M = -1), S !== void 0 && (S += _.charAt(N));
        else {
          S === void 0 && (S = _.substr(0, N));
          const I = m[D];
          I !== void 0 ? (M !== -1 && (S += encodeURIComponent(_.substring(M, N)), M = -1), S += I) : M === -1 && (M = N);
        }
      }
      return M !== -1 && (S += encodeURIComponent(_.substring(M))), S !== void 0 ? S : _;
    }
    function y(_) {
      let O;
      for (let P = 0; P < _.length; P++) {
        const S = _.charCodeAt(P);
        S === 35 || S === 63 ? (O === void 0 && (O = _.substr(0, P)), O += m[S]) : O !== void 0 && (O += _[P]);
      }
      return O !== void 0 ? O : _;
    }
    function b(_, O) {
      let P;
      return P = _.authority && _.path.length > 1 && _.scheme === "file" ? `//${_.authority}${_.path}` : _.path.charCodeAt(0) === 47 && (_.path.charCodeAt(1) >= 65 && _.path.charCodeAt(1) <= 90 || _.path.charCodeAt(1) >= 97 && _.path.charCodeAt(1) <= 122) && _.path.charCodeAt(2) === 58 ? _.path[1].toLowerCase() + _.path.substr(2) : _.path, i && (P = P.replace(/\//g, "\\")), P;
    }
    function w(_, O) {
      const P = O ? y : v;
      let S = "", { scheme: M, authority: N, path: D, query: I, fragment: B } = _;
      if (M && (S += M, S += ":"), (N || M === "file") && (S += h, S += h), N) {
        let z = N.indexOf("@");
        if (z !== -1) {
          const F = N.substr(0, z);
          N = N.substr(z + 1), z = F.lastIndexOf(":"), z === -1 ? S += P(F, !1, !1) : (S += P(F.substr(0, z), !1, !1), S += ":", S += P(F.substr(z + 1), !1, !0)), S += "@";
        }
        N = N.toLowerCase(), z = N.lastIndexOf(":"), z === -1 ? S += P(N, !1, !0) : (S += P(N.substr(0, z), !1, !0), S += N.substr(z));
      }
      if (D) {
        if (D.length >= 3 && D.charCodeAt(0) === 47 && D.charCodeAt(2) === 58) {
          const z = D.charCodeAt(1);
          z >= 65 && z <= 90 && (D = `/${String.fromCharCode(z + 32)}:${D.substr(3)}`);
        } else if (D.length >= 2 && D.charCodeAt(1) === 58) {
          const z = D.charCodeAt(0);
          z >= 65 && z <= 90 && (D = `${String.fromCharCode(z + 32)}:${D.substr(2)}`);
        }
        S += P(D, !0, !1);
      }
      return I && (S += "?", S += P(I, !1, !1)), B && (S += "#", S += O ? B : v(B, !1, !1)), S;
    }
    function T(_) {
      try {
        return decodeURIComponent(_);
      } catch {
        return _.length > 3 ? _.substr(0, 3) + T(_.substr(3)) : _;
      }
    }
    const E = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
    function L(_) {
      return _.match(E) ? _.replace(E, ((O) => T(O))) : _;
    }
    var k = r(470);
    const C = k.posix || k, A = "/";
    var R;
    (function(_) {
      _.joinPath = function(O, ...P) {
        return O.with({ path: C.join(O.path, ...P) });
      }, _.resolvePath = function(O, ...P) {
        let S = O.path, M = !1;
        S[0] !== A && (S = A + S, M = !0);
        let N = C.resolve(S, ...P);
        return M && N[0] === A && !O.authority && (N = N.substring(1)), O.with({ path: N });
      }, _.dirname = function(O) {
        if (O.path.length === 0 || O.path === A) return O;
        let P = C.dirname(O.path);
        return P.length === 1 && P.charCodeAt(0) === 46 && (P = ""), O.with({ path: P });
      }, _.basename = function(O) {
        return C.basename(O.path);
      }, _.extname = function(O) {
        return C.extname(O.path);
      };
    })(R || (R = {}));
  })(), TW = n;
})();
const { URI: Bu, Utils: Gf } = TW;
var lc;
(function(t) {
  t.basename = Gf.basename, t.dirname = Gf.dirname, t.extname = Gf.extname, t.joinPath = Gf.joinPath, t.resolvePath = Gf.resolvePath;
  function e(i, a) {
    return i?.toString() === a?.toString();
  }
  t.equals = e;
  function r(i, a) {
    const s = typeof i == "string" ? i : i.path, o = typeof a == "string" ? a : a.path, l = s.split("/").filter((p) => p.length > 0), u = o.split("/").filter((p) => p.length > 0);
    let h = 0;
    for (; h < l.length && l[h] === u[h]; h++)
      ;
    const d = "../".repeat(l.length - h), f = u.slice(h).join("/");
    return d + f;
  }
  t.relative = r;
  function n(i) {
    return Bu.parse(i.toString()).toString();
  }
  t.normalize = n;
})(lc || (lc = {}));
var Kr;
(function(t) {
  t[t.Changed = 0] = "Changed", t[t.Parsed = 1] = "Parsed", t[t.IndexedContent = 2] = "IndexedContent", t[t.ComputedScopes = 3] = "ComputedScopes", t[t.Linked = 4] = "Linked", t[t.IndexedReferences = 5] = "IndexedReferences", t[t.Validated = 6] = "Validated";
})(Kr || (Kr = {}));
class Q_e {
  constructor(e) {
    this.serviceRegistry = e.ServiceRegistry, this.textDocuments = e.workspace.TextDocuments, this.fileSystemProvider = e.workspace.FileSystemProvider;
  }
  async fromUri(e, r = nn.CancellationToken.None) {
    const n = await this.fileSystemProvider.readFile(e);
    return this.createAsync(e, n, r);
  }
  fromTextDocument(e, r, n) {
    return r = r ?? Bu.parse(e.uri), nn.CancellationToken.is(n) ? this.createAsync(r, e, n) : this.create(r, e, n);
  }
  fromString(e, r, n) {
    return nn.CancellationToken.is(n) ? this.createAsync(r, e, n) : this.create(r, e, n);
  }
  fromModel(e, r) {
    return this.create(r, { $model: e });
  }
  create(e, r, n) {
    if (typeof r == "string") {
      const i = this.parse(e, r, n);
      return this.createLangiumDocument(i, e, void 0, r);
    } else if ("$model" in r) {
      const i = { value: r.$model, parserErrors: [], lexerErrors: [] };
      return this.createLangiumDocument(i, e);
    } else {
      const i = this.parse(e, r.getText(), n);
      return this.createLangiumDocument(i, e, r);
    }
  }
  async createAsync(e, r, n) {
    if (typeof r == "string") {
      const i = await this.parseAsync(e, r, n);
      return this.createLangiumDocument(i, e, void 0, r);
    } else {
      const i = await this.parseAsync(e, r.getText(), n);
      return this.createLangiumDocument(i, e, r);
    }
  }
  /**
   * Create a LangiumDocument from a given parse result.
   *
   * A TextDocument is created on demand if it is not provided as argument here. Usually this
   * should not be necessary because the main purpose of the TextDocument is to convert between
   * text ranges and offsets, which is done solely in LSP request handling.
   *
   * With the introduction of {@link update} below this method is supposed to be mainly called
   * during workspace initialization and on addition/recognition of new files, while changes in
   * existing documents are processed via {@link update}.
   */
  createLangiumDocument(e, r, n, i) {
    let a;
    if (n)
      a = {
        parseResult: e,
        uri: r,
        state: Kr.Parsed,
        references: [],
        textDocument: n
      };
    else {
      const s = this.createTextDocumentGetter(r, i);
      a = {
        parseResult: e,
        uri: r,
        state: Kr.Parsed,
        references: [],
        get textDocument() {
          return s();
        }
      };
    }
    return e.value.$document = a, a;
  }
  async update(e, r) {
    var n, i;
    const a = (n = e.parseResult.value.$cstNode) === null || n === void 0 ? void 0 : n.root.fullText, s = (i = this.textDocuments) === null || i === void 0 ? void 0 : i.get(e.uri.toString()), o = s ? s.getText() : await this.fileSystemProvider.readFile(e.uri);
    if (s)
      Object.defineProperty(e, "textDocument", {
        value: s
      });
    else {
      const l = this.createTextDocumentGetter(e.uri, o);
      Object.defineProperty(e, "textDocument", {
        get: l
      });
    }
    return a !== o && (e.parseResult = await this.parseAsync(e.uri, o, r), e.parseResult.value.$document = e), e.state = Kr.Parsed, e;
  }
  parse(e, r, n) {
    return this.serviceRegistry.getServices(e).parser.LangiumParser.parse(r, n);
  }
  parseAsync(e, r, n) {
    return this.serviceRegistry.getServices(e).parser.AsyncParser.parse(r, n);
  }
  createTextDocumentGetter(e, r) {
    const n = this.serviceRegistry;
    let i;
    return () => i ?? (i = x6.create(e.toString(), n.getServices(e).LanguageMetaData.languageId, 0, r ?? ""));
  }
}
class J_e {
  constructor(e) {
    this.documentMap = /* @__PURE__ */ new Map(), this.langiumDocumentFactory = e.workspace.LangiumDocumentFactory, this.serviceRegistry = e.ServiceRegistry;
  }
  get all() {
    return oi(this.documentMap.values());
  }
  addDocument(e) {
    const r = e.uri.toString();
    if (this.documentMap.has(r))
      throw new Error(`A document with the URI '${r}' is already present.`);
    this.documentMap.set(r, e);
  }
  getDocument(e) {
    const r = e.toString();
    return this.documentMap.get(r);
  }
  async getOrCreateDocument(e, r) {
    let n = this.getDocument(e);
    return n || (n = await this.langiumDocumentFactory.fromUri(e, r), this.addDocument(n), n);
  }
  createDocument(e, r, n) {
    if (n)
      return this.langiumDocumentFactory.fromString(r, e, n).then((i) => (this.addDocument(i), i));
    {
      const i = this.langiumDocumentFactory.fromString(r, e);
      return this.addDocument(i), i;
    }
  }
  hasDocument(e) {
    return this.documentMap.has(e.toString());
  }
  invalidateDocument(e) {
    const r = e.toString(), n = this.documentMap.get(r);
    return n && (this.serviceRegistry.getServices(e).references.Linker.unlink(n), n.state = Kr.Changed, n.precomputedScopes = void 0, n.diagnostics = void 0), n;
  }
  deleteDocument(e) {
    const r = e.toString(), n = this.documentMap.get(r);
    return n && (n.state = Kr.Changed, this.documentMap.delete(r)), n;
  }
}
const C5 = /* @__PURE__ */ Symbol("ref_resolving");
class e9e {
  constructor(e) {
    this.reflection = e.shared.AstReflection, this.langiumDocuments = () => e.shared.workspace.LangiumDocuments, this.scopeProvider = e.references.ScopeProvider, this.astNodeLocator = e.workspace.AstNodeLocator;
  }
  async link(e, r = nn.CancellationToken.None) {
    for (const n of ad(e.parseResult.value))
      await Ta(r), MH(n).forEach((i) => this.doLink(i, e));
  }
  doLink(e, r) {
    var n;
    const i = e.reference;
    if (i._ref === void 0) {
      i._ref = C5;
      try {
        const a = this.getCandidate(e);
        if (jm(a))
          i._ref = a;
        else if (i._nodeDescription = a, this.langiumDocuments().hasDocument(a.documentUri)) {
          const s = this.loadAstNode(a);
          i._ref = s ?? this.createLinkingError(e, a);
        } else
          i._ref = void 0;
      } catch (a) {
        console.error(`An error occurred while resolving reference to '${i.$refText}':`, a);
        const s = (n = a.message) !== null && n !== void 0 ? n : String(a);
        i._ref = Object.assign(Object.assign({}, e), { message: `An error occurred while resolving reference to '${i.$refText}': ${s}` });
      }
      r.references.push(i);
    }
  }
  unlink(e) {
    for (const r of e.references)
      delete r._ref, delete r._nodeDescription;
    e.references = [];
  }
  getCandidate(e) {
    const n = this.scopeProvider.getScope(e).getElement(e.reference.$refText);
    return n ?? this.createLinkingError(e);
  }
  buildReference(e, r, n, i) {
    const a = this, s = {
      $refNode: n,
      $refText: i,
      get ref() {
        var o;
        if (Ti(this._ref))
          return this._ref;
        if (aTe(this._nodeDescription)) {
          const l = a.loadAstNode(this._nodeDescription);
          this._ref = l ?? a.createLinkingError({ reference: s, container: e, property: r }, this._nodeDescription);
        } else if (this._ref === void 0) {
          this._ref = C5;
          const l = zT(e).$document, u = a.getLinkedNode({ reference: s, container: e, property: r });
          if (u.error && l && l.state < Kr.ComputedScopes)
            return this._ref = void 0;
          this._ref = (o = u.node) !== null && o !== void 0 ? o : u.error, this._nodeDescription = u.descr, l?.references.push(this);
        } else if (this._ref === C5)
          throw new Error(`Cyclic reference resolution detected: ${a.astNodeLocator.getAstNodePath(e)}/${r} (symbol '${i}')`);
        return Ti(this._ref) ? this._ref : void 0;
      },
      get $nodeDescription() {
        return this._nodeDescription;
      },
      get error() {
        return jm(this._ref) ? this._ref : void 0;
      }
    };
    return s;
  }
  getLinkedNode(e) {
    var r;
    try {
      const n = this.getCandidate(e);
      if (jm(n))
        return { error: n };
      const i = this.loadAstNode(n);
      return i ? { node: i, descr: n } : {
        descr: n,
        error: this.createLinkingError(e, n)
      };
    } catch (n) {
      console.error(`An error occurred while resolving reference to '${e.reference.$refText}':`, n);
      const i = (r = n.message) !== null && r !== void 0 ? r : String(n);
      return {
        error: Object.assign(Object.assign({}, e), { message: `An error occurred while resolving reference to '${e.reference.$refText}': ${i}` })
      };
    }
  }
  loadAstNode(e) {
    if (e.node)
      return e.node;
    const r = this.langiumDocuments().getDocument(e.documentUri);
    if (r)
      return this.astNodeLocator.getAstNode(r.parseResult.value, e.path);
  }
  createLinkingError(e, r) {
    const n = zT(e.container).$document;
    n && n.state < Kr.ComputedScopes && console.warn(`Attempted reference resolution before document reached ComputedScopes state (${n.uri}).`);
    const i = this.reflection.getReferenceType(e);
    return Object.assign(Object.assign({}, e), { message: `Could not resolve reference to ${i} named '${e.reference.$refText}'.`, targetDescription: r });
  }
}
function t9e(t) {
  return typeof t.name == "string";
}
class r9e {
  getName(e) {
    if (t9e(e))
      return e.name;
  }
  getNameNode(e) {
    return PH(e.$cstNode, "name");
  }
}
class n9e {
  constructor(e) {
    this.nameProvider = e.references.NameProvider, this.index = e.shared.workspace.IndexManager, this.nodeLocator = e.workspace.AstNodeLocator;
  }
  findDeclaration(e) {
    if (e) {
      const r = ZTe(e), n = e.astNode;
      if (r && n) {
        const i = n[r.feature];
        if (Qs(i))
          return i.ref;
        if (Array.isArray(i)) {
          for (const a of i)
            if (Qs(a) && a.$refNode && a.$refNode.offset <= e.offset && a.$refNode.end >= e.end)
              return a.ref;
        }
      }
      if (n) {
        const i = this.nameProvider.getNameNode(n);
        if (i && (i === e || lTe(e, i)))
          return n;
      }
    }
  }
  findDeclarationNode(e) {
    const r = this.findDeclaration(e);
    if (r?.$cstNode) {
      const n = this.nameProvider.getNameNode(r);
      return n ?? r.$cstNode;
    }
  }
  findReferences(e, r) {
    const n = [];
    if (r.includeDeclaration) {
      const a = this.getReferenceToSelf(e);
      a && n.push(a);
    }
    let i = this.index.findAllReferences(e, this.nodeLocator.getAstNodePath(e));
    return r.documentUri && (i = i.filter((a) => lc.equals(a.sourceUri, r.documentUri))), n.push(...i), oi(n);
  }
  getReferenceToSelf(e) {
    const r = this.nameProvider.getNameNode(e);
    if (r) {
      const n = nc(e), i = this.nodeLocator.getAstNodePath(e);
      return {
        sourceUri: n.uri,
        sourcePath: i,
        targetUri: n.uri,
        targetPath: i,
        segment: Uy(r),
        local: !0
      };
    }
  }
}
class u2 {
  constructor(e) {
    if (this.map = /* @__PURE__ */ new Map(), e)
      for (const [r, n] of e)
        this.add(r, n);
  }
  /**
   * The total number of values in the multimap.
   */
  get size() {
    return BT.sum(oi(this.map.values()).map((e) => e.length));
  }
  /**
   * Clear all entries in the multimap.
   */
  clear() {
    this.map.clear();
  }
  /**
   * Operates differently depending on whether a `value` is given:
   *  * With a value, this method deletes the specific key / value pair from the multimap.
   *  * Without a value, all values associated with the given key are deleted.
   *
   * @returns `true` if a value existed and has been removed, or `false` if the specified
   *     key / value does not exist.
   */
  delete(e, r) {
    if (r === void 0)
      return this.map.delete(e);
    {
      const n = this.map.get(e);
      if (n) {
        const i = n.indexOf(r);
        if (i >= 0)
          return n.length === 1 ? this.map.delete(e) : n.splice(i, 1), !0;
      }
      return !1;
    }
  }
  /**
   * Returns an array of all values associated with the given key. If no value exists,
   * an empty array is returned.
   *
   * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a
   * value and `delete` to remove a value from the multimap.
   */
  get(e) {
    var r;
    return (r = this.map.get(e)) !== null && r !== void 0 ? r : [];
  }
  /**
   * Operates differently depending on whether a `value` is given:
   *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.
   *  * Without a value, this method returns `true` if the given key is present in the multimap.
   */
  has(e, r) {
    if (r === void 0)
      return this.map.has(e);
    {
      const n = this.map.get(e);
      return n ? n.indexOf(r) >= 0 : !1;
    }
  }
  /**
   * Add the given key / value pair to the multimap.
   */
  add(e, r) {
    return this.map.has(e) ? this.map.get(e).push(r) : this.map.set(e, [r]), this;
  }
  /**
   * Add the given set of key / value pairs to the multimap.
   */
  addAll(e, r) {
    return this.map.has(e) ? this.map.get(e).push(...r) : this.map.set(e, Array.from(r)), this;
  }
  /**
   * Invokes the given callback function for every key / value pair in the multimap.
   */
  forEach(e) {
    this.map.forEach((r, n) => r.forEach((i) => e(i, n, this)));
  }
  /**
   * Returns an iterator of key, value pairs for every entry in the map.
   */
  [Symbol.iterator]() {
    return this.entries().iterator();
  }
  /**
   * Returns a stream of key, value pairs for every entry in the map.
   */
  entries() {
    return oi(this.map.entries()).flatMap(([e, r]) => r.map((n) => [e, n]));
  }
  /**
   * Returns a stream of keys in the map.
   */
  keys() {
    return oi(this.map.keys());
  }
  /**
   * Returns a stream of values in the map.
   */
  values() {
    return oi(this.map.values()).flat();
  }
  /**
   * Returns a stream of key, value set pairs for every key in the map.
   */
  entriesGroupedByKey() {
    return oi(this.map.entries());
  }
}
class eN {
  get size() {
    return this.map.size;
  }
  constructor(e) {
    if (this.map = /* @__PURE__ */ new Map(), this.inverse = /* @__PURE__ */ new Map(), e)
      for (const [r, n] of e)
        this.set(r, n);
  }
  clear() {
    this.map.clear(), this.inverse.clear();
  }
  set(e, r) {
    return this.map.set(e, r), this.inverse.set(r, e), this;
  }
  get(e) {
    return this.map.get(e);
  }
  getKey(e) {
    return this.inverse.get(e);
  }
  delete(e) {
    const r = this.map.get(e);
    return r !== void 0 ? (this.map.delete(e), this.inverse.delete(r), !0) : !1;
  }
}
class i9e {
  constructor(e) {
    this.nameProvider = e.references.NameProvider, this.descriptions = e.workspace.AstNodeDescriptionProvider;
  }
  async computeExports(e, r = nn.CancellationToken.None) {
    return this.computeExportsForNode(e.parseResult.value, e, void 0, r);
  }
  /**
   * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.
   * The list of children to be considered is determined by the function parameter {@link children}.
   * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.
   *
   * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.
   * @param document The document containing the AST node to be exported.
   * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.
   * @param cancelToken Indicates when to cancel the current operation.
   * @throws `OperationCancelled` if a user action occurs during execution.
   * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.
   */
  async computeExportsForNode(e, r, n = _S, i = nn.CancellationToken.None) {
    const a = [];
    this.exportNode(e, a, r);
    for (const s of n(e))
      await Ta(i), this.exportNode(s, a, r);
    return a;
  }
  /**
   * Add a single node to the list of exports if it has a name. Override this method to change how
   * symbols are exported, e.g. by modifying their exported name.
   */
  exportNode(e, r, n) {
    const i = this.nameProvider.getName(e);
    i && r.push(this.descriptions.createDescription(e, i, n));
  }
  async computeLocalScopes(e, r = nn.CancellationToken.None) {
    const n = e.parseResult.value, i = new u2();
    for (const a of Pg(n))
      await Ta(r), this.processNode(a, e, i);
    return i;
  }
  /**
   * Process a single node during scopes computation. The default implementation makes the node visible
   * in the subtree of its container (if the node has a name). Override this method to change this,
   * e.g. by increasing the visibility to a higher level in the AST.
   */
  processNode(e, r, n) {
    const i = e.$container;
    if (i) {
      const a = this.nameProvider.getName(e);
      a && n.add(i, this.descriptions.createDescription(e, a, r));
    }
  }
}
class tN {
  constructor(e, r, n) {
    var i;
    this.elements = e, this.outerScope = r, this.caseInsensitive = (i = n?.caseInsensitive) !== null && i !== void 0 ? i : !1;
  }
  getAllElements() {
    return this.outerScope ? this.elements.concat(this.outerScope.getAllElements()) : this.elements;
  }
  getElement(e) {
    const r = this.caseInsensitive ? this.elements.find((n) => n.name.toLowerCase() === e.toLowerCase()) : this.elements.find((n) => n.name === e);
    if (r)
      return r;
    if (this.outerScope)
      return this.outerScope.getElement(e);
  }
}
class a9e {
  constructor(e, r, n) {
    var i;
    this.elements = /* @__PURE__ */ new Map(), this.caseInsensitive = (i = n?.caseInsensitive) !== null && i !== void 0 ? i : !1;
    for (const a of e) {
      const s = this.caseInsensitive ? a.name.toLowerCase() : a.name;
      this.elements.set(s, a);
    }
    this.outerScope = r;
  }
  getElement(e) {
    const r = this.caseInsensitive ? e.toLowerCase() : e, n = this.elements.get(r);
    if (n)
      return n;
    if (this.outerScope)
      return this.outerScope.getElement(e);
  }
  getAllElements() {
    let e = oi(this.elements.values());
    return this.outerScope && (e = e.concat(this.outerScope.getAllElements())), e;
  }
}
class EW {
  constructor() {
    this.toDispose = [], this.isDisposed = !1;
  }
  onDispose(e) {
    this.toDispose.push(e);
  }
  dispose() {
    this.throwIfDisposed(), this.clear(), this.isDisposed = !0, this.toDispose.forEach((e) => e.dispose());
  }
  throwIfDisposed() {
    if (this.isDisposed)
      throw new Error("This cache has already been disposed");
  }
}
class s9e extends EW {
  constructor() {
    super(...arguments), this.cache = /* @__PURE__ */ new Map();
  }
  has(e) {
    return this.throwIfDisposed(), this.cache.has(e);
  }
  set(e, r) {
    this.throwIfDisposed(), this.cache.set(e, r);
  }
  get(e, r) {
    if (this.throwIfDisposed(), this.cache.has(e))
      return this.cache.get(e);
    if (r) {
      const n = r();
      return this.cache.set(e, n), n;
    } else
      return;
  }
  delete(e) {
    return this.throwIfDisposed(), this.cache.delete(e);
  }
  clear() {
    this.throwIfDisposed(), this.cache.clear();
  }
}
class o9e extends EW {
  constructor(e) {
    super(), this.cache = /* @__PURE__ */ new Map(), this.converter = e ?? ((r) => r);
  }
  has(e, r) {
    return this.throwIfDisposed(), this.cacheForContext(e).has(r);
  }
  set(e, r, n) {
    this.throwIfDisposed(), this.cacheForContext(e).set(r, n);
  }
  get(e, r, n) {
    this.throwIfDisposed();
    const i = this.cacheForContext(e);
    if (i.has(r))
      return i.get(r);
    if (n) {
      const a = n();
      return i.set(r, a), a;
    } else
      return;
  }
  delete(e, r) {
    return this.throwIfDisposed(), this.cacheForContext(e).delete(r);
  }
  clear(e) {
    if (this.throwIfDisposed(), e) {
      const r = this.converter(e);
      this.cache.delete(r);
    } else
      this.cache.clear();
  }
  cacheForContext(e) {
    const r = this.converter(e);
    let n = this.cache.get(r);
    return n || (n = /* @__PURE__ */ new Map(), this.cache.set(r, n)), n;
  }
}
class l9e extends s9e {
  /**
   * Creates a new workspace cache.
   *
   * @param sharedServices Service container instance to hook into document lifecycle events.
   * @param state Optional document state on which the cache should evict.
   * If not provided, the cache will evict on `DocumentBuilder#onUpdate`.
   * *Deleted* documents are considered in both cases.
   */
  constructor(e, r) {
    super(), r ? (this.toDispose.push(e.workspace.DocumentBuilder.onBuildPhase(r, () => {
      this.clear();
    })), this.toDispose.push(e.workspace.DocumentBuilder.onUpdate((n, i) => {
      i.length > 0 && this.clear();
    }))) : this.toDispose.push(e.workspace.DocumentBuilder.onUpdate(() => {
      this.clear();
    }));
  }
}
class c9e {
  constructor(e) {
    this.reflection = e.shared.AstReflection, this.nameProvider = e.references.NameProvider, this.descriptions = e.workspace.AstNodeDescriptionProvider, this.indexManager = e.shared.workspace.IndexManager, this.globalScopeCache = new l9e(e.shared);
  }
  getScope(e) {
    const r = [], n = this.reflection.getReferenceType(e), i = nc(e.container).precomputedScopes;
    if (i) {
      let s = e.container;
      do {
        const o = i.get(s);
        o.length > 0 && r.push(oi(o).filter((l) => this.reflection.isSubtype(l.type, n))), s = s.$container;
      } while (s);
    }
    let a = this.getGlobalScope(n, e);
    for (let s = r.length - 1; s >= 0; s--)
      a = this.createScope(r[s], a);
    return a;
  }
  /**
   * Create a scope for the given collection of AST node descriptions.
   */
  createScope(e, r, n) {
    return new tN(oi(e), r, n);
  }
  /**
   * Create a scope for the given collection of AST nodes, which need to be transformed into respective
   * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.
   */
  createScopeForNodes(e, r, n) {
    const i = oi(e).map((a) => {
      const s = this.nameProvider.getName(a);
      if (s)
        return this.descriptions.createDescription(a, s);
    }).nonNullable();
    return new tN(i, r, n);
  }
  /**
   * Create a global scope filtered for the given reference type.
   */
  getGlobalScope(e, r) {
    return this.globalScopeCache.get(e, () => new a9e(this.indexManager.allElements(e)));
  }
}
function u9e(t) {
  return typeof t.$comment == "string";
}
function rN(t) {
  return typeof t == "object" && !!t && ("$ref" in t || "$error" in t);
}
class h9e {
  constructor(e) {
    this.ignoreProperties = /* @__PURE__ */ new Set(["$container", "$containerProperty", "$containerIndex", "$document", "$cstNode"]), this.langiumDocuments = e.shared.workspace.LangiumDocuments, this.astNodeLocator = e.workspace.AstNodeLocator, this.nameProvider = e.references.NameProvider, this.commentProvider = e.documentation.CommentProvider;
  }
  serialize(e, r) {
    const n = r ?? {}, i = r?.replacer, a = (o, l) => this.replacer(o, l, n), s = i ? (o, l) => i(o, l, a) : a;
    try {
      return this.currentDocument = nc(e), JSON.stringify(e, s, r?.space);
    } finally {
      this.currentDocument = void 0;
    }
  }
  deserialize(e, r) {
    const n = r ?? {}, i = JSON.parse(e);
    return this.linkNode(i, i, n), i;
  }
  replacer(e, r, { refText: n, sourceText: i, textRegions: a, comments: s, uriConverter: o }) {
    var l, u, h, d;
    if (!this.ignoreProperties.has(e))
      if (Qs(r)) {
        const f = r.ref, p = n ? r.$refText : void 0;
        if (f) {
          const g = nc(f);
          let m = "";
          this.currentDocument && this.currentDocument !== g && (o ? m = o(g.uri, r) : m = g.uri.toString());
          const v = this.astNodeLocator.getAstNodePath(f);
          return {
            $ref: `${m}#${v}`,
            $refText: p
          };
        } else
          return {
            $error: (u = (l = r.error) === null || l === void 0 ? void 0 : l.message) !== null && u !== void 0 ? u : "Could not resolve reference",
            $refText: p
          };
      } else if (Ti(r)) {
        let f;
        if (a && (f = this.addAstNodeRegionWithAssignmentsTo(Object.assign({}, r)), (!e || r.$document) && f?.$textRegion && (f.$textRegion.documentURI = (h = this.currentDocument) === null || h === void 0 ? void 0 : h.uri.toString())), i && !e && (f ?? (f = Object.assign({}, r)), f.$sourceText = (d = r.$cstNode) === null || d === void 0 ? void 0 : d.text), s) {
          f ?? (f = Object.assign({}, r));
          const p = this.commentProvider.getComment(r);
          p && (f.$comment = p.replace(/\r/g, ""));
        }
        return f ?? r;
      } else
        return r;
  }
  addAstNodeRegionWithAssignmentsTo(e) {
    const r = (n) => ({
      offset: n.offset,
      end: n.end,
      length: n.length,
      range: n.range
    });
    if (e.$cstNode) {
      const n = e.$textRegion = r(e.$cstNode), i = n.assignments = {};
      return Object.keys(e).filter((a) => !a.startsWith("$")).forEach((a) => {
        const s = XTe(e.$cstNode, a).map(r);
        s.length !== 0 && (i[a] = s);
      }), e;
    }
  }
  linkNode(e, r, n, i, a, s) {
    for (const [l, u] of Object.entries(e))
      if (Array.isArray(u))
        for (let h = 0; h < u.length; h++) {
          const d = u[h];
          rN(d) ? u[h] = this.reviveReference(e, l, r, d, n) : Ti(d) && this.linkNode(d, r, n, e, l, h);
        }
      else rN(u) ? e[l] = this.reviveReference(e, l, r, u, n) : Ti(u) && this.linkNode(u, r, n, e, l);
    const o = e;
    o.$container = i, o.$containerProperty = a, o.$containerIndex = s;
  }
  reviveReference(e, r, n, i, a) {
    let s = i.$refText, o = i.$error;
    if (i.$ref) {
      const l = this.getRefNode(n, i.$ref, a.uriConverter);
      if (Ti(l))
        return s || (s = this.nameProvider.getName(l)), {
          $refText: s ?? "",
          ref: l
        };
      o = l;
    }
    if (o) {
      const l = {
        $refText: s ?? ""
      };
      return l.error = {
        container: e,
        property: r,
        message: o,
        reference: l
      }, l;
    } else
      return;
  }
  getRefNode(e, r, n) {
    try {
      const i = r.indexOf("#");
      if (i === 0) {
        const l = this.astNodeLocator.getAstNode(e, r.substring(1));
        return l || "Could not resolve path: " + r;
      }
      if (i < 0) {
        const l = n ? n(r) : Bu.parse(r), u = this.langiumDocuments.getDocument(l);
        return u ? u.parseResult.value : "Could not find document for URI: " + r;
      }
      const a = n ? n(r.substring(0, i)) : Bu.parse(r.substring(0, i)), s = this.langiumDocuments.getDocument(a);
      if (!s)
        return "Could not find document for URI: " + r;
      if (i === r.length - 1)
        return s.parseResult.value;
      const o = this.astNodeLocator.getAstNode(s.parseResult.value, r.substring(i + 1));
      return o || "Could not resolve URI: " + r;
    } catch (i) {
      return String(i);
    }
  }
}
class d9e {
  /**
   * @deprecated Use the new `fileExtensionMap` (or `languageIdMap`) property instead.
   */
  get map() {
    return this.fileExtensionMap;
  }
  constructor(e) {
    this.languageIdMap = /* @__PURE__ */ new Map(), this.fileExtensionMap = /* @__PURE__ */ new Map(), this.textDocuments = e?.workspace.TextDocuments;
  }
  register(e) {
    const r = e.LanguageMetaData;
    for (const n of r.fileExtensions)
      this.fileExtensionMap.has(n) && console.warn(`The file extension ${n} is used by multiple languages. It is now assigned to '${r.languageId}'.`), this.fileExtensionMap.set(n, e);
    this.languageIdMap.set(r.languageId, e), this.languageIdMap.size === 1 ? this.singleton = e : this.singleton = void 0;
  }
  getServices(e) {
    var r, n;
    if (this.singleton !== void 0)
      return this.singleton;
    if (this.languageIdMap.size === 0)
      throw new Error("The service registry is empty. Use `register` to register the services of a language.");
    const i = (n = (r = this.textDocuments) === null || r === void 0 ? void 0 : r.get(e)) === null || n === void 0 ? void 0 : n.languageId;
    if (i !== void 0) {
      const o = this.languageIdMap.get(i);
      if (o)
        return o;
    }
    const a = lc.extname(e), s = this.fileExtensionMap.get(a);
    if (!s)
      throw i ? new Error(`The service registry contains no services for the extension '${a}' for language '${i}'.`) : new Error(`The service registry contains no services for the extension '${a}'.`);
    return s;
  }
  hasServices(e) {
    try {
      return this.getServices(e), !0;
    } catch {
      return !1;
    }
  }
  get all() {
    return Array.from(this.languageIdMap.values());
  }
}
function D0(t) {
  return { code: t };
}
var h2;
(function(t) {
  t.all = ["fast", "slow", "built-in"];
})(h2 || (h2 = {}));
class f9e {
  constructor(e) {
    this.entries = new u2(), this.entriesBefore = [], this.entriesAfter = [], this.reflection = e.shared.AstReflection;
  }
  /**
   * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)
   * or an array of validation checks.
   *
   * @param checksRecord Set of validation checks to register.
   * @param category Optional category for the validation checks (defaults to `'fast'`).
   * @param thisObj Optional object to be used as `this` when calling the validation check functions.
   */
  register(e, r = this, n = "fast") {
    if (n === "built-in")
      throw new Error("The 'built-in' category is reserved for lexer, parser, and linker errors.");
    for (const [i, a] of Object.entries(e)) {
      const s = a;
      if (Array.isArray(s))
        for (const o of s) {
          const l = {
            check: this.wrapValidationException(o, r),
            category: n
          };
          this.addEntry(i, l);
        }
      else if (typeof s == "function") {
        const o = {
          check: this.wrapValidationException(s, r),
          category: n
        };
        this.addEntry(i, o);
      } else
        Og();
    }
  }
  wrapValidationException(e, r) {
    return async (n, i, a) => {
      await this.handleException(() => e.call(r, n, i, a), "An error occurred during validation", i, n);
    };
  }
  async handleException(e, r, n, i) {
    try {
      await e();
    } catch (a) {
      if (fb(a))
        throw a;
      console.error(`${r}:`, a), a instanceof Error && a.stack && console.error(a.stack);
      const s = a instanceof Error ? a.message : String(a);
      n("error", `${r}: ${s}`, { node: i });
    }
  }
  addEntry(e, r) {
    if (e === "AstNode") {
      this.entries.add("AstNode", r);
      return;
    }
    for (const n of this.reflection.getAllSubTypes(e))
      this.entries.add(n, r);
  }
  getChecks(e, r) {
    let n = oi(this.entries.get(e)).concat(this.entries.get("AstNode"));
    return r && (n = n.filter((i) => r.includes(i.category))), n.map((i) => i.check);
  }
  /**
   * Register logic which will be executed once before validating all the nodes of an AST/Langium document.
   * This helps to prepare or initialize some information which are required or reusable for the following checks on the AstNodes.
   *
   * As an example, for validating unique fully-qualified names of nodes in the AST,
   * here the map for mapping names to nodes could be established.
   * During the usual checks on the nodes, they are put into this map with their name.
   *
   * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.
   * Therefore it is recommended to clear stored information
   * _before_ validating an AST to validate each AST unaffected from other ASTs
   * AND _after_ validating the AST to free memory by information which are no longer used.
   *
   * @param checkBefore a set-up function which will be called once before actually validating an AST
   * @param thisObj Optional object to be used as `this` when calling the validation check functions.
   */
  registerBeforeDocument(e, r = this) {
    this.entriesBefore.push(this.wrapPreparationException(e, "An error occurred during set-up of the validation", r));
  }
  /**
   * Register logic which will be executed once after validating all the nodes of an AST/Langium document.
   * This helps to finally evaluate information which are collected during the checks on the AstNodes.
   *
   * As an example, for validating unique fully-qualified names of nodes in the AST,
   * here the map with all the collected nodes and their names is checked
   * and validation hints are created for all nodes with the same name.
   *
   * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.
   * Therefore it is recommended to clear stored information
   * _before_ validating an AST to validate each AST unaffected from other ASTs
   * AND _after_ validating the AST to free memory by information which are no longer used.
   *
   * @param checkBefore a set-up function which will be called once before actually validating an AST
   * @param thisObj Optional object to be used as `this` when calling the validation check functions.
   */
  registerAfterDocument(e, r = this) {
    this.entriesAfter.push(this.wrapPreparationException(e, "An error occurred during tear-down of the validation", r));
  }
  wrapPreparationException(e, r, n) {
    return async (i, a, s, o) => {
      await this.handleException(() => e.call(n, i, a, s, o), r, a, i);
    };
  }
  get checksBefore() {
    return this.entriesBefore;
  }
  get checksAfter() {
    return this.entriesAfter;
  }
}
class p9e {
  constructor(e) {
    this.validationRegistry = e.validation.ValidationRegistry, this.metadata = e.LanguageMetaData;
  }
  async validateDocument(e, r = {}, n = nn.CancellationToken.None) {
    const i = e.parseResult, a = [];
    if (await Ta(n), (!r.categories || r.categories.includes("built-in")) && (this.processLexingErrors(i, a, r), r.stopAfterLexingErrors && a.some((s) => {
      var o;
      return ((o = s.data) === null || o === void 0 ? void 0 : o.code) === ms.LexingError;
    }) || (this.processParsingErrors(i, a, r), r.stopAfterParsingErrors && a.some((s) => {
      var o;
      return ((o = s.data) === null || o === void 0 ? void 0 : o.code) === ms.ParsingError;
    })) || (this.processLinkingErrors(e, a, r), r.stopAfterLinkingErrors && a.some((s) => {
      var o;
      return ((o = s.data) === null || o === void 0 ? void 0 : o.code) === ms.LinkingError;
    }))))
      return a;
    try {
      a.push(...await this.validateAst(i.value, r, n));
    } catch (s) {
      if (fb(s))
        throw s;
      console.error("An error occurred during validation:", s);
    }
    return await Ta(n), a;
  }
  processLexingErrors(e, r, n) {
    var i, a, s;
    const o = [...e.lexerErrors, ...(a = (i = e.lexerReport) === null || i === void 0 ? void 0 : i.diagnostics) !== null && a !== void 0 ? a : []];
    for (const l of o) {
      const u = (s = l.severity) !== null && s !== void 0 ? s : "error", h = {
        severity: A5(u),
        range: {
          start: {
            line: l.line - 1,
            character: l.column - 1
          },
          end: {
            line: l.line - 1,
            character: l.column + l.length - 1
          }
        },
        message: l.message,
        data: m9e(u),
        source: this.getSource()
      };
      r.push(h);
    }
  }
  processParsingErrors(e, r, n) {
    for (const i of e.parserErrors) {
      let a;
      if (isNaN(i.token.startOffset)) {
        if ("previousToken" in i) {
          const s = i.previousToken;
          if (isNaN(s.startOffset)) {
            const o = { line: 0, character: 0 };
            a = { start: o, end: o };
          } else {
            const o = { line: s.endLine - 1, character: s.endColumn };
            a = { start: o, end: o };
          }
        }
      } else
        a = $T(i.token);
      if (a) {
        const s = {
          severity: A5("error"),
          range: a,
          message: i.message,
          data: D0(ms.ParsingError),
          source: this.getSource()
        };
        r.push(s);
      }
    }
  }
  processLinkingErrors(e, r, n) {
    for (const i of e.references) {
      const a = i.error;
      if (a) {
        const s = {
          node: a.container,
          property: a.property,
          index: a.index,
          data: {
            code: ms.LinkingError,
            containerType: a.container.$type,
            property: a.property,
            refText: a.reference.$refText
          }
        };
        r.push(this.toDiagnostic("error", a.message, s));
      }
    }
  }
  async validateAst(e, r, n = nn.CancellationToken.None) {
    const i = [], a = (s, o, l) => {
      i.push(this.toDiagnostic(s, o, l));
    };
    return await this.validateAstBefore(e, r, a, n), await this.validateAstNodes(e, r, a, n), await this.validateAstAfter(e, r, a, n), i;
  }
  async validateAstBefore(e, r, n, i = nn.CancellationToken.None) {
    var a;
    const s = this.validationRegistry.checksBefore;
    for (const o of s)
      await Ta(i), await o(e, n, (a = r.categories) !== null && a !== void 0 ? a : [], i);
  }
  async validateAstNodes(e, r, n, i = nn.CancellationToken.None) {
    await Promise.all(ad(e).map(async (a) => {
      await Ta(i);
      const s = this.validationRegistry.getChecks(a.$type, r.categories);
      for (const o of s)
        await o(a, n, i);
    }));
  }
  async validateAstAfter(e, r, n, i = nn.CancellationToken.None) {
    var a;
    const s = this.validationRegistry.checksAfter;
    for (const o of s)
      await Ta(i), await o(e, n, (a = r.categories) !== null && a !== void 0 ? a : [], i);
  }
  toDiagnostic(e, r, n) {
    return {
      message: r,
      range: g9e(n),
      severity: A5(e),
      code: n.code,
      codeDescription: n.codeDescription,
      tags: n.tags,
      relatedInformation: n.relatedInformation,
      data: n.data,
      source: this.getSource()
    };
  }
  getSource() {
    return this.metadata.languageId;
  }
}
function g9e(t) {
  if (t.range)
    return t.range;
  let e;
  return typeof t.property == "string" ? e = PH(t.node.$cstNode, t.property, t.index) : typeof t.keyword == "string" && (e = jTe(t.node.$cstNode, t.keyword, t.index)), e ?? (e = t.node.$cstNode), e ? e.range : {
    start: { line: 0, character: 0 },
    end: { line: 0, character: 0 }
  };
}
function A5(t) {
  switch (t) {
    case "error":
      return 1;
    case "warning":
      return 2;
    case "info":
      return 3;
    case "hint":
      return 4;
    default:
      throw new Error("Invalid diagnostic severity: " + t);
  }
}
function m9e(t) {
  switch (t) {
    case "error":
      return D0(ms.LexingError);
    case "warning":
      return D0(ms.LexingWarning);
    case "info":
      return D0(ms.LexingInfo);
    case "hint":
      return D0(ms.LexingHint);
    default:
      throw new Error("Invalid diagnostic severity: " + t);
  }
}
var ms;
(function(t) {
  t.LexingError = "lexing-error", t.LexingWarning = "lexing-warning", t.LexingInfo = "lexing-info", t.LexingHint = "lexing-hint", t.ParsingError = "parsing-error", t.LinkingError = "linking-error";
})(ms || (ms = {}));
class v9e {
  constructor(e) {
    this.astNodeLocator = e.workspace.AstNodeLocator, this.nameProvider = e.references.NameProvider;
  }
  createDescription(e, r, n) {
    const i = n ?? nc(e);
    r ?? (r = this.nameProvider.getName(e));
    const a = this.astNodeLocator.getAstNodePath(e);
    if (!r)
      throw new Error(`Node at path ${a} has no name.`);
    let s;
    const o = () => {
      var l;
      return s ?? (s = Uy((l = this.nameProvider.getNameNode(e)) !== null && l !== void 0 ? l : e.$cstNode));
    };
    return {
      node: e,
      name: r,
      get nameSegment() {
        return o();
      },
      selectionSegment: Uy(e.$cstNode),
      type: e.$type,
      documentUri: i.uri,
      path: a
    };
  }
}
class y9e {
  constructor(e) {
    this.nodeLocator = e.workspace.AstNodeLocator;
  }
  async createDescriptions(e, r = nn.CancellationToken.None) {
    const n = [], i = e.parseResult.value;
    for (const a of ad(i))
      await Ta(r), MH(a).filter((s) => !jm(s)).forEach((s) => {
        const o = this.createDescription(s);
        o && n.push(o);
      });
    return n;
  }
  createDescription(e) {
    const r = e.reference.$nodeDescription, n = e.reference.$refNode;
    if (!r || !n)
      return;
    const i = nc(e.container).uri;
    return {
      sourceUri: i,
      sourcePath: this.nodeLocator.getAstNodePath(e.container),
      targetUri: r.documentUri,
      targetPath: r.path,
      segment: Uy(n),
      local: lc.equals(r.documentUri, i)
    };
  }
}
class x9e {
  constructor() {
    this.segmentSeparator = "/", this.indexSeparator = "@";
  }
  getAstNodePath(e) {
    if (e.$container) {
      const r = this.getAstNodePath(e.$container), n = this.getPathSegment(e);
      return r + this.segmentSeparator + n;
    }
    return "";
  }
  getPathSegment({ $containerProperty: e, $containerIndex: r }) {
    if (!e)
      throw new Error("Missing '$containerProperty' in AST node.");
    return r !== void 0 ? e + this.indexSeparator + r : e;
  }
  getAstNode(e, r) {
    return r.split(this.segmentSeparator).reduce((i, a) => {
      if (!i || a.length === 0)
        return i;
      const s = a.indexOf(this.indexSeparator);
      if (s > 0) {
        const o = a.substring(0, s), l = parseInt(a.substring(s + 1)), u = i[o];
        return u?.[l];
      }
      return i[a];
    }, e);
  }
}
var b9e = xW();
class w9e {
  constructor(e) {
    this._ready = new u7(), this.settings = {}, this.workspaceConfig = !1, this.onConfigurationSectionUpdateEmitter = new b9e.Emitter(), this.serviceRegistry = e.ServiceRegistry;
  }
  get ready() {
    return this._ready.promise;
  }
  initialize(e) {
    var r, n;
    this.workspaceConfig = (n = (r = e.capabilities.workspace) === null || r === void 0 ? void 0 : r.configuration) !== null && n !== void 0 ? n : !1;
  }
  async initialized(e) {
    if (this.workspaceConfig) {
      if (e.register) {
        const r = this.serviceRegistry.all;
        e.register({
          // Listen to configuration changes for all languages
          section: r.map((n) => this.toSectionName(n.LanguageMetaData.languageId))
        });
      }
      if (e.fetchConfiguration) {
        const r = this.serviceRegistry.all.map((i) => ({
          // Fetch the configuration changes for all languages
          section: this.toSectionName(i.LanguageMetaData.languageId)
        })), n = await e.fetchConfiguration(r);
        r.forEach((i, a) => {
          this.updateSectionConfiguration(i.section, n[a]);
        });
      }
    }
    this._ready.resolve();
  }
  /**
   *  Updates the cached configurations using the `change` notification parameters.
   *
   * @param change The parameters of a change configuration notification.
   * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`
   */
  updateConfiguration(e) {
    e.settings && Object.keys(e.settings).forEach((r) => {
      const n = e.settings[r];
      this.updateSectionConfiguration(r, n), this.onConfigurationSectionUpdateEmitter.fire({ section: r, configuration: n });
    });
  }
  updateSectionConfiguration(e, r) {
    this.settings[e] = r;
  }
  /**
  * Returns a configuration value stored for the given language.
  *
  * @param language The language id
  * @param configuration Configuration name
  */
  async getConfiguration(e, r) {
    await this.ready;
    const n = this.toSectionName(e);
    if (this.settings[n])
      return this.settings[n][r];
  }
  toSectionName(e) {
    return `${e}`;
  }
  get onConfigurationSectionUpdate() {
    return this.onConfigurationSectionUpdateEmitter.event;
  }
}
var ip;
(function(t) {
  function e(r) {
    return {
      dispose: async () => await r()
    };
  }
  t.create = e;
})(ip || (ip = {}));
class T9e {
  constructor(e) {
    this.updateBuildOptions = {
      // Default: run only the built-in validation checks and those in the _fast_ category (includes those without category)
      validation: {
        categories: ["built-in", "fast"]
      }
    }, this.updateListeners = [], this.buildPhaseListeners = new u2(), this.documentPhaseListeners = new u2(), this.buildState = /* @__PURE__ */ new Map(), this.documentBuildWaiters = /* @__PURE__ */ new Map(), this.currentState = Kr.Changed, this.langiumDocuments = e.workspace.LangiumDocuments, this.langiumDocumentFactory = e.workspace.LangiumDocumentFactory, this.textDocuments = e.workspace.TextDocuments, this.indexManager = e.workspace.IndexManager, this.serviceRegistry = e.ServiceRegistry;
  }
  async build(e, r = {}, n = nn.CancellationToken.None) {
    var i, a;
    for (const s of e) {
      const o = s.uri.toString();
      if (s.state === Kr.Validated) {
        if (typeof r.validation == "boolean" && r.validation)
          s.state = Kr.IndexedReferences, s.diagnostics = void 0, this.buildState.delete(o);
        else if (typeof r.validation == "object") {
          const l = this.buildState.get(o), u = (i = l?.result) === null || i === void 0 ? void 0 : i.validationChecks;
          if (u) {
            const d = ((a = r.validation.categories) !== null && a !== void 0 ? a : h2.all).filter((f) => !u.includes(f));
            d.length > 0 && (this.buildState.set(o, {
              completed: !1,
              options: {
                validation: Object.assign(Object.assign({}, r.validation), { categories: d })
              },
              result: l.result
            }), s.state = Kr.IndexedReferences);
          }
        }
      } else
        this.buildState.delete(o);
    }
    this.currentState = Kr.Changed, await this.emitUpdate(e.map((s) => s.uri), []), await this.buildDocuments(e, r, n);
  }
  async update(e, r, n = nn.CancellationToken.None) {
    this.currentState = Kr.Changed;
    for (const s of r)
      this.langiumDocuments.deleteDocument(s), this.buildState.delete(s.toString()), this.indexManager.remove(s);
    for (const s of e) {
      if (!this.langiumDocuments.invalidateDocument(s)) {
        const l = this.langiumDocumentFactory.fromModel({ $type: "INVALID" }, s);
        l.state = Kr.Changed, this.langiumDocuments.addDocument(l);
      }
      this.buildState.delete(s.toString());
    }
    const i = oi(e).concat(r).map((s) => s.toString()).toSet();
    this.langiumDocuments.all.filter((s) => !i.has(s.uri.toString()) && this.shouldRelink(s, i)).forEach((s) => {
      this.serviceRegistry.getServices(s.uri).references.Linker.unlink(s), s.state = Math.min(s.state, Kr.ComputedScopes), s.diagnostics = void 0;
    }), await this.emitUpdate(e, r), await Ta(n);
    const a = this.sortDocuments(this.langiumDocuments.all.filter((s) => {
      var o;
      return s.state < Kr.Linked || !(!((o = this.buildState.get(s.uri.toString())) === null || o === void 0) && o.completed);
    }).toArray());
    await this.buildDocuments(a, this.updateBuildOptions, n);
  }
  async emitUpdate(e, r) {
    await Promise.all(this.updateListeners.map((n) => n(e, r)));
  }
  /**
   * Sort the given documents by priority. By default, documents with an open text document are prioritized.
   * This is useful to ensure that visible documents show their diagnostics before all other documents.
   *
   * This improves the responsiveness in large workspaces as users usually don't care about diagnostics
   * in files that are currently not opened in the editor.
   */
  sortDocuments(e) {
    let r = 0, n = e.length - 1;
    for (; r < n; ) {
      for (; r < e.length && this.hasTextDocument(e[r]); )
        r++;
      for (; n >= 0 && !this.hasTextDocument(e[n]); )
        n--;
      r < n && ([e[r], e[n]] = [e[n], e[r]]);
    }
    return e;
  }
  hasTextDocument(e) {
    var r;
    return !!(!((r = this.textDocuments) === null || r === void 0) && r.get(e.uri));
  }
  /**
   * Check whether the given document should be relinked after changes were found in the given URIs.
   */
  shouldRelink(e, r) {
    return e.references.some((n) => n.error !== void 0) ? !0 : this.indexManager.isAffected(e, r);
  }
  onUpdate(e) {
    return this.updateListeners.push(e), ip.create(() => {
      const r = this.updateListeners.indexOf(e);
      r >= 0 && this.updateListeners.splice(r, 1);
    });
  }
  /**
   * Build the given documents by stepping through all build phases. If a document's state indicates
   * that a certain build phase is already done, the phase is skipped for that document.
   *
   * @param documents The documents to build.
   * @param options the {@link BuildOptions} to use.
   * @param cancelToken A cancellation token that can be used to cancel the build.
   * @returns A promise that resolves when the build is done.
   */
  async buildDocuments(e, r, n) {
    this.prepareBuild(e, r), await this.runCancelable(e, Kr.Parsed, n, (a) => this.langiumDocumentFactory.update(a, n)), await this.runCancelable(e, Kr.IndexedContent, n, (a) => this.indexManager.updateContent(a, n)), await this.runCancelable(e, Kr.ComputedScopes, n, async (a) => {
      const s = this.serviceRegistry.getServices(a.uri).references.ScopeComputation;
      a.precomputedScopes = await s.computeLocalScopes(a, n);
    }), await this.runCancelable(e, Kr.Linked, n, (a) => this.serviceRegistry.getServices(a.uri).references.Linker.link(a, n)), await this.runCancelable(e, Kr.IndexedReferences, n, (a) => this.indexManager.updateReferences(a, n));
    const i = e.filter((a) => this.shouldValidate(a));
    await this.runCancelable(i, Kr.Validated, n, (a) => this.validate(a, n));
    for (const a of e) {
      const s = this.buildState.get(a.uri.toString());
      s && (s.completed = !0);
    }
  }
  /**
   * Runs prior to beginning the build process to update the {@link DocumentBuildState} for each document
   *
   * @param documents collection of documents to be built
   * @param options the {@link BuildOptions} to use
   */
  prepareBuild(e, r) {
    for (const n of e) {
      const i = n.uri.toString(), a = this.buildState.get(i);
      (!a || a.completed) && this.buildState.set(i, {
        completed: !1,
        options: r,
        result: a?.result
      });
    }
  }
  /**
   * Runs a cancelable operation on a set of documents to bring them to a specified {@link DocumentState}.
   *
   * @param documents The array of documents to process.
   * @param targetState The target {@link DocumentState} to bring the documents to.
   * @param cancelToken A token that can be used to cancel the operation.
   * @param callback A function to be called for each document.
   * @returns A promise that resolves when all documents have been processed or the operation is canceled.
   * @throws Will throw `OperationCancelled` if the operation is canceled via a `CancellationToken`.
   */
  async runCancelable(e, r, n, i) {
    const a = e.filter((o) => o.state < r);
    for (const o of a)
      await Ta(n), await i(o), o.state = r, await this.notifyDocumentPhase(o, r, n);
    const s = e.filter((o) => o.state === r);
    await this.notifyBuildPhase(s, r, n), this.currentState = r;
  }
  onBuildPhase(e, r) {
    return this.buildPhaseListeners.add(e, r), ip.create(() => {
      this.buildPhaseListeners.delete(e, r);
    });
  }
  onDocumentPhase(e, r) {
    return this.documentPhaseListeners.add(e, r), ip.create(() => {
      this.documentPhaseListeners.delete(e, r);
    });
  }
  waitUntil(e, r, n) {
    let i;
    if (r && "path" in r ? i = r : n = r, n ?? (n = nn.CancellationToken.None), i) {
      const a = this.langiumDocuments.getDocument(i);
      if (a && a.state > e)
        return Promise.resolve(i);
    }
    return this.currentState >= e ? Promise.resolve(void 0) : n.isCancellationRequested ? Promise.reject(c2) : new Promise((a, s) => {
      const o = this.onBuildPhase(e, () => {
        if (o.dispose(), l.dispose(), i) {
          const u = this.langiumDocuments.getDocument(i);
          a(u?.uri);
        } else
          a(void 0);
      }), l = n.onCancellationRequested(() => {
        o.dispose(), l.dispose(), s(c2);
      });
    });
  }
  async notifyDocumentPhase(e, r, n) {
    const a = this.documentPhaseListeners.get(r).slice();
    for (const s of a)
      try {
        await s(e, n);
      } catch (o) {
        if (!fb(o))
          throw o;
      }
  }
  async notifyBuildPhase(e, r, n) {
    if (e.length === 0)
      return;
    const a = this.buildPhaseListeners.get(r).slice();
    for (const s of a)
      await Ta(n), await s(e, n);
  }
  /**
   * Determine whether the given document should be validated during a build. The default
   * implementation checks the `validation` property of the build options. If it's set to `true`
   * or a `ValidationOptions` object, the document is included in the validation phase.
   */
  shouldValidate(e) {
    return !!this.getBuildOptions(e).validation;
  }
  /**
   * Run validation checks on the given document and store the resulting diagnostics in the document.
   * If the document already contains diagnostics, the new ones are added to the list.
   */
  async validate(e, r) {
    var n, i;
    const a = this.serviceRegistry.getServices(e.uri).validation.DocumentValidator, s = this.getBuildOptions(e).validation, o = typeof s == "object" ? s : void 0, l = await a.validateDocument(e, o, r);
    e.diagnostics ? e.diagnostics.push(...l) : e.diagnostics = l;
    const u = this.buildState.get(e.uri.toString());
    if (u) {
      (n = u.result) !== null && n !== void 0 || (u.result = {});
      const h = (i = o?.categories) !== null && i !== void 0 ? i : h2.all;
      u.result.validationChecks ? u.result.validationChecks.push(...h) : u.result.validationChecks = [...h];
    }
  }
  getBuildOptions(e) {
    var r, n;
    return (n = (r = this.buildState.get(e.uri.toString())) === null || r === void 0 ? void 0 : r.options) !== null && n !== void 0 ? n : {};
  }
}
class E9e {
  constructor(e) {
    this.symbolIndex = /* @__PURE__ */ new Map(), this.symbolByTypeIndex = new o9e(), this.referenceIndex = /* @__PURE__ */ new Map(), this.documents = e.workspace.LangiumDocuments, this.serviceRegistry = e.ServiceRegistry, this.astReflection = e.AstReflection;
  }
  findAllReferences(e, r) {
    const n = nc(e).uri, i = [];
    return this.referenceIndex.forEach((a) => {
      a.forEach((s) => {
        lc.equals(s.targetUri, n) && s.targetPath === r && i.push(s);
      });
    }), oi(i);
  }
  allElements(e, r) {
    let n = oi(this.symbolIndex.keys());
    return r && (n = n.filter((i) => !r || r.has(i))), n.map((i) => this.getFileDescriptions(i, e)).flat();
  }
  getFileDescriptions(e, r) {
    var n;
    return r ? this.symbolByTypeIndex.get(e, r, () => {
      var a;
      return ((a = this.symbolIndex.get(e)) !== null && a !== void 0 ? a : []).filter((o) => this.astReflection.isSubtype(o.type, r));
    }) : (n = this.symbolIndex.get(e)) !== null && n !== void 0 ? n : [];
  }
  remove(e) {
    const r = e.toString();
    this.symbolIndex.delete(r), this.symbolByTypeIndex.clear(r), this.referenceIndex.delete(r);
  }
  async updateContent(e, r = nn.CancellationToken.None) {
    const i = await this.serviceRegistry.getServices(e.uri).references.ScopeComputation.computeExports(e, r), a = e.uri.toString();
    this.symbolIndex.set(a, i), this.symbolByTypeIndex.clear(a);
  }
  async updateReferences(e, r = nn.CancellationToken.None) {
    const i = await this.serviceRegistry.getServices(e.uri).workspace.ReferenceDescriptionProvider.createDescriptions(e, r);
    this.referenceIndex.set(e.uri.toString(), i);
  }
  isAffected(e, r) {
    const n = this.referenceIndex.get(e.uri.toString());
    return n ? n.some((i) => !i.local && r.has(i.targetUri.toString())) : !1;
  }
}
class k9e {
  constructor(e) {
    this.initialBuildOptions = {}, this._ready = new u7(), this.serviceRegistry = e.ServiceRegistry, this.langiumDocuments = e.workspace.LangiumDocuments, this.documentBuilder = e.workspace.DocumentBuilder, this.fileSystemProvider = e.workspace.FileSystemProvider, this.mutex = e.workspace.WorkspaceLock;
  }
  get ready() {
    return this._ready.promise;
  }
  get workspaceFolders() {
    return this.folders;
  }
  initialize(e) {
    var r;
    this.folders = (r = e.workspaceFolders) !== null && r !== void 0 ? r : void 0;
  }
  initialized(e) {
    return this.mutex.write((r) => {
      var n;
      return this.initializeWorkspace((n = this.folders) !== null && n !== void 0 ? n : [], r);
    });
  }
  async initializeWorkspace(e, r = nn.CancellationToken.None) {
    const n = await this.performStartup(e);
    await Ta(r), await this.documentBuilder.build(n, this.initialBuildOptions, r);
  }
  /**
   * Performs the uninterruptable startup sequence of the workspace manager.
   * This methods loads all documents in the workspace and other documents and returns them.
   */
  async performStartup(e) {
    const r = this.serviceRegistry.all.flatMap((a) => a.LanguageMetaData.fileExtensions), n = [], i = (a) => {
      n.push(a), this.langiumDocuments.hasDocument(a.uri) || this.langiumDocuments.addDocument(a);
    };
    return await this.loadAdditionalDocuments(e, i), await Promise.all(e.map((a) => [a, this.getRootFolder(a)]).map(async (a) => this.traverseFolder(...a, r, i))), this._ready.resolve(), n;
  }
  /**
   * Load all additional documents that shall be visible in the context of the given workspace
   * folders and add them to the collector. This can be used to include built-in libraries of
   * your language, which can be either loaded from provided files or constructed in memory.
   */
  loadAdditionalDocuments(e, r) {
    return Promise.resolve();
  }
  /**
   * Determine the root folder of the source documents in the given workspace folder.
   * The default implementation returns the URI of the workspace folder, but you can override
   * this to return a subfolder like `src` instead.
   */
  getRootFolder(e) {
    return Bu.parse(e.uri);
  }
  /**
   * Traverse the file system folder identified by the given URI and its subfolders. All
   * contained files that match the file extensions are added to the collector.
   */
  async traverseFolder(e, r, n, i) {
    const a = await this.fileSystemProvider.readDirectory(r);
    await Promise.all(a.map(async (s) => {
      if (this.includeEntry(e, s, n)) {
        if (s.isDirectory)
          await this.traverseFolder(e, s.uri, n, i);
        else if (s.isFile) {
          const o = await this.langiumDocuments.getOrCreateDocument(s.uri);
          i(o);
        }
      }
    }));
  }
  /**
   * Determine whether the given folder entry shall be included while indexing the workspace.
   */
  includeEntry(e, r, n) {
    const i = lc.basename(r.uri);
    if (i.startsWith("."))
      return !1;
    if (r.isDirectory)
      return i !== "node_modules" && i !== "out";
    if (r.isFile) {
      const a = lc.extname(r.uri);
      return n.includes(a);
    }
    return !1;
  }
}
class S9e {
  buildUnexpectedCharactersMessage(e, r, n, i, a) {
    return jT.buildUnexpectedCharactersMessage(e, r, n, i, a);
  }
  buildUnableToPopLexerModeMessage(e) {
    return jT.buildUnableToPopLexerModeMessage(e);
  }
}
const C9e = { mode: "full" };
class A9e {
  constructor(e) {
    this.errorMessageProvider = e.parser.LexerErrorMessageProvider, this.tokenBuilder = e.parser.TokenBuilder;
    const r = this.tokenBuilder.buildTokens(e.Grammar, {
      caseInsensitive: e.LanguageMetaData.caseInsensitive
    });
    this.tokenTypes = this.toTokenTypeDictionary(r);
    const n = nN(r) ? Object.values(r) : r, i = e.LanguageMetaData.mode === "production";
    this.chevrotainLexer = new la(n, {
      positionTracking: "full",
      skipValidations: i,
      errorMessageProvider: this.errorMessageProvider
    });
  }
  get definition() {
    return this.tokenTypes;
  }
  tokenize(e, r = C9e) {
    var n, i, a;
    const s = this.chevrotainLexer.tokenize(e);
    return {
      tokens: s.tokens,
      errors: s.errors,
      hidden: (n = s.groups.hidden) !== null && n !== void 0 ? n : [],
      report: (a = (i = this.tokenBuilder).flushLexingReport) === null || a === void 0 ? void 0 : a.call(i, e)
    };
  }
  toTokenTypeDictionary(e) {
    if (nN(e))
      return e;
    const r = kW(e) ? Object.values(e.modes).flat() : e, n = {};
    return r.forEach((i) => n[i.name] = i), n;
  }
}
function _9e(t) {
  return Array.isArray(t) && (t.length === 0 || "name" in t[0]);
}
function kW(t) {
  return t && "modes" in t && "defaultMode" in t;
}
function nN(t) {
  return !_9e(t) && !kW(t);
}
function L9e(t, e, r) {
  let n, i;
  typeof t == "string" ? (i = e, n = r) : (i = t.range.start, n = e), i || (i = Sr.create(0, 0));
  const a = SW(t), s = h7(n), o = N9e({
    lines: a,
    position: i,
    options: s
  });
  return B9e({
    index: 0,
    tokens: o,
    position: i
  });
}
function R9e(t, e) {
  const r = h7(e), n = SW(t);
  if (n.length === 0)
    return !1;
  const i = n[0], a = n[n.length - 1], s = r.start, o = r.end;
  return !!s?.exec(i) && !!o?.exec(a);
}
function SW(t) {
  let e = "";
  return typeof t == "string" ? e = t : e = t.text, e.split(PTe);
}
const iN = /\s*(@([\p{L}][\p{L}\p{N}]*)?)/uy, M9e = /\{(@[\p{L}][\p{L}\p{N}]*)(\s*)([^\r\n}]+)?\}/gu;
function N9e(t) {
  var e, r, n;
  const i = [];
  let a = t.position.line, s = t.position.character;
  for (let o = 0; o < t.lines.length; o++) {
    const l = o === 0, u = o === t.lines.length - 1;
    let h = t.lines[o], d = 0;
    if (l && t.options.start) {
      const p = (e = t.options.start) === null || e === void 0 ? void 0 : e.exec(h);
      p && (d = p.index + p[0].length);
    } else {
      const p = (r = t.options.line) === null || r === void 0 ? void 0 : r.exec(h);
      p && (d = p.index + p[0].length);
    }
    if (u) {
      const p = (n = t.options.end) === null || n === void 0 ? void 0 : n.exec(h);
      p && (h = h.substring(0, p.index));
    }
    if (h = h.substring(0, P9e(h)), w6(h, d) >= h.length) {
      if (i.length > 0) {
        const p = Sr.create(a, s);
        i.push({
          type: "break",
          content: "",
          range: fr.create(p, p)
        });
      }
    } else {
      iN.lastIndex = d;
      const p = iN.exec(h);
      if (p) {
        const g = p[0], m = p[1], v = Sr.create(a, s + d), y = Sr.create(a, s + d + g.length);
        i.push({
          type: "tag",
          content: m,
          range: fr.create(v, y)
        }), d += g.length, d = w6(h, d);
      }
      if (d < h.length) {
        const g = h.substring(d), m = Array.from(g.matchAll(M9e));
        i.push(...I9e(m, g, a, s + d));
      }
    }
    a++, s = 0;
  }
  return i.length > 0 && i[i.length - 1].type === "break" ? i.slice(0, -1) : i;
}
function I9e(t, e, r, n) {
  const i = [];
  if (t.length === 0) {
    const a = Sr.create(r, n), s = Sr.create(r, n + e.length);
    i.push({
      type: "text",
      content: e,
      range: fr.create(a, s)
    });
  } else {
    let a = 0;
    for (const o of t) {
      const l = o.index, u = e.substring(a, l);
      u.length > 0 && i.push({
        type: "text",
        content: e.substring(a, l),
        range: fr.create(Sr.create(r, a + n), Sr.create(r, l + n))
      });
      let h = u.length + 1;
      const d = o[1];
      if (i.push({
        type: "inline-tag",
        content: d,
        range: fr.create(Sr.create(r, a + h + n), Sr.create(r, a + h + d.length + n))
      }), h += d.length, o.length === 4) {
        h += o[2].length;
        const f = o[3];
        i.push({
          type: "text",
          content: f,
          range: fr.create(Sr.create(r, a + h + n), Sr.create(r, a + h + f.length + n))
        });
      } else
        i.push({
          type: "text",
          content: "",
          range: fr.create(Sr.create(r, a + h + n), Sr.create(r, a + h + n))
        });
      a = l + o[0].length;
    }
    const s = e.substring(a);
    s.length > 0 && i.push({
      type: "text",
      content: s,
      range: fr.create(Sr.create(r, a + n), Sr.create(r, a + n + s.length))
    });
  }
  return i;
}
const D9e = /\S/, O9e = /\s*$/;
function w6(t, e) {
  const r = t.substring(e).match(D9e);
  return r ? e + r.index : t.length;
}
function P9e(t) {
  const e = t.match(O9e);
  if (e && typeof e.index == "number")
    return e.index;
}
function B9e(t) {
  var e, r, n, i;
  const a = Sr.create(t.position.line, t.position.character);
  if (t.tokens.length === 0)
    return new aN([], fr.create(a, a));
  const s = [];
  for (; t.index < t.tokens.length; ) {
    const u = F9e(t, s[s.length - 1]);
    u && s.push(u);
  }
  const o = (r = (e = s[0]) === null || e === void 0 ? void 0 : e.range.start) !== null && r !== void 0 ? r : a, l = (i = (n = s[s.length - 1]) === null || n === void 0 ? void 0 : n.range.end) !== null && i !== void 0 ? i : a;
  return new aN(s, fr.create(o, l));
}
function F9e(t, e) {
  const r = t.tokens[t.index];
  if (r.type === "tag")
    return AW(t, !1);
  if (r.type === "text" || r.type === "inline-tag")
    return CW(t);
  $9e(r, e), t.index++;
}
function $9e(t, e) {
  if (e) {
    const r = new LW("", t.range);
    "inlines" in e ? e.inlines.push(r) : e.content.inlines.push(r);
  }
}
function CW(t) {
  let e = t.tokens[t.index];
  const r = e;
  let n = e;
  const i = [];
  for (; e && e.type !== "break" && e.type !== "tag"; )
    i.push(z9e(t)), n = e, e = t.tokens[t.index];
  return new T6(i, fr.create(r.range.start, n.range.end));
}
function z9e(t) {
  return t.tokens[t.index].type === "inline-tag" ? AW(t, !0) : _W(t);
}
function AW(t, e) {
  const r = t.tokens[t.index++], n = r.content.substring(1), i = t.tokens[t.index];
  if (i?.type === "text")
    if (e) {
      const a = _W(t);
      return new L5(n, new T6([a], a.range), e, fr.create(r.range.start, a.range.end));
    } else {
      const a = CW(t);
      return new L5(n, a, e, fr.create(r.range.start, a.range.end));
    }
  else {
    const a = r.range;
    return new L5(n, new T6([], a), e, a);
  }
}
function _W(t) {
  const e = t.tokens[t.index++];
  return new LW(e.content, e.range);
}
function h7(t) {
  if (!t)
    return h7({
      start: "/**",
      end: "*/",
      line: "*"
    });
  const { start: e, end: r, line: n } = t;
  return {
    start: _5(e, !0),
    end: _5(r, !1),
    line: _5(n, !0)
  };
}
function _5(t, e) {
  if (typeof t == "string" || typeof t == "object") {
    const r = typeof t == "string" ? Yx(t) : t.source;
    return e ? new RegExp(`^\\s*${r}`) : new RegExp(`\\s*${r}\\s*$`);
  } else
    return t;
}
class aN {
  constructor(e, r) {
    this.elements = e, this.range = r;
  }
  getTag(e) {
    return this.getAllTags().find((r) => r.name === e);
  }
  getTags(e) {
    return this.getAllTags().filter((r) => r.name === e);
  }
  getAllTags() {
    return this.elements.filter((e) => "name" in e);
  }
  toString() {
    let e = "";
    for (const r of this.elements)
      if (e.length === 0)
        e = r.toString();
      else {
        const n = r.toString();
        e += sN(e) + n;
      }
    return e.trim();
  }
  toMarkdown(e) {
    let r = "";
    for (const n of this.elements)
      if (r.length === 0)
        r = n.toMarkdown(e);
      else {
        const i = n.toMarkdown(e);
        r += sN(r) + i;
      }
    return r.trim();
  }
}
class L5 {
  constructor(e, r, n, i) {
    this.name = e, this.content = r, this.inline = n, this.range = i;
  }
  toString() {
    let e = `@${this.name}`;
    const r = this.content.toString();
    return this.content.inlines.length === 1 ? e = `${e} ${r}` : this.content.inlines.length > 1 && (e = `${e}
${r}`), this.inline ? `{${e}}` : e;
  }
  toMarkdown(e) {
    var r, n;
    return (n = (r = e?.renderTag) === null || r === void 0 ? void 0 : r.call(e, this)) !== null && n !== void 0 ? n : this.toMarkdownDefault(e);
  }
  toMarkdownDefault(e) {
    const r = this.content.toMarkdown(e);
    if (this.inline) {
      const a = G9e(this.name, r, e ?? {});
      if (typeof a == "string")
        return a;
    }
    let n = "";
    e?.tag === "italic" || e?.tag === void 0 ? n = "*" : e?.tag === "bold" ? n = "**" : e?.tag === "bold-italic" && (n = "***");
    let i = `${n}@${this.name}${n}`;
    return this.content.inlines.length === 1 ? i = `${i}  ${r}` : this.content.inlines.length > 1 && (i = `${i}
${r}`), this.inline ? `{${i}}` : i;
  }
}
function G9e(t, e, r) {
  var n, i;
  if (t === "linkplain" || t === "linkcode" || t === "link") {
    const a = e.indexOf(" ");
    let s = e;
    if (a > 0) {
      const l = w6(e, a);
      s = e.substring(l), e = e.substring(0, a);
    }
    return (t === "linkcode" || t === "link" && r.link === "code") && (s = `\`${s}\``), (i = (n = r.renderLink) === null || n === void 0 ? void 0 : n.call(r, e, s)) !== null && i !== void 0 ? i : V9e(e, s);
  }
}
function V9e(t, e) {
  try {
    return Bu.parse(t, !0), `[${e}](${t})`;
  } catch {
    return t;
  }
}
class T6 {
  constructor(e, r) {
    this.inlines = e, this.range = r;
  }
  toString() {
    let e = "";
    for (let r = 0; r < this.inlines.length; r++) {
      const n = this.inlines[r], i = this.inlines[r + 1];
      e += n.toString(), i && i.range.start.line > n.range.start.line && (e += `
`);
    }
    return e;
  }
  toMarkdown(e) {
    let r = "";
    for (let n = 0; n < this.inlines.length; n++) {
      const i = this.inlines[n], a = this.inlines[n + 1];
      r += i.toMarkdown(e), a && a.range.start.line > i.range.start.line && (r += `
`);
    }
    return r;
  }
}
class LW {
  constructor(e, r) {
    this.text = e, this.range = r;
  }
  toString() {
    return this.text;
  }
  toMarkdown() {
    return this.text;
  }
}
function sN(t) {
  return t.endsWith(`
`) ? `
` : `

`;
}
class U9e {
  constructor(e) {
    this.indexManager = e.shared.workspace.IndexManager, this.commentProvider = e.documentation.CommentProvider;
  }
  getDocumentation(e) {
    const r = this.commentProvider.getComment(e);
    if (r && R9e(r))
      return L9e(r).toMarkdown({
        renderLink: (i, a) => this.documentationLinkRenderer(e, i, a),
        renderTag: (i) => this.documentationTagRenderer(e, i)
      });
  }
  documentationLinkRenderer(e, r, n) {
    var i;
    const a = (i = this.findNameInPrecomputedScopes(e, r)) !== null && i !== void 0 ? i : this.findNameInGlobalScope(e, r);
    if (a && a.nameSegment) {
      const s = a.nameSegment.range.start.line + 1, o = a.nameSegment.range.start.character + 1, l = a.documentUri.with({ fragment: `L${s},${o}` });
      return `[${n}](${l.toString()})`;
    } else
      return;
  }
  documentationTagRenderer(e, r) {
  }
  findNameInPrecomputedScopes(e, r) {
    const i = nc(e).precomputedScopes;
    if (!i)
      return;
    let a = e;
    do {
      const o = i.get(a).find((l) => l.name === r);
      if (o)
        return o;
      a = a.$container;
    } while (a);
  }
  findNameInGlobalScope(e, r) {
    return this.indexManager.allElements().find((i) => i.name === r);
  }
}
class H9e {
  constructor(e) {
    this.grammarConfig = () => e.parser.GrammarConfig;
  }
  getComment(e) {
    var r;
    return u9e(e) ? e.$comment : (r = dTe(e.$cstNode, this.grammarConfig().multilineCommentRules)) === null || r === void 0 ? void 0 : r.text;
  }
}
class q9e {
  constructor(e) {
    this.syncParser = e.parser.LangiumParser;
  }
  parse(e, r) {
    return Promise.resolve(this.syncParser.parse(e));
  }
}
class W9e {
  constructor() {
    this.previousTokenSource = new nn.CancellationTokenSource(), this.writeQueue = [], this.readQueue = [], this.done = !0;
  }
  write(e) {
    this.cancelWrite();
    const r = K_e();
    return this.previousTokenSource = r, this.enqueue(this.writeQueue, e, r.token);
  }
  read(e) {
    return this.enqueue(this.readQueue, e);
  }
  enqueue(e, r, n = nn.CancellationToken.None) {
    const i = new u7(), a = {
      action: r,
      deferred: i,
      cancellationToken: n
    };
    return e.push(a), this.performNextOperation(), i.promise;
  }
  async performNextOperation() {
    if (!this.done)
      return;
    const e = [];
    if (this.writeQueue.length > 0)
      e.push(this.writeQueue.shift());
    else if (this.readQueue.length > 0)
      e.push(...this.readQueue.splice(0, this.readQueue.length));
    else
      return;
    this.done = !1, await Promise.all(e.map(async ({ action: r, deferred: n, cancellationToken: i }) => {
      try {
        const a = await Promise.resolve().then(() => r(i));
        n.resolve(a);
      } catch (a) {
        fb(a) ? n.resolve(void 0) : n.reject(a);
      }
    })), this.done = !0, this.performNextOperation();
  }
  cancelWrite() {
    this.previousTokenSource.cancel();
  }
}
class Y9e {
  constructor(e) {
    this.grammarElementIdMap = new eN(), this.tokenTypeIdMap = new eN(), this.grammar = e.Grammar, this.lexer = e.parser.Lexer, this.linker = e.references.Linker;
  }
  dehydrate(e) {
    return {
      lexerErrors: e.lexerErrors,
      lexerReport: e.lexerReport ? this.dehydrateLexerReport(e.lexerReport) : void 0,
      // We need to create shallow copies of the errors
      // The original errors inherit from the `Error` class, which is not transferable across worker threads
      parserErrors: e.parserErrors.map((r) => Object.assign(Object.assign({}, r), { message: r.message })),
      value: this.dehydrateAstNode(e.value, this.createDehyrationContext(e.value))
    };
  }
  dehydrateLexerReport(e) {
    return e;
  }
  createDehyrationContext(e) {
    const r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
    for (const i of ad(e))
      r.set(i, {});
    if (e.$cstNode)
      for (const i of FT(e.$cstNode))
        n.set(i, {});
    return {
      astNodes: r,
      cstNodes: n
    };
  }
  dehydrateAstNode(e, r) {
    const n = r.astNodes.get(e);
    n.$type = e.$type, n.$containerIndex = e.$containerIndex, n.$containerProperty = e.$containerProperty, e.$cstNode !== void 0 && (n.$cstNode = this.dehydrateCstNode(e.$cstNode, r));
    for (const [i, a] of Object.entries(e))
      if (!i.startsWith("$"))
        if (Array.isArray(a)) {
          const s = [];
          n[i] = s;
          for (const o of a)
            Ti(o) ? s.push(this.dehydrateAstNode(o, r)) : Qs(o) ? s.push(this.dehydrateReference(o, r)) : s.push(o);
        } else Ti(a) ? n[i] = this.dehydrateAstNode(a, r) : Qs(a) ? n[i] = this.dehydrateReference(a, r) : a !== void 0 && (n[i] = a);
    return n;
  }
  dehydrateReference(e, r) {
    const n = {};
    return n.$refText = e.$refText, e.$refNode && (n.$refNode = r.cstNodes.get(e.$refNode)), n;
  }
  dehydrateCstNode(e, r) {
    const n = r.cstNodes.get(e);
    return EH(e) ? n.fullText = e.fullText : n.grammarSource = this.getGrammarElementId(e.grammarSource), n.hidden = e.hidden, n.astNode = r.astNodes.get(e.astNode), Hp(e) ? n.content = e.content.map((i) => this.dehydrateCstNode(i, r)) : TH(e) && (n.tokenType = e.tokenType.name, n.offset = e.offset, n.length = e.length, n.startLine = e.range.start.line, n.startColumn = e.range.start.character, n.endLine = e.range.end.line, n.endColumn = e.range.end.character), n;
  }
  hydrate(e) {
    const r = e.value, n = this.createHydrationContext(r);
    return "$cstNode" in r && this.hydrateCstNode(r.$cstNode, n), {
      lexerErrors: e.lexerErrors,
      lexerReport: e.lexerReport,
      parserErrors: e.parserErrors,
      value: this.hydrateAstNode(r, n)
    };
  }
  createHydrationContext(e) {
    const r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
    for (const a of ad(e))
      r.set(a, {});
    let i;
    if (e.$cstNode)
      for (const a of FT(e.$cstNode)) {
        let s;
        "fullText" in a ? (s = new lW(a.fullText), i = s) : "content" in a ? s = new l7() : "tokenType" in a && (s = this.hydrateCstLeafNode(a)), s && (n.set(a, s), s.root = i);
      }
    return {
      astNodes: r,
      cstNodes: n
    };
  }
  hydrateAstNode(e, r) {
    const n = r.astNodes.get(e);
    n.$type = e.$type, n.$containerIndex = e.$containerIndex, n.$containerProperty = e.$containerProperty, e.$cstNode && (n.$cstNode = r.cstNodes.get(e.$cstNode));
    for (const [i, a] of Object.entries(e))
      if (!i.startsWith("$"))
        if (Array.isArray(a)) {
          const s = [];
          n[i] = s;
          for (const o of a)
            Ti(o) ? s.push(this.setParent(this.hydrateAstNode(o, r), n)) : Qs(o) ? s.push(this.hydrateReference(o, n, i, r)) : s.push(o);
        } else Ti(a) ? n[i] = this.setParent(this.hydrateAstNode(a, r), n) : Qs(a) ? n[i] = this.hydrateReference(a, n, i, r) : a !== void 0 && (n[i] = a);
    return n;
  }
  setParent(e, r) {
    return e.$container = r, e;
  }
  hydrateReference(e, r, n, i) {
    return this.linker.buildReference(r, n, i.cstNodes.get(e.$refNode), e.$refText);
  }
  hydrateCstNode(e, r, n = 0) {
    const i = r.cstNodes.get(e);
    if (typeof e.grammarSource == "number" && (i.grammarSource = this.getGrammarElement(e.grammarSource)), i.astNode = r.astNodes.get(e.astNode), Hp(i))
      for (const a of e.content) {
        const s = this.hydrateCstNode(a, r, n++);
        i.content.push(s);
      }
    return i;
  }
  hydrateCstLeafNode(e) {
    const r = this.getTokenType(e.tokenType), n = e.offset, i = e.length, a = e.startLine, s = e.startColumn, o = e.endLine, l = e.endColumn, u = e.hidden;
    return new m6(n, i, {
      start: {
        line: a,
        character: s
      },
      end: {
        line: o,
        character: l
      }
    }, r, u);
  }
  getTokenType(e) {
    return this.lexer.definition[e];
  }
  getGrammarElementId(e) {
    if (e)
      return this.grammarElementIdMap.size === 0 && this.createGrammarElementIdMap(), this.grammarElementIdMap.get(e);
  }
  getGrammarElement(e) {
    return this.grammarElementIdMap.size === 0 && this.createGrammarElementIdMap(), this.grammarElementIdMap.getKey(e);
  }
  createGrammarElementIdMap() {
    let e = 0;
    for (const r of ad(this.grammar))
      pTe(r) && this.grammarElementIdMap.set(r, e++);
  }
}
function Sc(t) {
  return {
    documentation: {
      CommentProvider: (e) => new H9e(e),
      DocumentationProvider: (e) => new U9e(e)
    },
    parser: {
      AsyncParser: (e) => new q9e(e),
      GrammarConfig: (e) => a6e(e),
      LangiumParser: (e) => H_e(e),
      CompletionParser: (e) => U_e(e),
      ValueConverter: () => new vW(),
      TokenBuilder: () => new mW(),
      Lexer: (e) => new A9e(e),
      ParserErrorMessageProvider: () => new hW(),
      LexerErrorMessageProvider: () => new S9e()
    },
    workspace: {
      AstNodeLocator: () => new x9e(),
      AstNodeDescriptionProvider: (e) => new v9e(e),
      ReferenceDescriptionProvider: (e) => new y9e(e)
    },
    references: {
      Linker: (e) => new e9e(e),
      NameProvider: () => new r9e(),
      ScopeProvider: (e) => new c9e(e),
      ScopeComputation: (e) => new i9e(e),
      References: (e) => new n9e(e)
    },
    serializer: {
      Hydrator: (e) => new Y9e(e),
      JsonSerializer: (e) => new h9e(e)
    },
    validation: {
      DocumentValidator: (e) => new p9e(e),
      ValidationRegistry: (e) => new f9e(e)
    },
    shared: () => t.shared
  };
}
function Cc(t) {
  return {
    ServiceRegistry: (e) => new d9e(e),
    workspace: {
      LangiumDocuments: (e) => new J_e(e),
      LangiumDocumentFactory: (e) => new Q_e(e),
      DocumentBuilder: (e) => new T9e(e),
      IndexManager: (e) => new E9e(e),
      WorkspaceManager: (e) => new k9e(e),
      FileSystemProvider: (e) => t.fileSystemProvider(e),
      WorkspaceLock: () => new W9e(),
      ConfigurationProvider: (e) => new w9e(e)
    }
  };
}
var oN;
(function(t) {
  t.merge = (e, r) => d2(d2({}, e), r);
})(oN || (oN = {}));
function Ai(t, e, r, n, i, a, s, o, l) {
  const u = [t, e, r, n, i, a, s, o, l].reduce(d2, {});
  return RW(u);
}
const X9e = /* @__PURE__ */ Symbol("isProxy");
function RW(t, e) {
  const r = new Proxy({}, {
    deleteProperty: () => !1,
    set: () => {
      throw new Error("Cannot set property on injected service container");
    },
    get: (n, i) => i === X9e ? !0 : cN(n, i, t, e || r),
    getOwnPropertyDescriptor: (n, i) => (cN(n, i, t, e || r), Object.getOwnPropertyDescriptor(n, i)),
    // used by for..in
    has: (n, i) => i in t,
    // used by ..in..
    ownKeys: () => [...Object.getOwnPropertyNames(t)]
    // used by for..in
  });
  return r;
}
const lN = /* @__PURE__ */ Symbol();
function cN(t, e, r, n) {
  if (e in t) {
    if (t[e] instanceof Error)
      throw new Error("Construction failure. Please make sure that your dependencies are constructable.", { cause: t[e] });
    if (t[e] === lN)
      throw new Error('Cycle detected. Please make "' + String(e) + '" lazy. Visit https://langium.org/docs/reference/configuration-services/#resolving-cyclic-dependencies');
    return t[e];
  } else if (e in r) {
    const i = r[e];
    t[e] = lN;
    try {
      t[e] = typeof i == "function" ? i(n) : RW(i, n);
    } catch (a) {
      throw t[e] = a instanceof Error ? a : void 0, a;
    }
    return t[e];
  } else
    return;
}
function d2(t, e) {
  if (e) {
    for (const [r, n] of Object.entries(e))
      if (n !== void 0) {
        const i = t[r];
        i !== null && n !== null && typeof i == "object" && typeof n == "object" ? t[r] = d2(i, n) : t[r] = n;
      }
  }
  return t;
}
class j9e {
  readFile() {
    throw new Error("No file system is available.");
  }
  async readDirectory() {
    return [];
  }
}
const Ac = {
  fileSystemProvider: () => new j9e()
}, K9e = {
  Grammar: () => {
  },
  LanguageMetaData: () => ({
    caseInsensitive: !1,
    fileExtensions: [".langium"],
    languageId: "langium"
  })
}, Z9e = {
  AstReflection: () => new RH()
};
function Q9e() {
  const t = Ai(Cc(Ac), Z9e), e = Ai(Sc({ shared: t }), K9e);
  return t.ServiceRegistry.register(e), e;
}
function ch(t) {
  var e;
  const r = Q9e(), n = r.serializer.JsonSerializer.deserialize(t);
  return r.shared.workspace.LangiumDocumentFactory.fromModel(n, Bu.parse(`memory://${(e = n.name) !== null && e !== void 0 ? e : "grammar"}.langium`)), n;
}
var J9e = Object.defineProperty, gt = (t, e) => J9e(t, "name", { value: e, configurable: !0 }), uN = "Statement", iv = "Architecture";
function eLe(t) {
  return Ns.isInstance(t, iv);
}
gt(eLe, "isArchitecture");
var tm = "Axis", O0 = "Branch";
function tLe(t) {
  return Ns.isInstance(t, O0);
}
gt(tLe, "isBranch");
var rm = "Checkout", nm = "CherryPicking", R5 = "ClassDefStatement", P0 = "Commit";
function rLe(t) {
  return Ns.isInstance(t, P0);
}
gt(rLe, "isCommit");
var M5 = "Curve", N5 = "Edge", I5 = "Entry", B0 = "GitGraph";
function nLe(t) {
  return Ns.isInstance(t, B0);
}
gt(nLe, "isGitGraph");
var D5 = "Group", av = "Info";
function iLe(t) {
  return Ns.isInstance(t, av);
}
gt(iLe, "isInfo");
var im = "Item", O5 = "Junction", F0 = "Merge";
function aLe(t) {
  return Ns.isInstance(t, F0);
}
gt(aLe, "isMerge");
var P5 = "Option", sv = "Packet";
function sLe(t) {
  return Ns.isInstance(t, sv);
}
gt(sLe, "isPacket");
var ov = "PacketBlock";
function oLe(t) {
  return Ns.isInstance(t, ov);
}
gt(oLe, "isPacketBlock");
var lv = "Pie";
function lLe(t) {
  return Ns.isInstance(t, lv);
}
gt(lLe, "isPie");
var cv = "PieSection";
function cLe(t) {
  return Ns.isInstance(t, cv);
}
gt(cLe, "isPieSection");
var B5 = "Radar", F5 = "Service", uv = "Treemap";
function uLe(t) {
  return Ns.isInstance(t, uv);
}
gt(uLe, "isTreemap");
var $5 = "TreemapRow", am = "Direction", sm = "Leaf", om = "Section", MW = class extends wH {
  static {
    gt(this, "MermaidAstReflection");
  }
  getAllTypes() {
    return [iv, tm, O0, rm, nm, R5, P0, M5, am, N5, I5, B0, D5, av, im, O5, sm, F0, P5, sv, ov, lv, cv, B5, om, F5, uN, uv, $5];
  }
  computeIsSubtype(t, e) {
    switch (t) {
      case O0:
      case rm:
      case nm:
      case P0:
      case F0:
        return this.isSubtype(uN, e);
      case am:
        return this.isSubtype(B0, e);
      case sm:
      case om:
        return this.isSubtype(im, e);
      default:
        return !1;
    }
  }
  getReferenceType(t) {
    const e = `${t.container.$type}:${t.property}`;
    if (e === "Entry:axis")
      return tm;
    throw new Error(`${e} is not a valid reference id.`);
  }
  getTypeMetaData(t) {
    switch (t) {
      case iv:
        return {
          name: iv,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "edges", defaultValue: [] },
            { name: "groups", defaultValue: [] },
            { name: "junctions", defaultValue: [] },
            { name: "services", defaultValue: [] },
            { name: "title" }
          ]
        };
      case tm:
        return {
          name: tm,
          properties: [
            { name: "label" },
            { name: "name" }
          ]
        };
      case O0:
        return {
          name: O0,
          properties: [
            { name: "name" },
            { name: "order" }
          ]
        };
      case rm:
        return {
          name: rm,
          properties: [
            { name: "branch" }
          ]
        };
      case nm:
        return {
          name: nm,
          properties: [
            { name: "id" },
            { name: "parent" },
            { name: "tags", defaultValue: [] }
          ]
        };
      case R5:
        return {
          name: R5,
          properties: [
            { name: "className" },
            { name: "styleText" }
          ]
        };
      case P0:
        return {
          name: P0,
          properties: [
            { name: "id" },
            { name: "message" },
            { name: "tags", defaultValue: [] },
            { name: "type" }
          ]
        };
      case M5:
        return {
          name: M5,
          properties: [
            { name: "entries", defaultValue: [] },
            { name: "label" },
            { name: "name" }
          ]
        };
      case N5:
        return {
          name: N5,
          properties: [
            { name: "lhsDir" },
            { name: "lhsGroup", defaultValue: !1 },
            { name: "lhsId" },
            { name: "lhsInto", defaultValue: !1 },
            { name: "rhsDir" },
            { name: "rhsGroup", defaultValue: !1 },
            { name: "rhsId" },
            { name: "rhsInto", defaultValue: !1 },
            { name: "title" }
          ]
        };
      case I5:
        return {
          name: I5,
          properties: [
            { name: "axis" },
            { name: "value" }
          ]
        };
      case B0:
        return {
          name: B0,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "statements", defaultValue: [] },
            { name: "title" }
          ]
        };
      case D5:
        return {
          name: D5,
          properties: [
            { name: "icon" },
            { name: "id" },
            { name: "in" },
            { name: "title" }
          ]
        };
      case av:
        return {
          name: av,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "title" }
          ]
        };
      case im:
        return {
          name: im,
          properties: [
            { name: "classSelector" },
            { name: "name" }
          ]
        };
      case O5:
        return {
          name: O5,
          properties: [
            { name: "id" },
            { name: "in" }
          ]
        };
      case F0:
        return {
          name: F0,
          properties: [
            { name: "branch" },
            { name: "id" },
            { name: "tags", defaultValue: [] },
            { name: "type" }
          ]
        };
      case P5:
        return {
          name: P5,
          properties: [
            { name: "name" },
            { name: "value", defaultValue: !1 }
          ]
        };
      case sv:
        return {
          name: sv,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "blocks", defaultValue: [] },
            { name: "title" }
          ]
        };
      case ov:
        return {
          name: ov,
          properties: [
            { name: "bits" },
            { name: "end" },
            { name: "label" },
            { name: "start" }
          ]
        };
      case lv:
        return {
          name: lv,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "sections", defaultValue: [] },
            { name: "showData", defaultValue: !1 },
            { name: "title" }
          ]
        };
      case cv:
        return {
          name: cv,
          properties: [
            { name: "label" },
            { name: "value" }
          ]
        };
      case B5:
        return {
          name: B5,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "axes", defaultValue: [] },
            { name: "curves", defaultValue: [] },
            { name: "options", defaultValue: [] },
            { name: "title" }
          ]
        };
      case F5:
        return {
          name: F5,
          properties: [
            { name: "icon" },
            { name: "iconText" },
            { name: "id" },
            { name: "in" },
            { name: "title" }
          ]
        };
      case uv:
        return {
          name: uv,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "title" },
            { name: "TreemapRows", defaultValue: [] }
          ]
        };
      case $5:
        return {
          name: $5,
          properties: [
            { name: "indent" },
            { name: "item" }
          ]
        };
      case am:
        return {
          name: am,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "dir" },
            { name: "statements", defaultValue: [] },
            { name: "title" }
          ]
        };
      case sm:
        return {
          name: sm,
          properties: [
            { name: "classSelector" },
            { name: "name" },
            { name: "value" }
          ]
        };
      case om:
        return {
          name: om,
          properties: [
            { name: "classSelector" },
            { name: "name" }
          ]
        };
      default:
        return {
          name: t,
          properties: []
        };
    }
  }
}, Ns = new MW(), hN, hLe = /* @__PURE__ */ gt(() => hN ?? (hN = ch(`{"$type":"Grammar","isDeclared":true,"name":"Info","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Info","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"info"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"*"},{"$type":"Group","elements":[{"$type":"Keyword","value":"showInfo"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"*"}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"?"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@7"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@8"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "InfoGrammar"), dN, dLe = /* @__PURE__ */ gt(() => dN ?? (dN = ch(`{"$type":"Grammar","isDeclared":true,"name":"Packet","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Packet","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"packet"},{"$type":"Keyword","value":"packet-beta"}]},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]},{"$type":"Assignment","feature":"blocks","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"PacketBlock","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Assignment","feature":"start","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"-"},{"$type":"Assignment","feature":"end","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}],"cardinality":"?"}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"+"},{"$type":"Assignment","feature":"bits","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}]}]},{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@8"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@9"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "PacketGrammar"), fN, fLe = /* @__PURE__ */ gt(() => fN ?? (fN = ch(`{"$type":"Grammar","isDeclared":true,"name":"Pie","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Pie","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"pie"},{"$type":"Assignment","feature":"showData","operator":"?=","terminal":{"$type":"Keyword","value":"showData"},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]},{"$type":"Assignment","feature":"sections","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"PieSection","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]}},{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"FLOAT_PIE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/-?[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT_PIE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/-?(0|[1-9][0-9]*)(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER_PIE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@2"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@3"}}]},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@11"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@12"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "PieGrammar"), pN, pLe = /* @__PURE__ */ gt(() => pN ?? (pN = ch(`{"$type":"Grammar","isDeclared":true,"name":"Architecture","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Architecture","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"architecture-beta"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Statement","definition":{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"groups","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"services","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Assignment","feature":"junctions","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}},{"$type":"Assignment","feature":"edges","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"LeftPort","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"lhsDir","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"RightPort","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"rhsDir","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Keyword","value":":"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Arrow","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]},{"$type":"Assignment","feature":"lhsInto","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"--"},{"$type":"Group","elements":[{"$type":"Keyword","value":"-"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@29"},"arguments":[]}},{"$type":"Keyword","value":"-"}]}]},{"$type":"Assignment","feature":"rhsInto","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Group","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"group"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Assignment","feature":"icon","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@28"},"arguments":[]},"cardinality":"?"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@29"},"arguments":[]},"cardinality":"?"},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Service","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"service"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"iconText","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@21"},"arguments":[]}},{"$type":"Assignment","feature":"icon","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@28"},"arguments":[]}}],"cardinality":"?"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@29"},"arguments":[]},"cardinality":"?"},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Junction","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"junction"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Edge","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"lhsId","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Assignment","feature":"lhsGroup","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"Assignment","feature":"rhsId","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Assignment","feature":"rhsGroup","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"ARROW_DIRECTION","definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"L"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"R"}}]},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"T"}}]},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"B"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARROW_GROUP","definition":{"$type":"RegexToken","regex":"/\\\\{group\\\\}/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARROW_INTO","definition":{"$type":"RegexToken","regex":"/<|>/"},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@18"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@19"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false},{"$type":"TerminalRule","name":"ARCH_ICON","definition":{"$type":"RegexToken","regex":"/\\\\([\\\\w-:]+\\\\)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARCH_TITLE","definition":{"$type":"RegexToken","regex":"/\\\\[[\\\\w ]+\\\\]/"},"fragment":false,"hidden":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "ArchitectureGrammar"), gN, gLe = /* @__PURE__ */ gt(() => gN ?? (gN = ch(`{"$type":"Grammar","isDeclared":true,"name":"GitGraph","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"GitGraph","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"Group","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"Keyword","value":":"}]},{"$type":"Keyword","value":"gitGraph:"},{"$type":"Group","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]},{"$type":"Keyword","value":":"}]}]},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]},{"$type":"Assignment","feature":"statements","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Statement","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Direction","definition":{"$type":"Assignment","feature":"dir","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"LR"},{"$type":"Keyword","value":"TB"},{"$type":"Keyword","value":"BT"}]}},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Commit","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"commit"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"msg:","cardinality":"?"},{"$type":"Assignment","feature":"message","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"type:"},{"$type":"Assignment","feature":"type","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"NORMAL"},{"$type":"Keyword","value":"REVERSE"},{"$type":"Keyword","value":"HIGHLIGHT"}]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Branch","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"branch"},{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@24"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"order:"},{"$type":"Assignment","feature":"order","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Merge","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"merge"},{"$type":"Assignment","feature":"branch","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@24"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]}},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"type:"},{"$type":"Assignment","feature":"type","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"NORMAL"},{"$type":"Keyword","value":"REVERSE"},{"$type":"Keyword","value":"HIGHLIGHT"}]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Checkout","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"checkout"},{"$type":"Keyword","value":"switch"}]},{"$type":"Assignment","feature":"branch","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@24"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"CherryPicking","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"cherry-pick"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"parent:"},{"$type":"Assignment","feature":"parent","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@14"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@15"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false},{"$type":"TerminalRule","name":"REFERENCE","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\\\w([-\\\\./\\\\w]*[-\\\\w])?/"},"fragment":false,"hidden":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "GitGraphGrammar"), mN, mLe = /* @__PURE__ */ gt(() => mN ?? (mN = ch(`{"$type":"Grammar","isDeclared":true,"name":"Radar","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Radar","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"radar-beta"},{"$type":"Keyword","value":"radar-beta:"},{"$type":"Group","elements":[{"$type":"Keyword","value":"radar-beta"},{"$type":"Keyword","value":":"}]}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]},{"$type":"Group","elements":[{"$type":"Keyword","value":"axis"},{"$type":"Assignment","feature":"axes","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"axes","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"curve"},{"$type":"Assignment","feature":"curves","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"curves","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"options","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"options","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Label","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"["},{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[]}},{"$type":"Keyword","value":"]"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Axis","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[],"cardinality":"?"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Curve","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[],"cardinality":"?"},{"$type":"Keyword","value":"{"},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"Keyword","value":"}"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Entries","definition":{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"}]}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"DetailedEntry","returnType":{"$ref":"#/interfaces@0"},"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"axis","operator":"=","terminal":{"$type":"CrossReference","type":{"$ref":"#/rules@2"},"terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},"deprecatedSyntax":false}},{"$type":"Keyword","value":":","cardinality":"?"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"NumberEntry","returnType":{"$ref":"#/interfaces@0"},"definition":{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Option","definition":{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"showLegend"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"ticks"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"max"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"min"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"graticule"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}}]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"GRATICULE","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"circle"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"polygon"}}]},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@15"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@16"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"interfaces":[{"$type":"Interface","name":"Entry","attributes":[{"$type":"TypeAttribute","name":"axis","isOptional":true,"type":{"$type":"ReferenceType","referenceType":{"$type":"SimpleType","typeRef":{"$ref":"#/rules@2"}}}},{"$type":"TypeAttribute","name":"value","type":{"$type":"SimpleType","primitiveType":"number"},"isOptional":false}],"superTypes":[]}],"definesHiddenTokens":false,"hiddenTokens":[],"types":[],"usedGrammars":[]}`)), "RadarGrammar"), vN, vLe = /* @__PURE__ */ gt(() => vN ?? (vN = ch(`{"$type":"Grammar","isDeclared":true,"name":"Treemap","rules":[{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"ParserRule","entry":true,"name":"Treemap","returnType":{"$ref":"#/interfaces@4"},"definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@0"},"arguments":[]},{"$type":"Assignment","feature":"TreemapRows","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]}}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"TREEMAP_KEYWORD","definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"treemap-beta"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"treemap"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"CLASS_DEF","definition":{"$type":"RegexToken","regex":"/classDef\\\\s+([a-zA-Z_][a-zA-Z0-9_]+)(?:\\\\s+([^;\\\\r\\\\n]*))?(?:;)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STYLE_SEPARATOR","definition":{"$type":"CharacterRange","left":{"$type":"Keyword","value":":::"}},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"SEPARATOR","definition":{"$type":"CharacterRange","left":{"$type":"Keyword","value":":"}},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"COMMA","definition":{"$type":"CharacterRange","left":{"$type":"Keyword","value":","}},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WS","definition":{"$type":"RegexToken","regex":"/[ \\\\t]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"ML_COMMENT","definition":{"$type":"RegexToken","regex":"/\\\\%\\\\%[^\\\\n]*/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"NL","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false},{"$type":"ParserRule","name":"TreemapRow","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"indent","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"item","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"ClassDef","dataType":"string","definition":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Item","returnType":{"$ref":"#/interfaces@0"},"definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Section","returnType":{"$ref":"#/interfaces@1"},"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]},{"$type":"Assignment","feature":"classSelector","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}],"cardinality":"?"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Leaf","returnType":{"$ref":"#/interfaces@2"},"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"?"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]},{"$type":"Assignment","feature":"classSelector","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}],"cardinality":"?"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"INDENTATION","definition":{"$type":"RegexToken","regex":"/[ \\\\t]{1,}/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID2","definition":{"$type":"RegexToken","regex":"/[a-zA-Z_][a-zA-Z0-9_]*/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER2","definition":{"$type":"RegexToken","regex":"/[0-9_\\\\.\\\\,]+/"},"fragment":false,"hidden":false},{"$type":"ParserRule","name":"MyNumber","dataType":"number","definition":{"$type":"RuleCall","rule":{"$ref":"#/rules@21"},"arguments":[]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"STRING2","definition":{"$type":"RegexToken","regex":"/\\"[^\\"]*\\"|'[^']*'/"},"fragment":false,"hidden":false}],"interfaces":[{"$type":"Interface","name":"Item","attributes":[{"$type":"TypeAttribute","name":"name","type":{"$type":"SimpleType","primitiveType":"string"},"isOptional":false},{"$type":"TypeAttribute","name":"classSelector","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]},{"$type":"Interface","name":"Section","superTypes":[{"$ref":"#/interfaces@0"}],"attributes":[]},{"$type":"Interface","name":"Leaf","superTypes":[{"$ref":"#/interfaces@0"}],"attributes":[{"$type":"TypeAttribute","name":"value","type":{"$type":"SimpleType","primitiveType":"number"},"isOptional":false}]},{"$type":"Interface","name":"ClassDefStatement","attributes":[{"$type":"TypeAttribute","name":"className","type":{"$type":"SimpleType","primitiveType":"string"},"isOptional":false},{"$type":"TypeAttribute","name":"styleText","type":{"$type":"SimpleType","primitiveType":"string"},"isOptional":false}],"superTypes":[]},{"$type":"Interface","name":"Treemap","attributes":[{"$type":"TypeAttribute","name":"TreemapRows","type":{"$type":"ArrayType","elementType":{"$type":"SimpleType","typeRef":{"$ref":"#/rules@14"}}},"isOptional":false},{"$type":"TypeAttribute","name":"title","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accTitle","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accDescr","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]}],"definesHiddenTokens":false,"hiddenTokens":[],"imports":[],"types":[],"usedGrammars":[],"$comment":"/**\\n * Treemap grammar for Langium\\n * Converted from mindmap grammar\\n *\\n * The ML_COMMENT and NL hidden terminals handle whitespace, comments, and newlines\\n * before the treemap keyword, allowing for empty lines and comments before the\\n * treemap declaration.\\n */"}`)), "TreemapGrammar"), yLe = {
  languageId: "info",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, xLe = {
  languageId: "packet",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, bLe = {
  languageId: "pie",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, wLe = {
  languageId: "architecture",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, TLe = {
  languageId: "gitGraph",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, ELe = {
  languageId: "radar",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, kLe = {
  languageId: "treemap",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, uh = {
  AstReflection: /* @__PURE__ */ gt(() => new MW(), "AstReflection")
}, SLe = {
  Grammar: /* @__PURE__ */ gt(() => hLe(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ gt(() => yLe, "LanguageMetaData"),
  parser: {}
}, CLe = {
  Grammar: /* @__PURE__ */ gt(() => dLe(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ gt(() => xLe, "LanguageMetaData"),
  parser: {}
}, ALe = {
  Grammar: /* @__PURE__ */ gt(() => fLe(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ gt(() => bLe, "LanguageMetaData"),
  parser: {}
}, _Le = {
  Grammar: /* @__PURE__ */ gt(() => pLe(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ gt(() => wLe, "LanguageMetaData"),
  parser: {}
}, LLe = {
  Grammar: /* @__PURE__ */ gt(() => gLe(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ gt(() => TLe, "LanguageMetaData"),
  parser: {}
}, RLe = {
  Grammar: /* @__PURE__ */ gt(() => mLe(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ gt(() => ELe, "LanguageMetaData"),
  parser: {}
}, MLe = {
  Grammar: /* @__PURE__ */ gt(() => vLe(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ gt(() => kLe, "LanguageMetaData"),
  parser: {}
}, NLe = /accDescr(?:[\t ]*:([^\n\r]*)|\s*{([^}]*)})/, ILe = /accTitle[\t ]*:([^\n\r]*)/, DLe = /title([\t ][^\n\r]*|)/, OLe = {
  ACC_DESCR: NLe,
  ACC_TITLE: ILe,
  TITLE: DLe
}, pb = class extends vW {
  static {
    gt(this, "AbstractMermaidValueConverter");
  }
  runConverter(t, e, r) {
    let n = this.runCommonConverter(t, e, r);
    return n === void 0 && (n = this.runCustomConverter(t, e, r)), n === void 0 ? super.runConverter(t, e, r) : n;
  }
  runCommonConverter(t, e, r) {
    const n = OLe[t.name];
    if (n === void 0)
      return;
    const i = n.exec(e);
    if (i !== null) {
      if (i[1] !== void 0)
        return i[1].trim().replace(/[\t ]{2,}/gm, " ");
      if (i[2] !== void 0)
        return i[2].replace(/^\s*/gm, "").replace(/\s+$/gm, "").replace(/[\t ]{2,}/gm, " ").replace(/[\n\r]{2,}/gm, `
`);
    }
  }
}, gb = class extends pb {
  static {
    gt(this, "CommonValueConverter");
  }
  runCustomConverter(t, e, r) {
  }
}, _c = class extends mW {
  static {
    gt(this, "AbstractMermaidTokenBuilder");
  }
  constructor(t) {
    super(), this.keywords = new Set(t);
  }
  buildKeywordTokens(t, e, r) {
    const n = super.buildKeywordTokens(t, e, r);
    return n.forEach((i) => {
      this.keywords.has(i.name) && i.PATTERN !== void 0 && (i.PATTERN = new RegExp(i.PATTERN.toString() + "(?:(?=%%)|(?!\\S))"));
    }), n;
  }
};
(class extends _c {
  static {
    gt(this, "CommonTokenBuilder");
  }
});
var PLe = class extends _c {
  static {
    gt(this, "GitGraphTokenBuilder");
  }
  constructor() {
    super(["gitGraph"]);
  }
}, NW = {
  parser: {
    TokenBuilder: /* @__PURE__ */ gt(() => new PLe(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ gt(() => new gb(), "ValueConverter")
  }
};
function IW(t = Ac) {
  const e = Ai(
    Cc(t),
    uh
  ), r = Ai(
    Sc({ shared: e }),
    LLe,
    NW
  );
  return e.ServiceRegistry.register(r), { shared: e, GitGraph: r };
}
gt(IW, "createGitGraphServices");
var BLe = class extends _c {
  static {
    gt(this, "InfoTokenBuilder");
  }
  constructor() {
    super(["info", "showInfo"]);
  }
}, DW = {
  parser: {
    TokenBuilder: /* @__PURE__ */ gt(() => new BLe(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ gt(() => new gb(), "ValueConverter")
  }
};
function OW(t = Ac) {
  const e = Ai(
    Cc(t),
    uh
  ), r = Ai(
    Sc({ shared: e }),
    SLe,
    DW
  );
  return e.ServiceRegistry.register(r), { shared: e, Info: r };
}
gt(OW, "createInfoServices");
var FLe = class extends _c {
  static {
    gt(this, "PacketTokenBuilder");
  }
  constructor() {
    super(["packet"]);
  }
}, PW = {
  parser: {
    TokenBuilder: /* @__PURE__ */ gt(() => new FLe(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ gt(() => new gb(), "ValueConverter")
  }
};
function BW(t = Ac) {
  const e = Ai(
    Cc(t),
    uh
  ), r = Ai(
    Sc({ shared: e }),
    CLe,
    PW
  );
  return e.ServiceRegistry.register(r), { shared: e, Packet: r };
}
gt(BW, "createPacketServices");
var $Le = class extends _c {
  static {
    gt(this, "PieTokenBuilder");
  }
  constructor() {
    super(["pie", "showData"]);
  }
}, zLe = class extends pb {
  static {
    gt(this, "PieValueConverter");
  }
  runCustomConverter(t, e, r) {
    if (t.name === "PIE_SECTION_LABEL")
      return e.replace(/"/g, "").trim();
  }
}, FW = {
  parser: {
    TokenBuilder: /* @__PURE__ */ gt(() => new $Le(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ gt(() => new zLe(), "ValueConverter")
  }
};
function $W(t = Ac) {
  const e = Ai(
    Cc(t),
    uh
  ), r = Ai(
    Sc({ shared: e }),
    ALe,
    FW
  );
  return e.ServiceRegistry.register(r), { shared: e, Pie: r };
}
gt($W, "createPieServices");
var GLe = class extends _c {
  static {
    gt(this, "ArchitectureTokenBuilder");
  }
  constructor() {
    super(["architecture"]);
  }
}, VLe = class extends pb {
  static {
    gt(this, "ArchitectureValueConverter");
  }
  runCustomConverter(t, e, r) {
    if (t.name === "ARCH_ICON")
      return e.replace(/[()]/g, "").trim();
    if (t.name === "ARCH_TEXT_ICON")
      return e.replace(/["()]/g, "");
    if (t.name === "ARCH_TITLE")
      return e.replace(/[[\]]/g, "").trim();
  }
}, zW = {
  parser: {
    TokenBuilder: /* @__PURE__ */ gt(() => new GLe(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ gt(() => new VLe(), "ValueConverter")
  }
};
function GW(t = Ac) {
  const e = Ai(
    Cc(t),
    uh
  ), r = Ai(
    Sc({ shared: e }),
    _Le,
    zW
  );
  return e.ServiceRegistry.register(r), { shared: e, Architecture: r };
}
gt(GW, "createArchitectureServices");
var ULe = class extends _c {
  static {
    gt(this, "RadarTokenBuilder");
  }
  constructor() {
    super(["radar-beta"]);
  }
}, VW = {
  parser: {
    TokenBuilder: /* @__PURE__ */ gt(() => new ULe(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ gt(() => new gb(), "ValueConverter")
  }
};
function UW(t = Ac) {
  const e = Ai(
    Cc(t),
    uh
  ), r = Ai(
    Sc({ shared: e }),
    RLe,
    VW
  );
  return e.ServiceRegistry.register(r), { shared: e, Radar: r };
}
gt(UW, "createRadarServices");
var HLe = class extends _c {
  static {
    gt(this, "TreemapTokenBuilder");
  }
  constructor() {
    super(["treemap"]);
  }
}, qLe = /classDef\s+([A-Z_a-z]\w+)(?:\s+([^\n\r;]*))?;?/, WLe = class extends pb {
  static {
    gt(this, "TreemapValueConverter");
  }
  runCustomConverter(t, e, r) {
    if (t.name === "NUMBER2")
      return parseFloat(e.replace(/,/g, ""));
    if (t.name === "SEPARATOR")
      return e.substring(1, e.length - 1);
    if (t.name === "STRING2")
      return e.substring(1, e.length - 1);
    if (t.name === "INDENTATION")
      return e.length;
    if (t.name === "ClassDef") {
      if (typeof e != "string")
        return e;
      const n = qLe.exec(e);
      if (n)
        return {
          $type: "ClassDefStatement",
          className: n[1],
          styleText: n[2] || void 0
        };
    }
  }
};
function HW(t) {
  const e = t.validation.TreemapValidator, r = t.validation.ValidationRegistry;
  if (r) {
    const n = {
      Treemap: e.checkSingleRoot.bind(e)
      // Remove unused validation for TreemapRow
    };
    r.register(n, e);
  }
}
gt(HW, "registerValidationChecks");
var YLe = class {
  static {
    gt(this, "TreemapValidator");
  }
  /**
   * Validates that a treemap has only one root node.
   * A root node is defined as a node that has no indentation.
   */
  checkSingleRoot(t, e) {
    let r;
    for (const n of t.TreemapRows)
      n.item && (r === void 0 && // Check if this is a root node (no indentation)
      n.indent === void 0 ? r = 0 : n.indent === void 0 ? e("error", "Multiple root nodes are not allowed in a treemap.", {
        node: n,
        property: "item"
      }) : r !== void 0 && r >= parseInt(n.indent, 10) && e("error", "Multiple root nodes are not allowed in a treemap.", {
        node: n,
        property: "item"
      }));
  }
}, qW = {
  parser: {
    TokenBuilder: /* @__PURE__ */ gt(() => new HLe(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ gt(() => new WLe(), "ValueConverter")
  },
  validation: {
    TreemapValidator: /* @__PURE__ */ gt(() => new YLe(), "TreemapValidator")
  }
};
function WW(t = Ac) {
  const e = Ai(
    Cc(t),
    uh
  ), r = Ai(
    Sc({ shared: e }),
    MLe,
    qW
  );
  return e.ServiceRegistry.register(r), HW(r), { shared: e, Treemap: r };
}
gt(WW, "createTreemapServices");
var No = {}, XLe = {
  info: /* @__PURE__ */ gt(async () => {
    const { createInfoServices: t } = await Promise.resolve().then(() => B$e), e = t().Info.parser.LangiumParser;
    No.info = e;
  }, "info"),
  packet: /* @__PURE__ */ gt(async () => {
    const { createPacketServices: t } = await Promise.resolve().then(() => F$e), e = t().Packet.parser.LangiumParser;
    No.packet = e;
  }, "packet"),
  pie: /* @__PURE__ */ gt(async () => {
    const { createPieServices: t } = await Promise.resolve().then(() => $$e), e = t().Pie.parser.LangiumParser;
    No.pie = e;
  }, "pie"),
  architecture: /* @__PURE__ */ gt(async () => {
    const { createArchitectureServices: t } = await Promise.resolve().then(() => z$e), e = t().Architecture.parser.LangiumParser;
    No.architecture = e;
  }, "architecture"),
  gitGraph: /* @__PURE__ */ gt(async () => {
    const { createGitGraphServices: t } = await Promise.resolve().then(() => G$e), e = t().GitGraph.parser.LangiumParser;
    No.gitGraph = e;
  }, "gitGraph"),
  radar: /* @__PURE__ */ gt(async () => {
    const { createRadarServices: t } = await Promise.resolve().then(() => V$e), e = t().Radar.parser.LangiumParser;
    No.radar = e;
  }, "radar"),
  treemap: /* @__PURE__ */ gt(async () => {
    const { createTreemapServices: t } = await Promise.resolve().then(() => U$e), e = t().Treemap.parser.LangiumParser;
    No.treemap = e;
  }, "treemap")
};
async function Lc(t, e) {
  const r = XLe[t];
  if (!r)
    throw new Error(`Unknown diagram type: ${t}`);
  No[t] || await r();
  const i = No[t].parse(e);
  if (i.lexerErrors.length > 0 || i.parserErrors.length > 0)
    throw new jLe(i);
  return i.value;
}
gt(Lc, "parse");
var jLe = class extends Error {
  constructor(t) {
    const e = t.lexerErrors.map((n) => n.message).join(`
`), r = t.parserErrors.map((n) => n.message).join(`
`);
    super(`Parsing failed: ${e} ${r}`), this.result = t;
  }
  static {
    gt(this, "MermaidParseError");
  }
}, Mr = {
  NORMAL: 0,
  REVERSE: 1,
  HIGHLIGHT: 2,
  MERGE: 3,
  CHERRY_PICK: 4
}, KLe = ur.gitGraph, hh = /* @__PURE__ */ x(() => Hi({
  ...KLe,
  ...pr().gitGraph
}), "getConfig"), vt = new bH(() => {
  const t = hh(), e = t.mainBranchName, r = t.mainBranchOrder;
  return {
    mainBranchName: e,
    commits: /* @__PURE__ */ new Map(),
    head: null,
    branchConfig: /* @__PURE__ */ new Map([[e, { name: e, order: r }]]),
    branches: /* @__PURE__ */ new Map([[e, null]]),
    currBranch: e,
    direction: "LR",
    seq: 0,
    options: {}
  };
});
function mb() {
  return hB({ length: 7 });
}
x(mb, "getID");
function YW(t, e) {
  const r = /* @__PURE__ */ Object.create(null);
  return t.reduce((n, i) => {
    const a = e(i);
    return r[a] || (r[a] = !0, n.push(i)), n;
  }, []);
}
x(YW, "uniqBy");
var ZLe = /* @__PURE__ */ x(function(t) {
  vt.records.direction = t;
}, "setDirection"), QLe = /* @__PURE__ */ x(function(t) {
  ie.debug("options str", t), t = t?.trim(), t = t || "{}";
  try {
    vt.records.options = JSON.parse(t);
  } catch (e) {
    ie.error("error while parsing gitGraph options", e.message);
  }
}, "setOptions"), JLe = /* @__PURE__ */ x(function() {
  return vt.records.options;
}, "getOptions"), eRe = /* @__PURE__ */ x(function(t) {
  let e = t.msg, r = t.id;
  const n = t.type;
  let i = t.tags;
  ie.info("commit", e, r, n, i), ie.debug("Entering commit:", e, r, n, i);
  const a = hh();
  r = at.sanitizeText(r, a), e = at.sanitizeText(e, a), i = i?.map((o) => at.sanitizeText(o, a));
  const s = {
    id: r || vt.records.seq + "-" + mb(),
    message: e,
    seq: vt.records.seq++,
    type: n ?? Mr.NORMAL,
    tags: i ?? [],
    parents: vt.records.head == null ? [] : [vt.records.head.id],
    branch: vt.records.currBranch
  };
  vt.records.head = s, ie.info("main branch", a.mainBranchName), vt.records.commits.has(s.id) && ie.warn(`Commit ID ${s.id} already exists`), vt.records.commits.set(s.id, s), vt.records.branches.set(vt.records.currBranch, s.id), ie.debug("in pushCommit " + s.id);
}, "commit"), tRe = /* @__PURE__ */ x(function(t) {
  let e = t.name;
  const r = t.order;
  if (e = at.sanitizeText(e, hh()), vt.records.branches.has(e))
    throw new Error(
      `Trying to create an existing branch. (Help: Either use a new name if you want create a new branch or try using "checkout ${e}")`
    );
  vt.records.branches.set(e, vt.records.head != null ? vt.records.head.id : null), vt.records.branchConfig.set(e, { name: e, order: r }), XW(e), ie.debug("in createBranch");
}, "branch"), rRe = /* @__PURE__ */ x((t) => {
  let e = t.branch, r = t.id;
  const n = t.type, i = t.tags, a = hh();
  e = at.sanitizeText(e, a), r && (r = at.sanitizeText(r, a));
  const s = vt.records.branches.get(vt.records.currBranch), o = vt.records.branches.get(e), l = s ? vt.records.commits.get(s) : void 0, u = o ? vt.records.commits.get(o) : void 0;
  if (l && u && l.branch === e)
    throw new Error(`Cannot merge branch '${e}' into itself.`);
  if (vt.records.currBranch === e) {
    const f = new Error('Incorrect usage of "merge". Cannot merge a branch to itself');
    throw f.hash = {
      text: `merge ${e}`,
      token: `merge ${e}`,
      expected: ["branch abc"]
    }, f;
  }
  if (l === void 0 || !l) {
    const f = new Error(
      `Incorrect usage of "merge". Current branch (${vt.records.currBranch})has no commits`
    );
    throw f.hash = {
      text: `merge ${e}`,
      token: `merge ${e}`,
      expected: ["commit"]
    }, f;
  }
  if (!vt.records.branches.has(e)) {
    const f = new Error(
      'Incorrect usage of "merge". Branch to be merged (' + e + ") does not exist"
    );
    throw f.hash = {
      text: `merge ${e}`,
      token: `merge ${e}`,
      expected: [`branch ${e}`]
    }, f;
  }
  if (u === void 0 || !u) {
    const f = new Error(
      'Incorrect usage of "merge". Branch to be merged (' + e + ") has no commits"
    );
    throw f.hash = {
      text: `merge ${e}`,
      token: `merge ${e}`,
      expected: ['"commit"']
    }, f;
  }
  if (l === u) {
    const f = new Error('Incorrect usage of "merge". Both branches have same head');
    throw f.hash = {
      text: `merge ${e}`,
      token: `merge ${e}`,
      expected: ["branch abc"]
    }, f;
  }
  if (r && vt.records.commits.has(r)) {
    const f = new Error(
      'Incorrect usage of "merge". Commit with id:' + r + " already exists, use different custom id"
    );
    throw f.hash = {
      text: `merge ${e} ${r} ${n} ${i?.join(" ")}`,
      token: `merge ${e} ${r} ${n} ${i?.join(" ")}`,
      expected: [
        `merge ${e} ${r}_UNIQUE ${n} ${i?.join(" ")}`
      ]
    }, f;
  }
  const h = o || "", d = {
    id: r || `${vt.records.seq}-${mb()}`,
    message: `merged branch ${e} into ${vt.records.currBranch}`,
    seq: vt.records.seq++,
    parents: vt.records.head == null ? [] : [vt.records.head.id, h],
    branch: vt.records.currBranch,
    type: Mr.MERGE,
    customType: n,
    customId: !!r,
    tags: i ?? []
  };
  vt.records.head = d, vt.records.commits.set(d.id, d), vt.records.branches.set(vt.records.currBranch, d.id), ie.debug(vt.records.branches), ie.debug("in mergeBranch");
}, "merge"), nRe = /* @__PURE__ */ x(function(t) {
  let e = t.id, r = t.targetId, n = t.tags, i = t.parent;
  ie.debug("Entering cherryPick:", e, r, n);
  const a = hh();
  if (e = at.sanitizeText(e, a), r = at.sanitizeText(r, a), n = n?.map((l) => at.sanitizeText(l, a)), i = at.sanitizeText(i, a), !e || !vt.records.commits.has(e)) {
    const l = new Error(
      'Incorrect usage of "cherryPick". Source commit id should exist and provided'
    );
    throw l.hash = {
      text: `cherryPick ${e} ${r}`,
      token: `cherryPick ${e} ${r}`,
      expected: ["cherry-pick abc"]
    }, l;
  }
  const s = vt.records.commits.get(e);
  if (s === void 0 || !s)
    throw new Error('Incorrect usage of "cherryPick". Source commit id should exist and provided');
  if (i && !(Array.isArray(s.parents) && s.parents.includes(i)))
    throw new Error(
      "Invalid operation: The specified parent commit is not an immediate parent of the cherry-picked commit."
    );
  const o = s.branch;
  if (s.type === Mr.MERGE && !i)
    throw new Error(
      "Incorrect usage of cherry-pick: If the source commit is a merge commit, an immediate parent commit must be specified."
    );
  if (!r || !vt.records.commits.has(r)) {
    if (o === vt.records.currBranch) {
      const d = new Error(
        'Incorrect usage of "cherryPick". Source commit is already on current branch'
      );
      throw d.hash = {
        text: `cherryPick ${e} ${r}`,
        token: `cherryPick ${e} ${r}`,
        expected: ["cherry-pick abc"]
      }, d;
    }
    const l = vt.records.branches.get(vt.records.currBranch);
    if (l === void 0 || !l) {
      const d = new Error(
        `Incorrect usage of "cherry-pick". Current branch (${vt.records.currBranch})has no commits`
      );
      throw d.hash = {
        text: `cherryPick ${e} ${r}`,
        token: `cherryPick ${e} ${r}`,
        expected: ["cherry-pick abc"]
      }, d;
    }
    const u = vt.records.commits.get(l);
    if (u === void 0 || !u) {
      const d = new Error(
        `Incorrect usage of "cherry-pick". Current branch (${vt.records.currBranch})has no commits`
      );
      throw d.hash = {
        text: `cherryPick ${e} ${r}`,
        token: `cherryPick ${e} ${r}`,
        expected: ["cherry-pick abc"]
      }, d;
    }
    const h = {
      id: vt.records.seq + "-" + mb(),
      message: `cherry-picked ${s?.message} into ${vt.records.currBranch}`,
      seq: vt.records.seq++,
      parents: vt.records.head == null ? [] : [vt.records.head.id, s.id],
      branch: vt.records.currBranch,
      type: Mr.CHERRY_PICK,
      tags: n ? n.filter(Boolean) : [
        `cherry-pick:${s.id}${s.type === Mr.MERGE ? `|parent:${i}` : ""}`
      ]
    };
    vt.records.head = h, vt.records.commits.set(h.id, h), vt.records.branches.set(vt.records.currBranch, h.id), ie.debug(vt.records.branches), ie.debug("in cherryPick");
  }
}, "cherryPick"), XW = /* @__PURE__ */ x(function(t) {
  if (t = at.sanitizeText(t, hh()), vt.records.branches.has(t)) {
    vt.records.currBranch = t;
    const e = vt.records.branches.get(vt.records.currBranch);
    e === void 0 || !e ? vt.records.head = null : vt.records.head = vt.records.commits.get(e) ?? null;
  } else {
    const e = new Error(
      `Trying to checkout branch which is not yet created. (Help try using "branch ${t}")`
    );
    throw e.hash = {
      text: `checkout ${t}`,
      token: `checkout ${t}`,
      expected: [`branch ${t}`]
    }, e;
  }
}, "checkout");
function E6(t, e, r) {
  const n = t.indexOf(e);
  n === -1 ? t.push(r) : t.splice(n, 1, r);
}
x(E6, "upsert");
function d7(t) {
  const e = t.reduce((i, a) => i.seq > a.seq ? i : a, t[0]);
  let r = "";
  t.forEach(function(i) {
    i === e ? r += "	*" : r += "	|";
  });
  const n = [r, e.id, e.seq];
  for (const i in vt.records.branches)
    vt.records.branches.get(i) === e.id && n.push(i);
  if (ie.debug(n.join(" ")), e.parents && e.parents.length == 2 && e.parents[0] && e.parents[1]) {
    const i = vt.records.commits.get(e.parents[0]);
    E6(t, e, i), e.parents[1] && t.push(vt.records.commits.get(e.parents[1]));
  } else {
    if (e.parents.length == 0)
      return;
    if (e.parents[0]) {
      const i = vt.records.commits.get(e.parents[0]);
      E6(t, e, i);
    }
  }
  t = YW(t, (i) => i.id), d7(t);
}
x(d7, "prettyPrintCommitHistory");
var iRe = /* @__PURE__ */ x(function() {
  ie.debug(vt.records.commits);
  const t = jW()[0];
  d7([t]);
}, "prettyPrint"), aRe = /* @__PURE__ */ x(function() {
  vt.reset(), _n();
}, "clear"), sRe = /* @__PURE__ */ x(function() {
  return [...vt.records.branchConfig.values()].map((e, r) => e.order !== null && e.order !== void 0 ? e : {
    ...e,
    order: parseFloat(`0.${r}`)
  }).sort((e, r) => (e.order ?? 0) - (r.order ?? 0)).map(({ name: e }) => ({ name: e }));
}, "getBranchesAsObjArray"), oRe = /* @__PURE__ */ x(function() {
  return vt.records.branches;
}, "getBranches"), lRe = /* @__PURE__ */ x(function() {
  return vt.records.commits;
}, "getCommits"), jW = /* @__PURE__ */ x(function() {
  const t = [...vt.records.commits.values()];
  return t.forEach(function(e) {
    ie.debug(e.id);
  }), t.sort((e, r) => e.seq - r.seq), t;
}, "getCommitsArray"), cRe = /* @__PURE__ */ x(function() {
  return vt.records.currBranch;
}, "getCurrentBranch"), uRe = /* @__PURE__ */ x(function() {
  return vt.records.direction;
}, "getDirection"), hRe = /* @__PURE__ */ x(function() {
  return vt.records.head;
}, "getHead"), KW = {
  commitType: Mr,
  getConfig: hh,
  setDirection: ZLe,
  setOptions: QLe,
  getOptions: JLe,
  commit: eRe,
  branch: tRe,
  merge: rRe,
  cherryPick: nRe,
  checkout: XW,
  //reset,
  prettyPrint: iRe,
  clear: aRe,
  getBranchesAsObjArray: sRe,
  getBranches: oRe,
  getCommits: lRe,
  getCommitsArray: jW,
  getCurrentBranch: cRe,
  getDirection: uRe,
  getHead: hRe,
  setAccTitle: Cn,
  getAccTitle: Gn,
  getAccDescription: Un,
  setAccDescription: Vn,
  setDiagramTitle: Zn,
  getDiagramTitle: Ln
}, dRe = /* @__PURE__ */ x((t, e) => {
  nh(t, e), t.dir && e.setDirection(t.dir);
  for (const r of t.statements)
    fRe(r, e);
}, "populate"), fRe = /* @__PURE__ */ x((t, e) => {
  const n = {
    Commit: /* @__PURE__ */ x((i) => e.commit(pRe(i)), "Commit"),
    Branch: /* @__PURE__ */ x((i) => e.branch(gRe(i)), "Branch"),
    Merge: /* @__PURE__ */ x((i) => e.merge(mRe(i)), "Merge"),
    Checkout: /* @__PURE__ */ x((i) => e.checkout(vRe(i)), "Checkout"),
    CherryPicking: /* @__PURE__ */ x((i) => e.cherryPick(yRe(i)), "CherryPicking")
  }[t.$type];
  n ? n(t) : ie.error(`Unknown statement type: ${t.$type}`);
}, "parseStatement"), pRe = /* @__PURE__ */ x((t) => ({
  id: t.id,
  msg: t.message ?? "",
  type: t.type !== void 0 ? Mr[t.type] : Mr.NORMAL,
  tags: t.tags ?? void 0
}), "parseCommit"), gRe = /* @__PURE__ */ x((t) => ({
  name: t.name,
  order: t.order ?? 0
}), "parseBranch"), mRe = /* @__PURE__ */ x((t) => ({
  branch: t.branch,
  id: t.id ?? "",
  type: t.type !== void 0 ? Mr[t.type] : void 0,
  tags: t.tags ?? void 0
}), "parseMerge"), vRe = /* @__PURE__ */ x((t) => t.branch, "parseCheckout"), yRe = /* @__PURE__ */ x((t) => ({
  id: t.id,
  targetId: "",
  tags: t.tags?.length === 0 ? void 0 : t.tags,
  parent: t.parent
}), "parseCherryPicking"), xRe = {
  parse: /* @__PURE__ */ x(async (t) => {
    const e = await Lc("gitGraph", t);
    ie.debug(e), dRe(e, KW);
  }, "parse")
}, bRe = we(), Ha = bRe?.gitGraph, Pl = 10, Bl = 40, Vs = 4, Po = 2, Qc = 8, sa = /* @__PURE__ */ new Map(), ca = /* @__PURE__ */ new Map(), f2 = 30, $0 = /* @__PURE__ */ new Map(), p2 = [], _l = 0, hr = "LR", wRe = /* @__PURE__ */ x(() => {
  sa.clear(), ca.clear(), $0.clear(), _l = 0, p2 = [], hr = "LR";
}, "clear"), ZW = /* @__PURE__ */ x((t) => {
  const e = document.createElementNS("http://www.w3.org/2000/svg", "text");
  return (typeof t == "string" ? t.split(/\\n|\n|<br\s*\/?>/gi) : t).forEach((n) => {
    const i = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    i.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), i.setAttribute("dy", "1em"), i.setAttribute("x", "0"), i.setAttribute("class", "row"), i.textContent = n.trim(), e.appendChild(i);
  }), e;
}, "drawText"), QW = /* @__PURE__ */ x((t) => {
  let e, r, n;
  return hr === "BT" ? (r = /* @__PURE__ */ x((i, a) => i <= a, "comparisonFunc"), n = 1 / 0) : (r = /* @__PURE__ */ x((i, a) => i >= a, "comparisonFunc"), n = 0), t.forEach((i) => {
    const a = hr === "TB" || hr == "BT" ? ca.get(i)?.y : ca.get(i)?.x;
    a !== void 0 && r(a, n) && (e = i, n = a);
  }), e;
}, "findClosestParent"), TRe = /* @__PURE__ */ x((t) => {
  let e = "", r = 1 / 0;
  return t.forEach((n) => {
    const i = ca.get(n).y;
    i <= r && (e = n, r = i);
  }), e || void 0;
}, "findClosestParentBT"), ERe = /* @__PURE__ */ x((t, e, r) => {
  let n = r, i = r;
  const a = [];
  t.forEach((s) => {
    const o = e.get(s);
    if (!o)
      throw new Error(`Commit not found for key ${s}`);
    o.parents.length ? (n = SRe(o), i = Math.max(n, i)) : a.push(o), CRe(o, n);
  }), n = i, a.forEach((s) => {
    ARe(s, n, r);
  }), t.forEach((s) => {
    const o = e.get(s);
    if (o?.parents.length) {
      const l = TRe(o.parents);
      n = ca.get(l).y - Bl, n <= i && (i = n);
      const u = sa.get(o.branch).pos, h = n - Pl;
      ca.set(o.id, { x: u, y: h });
    }
  });
}, "setParallelBTPos"), kRe = /* @__PURE__ */ x((t) => {
  const e = QW(t.parents.filter((n) => n !== null));
  if (!e)
    throw new Error(`Closest parent not found for commit ${t.id}`);
  const r = ca.get(e)?.y;
  if (r === void 0)
    throw new Error(`Closest parent position not found for commit ${t.id}`);
  return r;
}, "findClosestParentPos"), SRe = /* @__PURE__ */ x((t) => kRe(t) + Bl, "calculateCommitPosition"), CRe = /* @__PURE__ */ x((t, e) => {
  const r = sa.get(t.branch);
  if (!r)
    throw new Error(`Branch not found for commit ${t.id}`);
  const n = r.pos, i = e + Pl;
  return ca.set(t.id, { x: n, y: i }), { x: n, y: i };
}, "setCommitPosition"), ARe = /* @__PURE__ */ x((t, e, r) => {
  const n = sa.get(t.branch);
  if (!n)
    throw new Error(`Branch not found for commit ${t.id}`);
  const i = e + r, a = n.pos;
  ca.set(t.id, { x: a, y: i });
}, "setRootPosition"), _Re = /* @__PURE__ */ x((t, e, r, n, i, a) => {
  if (a === Mr.HIGHLIGHT)
    t.append("rect").attr("x", r.x - 10).attr("y", r.y - 10).attr("width", 20).attr("height", 20).attr(
      "class",
      `commit ${e.id} commit-highlight${i % Qc} ${n}-outer`
    ), t.append("rect").attr("x", r.x - 6).attr("y", r.y - 6).attr("width", 12).attr("height", 12).attr(
      "class",
      `commit ${e.id} commit${i % Qc} ${n}-inner`
    );
  else if (a === Mr.CHERRY_PICK)
    t.append("circle").attr("cx", r.x).attr("cy", r.y).attr("r", 10).attr("class", `commit ${e.id} ${n}`), t.append("circle").attr("cx", r.x - 3).attr("cy", r.y + 2).attr("r", 2.75).attr("fill", "#fff").attr("class", `commit ${e.id} ${n}`), t.append("circle").attr("cx", r.x + 3).attr("cy", r.y + 2).attr("r", 2.75).attr("fill", "#fff").attr("class", `commit ${e.id} ${n}`), t.append("line").attr("x1", r.x + 3).attr("y1", r.y + 1).attr("x2", r.x).attr("y2", r.y - 5).attr("stroke", "#fff").attr("class", `commit ${e.id} ${n}`), t.append("line").attr("x1", r.x - 3).attr("y1", r.y + 1).attr("x2", r.x).attr("y2", r.y - 5).attr("stroke", "#fff").attr("class", `commit ${e.id} ${n}`);
  else {
    const s = t.append("circle");
    if (s.attr("cx", r.x), s.attr("cy", r.y), s.attr("r", e.type === Mr.MERGE ? 9 : 10), s.attr("class", `commit ${e.id} commit${i % Qc}`), a === Mr.MERGE) {
      const o = t.append("circle");
      o.attr("cx", r.x), o.attr("cy", r.y), o.attr("r", 6), o.attr(
        "class",
        `commit ${n} ${e.id} commit${i % Qc}`
      );
    }
    a === Mr.REVERSE && t.append("path").attr(
      "d",
      `M ${r.x - 5},${r.y - 5}L${r.x + 5},${r.y + 5}M${r.x - 5},${r.y + 5}L${r.x + 5},${r.y - 5}`
    ).attr("class", `commit ${n} ${e.id} commit${i % Qc}`);
  }
}, "drawCommitBullet"), LRe = /* @__PURE__ */ x((t, e, r, n) => {
  if (e.type !== Mr.CHERRY_PICK && (e.customId && e.type === Mr.MERGE || e.type !== Mr.MERGE) && Ha?.showCommitLabel) {
    const i = t.append("g"), a = i.insert("rect").attr("class", "commit-label-bkg"), s = i.append("text").attr("x", n).attr("y", r.y + 25).attr("class", "commit-label").text(e.id), o = s.node()?.getBBox();
    if (o && (a.attr("x", r.posWithOffset - o.width / 2 - Po).attr("y", r.y + 13.5).attr("width", o.width + 2 * Po).attr("height", o.height + 2 * Po), hr === "TB" || hr === "BT" ? (a.attr("x", r.x - (o.width + 4 * Vs + 5)).attr("y", r.y - 12), s.attr("x", r.x - (o.width + 4 * Vs)).attr("y", r.y + o.height - 12)) : s.attr("x", r.posWithOffset - o.width / 2), Ha.rotateCommitLabel))
      if (hr === "TB" || hr === "BT")
        s.attr(
          "transform",
          "rotate(-45, " + r.x + ", " + r.y + ")"
        ), a.attr(
          "transform",
          "rotate(-45, " + r.x + ", " + r.y + ")"
        );
      else {
        const l = -7.5 - (o.width + 10) / 25 * 9.5, u = 10 + o.width / 25 * 8.5;
        i.attr(
          "transform",
          "translate(" + l + ", " + u + ") rotate(-45, " + n + ", " + r.y + ")"
        );
      }
  }
}, "drawCommitLabel"), RRe = /* @__PURE__ */ x((t, e, r, n) => {
  if (e.tags.length > 0) {
    let i = 0, a = 0, s = 0;
    const o = [];
    for (const l of e.tags.reverse()) {
      const u = t.insert("polygon"), h = t.append("circle"), d = t.append("text").attr("y", r.y - 16 - i).attr("class", "tag-label").text(l), f = d.node()?.getBBox();
      if (!f)
        throw new Error("Tag bbox not found");
      a = Math.max(a, f.width), s = Math.max(s, f.height), d.attr("x", r.posWithOffset - f.width / 2), o.push({
        tag: d,
        hole: h,
        rect: u,
        yOffset: i
      }), i += 20;
    }
    for (const { tag: l, hole: u, rect: h, yOffset: d } of o) {
      const f = s / 2, p = r.y - 19.2 - d;
      if (h.attr("class", "tag-label-bkg").attr(
        "points",
        `
      ${n - a / 2 - Vs / 2},${p + Po}  
      ${n - a / 2 - Vs / 2},${p - Po}
      ${r.posWithOffset - a / 2 - Vs},${p - f - Po}
      ${r.posWithOffset + a / 2 + Vs},${p - f - Po}
      ${r.posWithOffset + a / 2 + Vs},${p + f + Po}
      ${r.posWithOffset - a / 2 - Vs},${p + f + Po}`
      ), u.attr("cy", p).attr("cx", n - a / 2 + Vs / 2).attr("r", 1.5).attr("class", "tag-hole"), hr === "TB" || hr === "BT") {
        const g = n + d;
        h.attr("class", "tag-label-bkg").attr(
          "points",
          `
        ${r.x},${g + 2}
        ${r.x},${g - 2}
        ${r.x + Pl},${g - f - 2}
        ${r.x + Pl + a + 4},${g - f - 2}
        ${r.x + Pl + a + 4},${g + f + 2}
        ${r.x + Pl},${g + f + 2}`
        ).attr("transform", "translate(12,12) rotate(45, " + r.x + "," + n + ")"), u.attr("cx", r.x + Vs / 2).attr("cy", g).attr("transform", "translate(12,12) rotate(45, " + r.x + "," + n + ")"), l.attr("x", r.x + 5).attr("y", g + 3).attr("transform", "translate(14,14) rotate(45, " + r.x + "," + n + ")");
      }
    }
  }
}, "drawCommitTags"), MRe = /* @__PURE__ */ x((t) => {
  switch (t.customType ?? t.type) {
    case Mr.NORMAL:
      return "commit-normal";
    case Mr.REVERSE:
      return "commit-reverse";
    case Mr.HIGHLIGHT:
      return "commit-highlight";
    case Mr.MERGE:
      return "commit-merge";
    case Mr.CHERRY_PICK:
      return "commit-cherry-pick";
    default:
      return "commit-normal";
  }
}, "getCommitClassType"), NRe = /* @__PURE__ */ x((t, e, r, n) => {
  const i = { x: 0, y: 0 };
  if (t.parents.length > 0) {
    const a = QW(t.parents);
    if (a) {
      const s = n.get(a) ?? i;
      return e === "TB" ? s.y + Bl : e === "BT" ? (n.get(t.id) ?? i).y - Bl : s.x + Bl;
    }
  } else
    return e === "TB" ? f2 : e === "BT" ? (n.get(t.id) ?? i).y - Bl : 0;
  return 0;
}, "calculatePosition"), IRe = /* @__PURE__ */ x((t, e, r) => {
  const n = hr === "BT" && r ? e : e + Pl, i = hr === "TB" || hr === "BT" ? n : sa.get(t.branch)?.pos, a = hr === "TB" || hr === "BT" ? sa.get(t.branch)?.pos : n;
  if (a === void 0 || i === void 0)
    throw new Error(`Position were undefined for commit ${t.id}`);
  return { x: a, y: i, posWithOffset: n };
}, "getCommitPosition"), yN = /* @__PURE__ */ x((t, e, r) => {
  if (!Ha)
    throw new Error("GitGraph config not found");
  const n = t.append("g").attr("class", "commit-bullets"), i = t.append("g").attr("class", "commit-labels");
  let a = hr === "TB" || hr === "BT" ? f2 : 0;
  const s = [...e.keys()], o = Ha?.parallelCommits ?? !1, l = /* @__PURE__ */ x((h, d) => {
    const f = e.get(h)?.seq, p = e.get(d)?.seq;
    return f !== void 0 && p !== void 0 ? f - p : 0;
  }, "sortKeys");
  let u = s.sort(l);
  hr === "BT" && (o && ERe(u, e, a), u = u.reverse()), u.forEach((h) => {
    const d = e.get(h);
    if (!d)
      throw new Error(`Commit not found for key ${h}`);
    o && (a = NRe(d, hr, a, ca));
    const f = IRe(d, a, o);
    if (r) {
      const p = MRe(d), g = d.customType ?? d.type, m = sa.get(d.branch)?.index ?? 0;
      _Re(n, d, f, p, m, g), LRe(i, d, f, a), RRe(i, d, f, a);
    }
    hr === "TB" || hr === "BT" ? ca.set(d.id, { x: f.x, y: f.posWithOffset }) : ca.set(d.id, { x: f.posWithOffset, y: f.y }), a = hr === "BT" && o ? a + Bl : a + Bl + Pl, a > _l && (_l = a);
  });
}, "drawCommits"), DRe = /* @__PURE__ */ x((t, e, r, n, i) => {
  const s = (hr === "TB" || hr === "BT" ? r.x < n.x : r.y < n.y) ? e.branch : t.branch, o = /* @__PURE__ */ x((u) => u.branch === s, "isOnBranchToGetCurve"), l = /* @__PURE__ */ x((u) => u.seq > t.seq && u.seq < e.seq, "isBetweenCommits");
  return [...i.values()].some((u) => l(u) && o(u));
}, "shouldRerouteArrow"), z0 = /* @__PURE__ */ x((t, e, r = 0) => {
  const n = t + Math.abs(t - e) / 2;
  if (r > 5)
    return n;
  if (p2.every((s) => Math.abs(s - n) >= 10))
    return p2.push(n), n;
  const a = Math.abs(t - e);
  return z0(t, e - a / 5, r + 1);
}, "findLane"), ORe = /* @__PURE__ */ x((t, e, r, n) => {
  const i = ca.get(e.id), a = ca.get(r.id);
  if (i === void 0 || a === void 0)
    throw new Error(`Commit positions not found for commits ${e.id} and ${r.id}`);
  const s = DRe(e, r, i, a, n);
  let o = "", l = "", u = 0, h = 0, d = sa.get(r.branch)?.index;
  r.type === Mr.MERGE && e.id !== r.parents[0] && (d = sa.get(e.branch)?.index);
  let f;
  if (s) {
    o = "A 10 10, 0, 0, 0,", l = "A 10 10, 0, 0, 1,", u = 10, h = 10;
    const p = i.y < a.y ? z0(i.y, a.y) : z0(a.y, i.y), g = i.x < a.x ? z0(i.x, a.x) : z0(a.x, i.x);
    hr === "TB" ? i.x < a.x ? f = `M ${i.x} ${i.y} L ${g - u} ${i.y} ${l} ${g} ${i.y + h} L ${g} ${a.y - u} ${o} ${g + h} ${a.y} L ${a.x} ${a.y}` : (d = sa.get(e.branch)?.index, f = `M ${i.x} ${i.y} L ${g + u} ${i.y} ${o} ${g} ${i.y + h} L ${g} ${a.y - u} ${l} ${g - h} ${a.y} L ${a.x} ${a.y}`) : hr === "BT" ? i.x < a.x ? f = `M ${i.x} ${i.y} L ${g - u} ${i.y} ${o} ${g} ${i.y - h} L ${g} ${a.y + u} ${l} ${g + h} ${a.y} L ${a.x} ${a.y}` : (d = sa.get(e.branch)?.index, f = `M ${i.x} ${i.y} L ${g + u} ${i.y} ${l} ${g} ${i.y - h} L ${g} ${a.y + u} ${o} ${g - h} ${a.y} L ${a.x} ${a.y}`) : i.y < a.y ? f = `M ${i.x} ${i.y} L ${i.x} ${p - u} ${o} ${i.x + h} ${p} L ${a.x - u} ${p} ${l} ${a.x} ${p + h} L ${a.x} ${a.y}` : (d = sa.get(e.branch)?.index, f = `M ${i.x} ${i.y} L ${i.x} ${p + u} ${l} ${i.x + h} ${p} L ${a.x - u} ${p} ${o} ${a.x} ${p - h} L ${a.x} ${a.y}`);
  } else
    o = "A 20 20, 0, 0, 0,", l = "A 20 20, 0, 0, 1,", u = 20, h = 20, hr === "TB" ? (i.x < a.x && (r.type === Mr.MERGE && e.id !== r.parents[0] ? f = `M ${i.x} ${i.y} L ${i.x} ${a.y - u} ${o} ${i.x + h} ${a.y} L ${a.x} ${a.y}` : f = `M ${i.x} ${i.y} L ${a.x - u} ${i.y} ${l} ${a.x} ${i.y + h} L ${a.x} ${a.y}`), i.x > a.x && (o = "A 20 20, 0, 0, 0,", l = "A 20 20, 0, 0, 1,", u = 20, h = 20, r.type === Mr.MERGE && e.id !== r.parents[0] ? f = `M ${i.x} ${i.y} L ${i.x} ${a.y - u} ${l} ${i.x - h} ${a.y} L ${a.x} ${a.y}` : f = `M ${i.x} ${i.y} L ${a.x + u} ${i.y} ${o} ${a.x} ${i.y + h} L ${a.x} ${a.y}`), i.x === a.x && (f = `M ${i.x} ${i.y} L ${a.x} ${a.y}`)) : hr === "BT" ? (i.x < a.x && (r.type === Mr.MERGE && e.id !== r.parents[0] ? f = `M ${i.x} ${i.y} L ${i.x} ${a.y + u} ${l} ${i.x + h} ${a.y} L ${a.x} ${a.y}` : f = `M ${i.x} ${i.y} L ${a.x - u} ${i.y} ${o} ${a.x} ${i.y - h} L ${a.x} ${a.y}`), i.x > a.x && (o = "A 20 20, 0, 0, 0,", l = "A 20 20, 0, 0, 1,", u = 20, h = 20, r.type === Mr.MERGE && e.id !== r.parents[0] ? f = `M ${i.x} ${i.y} L ${i.x} ${a.y + u} ${o} ${i.x - h} ${a.y} L ${a.x} ${a.y}` : f = `M ${i.x} ${i.y} L ${a.x - u} ${i.y} ${o} ${a.x} ${i.y - h} L ${a.x} ${a.y}`), i.x === a.x && (f = `M ${i.x} ${i.y} L ${a.x} ${a.y}`)) : (i.y < a.y && (r.type === Mr.MERGE && e.id !== r.parents[0] ? f = `M ${i.x} ${i.y} L ${a.x - u} ${i.y} ${l} ${a.x} ${i.y + h} L ${a.x} ${a.y}` : f = `M ${i.x} ${i.y} L ${i.x} ${a.y - u} ${o} ${i.x + h} ${a.y} L ${a.x} ${a.y}`), i.y > a.y && (r.type === Mr.MERGE && e.id !== r.parents[0] ? f = `M ${i.x} ${i.y} L ${a.x - u} ${i.y} ${o} ${a.x} ${i.y - h} L ${a.x} ${a.y}` : f = `M ${i.x} ${i.y} L ${i.x} ${a.y + u} ${l} ${i.x + h} ${a.y} L ${a.x} ${a.y}`), i.y === a.y && (f = `M ${i.x} ${i.y} L ${a.x} ${a.y}`));
  if (f === void 0)
    throw new Error("Line definition not found");
  t.append("path").attr("d", f).attr("class", "arrow arrow" + d % Qc);
}, "drawArrow"), PRe = /* @__PURE__ */ x((t, e) => {
  const r = t.append("g").attr("class", "commit-arrows");
  [...e.keys()].forEach((n) => {
    const i = e.get(n);
    i.parents && i.parents.length > 0 && i.parents.forEach((a) => {
      ORe(r, e.get(a), i, e);
    });
  });
}, "drawArrows"), BRe = /* @__PURE__ */ x((t, e) => {
  const r = t.append("g");
  e.forEach((n, i) => {
    const a = i % Qc, s = sa.get(n.name)?.pos;
    if (s === void 0)
      throw new Error(`Position not found for branch ${n.name}`);
    const o = r.append("line");
    o.attr("x1", 0), o.attr("y1", s), o.attr("x2", _l), o.attr("y2", s), o.attr("class", "branch branch" + a), hr === "TB" ? (o.attr("y1", f2), o.attr("x1", s), o.attr("y2", _l), o.attr("x2", s)) : hr === "BT" && (o.attr("y1", _l), o.attr("x1", s), o.attr("y2", f2), o.attr("x2", s)), p2.push(s);
    const l = n.name, u = ZW(l), h = r.insert("rect"), f = r.insert("g").attr("class", "branchLabel").insert("g").attr("class", "label branch-label" + a);
    f.node().appendChild(u);
    const p = u.getBBox();
    h.attr("class", "branchLabelBkg label" + a).attr("rx", 4).attr("ry", 4).attr("x", -p.width - 4 - (Ha?.rotateCommitLabel === !0 ? 30 : 0)).attr("y", -p.height / 2 + 8).attr("width", p.width + 18).attr("height", p.height + 4), f.attr(
      "transform",
      "translate(" + (-p.width - 14 - (Ha?.rotateCommitLabel === !0 ? 30 : 0)) + ", " + (s - p.height / 2 - 1) + ")"
    ), hr === "TB" ? (h.attr("x", s - p.width / 2 - 10).attr("y", 0), f.attr("transform", "translate(" + (s - p.width / 2 - 5) + ", 0)")) : hr === "BT" ? (h.attr("x", s - p.width / 2 - 10).attr("y", _l), f.attr("transform", "translate(" + (s - p.width / 2 - 5) + ", " + _l + ")")) : h.attr("transform", "translate(-19, " + (s - p.height / 2) + ")");
  });
}, "drawBranches"), FRe = /* @__PURE__ */ x(function(t, e, r, n, i) {
  return sa.set(t, { pos: e, index: r }), e += 50 + (i ? 40 : 0) + (hr === "TB" || hr === "BT" ? n.width / 2 : 0), e;
}, "setBranchPosition"), $Re = /* @__PURE__ */ x(function(t, e, r, n) {
  if (wRe(), ie.debug("in gitgraph renderer", t + `
`, "id:", e, r), !Ha)
    throw new Error("GitGraph config not found");
  const i = Ha.rotateCommitLabel ?? !1, a = n.db;
  $0 = a.getCommits();
  const s = a.getBranchesAsObjArray();
  hr = a.getDirection();
  const o = Qe(`[id="${e}"]`);
  let l = 0;
  s.forEach((u, h) => {
    const d = ZW(u.name), f = o.append("g"), p = f.insert("g").attr("class", "branchLabel"), g = p.insert("g").attr("class", "label branch-label");
    g.node()?.appendChild(d);
    const m = d.getBBox();
    l = FRe(u.name, l, h, m, i), g.remove(), p.remove(), f.remove();
  }), yN(o, $0, !1), Ha.showBranches && BRe(o, s), PRe(o, $0), yN(o, $0, !0), Zt.insertTitle(
    o,
    "gitTitleText",
    Ha.titleTopMargin ?? 0,
    a.getDiagramTitle()
  ), FI(
    void 0,
    o,
    Ha.diagramPadding,
    Ha.useMaxWidth
  );
}, "draw"), zRe = {
  draw: $Re
}, GRe = /* @__PURE__ */ x((t) => `
  .commit-id,
  .commit-msg,
  .branch-label {
    fill: lightgrey;
    color: lightgrey;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  ${[0, 1, 2, 3, 4, 5, 6, 7].map(
  (e) => `
        .branch-label${e} { fill: ${t["gitBranchLabel" + e]}; }
        .commit${e} { stroke: ${t["git" + e]}; fill: ${t["git" + e]}; }
        .commit-highlight${e} { stroke: ${t["gitInv" + e]}; fill: ${t["gitInv" + e]}; }
        .label${e}  { fill: ${t["git" + e]}; }
        .arrow${e} { stroke: ${t["git" + e]}; }
        `
).join(`
`)}

  .branch {
    stroke-width: 1;
    stroke: ${t.lineColor};
    stroke-dasharray: 2;
  }
  .commit-label { font-size: ${t.commitLabelFontSize}; fill: ${t.commitLabelColor};}
  .commit-label-bkg { font-size: ${t.commitLabelFontSize}; fill: ${t.commitLabelBackground}; opacity: 0.5; }
  .tag-label { font-size: ${t.tagLabelFontSize}; fill: ${t.tagLabelColor};}
  .tag-label-bkg { fill: ${t.tagLabelBackground}; stroke: ${t.tagLabelBorder}; }
  .tag-hole { fill: ${t.textColor}; }

  .commit-merge {
    stroke: ${t.primaryColor};
    fill: ${t.primaryColor};
  }
  .commit-reverse {
    stroke: ${t.primaryColor};
    fill: ${t.primaryColor};
    stroke-width: 3;
  }
  .commit-highlight-outer {
  }
  .commit-highlight-inner {
    stroke: ${t.primaryColor};
    fill: ${t.primaryColor};
  }

  .arrow { stroke-width: 8; stroke-linecap: round; fill: none}
  .gitTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${t.textColor};
  }
`, "getStyles"), VRe = GRe, URe = {
  parser: xRe,
  db: KW,
  renderer: zRe,
  styles: VRe
};
const HRe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: URe
}, Symbol.toStringTag, { value: "Module" }));
var hv = { exports: {} }, qRe = hv.exports, xN;
function WRe() {
  return xN || (xN = 1, (function(t, e) {
    (function(r, n) {
      t.exports = n();
    })(qRe, (function() {
      var r = "day";
      return function(n, i, a) {
        var s = function(u) {
          return u.add(4 - u.isoWeekday(), r);
        }, o = i.prototype;
        o.isoWeekYear = function() {
          return s(this).year();
        }, o.isoWeek = function(u) {
          if (!this.$utils().u(u)) return this.add(7 * (u - this.isoWeek()), r);
          var h, d, f, p, g = s(this), m = (h = this.isoWeekYear(), d = this.$u, f = (d ? a.utc : a)().year(h).startOf("year"), p = 4 - f.isoWeekday(), f.isoWeekday() > 4 && (p += 7), f.add(p, r));
          return g.diff(m, "week") + 1;
        }, o.isoWeekday = function(u) {
          return this.$utils().u(u) ? this.day() || 7 : this.day(this.day() % 7 ? u : u - 7);
        };
        var l = o.startOf;
        o.startOf = function(u, h) {
          var d = this.$utils(), f = !!d.u(h) || h;
          return d.p(u) === "isoweek" ? f ? this.date(this.date() - (this.isoWeekday() - 1)).startOf("day") : this.date(this.date() - 1 - (this.isoWeekday() - 1) + 7).endOf("day") : l.bind(this)(u, h);
        };
      };
    }));
  })(hv)), hv.exports;
}
var YRe = WRe();
const XRe = /* @__PURE__ */ $u(YRe);
var dv = { exports: {} }, jRe = dv.exports, bN;
function KRe() {
  return bN || (bN = 1, (function(t, e) {
    (function(r, n) {
      t.exports = n();
    })(jRe, (function() {
      var r = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, n = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, i = /\d/, a = /\d\d/, s = /\d\d?/, o = /\d*[^-_:/,()\s\d]+/, l = {}, u = function(v) {
        return (v = +v) + (v > 68 ? 1900 : 2e3);
      }, h = function(v) {
        return function(y) {
          this[v] = +y;
        };
      }, d = [/[+-]\d\d:?(\d\d)?|Z/, function(v) {
        (this.zone || (this.zone = {})).offset = (function(y) {
          if (!y || y === "Z") return 0;
          var b = y.match(/([+-]|\d\d)/g), w = 60 * b[1] + (+b[2] || 0);
          return w === 0 ? 0 : b[0] === "+" ? -w : w;
        })(v);
      }], f = function(v) {
        var y = l[v];
        return y && (y.indexOf ? y : y.s.concat(y.f));
      }, p = function(v, y) {
        var b, w = l.meridiem;
        if (w) {
          for (var T = 1; T <= 24; T += 1) if (v.indexOf(w(T, 0, y)) > -1) {
            b = T > 12;
            break;
          }
        } else b = v === (y ? "pm" : "PM");
        return b;
      }, g = { A: [o, function(v) {
        this.afternoon = p(v, !1);
      }], a: [o, function(v) {
        this.afternoon = p(v, !0);
      }], Q: [i, function(v) {
        this.month = 3 * (v - 1) + 1;
      }], S: [i, function(v) {
        this.milliseconds = 100 * +v;
      }], SS: [a, function(v) {
        this.milliseconds = 10 * +v;
      }], SSS: [/\d{3}/, function(v) {
        this.milliseconds = +v;
      }], s: [s, h("seconds")], ss: [s, h("seconds")], m: [s, h("minutes")], mm: [s, h("minutes")], H: [s, h("hours")], h: [s, h("hours")], HH: [s, h("hours")], hh: [s, h("hours")], D: [s, h("day")], DD: [a, h("day")], Do: [o, function(v) {
        var y = l.ordinal, b = v.match(/\d+/);
        if (this.day = b[0], y) for (var w = 1; w <= 31; w += 1) y(w).replace(/\[|\]/g, "") === v && (this.day = w);
      }], w: [s, h("week")], ww: [a, h("week")], M: [s, h("month")], MM: [a, h("month")], MMM: [o, function(v) {
        var y = f("months"), b = (f("monthsShort") || y.map((function(w) {
          return w.slice(0, 3);
        }))).indexOf(v) + 1;
        if (b < 1) throw new Error();
        this.month = b % 12 || b;
      }], MMMM: [o, function(v) {
        var y = f("months").indexOf(v) + 1;
        if (y < 1) throw new Error();
        this.month = y % 12 || y;
      }], Y: [/[+-]?\d+/, h("year")], YY: [a, function(v) {
        this.year = u(v);
      }], YYYY: [/\d{4}/, h("year")], Z: d, ZZ: d };
      function m(v) {
        var y, b;
        y = v, b = l && l.formats;
        for (var w = (v = y.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (function(R, _, O) {
          var P = O && O.toUpperCase();
          return _ || b[O] || r[O] || b[P].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(S, M, N) {
            return M || N.slice(1);
          }));
        }))).match(n), T = w.length, E = 0; E < T; E += 1) {
          var L = w[E], k = g[L], C = k && k[0], A = k && k[1];
          w[E] = A ? { regex: C, parser: A } : L.replace(/^\[|\]$/g, "");
        }
        return function(R) {
          for (var _ = {}, O = 0, P = 0; O < T; O += 1) {
            var S = w[O];
            if (typeof S == "string") P += S.length;
            else {
              var M = S.regex, N = S.parser, D = R.slice(P), I = M.exec(D)[0];
              N.call(_, I), R = R.replace(I, "");
            }
          }
          return (function(B) {
            var z = B.afternoon;
            if (z !== void 0) {
              var F = B.hours;
              z ? F < 12 && (B.hours += 12) : F === 12 && (B.hours = 0), delete B.afternoon;
            }
          })(_), _;
        };
      }
      return function(v, y, b) {
        b.p.customParseFormat = !0, v && v.parseTwoDigitYear && (u = v.parseTwoDigitYear);
        var w = y.prototype, T = w.parse;
        w.parse = function(E) {
          var L = E.date, k = E.utc, C = E.args;
          this.$u = k;
          var A = C[1];
          if (typeof A == "string") {
            var R = C[2] === !0, _ = C[3] === !0, O = R || _, P = C[2];
            _ && (P = C[2]), l = this.$locale(), !R && P && (l = b.Ls[P]), this.$d = (function(D, I, B, z) {
              try {
                if (["x", "X"].indexOf(I) > -1) return new Date((I === "X" ? 1e3 : 1) * D);
                var F = m(I)(D), V = F.year, H = F.month, J = F.day, q = F.hours, ae = F.minutes, re = F.seconds, pe = F.milliseconds, K = F.zone, Z = F.week, X = /* @__PURE__ */ new Date(), Y = J || (V || H ? 1 : X.getDate()), ee = V || X.getFullYear(), j = 0;
                V && !H || (j = H > 0 ? H - 1 : X.getMonth());
                var fe, te = q || 0, Ae = ae || 0, W = re || 0, De = pe || 0;
                return K ? new Date(Date.UTC(ee, j, Y, te, Ae, W, De + 60 * K.offset * 1e3)) : B ? new Date(Date.UTC(ee, j, Y, te, Ae, W, De)) : (fe = new Date(ee, j, Y, te, Ae, W, De), Z && (fe = z(fe).week(Z).toDate()), fe);
              } catch {
                return /* @__PURE__ */ new Date("");
              }
            })(L, A, k, b), this.init(), P && P !== !0 && (this.$L = this.locale(P).$L), O && L != this.format(A) && (this.$d = /* @__PURE__ */ new Date("")), l = {};
          } else if (A instanceof Array) for (var S = A.length, M = 1; M <= S; M += 1) {
            C[1] = A[M - 1];
            var N = b.apply(this, C);
            if (N.isValid()) {
              this.$d = N.$d, this.$L = N.$L, this.init();
              break;
            }
            M === S && (this.$d = /* @__PURE__ */ new Date(""));
          }
          else T.call(this, E);
        };
      };
    }));
  })(dv)), dv.exports;
}
var ZRe = KRe();
const QRe = /* @__PURE__ */ $u(ZRe);
var fv = { exports: {} }, JRe = fv.exports, wN;
function eMe() {
  return wN || (wN = 1, (function(t, e) {
    (function(r, n) {
      t.exports = n();
    })(JRe, (function() {
      return function(r, n) {
        var i = n.prototype, a = i.format;
        i.format = function(s) {
          var o = this, l = this.$locale();
          if (!this.isValid()) return a.bind(this)(s);
          var u = this.$utils(), h = (s || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, (function(d) {
            switch (d) {
              case "Q":
                return Math.ceil((o.$M + 1) / 3);
              case "Do":
                return l.ordinal(o.$D);
              case "gggg":
                return o.weekYear();
              case "GGGG":
                return o.isoWeekYear();
              case "wo":
                return l.ordinal(o.week(), "W");
              case "w":
              case "ww":
                return u.s(o.week(), d === "w" ? 1 : 2, "0");
              case "W":
              case "WW":
                return u.s(o.isoWeek(), d === "W" ? 1 : 2, "0");
              case "k":
              case "kk":
                return u.s(String(o.$H === 0 ? 24 : o.$H), d === "k" ? 1 : 2, "0");
              case "X":
                return Math.floor(o.$d.getTime() / 1e3);
              case "x":
                return o.$d.getTime();
              case "z":
                return "[" + o.offsetName() + "]";
              case "zzz":
                return "[" + o.offsetName("long") + "]";
              default:
                return d;
            }
          }));
          return a.bind(this)(h);
        };
      };
    }));
  })(fv)), fv.exports;
}
var tMe = eMe();
const rMe = /* @__PURE__ */ $u(tMe);
var pv = { exports: {} }, nMe = pv.exports, TN;
function iMe() {
  return TN || (TN = 1, (function(t, e) {
    (function(r, n) {
      t.exports = n();
    })(nMe, (function() {
      var r, n, i = 1e3, a = 6e4, s = 36e5, o = 864e5, l = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, u = 31536e6, h = 2628e6, d = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/, f = { years: u, months: h, days: o, hours: s, minutes: a, seconds: i, milliseconds: 1, weeks: 6048e5 }, p = function(L) {
        return L instanceof T;
      }, g = function(L, k, C) {
        return new T(L, C, k.$l);
      }, m = function(L) {
        return n.p(L) + "s";
      }, v = function(L) {
        return L < 0;
      }, y = function(L) {
        return v(L) ? Math.ceil(L) : Math.floor(L);
      }, b = function(L) {
        return Math.abs(L);
      }, w = function(L, k) {
        return L ? v(L) ? { negative: !0, format: "" + b(L) + k } : { negative: !1, format: "" + L + k } : { negative: !1, format: "" };
      }, T = (function() {
        function L(C, A, R) {
          var _ = this;
          if (this.$d = {}, this.$l = R, C === void 0 && (this.$ms = 0, this.parseFromMilliseconds()), A) return g(C * f[m(A)], this);
          if (typeof C == "number") return this.$ms = C, this.parseFromMilliseconds(), this;
          if (typeof C == "object") return Object.keys(C).forEach((function(S) {
            _.$d[m(S)] = C[S];
          })), this.calMilliseconds(), this;
          if (typeof C == "string") {
            var O = C.match(d);
            if (O) {
              var P = O.slice(2).map((function(S) {
                return S != null ? Number(S) : 0;
              }));
              return this.$d.years = P[0], this.$d.months = P[1], this.$d.weeks = P[2], this.$d.days = P[3], this.$d.hours = P[4], this.$d.minutes = P[5], this.$d.seconds = P[6], this.calMilliseconds(), this;
            }
          }
          return this;
        }
        var k = L.prototype;
        return k.calMilliseconds = function() {
          var C = this;
          this.$ms = Object.keys(this.$d).reduce((function(A, R) {
            return A + (C.$d[R] || 0) * f[R];
          }), 0);
        }, k.parseFromMilliseconds = function() {
          var C = this.$ms;
          this.$d.years = y(C / u), C %= u, this.$d.months = y(C / h), C %= h, this.$d.days = y(C / o), C %= o, this.$d.hours = y(C / s), C %= s, this.$d.minutes = y(C / a), C %= a, this.$d.seconds = y(C / i), C %= i, this.$d.milliseconds = C;
        }, k.toISOString = function() {
          var C = w(this.$d.years, "Y"), A = w(this.$d.months, "M"), R = +this.$d.days || 0;
          this.$d.weeks && (R += 7 * this.$d.weeks);
          var _ = w(R, "D"), O = w(this.$d.hours, "H"), P = w(this.$d.minutes, "M"), S = this.$d.seconds || 0;
          this.$d.milliseconds && (S += this.$d.milliseconds / 1e3, S = Math.round(1e3 * S) / 1e3);
          var M = w(S, "S"), N = C.negative || A.negative || _.negative || O.negative || P.negative || M.negative, D = O.format || P.format || M.format ? "T" : "", I = (N ? "-" : "") + "P" + C.format + A.format + _.format + D + O.format + P.format + M.format;
          return I === "P" || I === "-P" ? "P0D" : I;
        }, k.toJSON = function() {
          return this.toISOString();
        }, k.format = function(C) {
          var A = C || "YYYY-MM-DDTHH:mm:ss", R = { Y: this.$d.years, YY: n.s(this.$d.years, 2, "0"), YYYY: n.s(this.$d.years, 4, "0"), M: this.$d.months, MM: n.s(this.$d.months, 2, "0"), D: this.$d.days, DD: n.s(this.$d.days, 2, "0"), H: this.$d.hours, HH: n.s(this.$d.hours, 2, "0"), m: this.$d.minutes, mm: n.s(this.$d.minutes, 2, "0"), s: this.$d.seconds, ss: n.s(this.$d.seconds, 2, "0"), SSS: n.s(this.$d.milliseconds, 3, "0") };
          return A.replace(l, (function(_, O) {
            return O || String(R[_]);
          }));
        }, k.as = function(C) {
          return this.$ms / f[m(C)];
        }, k.get = function(C) {
          var A = this.$ms, R = m(C);
          return R === "milliseconds" ? A %= 1e3 : A = R === "weeks" ? y(A / f[R]) : this.$d[R], A || 0;
        }, k.add = function(C, A, R) {
          var _;
          return _ = A ? C * f[m(A)] : p(C) ? C.$ms : g(C, this).$ms, g(this.$ms + _ * (R ? -1 : 1), this);
        }, k.subtract = function(C, A) {
          return this.add(C, A, !0);
        }, k.locale = function(C) {
          var A = this.clone();
          return A.$l = C, A;
        }, k.clone = function() {
          return g(this.$ms, this);
        }, k.humanize = function(C) {
          return r().add(this.$ms, "ms").locale(this.$l).fromNow(!C);
        }, k.valueOf = function() {
          return this.asMilliseconds();
        }, k.milliseconds = function() {
          return this.get("milliseconds");
        }, k.asMilliseconds = function() {
          return this.as("milliseconds");
        }, k.seconds = function() {
          return this.get("seconds");
        }, k.asSeconds = function() {
          return this.as("seconds");
        }, k.minutes = function() {
          return this.get("minutes");
        }, k.asMinutes = function() {
          return this.as("minutes");
        }, k.hours = function() {
          return this.get("hours");
        }, k.asHours = function() {
          return this.as("hours");
        }, k.days = function() {
          return this.get("days");
        }, k.asDays = function() {
          return this.as("days");
        }, k.weeks = function() {
          return this.get("weeks");
        }, k.asWeeks = function() {
          return this.as("weeks");
        }, k.months = function() {
          return this.get("months");
        }, k.asMonths = function() {
          return this.as("months");
        }, k.years = function() {
          return this.get("years");
        }, k.asYears = function() {
          return this.as("years");
        }, L;
      })(), E = function(L, k, C) {
        return L.add(k.years() * C, "y").add(k.months() * C, "M").add(k.days() * C, "d").add(k.hours() * C, "h").add(k.minutes() * C, "m").add(k.seconds() * C, "s").add(k.milliseconds() * C, "ms");
      };
      return function(L, k, C) {
        r = C, n = C().$utils(), C.duration = function(_, O) {
          var P = C.locale();
          return g(_, { $l: P }, O);
        }, C.isDuration = p;
        var A = k.prototype.add, R = k.prototype.subtract;
        k.prototype.add = function(_, O) {
          return p(_) ? E(this, _, 1) : A.bind(this)(_, O);
        }, k.prototype.subtract = function(_, O) {
          return p(_) ? E(this, _, -1) : R.bind(this)(_, O);
        };
      };
    }));
  })(pv)), pv.exports;
}
var aMe = iMe();
const sMe = /* @__PURE__ */ $u(aMe);
var k6 = (function() {
  var t = /* @__PURE__ */ x(function(P, S, M, N) {
    for (M = M || {}, N = P.length; N--; M[P[N]] = S) ;
    return M;
  }, "o"), e = [6, 8, 10, 12, 13, 14, 15, 16, 17, 18, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 33, 35, 36, 38, 40], r = [1, 26], n = [1, 27], i = [1, 28], a = [1, 29], s = [1, 30], o = [1, 31], l = [1, 32], u = [1, 33], h = [1, 34], d = [1, 9], f = [1, 10], p = [1, 11], g = [1, 12], m = [1, 13], v = [1, 14], y = [1, 15], b = [1, 16], w = [1, 19], T = [1, 20], E = [1, 21], L = [1, 22], k = [1, 23], C = [1, 25], A = [1, 35], R = {
    trace: /* @__PURE__ */ x(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, gantt: 4, document: 5, EOF: 6, line: 7, SPACE: 8, statement: 9, NL: 10, weekday: 11, weekday_monday: 12, weekday_tuesday: 13, weekday_wednesday: 14, weekday_thursday: 15, weekday_friday: 16, weekday_saturday: 17, weekday_sunday: 18, weekend: 19, weekend_friday: 20, weekend_saturday: 21, dateFormat: 22, inclusiveEndDates: 23, topAxis: 24, axisFormat: 25, tickInterval: 26, excludes: 27, includes: 28, todayMarker: 29, title: 30, acc_title: 31, acc_title_value: 32, acc_descr: 33, acc_descr_value: 34, acc_descr_multiline_value: 35, section: 36, clickStatement: 37, taskTxt: 38, taskData: 39, click: 40, callbackname: 41, callbackargs: 42, href: 43, clickStatementDebug: 44, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "gantt", 6: "EOF", 8: "SPACE", 10: "NL", 12: "weekday_monday", 13: "weekday_tuesday", 14: "weekday_wednesday", 15: "weekday_thursday", 16: "weekday_friday", 17: "weekday_saturday", 18: "weekday_sunday", 20: "weekend_friday", 21: "weekend_saturday", 22: "dateFormat", 23: "inclusiveEndDates", 24: "topAxis", 25: "axisFormat", 26: "tickInterval", 27: "excludes", 28: "includes", 29: "todayMarker", 30: "title", 31: "acc_title", 32: "acc_title_value", 33: "acc_descr", 34: "acc_descr_value", 35: "acc_descr_multiline_value", 36: "section", 38: "taskTxt", 39: "taskData", 40: "click", 41: "callbackname", 42: "callbackargs", 43: "href" },
    productions_: [0, [3, 3], [5, 0], [5, 2], [7, 2], [7, 1], [7, 1], [7, 1], [11, 1], [11, 1], [11, 1], [11, 1], [11, 1], [11, 1], [11, 1], [19, 1], [19, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 2], [9, 2], [9, 1], [9, 1], [9, 1], [9, 2], [37, 2], [37, 3], [37, 3], [37, 4], [37, 3], [37, 4], [37, 2], [44, 2], [44, 3], [44, 3], [44, 4], [44, 3], [44, 4], [44, 2]],
    performAction: /* @__PURE__ */ x(function(S, M, N, D, I, B, z) {
      var F = B.length - 1;
      switch (I) {
        case 1:
          return B[F - 1];
        case 2:
          this.$ = [];
          break;
        case 3:
          B[F - 1].push(B[F]), this.$ = B[F - 1];
          break;
        case 4:
        case 5:
          this.$ = B[F];
          break;
        case 6:
        case 7:
          this.$ = [];
          break;
        case 8:
          D.setWeekday("monday");
          break;
        case 9:
          D.setWeekday("tuesday");
          break;
        case 10:
          D.setWeekday("wednesday");
          break;
        case 11:
          D.setWeekday("thursday");
          break;
        case 12:
          D.setWeekday("friday");
          break;
        case 13:
          D.setWeekday("saturday");
          break;
        case 14:
          D.setWeekday("sunday");
          break;
        case 15:
          D.setWeekend("friday");
          break;
        case 16:
          D.setWeekend("saturday");
          break;
        case 17:
          D.setDateFormat(B[F].substr(11)), this.$ = B[F].substr(11);
          break;
        case 18:
          D.enableInclusiveEndDates(), this.$ = B[F].substr(18);
          break;
        case 19:
          D.TopAxis(), this.$ = B[F].substr(8);
          break;
        case 20:
          D.setAxisFormat(B[F].substr(11)), this.$ = B[F].substr(11);
          break;
        case 21:
          D.setTickInterval(B[F].substr(13)), this.$ = B[F].substr(13);
          break;
        case 22:
          D.setExcludes(B[F].substr(9)), this.$ = B[F].substr(9);
          break;
        case 23:
          D.setIncludes(B[F].substr(9)), this.$ = B[F].substr(9);
          break;
        case 24:
          D.setTodayMarker(B[F].substr(12)), this.$ = B[F].substr(12);
          break;
        case 27:
          D.setDiagramTitle(B[F].substr(6)), this.$ = B[F].substr(6);
          break;
        case 28:
          this.$ = B[F].trim(), D.setAccTitle(this.$);
          break;
        case 29:
        case 30:
          this.$ = B[F].trim(), D.setAccDescription(this.$);
          break;
        case 31:
          D.addSection(B[F].substr(8)), this.$ = B[F].substr(8);
          break;
        case 33:
          D.addTask(B[F - 1], B[F]), this.$ = "task";
          break;
        case 34:
          this.$ = B[F - 1], D.setClickEvent(B[F - 1], B[F], null);
          break;
        case 35:
          this.$ = B[F - 2], D.setClickEvent(B[F - 2], B[F - 1], B[F]);
          break;
        case 36:
          this.$ = B[F - 2], D.setClickEvent(B[F - 2], B[F - 1], null), D.setLink(B[F - 2], B[F]);
          break;
        case 37:
          this.$ = B[F - 3], D.setClickEvent(B[F - 3], B[F - 2], B[F - 1]), D.setLink(B[F - 3], B[F]);
          break;
        case 38:
          this.$ = B[F - 2], D.setClickEvent(B[F - 2], B[F], null), D.setLink(B[F - 2], B[F - 1]);
          break;
        case 39:
          this.$ = B[F - 3], D.setClickEvent(B[F - 3], B[F - 1], B[F]), D.setLink(B[F - 3], B[F - 2]);
          break;
        case 40:
          this.$ = B[F - 1], D.setLink(B[F - 1], B[F]);
          break;
        case 41:
        case 47:
          this.$ = B[F - 1] + " " + B[F];
          break;
        case 42:
        case 43:
        case 45:
          this.$ = B[F - 2] + " " + B[F - 1] + " " + B[F];
          break;
        case 44:
        case 46:
          this.$ = B[F - 3] + " " + B[F - 2] + " " + B[F - 1] + " " + B[F];
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, t(e, [2, 2], { 5: 3 }), { 6: [1, 4], 7: 5, 8: [1, 6], 9: 7, 10: [1, 8], 11: 17, 12: r, 13: n, 14: i, 15: a, 16: s, 17: o, 18: l, 19: 18, 20: u, 21: h, 22: d, 23: f, 24: p, 25: g, 26: m, 27: v, 28: y, 29: b, 30: w, 31: T, 33: E, 35: L, 36: k, 37: 24, 38: C, 40: A }, t(e, [2, 7], { 1: [2, 1] }), t(e, [2, 3]), { 9: 36, 11: 17, 12: r, 13: n, 14: i, 15: a, 16: s, 17: o, 18: l, 19: 18, 20: u, 21: h, 22: d, 23: f, 24: p, 25: g, 26: m, 27: v, 28: y, 29: b, 30: w, 31: T, 33: E, 35: L, 36: k, 37: 24, 38: C, 40: A }, t(e, [2, 5]), t(e, [2, 6]), t(e, [2, 17]), t(e, [2, 18]), t(e, [2, 19]), t(e, [2, 20]), t(e, [2, 21]), t(e, [2, 22]), t(e, [2, 23]), t(e, [2, 24]), t(e, [2, 25]), t(e, [2, 26]), t(e, [2, 27]), { 32: [1, 37] }, { 34: [1, 38] }, t(e, [2, 30]), t(e, [2, 31]), t(e, [2, 32]), { 39: [1, 39] }, t(e, [2, 8]), t(e, [2, 9]), t(e, [2, 10]), t(e, [2, 11]), t(e, [2, 12]), t(e, [2, 13]), t(e, [2, 14]), t(e, [2, 15]), t(e, [2, 16]), { 41: [1, 40], 43: [1, 41] }, t(e, [2, 4]), t(e, [2, 28]), t(e, [2, 29]), t(e, [2, 33]), t(e, [2, 34], { 42: [1, 42], 43: [1, 43] }), t(e, [2, 40], { 41: [1, 44] }), t(e, [2, 35], { 43: [1, 45] }), t(e, [2, 36]), t(e, [2, 38], { 42: [1, 46] }), t(e, [2, 37]), t(e, [2, 39])],
    defaultActions: {},
    parseError: /* @__PURE__ */ x(function(S, M) {
      if (M.recoverable)
        this.trace(S);
      else {
        var N = new Error(S);
        throw N.hash = M, N;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ x(function(S) {
      var M = this, N = [0], D = [], I = [null], B = [], z = this.table, F = "", V = 0, H = 0, J = 2, q = 1, ae = B.slice.call(arguments, 1), re = Object.create(this.lexer), pe = { yy: {} };
      for (var K in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, K) && (pe.yy[K] = this.yy[K]);
      re.setInput(S, pe.yy), pe.yy.lexer = re, pe.yy.parser = this, typeof re.yylloc > "u" && (re.yylloc = {});
      var Z = re.yylloc;
      B.push(Z);
      var X = re.options && re.options.ranges;
      typeof pe.yy.parseError == "function" ? this.parseError = pe.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Y(ke) {
        N.length = N.length - 2 * ke, I.length = I.length - ke, B.length = B.length - ke;
      }
      x(Y, "popStack");
      function ee() {
        var ke;
        return ke = D.pop() || re.lex() || q, typeof ke != "number" && (ke instanceof Array && (D = ke, ke = D.pop()), ke = M.symbols_[ke] || ke), ke;
      }
      x(ee, "lex");
      for (var j, fe, te, Ae, W = {}, De, ue, ze, Ge; ; ) {
        if (fe = N[N.length - 1], this.defaultActions[fe] ? te = this.defaultActions[fe] : ((j === null || typeof j > "u") && (j = ee()), te = z[fe] && z[fe][j]), typeof te > "u" || !te.length || !te[0]) {
          var Ve = "";
          Ge = [];
          for (De in z[fe])
            this.terminals_[De] && De > J && Ge.push("'" + this.terminals_[De] + "'");
          re.showPosition ? Ve = "Parse error on line " + (V + 1) + `:
` + re.showPosition() + `
Expecting ` + Ge.join(", ") + ", got '" + (this.terminals_[j] || j) + "'" : Ve = "Parse error on line " + (V + 1) + ": Unexpected " + (j == q ? "end of input" : "'" + (this.terminals_[j] || j) + "'"), this.parseError(Ve, {
            text: re.match,
            token: this.terminals_[j] || j,
            line: re.yylineno,
            loc: Z,
            expected: Ge
          });
        }
        if (te[0] instanceof Array && te.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + fe + ", token: " + j);
        switch (te[0]) {
          case 1:
            N.push(j), I.push(re.yytext), B.push(re.yylloc), N.push(te[1]), j = null, H = re.yyleng, F = re.yytext, V = re.yylineno, Z = re.yylloc;
            break;
          case 2:
            if (ue = this.productions_[te[1]][1], W.$ = I[I.length - ue], W._$ = {
              first_line: B[B.length - (ue || 1)].first_line,
              last_line: B[B.length - 1].last_line,
              first_column: B[B.length - (ue || 1)].first_column,
              last_column: B[B.length - 1].last_column
            }, X && (W._$.range = [
              B[B.length - (ue || 1)].range[0],
              B[B.length - 1].range[1]
            ]), Ae = this.performAction.apply(W, [
              F,
              H,
              V,
              pe.yy,
              te[1],
              I,
              B
            ].concat(ae)), typeof Ae < "u")
              return Ae;
            ue && (N = N.slice(0, -1 * ue * 2), I = I.slice(0, -1 * ue), B = B.slice(0, -1 * ue)), N.push(this.productions_[te[1]][0]), I.push(W.$), B.push(W._$), ze = z[N[N.length - 2]][N[N.length - 1]], N.push(ze);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, _ = /* @__PURE__ */ (function() {
    var P = {
      EOF: 1,
      parseError: /* @__PURE__ */ x(function(M, N) {
        if (this.yy.parser)
          this.yy.parser.parseError(M, N);
        else
          throw new Error(M);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ x(function(S, M) {
        return this.yy = M || this.yy || {}, this._input = S, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ x(function() {
        var S = this._input[0];
        this.yytext += S, this.yyleng++, this.offset++, this.match += S, this.matched += S;
        var M = S.match(/(?:\r\n?|\n).*/g);
        return M ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), S;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ x(function(S) {
        var M = S.length, N = S.split(/(?:\r\n?|\n)/g);
        this._input = S + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - M), this.offset -= M;
        var D = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), N.length - 1 && (this.yylineno -= N.length - 1);
        var I = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: N ? (N.length === D.length ? this.yylloc.first_column : 0) + D[D.length - N.length].length - N[0].length : this.yylloc.first_column - M
        }, this.options.ranges && (this.yylloc.range = [I[0], I[0] + this.yyleng - M]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ x(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ x(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ x(function(S) {
        this.unput(this.match.slice(S));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ x(function() {
        var S = this.matched.substr(0, this.matched.length - this.match.length);
        return (S.length > 20 ? "..." : "") + S.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ x(function() {
        var S = this.match;
        return S.length < 20 && (S += this._input.substr(0, 20 - S.length)), (S.substr(0, 20) + (S.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ x(function() {
        var S = this.pastInput(), M = new Array(S.length + 1).join("-");
        return S + this.upcomingInput() + `
` + M + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ x(function(S, M) {
        var N, D, I;
        if (this.options.backtrack_lexer && (I = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (I.yylloc.range = this.yylloc.range.slice(0))), D = S[0].match(/(?:\r\n?|\n).*/g), D && (this.yylineno += D.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: D ? D[D.length - 1].length - D[D.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + S[0].length
        }, this.yytext += S[0], this.match += S[0], this.matches = S, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(S[0].length), this.matched += S[0], N = this.performAction.call(this, this.yy, this, M, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), N)
          return N;
        if (this._backtrack) {
          for (var B in I)
            this[B] = I[B];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ x(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var S, M, N, D;
        this._more || (this.yytext = "", this.match = "");
        for (var I = this._currentRules(), B = 0; B < I.length; B++)
          if (N = this._input.match(this.rules[I[B]]), N && (!M || N[0].length > M[0].length)) {
            if (M = N, D = B, this.options.backtrack_lexer) {
              if (S = this.test_match(N, I[B]), S !== !1)
                return S;
              if (this._backtrack) {
                M = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return M ? (S = this.test_match(M, I[D]), S !== !1 ? S : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ x(function() {
        var M = this.next();
        return M || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ x(function(M) {
        this.conditionStack.push(M);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ x(function() {
        var M = this.conditionStack.length - 1;
        return M > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ x(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ x(function(M) {
        return M = this.conditionStack.length - 1 - Math.abs(M || 0), M >= 0 ? this.conditionStack[M] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ x(function(M) {
        this.begin(M);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ x(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ x(function(M, N, D, I) {
        switch (D) {
          case 0:
            return this.begin("open_directive"), "open_directive";
          case 1:
            return this.begin("acc_title"), 31;
          case 2:
            return this.popState(), "acc_title_value";
          case 3:
            return this.begin("acc_descr"), 33;
          case 4:
            return this.popState(), "acc_descr_value";
          case 5:
            this.begin("acc_descr_multiline");
            break;
          case 6:
            this.popState();
            break;
          case 7:
            return "acc_descr_multiline_value";
          case 8:
            break;
          case 9:
            break;
          case 10:
            break;
          case 11:
            return 10;
          case 12:
            break;
          case 13:
            break;
          case 14:
            this.begin("href");
            break;
          case 15:
            this.popState();
            break;
          case 16:
            return 43;
          case 17:
            this.begin("callbackname");
            break;
          case 18:
            this.popState();
            break;
          case 19:
            this.popState(), this.begin("callbackargs");
            break;
          case 20:
            return 41;
          case 21:
            this.popState();
            break;
          case 22:
            return 42;
          case 23:
            this.begin("click");
            break;
          case 24:
            this.popState();
            break;
          case 25:
            return 40;
          case 26:
            return 4;
          case 27:
            return 22;
          case 28:
            return 23;
          case 29:
            return 24;
          case 30:
            return 25;
          case 31:
            return 26;
          case 32:
            return 28;
          case 33:
            return 27;
          case 34:
            return 29;
          case 35:
            return 12;
          case 36:
            return 13;
          case 37:
            return 14;
          case 38:
            return 15;
          case 39:
            return 16;
          case 40:
            return 17;
          case 41:
            return 18;
          case 42:
            return 20;
          case 43:
            return 21;
          case 44:
            return "date";
          case 45:
            return 30;
          case 46:
            return "accDescription";
          case 47:
            return 36;
          case 48:
            return 38;
          case 49:
            return 39;
          case 50:
            return ":";
          case 51:
            return 6;
          case 52:
            return "INVALID";
        }
      }, "anonymous"),
      rules: [/^(?:%%\{)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:%%(?!\{)*[^\n]*)/i, /^(?:[^\}]%%*[^\n]*)/i, /^(?:%%*[^\n]*[\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:%[^\n]*)/i, /^(?:href[\s]+["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:call[\s]+)/i, /^(?:\([\s]*\))/i, /^(?:\()/i, /^(?:[^(]*)/i, /^(?:\))/i, /^(?:[^)]*)/i, /^(?:click[\s]+)/i, /^(?:[\s\n])/i, /^(?:[^\s\n]*)/i, /^(?:gantt\b)/i, /^(?:dateFormat\s[^#\n;]+)/i, /^(?:inclusiveEndDates\b)/i, /^(?:topAxis\b)/i, /^(?:axisFormat\s[^#\n;]+)/i, /^(?:tickInterval\s[^#\n;]+)/i, /^(?:includes\s[^#\n;]+)/i, /^(?:excludes\s[^#\n;]+)/i, /^(?:todayMarker\s[^\n;]+)/i, /^(?:weekday\s+monday\b)/i, /^(?:weekday\s+tuesday\b)/i, /^(?:weekday\s+wednesday\b)/i, /^(?:weekday\s+thursday\b)/i, /^(?:weekday\s+friday\b)/i, /^(?:weekday\s+saturday\b)/i, /^(?:weekday\s+sunday\b)/i, /^(?:weekend\s+friday\b)/i, /^(?:weekend\s+saturday\b)/i, /^(?:\d\d\d\d-\d\d-\d\d\b)/i, /^(?:title\s[^\n]+)/i, /^(?:accDescription\s[^#\n;]+)/i, /^(?:section\s[^\n]+)/i, /^(?:[^:\n]+)/i, /^(?::[^#\n;]+)/i, /^(?::)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { acc_descr_multiline: { rules: [6, 7], inclusive: !1 }, acc_descr: { rules: [4], inclusive: !1 }, acc_title: { rules: [2], inclusive: !1 }, callbackargs: { rules: [21, 22], inclusive: !1 }, callbackname: { rules: [18, 19, 20], inclusive: !1 }, href: { rules: [15, 16], inclusive: !1 }, click: { rules: [24, 25], inclusive: !1 }, INITIAL: { rules: [0, 1, 3, 5, 8, 9, 10, 11, 12, 13, 14, 17, 23, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52], inclusive: !0 } }
    };
    return P;
  })();
  R.lexer = _;
  function O() {
    this.yy = {};
  }
  return x(O, "Parser"), O.prototype = R, R.Parser = O, new O();
})();
k6.parser = k6;
var oMe = k6;
Xn.extend(XRe);
Xn.extend(QRe);
Xn.extend(rMe);
var EN = { friday: 5, saturday: 6 }, Js = "", f7 = "", p7 = void 0, g7 = "", Yg = [], Xg = [], m7 = /* @__PURE__ */ new Map(), v7 = [], g2 = [], zd = "", y7 = "", JW = ["active", "done", "crit", "milestone", "vert"], x7 = [], jg = !1, b7 = !1, w7 = "sunday", m2 = "saturday", S6 = 0, lMe = /* @__PURE__ */ x(function() {
  v7 = [], g2 = [], zd = "", x7 = [], gv = 0, A6 = void 0, mv = void 0, In = [], Js = "", f7 = "", y7 = "", p7 = void 0, g7 = "", Yg = [], Xg = [], jg = !1, b7 = !1, S6 = 0, m7 = /* @__PURE__ */ new Map(), _n(), w7 = "sunday", m2 = "saturday";
}, "clear"), cMe = /* @__PURE__ */ x(function(t) {
  f7 = t;
}, "setAxisFormat"), uMe = /* @__PURE__ */ x(function() {
  return f7;
}, "getAxisFormat"), hMe = /* @__PURE__ */ x(function(t) {
  p7 = t;
}, "setTickInterval"), dMe = /* @__PURE__ */ x(function() {
  return p7;
}, "getTickInterval"), fMe = /* @__PURE__ */ x(function(t) {
  g7 = t;
}, "setTodayMarker"), pMe = /* @__PURE__ */ x(function() {
  return g7;
}, "getTodayMarker"), gMe = /* @__PURE__ */ x(function(t) {
  Js = t;
}, "setDateFormat"), mMe = /* @__PURE__ */ x(function() {
  jg = !0;
}, "enableInclusiveEndDates"), vMe = /* @__PURE__ */ x(function() {
  return jg;
}, "endDatesAreInclusive"), yMe = /* @__PURE__ */ x(function() {
  b7 = !0;
}, "enableTopAxis"), xMe = /* @__PURE__ */ x(function() {
  return b7;
}, "topAxisEnabled"), bMe = /* @__PURE__ */ x(function(t) {
  y7 = t;
}, "setDisplayMode"), wMe = /* @__PURE__ */ x(function() {
  return y7;
}, "getDisplayMode"), TMe = /* @__PURE__ */ x(function() {
  return Js;
}, "getDateFormat"), EMe = /* @__PURE__ */ x(function(t) {
  Yg = t.toLowerCase().split(/[\s,]+/);
}, "setIncludes"), kMe = /* @__PURE__ */ x(function() {
  return Yg;
}, "getIncludes"), SMe = /* @__PURE__ */ x(function(t) {
  Xg = t.toLowerCase().split(/[\s,]+/);
}, "setExcludes"), CMe = /* @__PURE__ */ x(function() {
  return Xg;
}, "getExcludes"), AMe = /* @__PURE__ */ x(function() {
  return m7;
}, "getLinks"), _Me = /* @__PURE__ */ x(function(t) {
  zd = t, v7.push(t);
}, "addSection"), LMe = /* @__PURE__ */ x(function() {
  return v7;
}, "getSections"), RMe = /* @__PURE__ */ x(function() {
  let t = kN();
  const e = 10;
  let r = 0;
  for (; !t && r < e; )
    t = kN(), r++;
  return g2 = In, g2;
}, "getTasks"), eY = /* @__PURE__ */ x(function(t, e, r, n) {
  const i = t.format(e.trim()), a = t.format("YYYY-MM-DD");
  return n.includes(i) || n.includes(a) ? !1 : r.includes("weekends") && (t.isoWeekday() === EN[m2] || t.isoWeekday() === EN[m2] + 1) || r.includes(t.format("dddd").toLowerCase()) ? !0 : r.includes(i) || r.includes(a);
}, "isInvalidDate"), MMe = /* @__PURE__ */ x(function(t) {
  w7 = t;
}, "setWeekday"), NMe = /* @__PURE__ */ x(function() {
  return w7;
}, "getWeekday"), IMe = /* @__PURE__ */ x(function(t) {
  m2 = t;
}, "setWeekend"), tY = /* @__PURE__ */ x(function(t, e, r, n) {
  if (!r.length || t.manualEndTime)
    return;
  let i;
  t.startTime instanceof Date ? i = Xn(t.startTime) : i = Xn(t.startTime, e, !0), i = i.add(1, "d");
  let a;
  t.endTime instanceof Date ? a = Xn(t.endTime) : a = Xn(t.endTime, e, !0);
  const [s, o] = DMe(
    i,
    a,
    e,
    r,
    n
  );
  t.endTime = s.toDate(), t.renderEndTime = o;
}, "checkTaskDates"), DMe = /* @__PURE__ */ x(function(t, e, r, n, i) {
  let a = !1, s = null;
  for (; t <= e; )
    a || (s = e.toDate()), a = eY(t, r, n, i), a && (e = e.add(1, "d")), t = t.add(1, "d");
  return [e, s];
}, "fixTaskDates"), C6 = /* @__PURE__ */ x(function(t, e, r) {
  if (r = r.trim(), (/* @__PURE__ */ x((o) => {
    const l = o.trim();
    return l === "x" || l === "X";
  }, "isTimestampFormat"))(e) && /^\d+$/.test(r))
    return new Date(Number(r));
  const a = /^after\s+(?<ids>[\d\w- ]+)/.exec(r);
  if (a !== null) {
    let o = null;
    for (const u of a.groups.ids.split(" ")) {
      let h = dh(u);
      h !== void 0 && (!o || h.endTime > o.endTime) && (o = h);
    }
    if (o)
      return o.endTime;
    const l = /* @__PURE__ */ new Date();
    return l.setHours(0, 0, 0, 0), l;
  }
  let s = Xn(r, e.trim(), !0);
  if (s.isValid())
    return s.toDate();
  {
    ie.debug("Invalid date:" + r), ie.debug("With date format:" + e.trim());
    const o = new Date(r);
    if (o === void 0 || isNaN(o.getTime()) || // WebKit browsers can mis-parse invalid dates to be ridiculously
    // huge numbers, e.g. new Date('202304') gets parsed as January 1, 202304.
    // This can cause virtually infinite loops while rendering, so for the
    // purposes of Gantt charts we'll just treat any date beyond 10,000 AD/BC as
    // invalid.
    o.getFullYear() < -1e4 || o.getFullYear() > 1e4)
      throw new Error("Invalid date:" + r);
    return o;
  }
}, "getStartDate"), rY = /* @__PURE__ */ x(function(t) {
  const e = /^(\d+(?:\.\d+)?)([Mdhmswy]|ms)$/.exec(t.trim());
  return e !== null ? [Number.parseFloat(e[1]), e[2]] : [NaN, "ms"];
}, "parseDuration"), nY = /* @__PURE__ */ x(function(t, e, r, n = !1) {
  r = r.trim();
  const a = /^until\s+(?<ids>[\d\w- ]+)/.exec(r);
  if (a !== null) {
    let h = null;
    for (const f of a.groups.ids.split(" ")) {
      let p = dh(f);
      p !== void 0 && (!h || p.startTime < h.startTime) && (h = p);
    }
    if (h)
      return h.startTime;
    const d = /* @__PURE__ */ new Date();
    return d.setHours(0, 0, 0, 0), d;
  }
  let s = Xn(r, e.trim(), !0);
  if (s.isValid())
    return n && (s = s.add(1, "d")), s.toDate();
  let o = Xn(t);
  const [l, u] = rY(r);
  if (!Number.isNaN(l)) {
    const h = o.add(l, u);
    h.isValid() && (o = h);
  }
  return o.toDate();
}, "getEndDate"), gv = 0, ld = /* @__PURE__ */ x(function(t) {
  return t === void 0 ? (gv = gv + 1, "task" + gv) : t;
}, "parseId"), OMe = /* @__PURE__ */ x(function(t, e) {
  let r;
  e.substr(0, 1) === ":" ? r = e.substr(1, e.length) : r = e;
  const n = r.split(","), i = {};
  T7(n, i, JW);
  for (let s = 0; s < n.length; s++)
    n[s] = n[s].trim();
  let a = "";
  switch (n.length) {
    case 1:
      i.id = ld(), i.startTime = t.endTime, a = n[0];
      break;
    case 2:
      i.id = ld(), i.startTime = C6(void 0, Js, n[0]), a = n[1];
      break;
    case 3:
      i.id = ld(n[0]), i.startTime = C6(void 0, Js, n[1]), a = n[2];
      break;
  }
  return a && (i.endTime = nY(i.startTime, Js, a, jg), i.manualEndTime = Xn(a, "YYYY-MM-DD", !0).isValid(), tY(i, Js, Xg, Yg)), i;
}, "compileData"), PMe = /* @__PURE__ */ x(function(t, e) {
  let r;
  e.substr(0, 1) === ":" ? r = e.substr(1, e.length) : r = e;
  const n = r.split(","), i = {};
  T7(n, i, JW);
  for (let a = 0; a < n.length; a++)
    n[a] = n[a].trim();
  switch (n.length) {
    case 1:
      i.id = ld(), i.startTime = {
        type: "prevTaskEnd",
        id: t
      }, i.endTime = {
        data: n[0]
      };
      break;
    case 2:
      i.id = ld(), i.startTime = {
        type: "getStartDate",
        startData: n[0]
      }, i.endTime = {
        data: n[1]
      };
      break;
    case 3:
      i.id = ld(n[0]), i.startTime = {
        type: "getStartDate",
        startData: n[1]
      }, i.endTime = {
        data: n[2]
      };
      break;
  }
  return i;
}, "parseData"), A6, mv, In = [], iY = {}, BMe = /* @__PURE__ */ x(function(t, e) {
  const r = {
    section: zd,
    type: zd,
    processed: !1,
    manualEndTime: !1,
    renderEndTime: null,
    raw: { data: e },
    task: t,
    classes: []
  }, n = PMe(mv, e);
  r.raw.startTime = n.startTime, r.raw.endTime = n.endTime, r.id = n.id, r.prevTaskId = mv, r.active = n.active, r.done = n.done, r.crit = n.crit, r.milestone = n.milestone, r.vert = n.vert, r.order = S6, S6++;
  const i = In.push(r);
  mv = r.id, iY[r.id] = i - 1;
}, "addTask"), dh = /* @__PURE__ */ x(function(t) {
  const e = iY[t];
  return In[e];
}, "findTaskById"), FMe = /* @__PURE__ */ x(function(t, e) {
  const r = {
    section: zd,
    type: zd,
    description: t,
    task: t,
    classes: []
  }, n = OMe(A6, e);
  r.startTime = n.startTime, r.endTime = n.endTime, r.id = n.id, r.active = n.active, r.done = n.done, r.crit = n.crit, r.milestone = n.milestone, r.vert = n.vert, A6 = r, g2.push(r);
}, "addTaskOrg"), kN = /* @__PURE__ */ x(function() {
  const t = /* @__PURE__ */ x(function(r) {
    const n = In[r];
    let i = "";
    switch (In[r].raw.startTime.type) {
      case "prevTaskEnd": {
        const a = dh(n.prevTaskId);
        n.startTime = a.endTime;
        break;
      }
      case "getStartDate":
        i = C6(void 0, Js, In[r].raw.startTime.startData), i && (In[r].startTime = i);
        break;
    }
    return In[r].startTime && (In[r].endTime = nY(
      In[r].startTime,
      Js,
      In[r].raw.endTime.data,
      jg
    ), In[r].endTime && (In[r].processed = !0, In[r].manualEndTime = Xn(
      In[r].raw.endTime.data,
      "YYYY-MM-DD",
      !0
    ).isValid(), tY(In[r], Js, Xg, Yg))), In[r].processed;
  }, "compileTask");
  let e = !0;
  for (const [r, n] of In.entries())
    t(r), e = e && n.processed;
  return e;
}, "compileTasks"), $Me = /* @__PURE__ */ x(function(t, e) {
  let r = e;
  we().securityLevel !== "loose" && (r = Uu.sanitizeUrl(e)), t.split(",").forEach(function(n) {
    dh(n) !== void 0 && (sY(n, () => {
      window.open(r, "_self");
    }), m7.set(n, r));
  }), aY(t, "clickable");
}, "setLink"), aY = /* @__PURE__ */ x(function(t, e) {
  t.split(",").forEach(function(r) {
    let n = dh(r);
    n !== void 0 && n.classes.push(e);
  });
}, "setClass"), zMe = /* @__PURE__ */ x(function(t, e, r) {
  if (we().securityLevel !== "loose" || e === void 0)
    return;
  let n = [];
  if (typeof r == "string") {
    n = r.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
    for (let a = 0; a < n.length; a++) {
      let s = n[a].trim();
      s.startsWith('"') && s.endsWith('"') && (s = s.substr(1, s.length - 2)), n[a] = s;
    }
  }
  n.length === 0 && n.push(t), dh(t) !== void 0 && sY(t, () => {
    Zt.runFunc(e, ...n);
  });
}, "setClickFun"), sY = /* @__PURE__ */ x(function(t, e) {
  x7.push(
    function() {
      const r = document.querySelector(`[id="${t}"]`);
      r !== null && r.addEventListener("click", function() {
        e();
      });
    },
    function() {
      const r = document.querySelector(`[id="${t}-text"]`);
      r !== null && r.addEventListener("click", function() {
        e();
      });
    }
  );
}, "pushFun"), GMe = /* @__PURE__ */ x(function(t, e, r) {
  t.split(",").forEach(function(n) {
    zMe(n, e, r);
  }), aY(t, "clickable");
}, "setClickEvent"), VMe = /* @__PURE__ */ x(function(t) {
  x7.forEach(function(e) {
    e(t);
  });
}, "bindFunctions"), UMe = {
  getConfig: /* @__PURE__ */ x(() => we().gantt, "getConfig"),
  clear: lMe,
  setDateFormat: gMe,
  getDateFormat: TMe,
  enableInclusiveEndDates: mMe,
  endDatesAreInclusive: vMe,
  enableTopAxis: yMe,
  topAxisEnabled: xMe,
  setAxisFormat: cMe,
  getAxisFormat: uMe,
  setTickInterval: hMe,
  getTickInterval: dMe,
  setTodayMarker: fMe,
  getTodayMarker: pMe,
  setAccTitle: Cn,
  getAccTitle: Gn,
  setDiagramTitle: Zn,
  getDiagramTitle: Ln,
  setDisplayMode: bMe,
  getDisplayMode: wMe,
  setAccDescription: Vn,
  getAccDescription: Un,
  addSection: _Me,
  getSections: LMe,
  getTasks: RMe,
  addTask: BMe,
  findTaskById: dh,
  addTaskOrg: FMe,
  setIncludes: EMe,
  getIncludes: kMe,
  setExcludes: SMe,
  getExcludes: CMe,
  setClickEvent: GMe,
  setLink: $Me,
  getLinks: AMe,
  bindFunctions: VMe,
  parseDuration: rY,
  isInvalidDate: eY,
  setWeekday: MMe,
  getWeekday: NMe,
  setWeekend: IMe
};
function T7(t, e, r) {
  let n = !0;
  for (; n; )
    n = !1, r.forEach(function(i) {
      const a = "^\\s*" + i + "\\s*$", s = new RegExp(a);
      t[0].match(s) && (e[i] = !0, t.shift(1), n = !0);
    });
}
x(T7, "getTaskTags");
Xn.extend(sMe);
var HMe = /* @__PURE__ */ x(function() {
  ie.debug("Something is calling, setConf, remove the call");
}, "setConf"), SN = {
  monday: dp,
  tuesday: kD,
  wednesday: SD,
  thursday: vu,
  friday: CD,
  saturday: AD,
  sunday: ug
}, qMe = /* @__PURE__ */ x((t, e) => {
  let r = [...t].map(() => -1 / 0), n = [...t].sort((a, s) => a.startTime - s.startTime || a.order - s.order), i = 0;
  for (const a of n)
    for (let s = 0; s < r.length; s++)
      if (a.startTime >= r[s]) {
        r[s] = a.endTime, a.order = s + e, s > i && (i = s);
        break;
      }
  return i;
}, "getMaxIntersections"), Ao, z5 = 1e4, WMe = /* @__PURE__ */ x(function(t, e, r, n) {
  const i = we().gantt, a = we().securityLevel;
  let s;
  a === "sandbox" && (s = Qe("#i" + e));
  const o = Qe(a === "sandbox" ? s.nodes()[0].contentDocument.body : "body"), l = a === "sandbox" ? s.nodes()[0].contentDocument : document, u = l.getElementById(e);
  Ao = u.parentElement.offsetWidth, Ao === void 0 && (Ao = 1200), i.useWidth !== void 0 && (Ao = i.useWidth);
  const h = n.db.getTasks();
  let d = [];
  for (const A of h)
    d.push(A.type);
  d = C(d);
  const f = {};
  let p = 2 * i.topPadding;
  if (n.db.getDisplayMode() === "compact" || i.displayMode === "compact") {
    const A = {};
    for (const _ of h)
      A[_.section] === void 0 ? A[_.section] = [_] : A[_.section].push(_);
    let R = 0;
    for (const _ of Object.keys(A)) {
      const O = qMe(A[_], R) + 1;
      R += O, p += O * (i.barHeight + i.barGap), f[_] = O;
    }
  } else {
    p += h.length * (i.barHeight + i.barGap);
    for (const A of d)
      f[A] = h.filter((R) => R.type === A).length;
  }
  u.setAttribute("viewBox", "0 0 " + Ao + " " + p);
  const g = o.select(`[id="${e}"]`), m = ene().domain([
    oZ(h, function(A) {
      return A.startTime;
    }),
    sZ(h, function(A) {
      return A.endTime;
    })
  ]).rangeRound([0, Ao - i.leftPadding - i.rightPadding]);
  function v(A, R) {
    const _ = A.startTime, O = R.startTime;
    let P = 0;
    return _ > O ? P = 1 : _ < O && (P = -1), P;
  }
  x(v, "taskCompare"), h.sort(v), y(h, Ao, p), Xi(g, p, Ao, i.useMaxWidth), g.append("text").text(n.db.getDiagramTitle()).attr("x", Ao / 2).attr("y", i.titleTopMargin).attr("class", "titleText");
  function y(A, R, _) {
    const O = i.barHeight, P = O + i.barGap, S = i.topPadding, M = i.leftPadding, N = gd().domain([0, d.length]).range(["#00B9FA", "#F95002"]).interpolate(RJ);
    w(
      P,
      S,
      M,
      R,
      _,
      A,
      n.db.getExcludes(),
      n.db.getIncludes()
    ), E(M, S, R, _), b(A, P, S, M, O, N, R), L(P, S), k(M, S, R, _);
  }
  x(y, "makeGantt");
  function b(A, R, _, O, P, S, M) {
    A.sort((F, V) => F.vert === V.vert ? 0 : F.vert ? 1 : -1);
    const D = [...new Set(A.map((F) => F.order))].map((F) => A.find((V) => V.order === F));
    g.append("g").selectAll("rect").data(D).enter().append("rect").attr("x", 0).attr("y", function(F, V) {
      return V = F.order, V * R + _ - 2;
    }).attr("width", function() {
      return M - i.rightPadding / 2;
    }).attr("height", R).attr("class", function(F) {
      for (const [V, H] of d.entries())
        if (F.type === H)
          return "section section" + V % i.numberSectionStyles;
      return "section section0";
    }).enter();
    const I = g.append("g").selectAll("rect").data(A).enter(), B = n.db.getLinks();
    if (I.append("rect").attr("id", function(F) {
      return F.id;
    }).attr("rx", 3).attr("ry", 3).attr("x", function(F) {
      return F.milestone ? m(F.startTime) + O + 0.5 * (m(F.endTime) - m(F.startTime)) - 0.5 * P : m(F.startTime) + O;
    }).attr("y", function(F, V) {
      return V = F.order, F.vert ? i.gridLineStartPadding : V * R + _;
    }).attr("width", function(F) {
      return F.milestone ? P : F.vert ? 0.08 * P : m(F.renderEndTime || F.endTime) - m(F.startTime);
    }).attr("height", function(F) {
      return F.vert ? h.length * (i.barHeight + i.barGap) + i.barHeight * 2 : P;
    }).attr("transform-origin", function(F, V) {
      return V = F.order, (m(F.startTime) + O + 0.5 * (m(F.endTime) - m(F.startTime))).toString() + "px " + (V * R + _ + 0.5 * P).toString() + "px";
    }).attr("class", function(F) {
      const V = "task";
      let H = "";
      F.classes.length > 0 && (H = F.classes.join(" "));
      let J = 0;
      for (const [ae, re] of d.entries())
        F.type === re && (J = ae % i.numberSectionStyles);
      let q = "";
      return F.active ? F.crit ? q += " activeCrit" : q = " active" : F.done ? F.crit ? q = " doneCrit" : q = " done" : F.crit && (q += " crit"), q.length === 0 && (q = " task"), F.milestone && (q = " milestone " + q), F.vert && (q = " vert " + q), q += J, q += " " + H, V + q;
    }), I.append("text").attr("id", function(F) {
      return F.id + "-text";
    }).text(function(F) {
      return F.task;
    }).attr("font-size", i.fontSize).attr("x", function(F) {
      let V = m(F.startTime), H = m(F.renderEndTime || F.endTime);
      if (F.milestone && (V += 0.5 * (m(F.endTime) - m(F.startTime)) - 0.5 * P, H = V + P), F.vert)
        return m(F.startTime) + O;
      const J = this.getBBox().width;
      return J > H - V ? H + J + 1.5 * i.leftPadding > M ? V + O - 5 : H + O + 5 : (H - V) / 2 + V + O;
    }).attr("y", function(F, V) {
      return F.vert ? i.gridLineStartPadding + h.length * (i.barHeight + i.barGap) + 60 : (V = F.order, V * R + i.barHeight / 2 + (i.fontSize / 2 - 2) + _);
    }).attr("text-height", P).attr("class", function(F) {
      const V = m(F.startTime);
      let H = m(F.endTime);
      F.milestone && (H = V + P);
      const J = this.getBBox().width;
      let q = "";
      F.classes.length > 0 && (q = F.classes.join(" "));
      let ae = 0;
      for (const [pe, K] of d.entries())
        F.type === K && (ae = pe % i.numberSectionStyles);
      let re = "";
      return F.active && (F.crit ? re = "activeCritText" + ae : re = "activeText" + ae), F.done ? F.crit ? re = re + " doneCritText" + ae : re = re + " doneText" + ae : F.crit && (re = re + " critText" + ae), F.milestone && (re += " milestoneText"), F.vert && (re += " vertText"), J > H - V ? H + J + 1.5 * i.leftPadding > M ? q + " taskTextOutsideLeft taskTextOutside" + ae + " " + re : q + " taskTextOutsideRight taskTextOutside" + ae + " " + re + " width-" + J : q + " taskText taskText" + ae + " " + re + " width-" + J;
    }), we().securityLevel === "sandbox") {
      let F;
      F = Qe("#i" + e);
      const V = F.nodes()[0].contentDocument;
      I.filter(function(H) {
        return B.has(H.id);
      }).each(function(H) {
        var J = V.querySelector("#" + H.id), q = V.querySelector("#" + H.id + "-text");
        const ae = J.parentNode;
        var re = V.createElement("a");
        re.setAttribute("xlink:href", B.get(H.id)), re.setAttribute("target", "_top"), ae.appendChild(re), re.appendChild(J), re.appendChild(q);
      });
    }
  }
  x(b, "drawRects");
  function w(A, R, _, O, P, S, M, N) {
    if (M.length === 0 && N.length === 0)
      return;
    let D, I;
    for (const { startTime: J, endTime: q } of S)
      (D === void 0 || J < D) && (D = J), (I === void 0 || q > I) && (I = q);
    if (!D || !I)
      return;
    if (Xn(I).diff(Xn(D), "year") > 5) {
      ie.warn(
        "The difference between the min and max time is more than 5 years. This will cause performance issues. Skipping drawing exclude days."
      );
      return;
    }
    const B = n.db.getDateFormat(), z = [];
    let F = null, V = Xn(D);
    for (; V.valueOf() <= I; )
      n.db.isInvalidDate(V, B, M, N) ? F ? F.end = V : F = {
        start: V,
        end: V
      } : F && (z.push(F), F = null), V = V.add(1, "d");
    g.append("g").selectAll("rect").data(z).enter().append("rect").attr("id", (J) => "exclude-" + J.start.format("YYYY-MM-DD")).attr("x", (J) => m(J.start.startOf("day")) + _).attr("y", i.gridLineStartPadding).attr("width", (J) => m(J.end.endOf("day")) - m(J.start.startOf("day"))).attr("height", P - R - i.gridLineStartPadding).attr("transform-origin", function(J, q) {
      return (m(J.start) + _ + 0.5 * (m(J.end) - m(J.start))).toString() + "px " + (q * A + 0.5 * P).toString() + "px";
    }).attr("class", "exclude-range");
  }
  x(w, "drawExcludeDays");
  function T(A, R, _, O) {
    if (_ <= 0 || A > R)
      return 1 / 0;
    const P = R - A, S = Xn.duration({ [O ?? "day"]: _ }).asMilliseconds();
    return S <= 0 ? 1 / 0 : Math.ceil(P / S);
  }
  x(T, "getEstimatedTickCount");
  function E(A, R, _, O) {
    const P = n.db.getDateFormat(), S = n.db.getAxisFormat();
    let M;
    S ? M = S : P === "D" ? M = "%d" : M = i.axisFormat ?? "%Y-%m-%d";
    let N = mZ(m).tickSize(-O + R + i.gridLineStartPadding).tickFormat(Vv(M));
    const I = /^([1-9]\d*)(millisecond|second|minute|hour|day|week|month)$/.exec(
      n.db.getTickInterval() || i.tickInterval
    );
    if (I !== null) {
      const B = parseInt(I[1], 10);
      if (isNaN(B) || B <= 0)
        ie.warn(
          `Invalid tick interval value: "${I[1]}". Skipping custom tick interval.`
        );
      else {
        const z = I[2], F = n.db.getWeekday() || i.weekday, V = m.domain(), H = V[0], J = V[1], q = T(H, J, B, z);
        if (q > z5)
          ie.warn(
            `The tick interval "${B}${z}" would generate ${q} ticks, which exceeds the maximum allowed (${z5}). This may indicate an invalid date or time range. Skipping custom tick interval.`
          );
        else
          switch (z) {
            case "millisecond":
              N.ticks(md.every(B));
              break;
            case "second":
              N.ticks(Rl.every(B));
              break;
            case "minute":
              N.ticks(up.every(B));
              break;
            case "hour":
              N.ticks(hp.every(B));
              break;
            case "day":
              N.ticks(mu.every(B));
              break;
            case "week":
              N.ticks(SN[F].every(B));
              break;
            case "month":
              N.ticks(fp.every(B));
              break;
          }
      }
    }
    if (g.append("g").attr("class", "grid").attr("transform", "translate(" + A + ", " + (O - 50) + ")").call(N).selectAll("text").style("text-anchor", "middle").attr("fill", "#000").attr("stroke", "none").attr("font-size", 10).attr("dy", "1em"), n.db.topAxisEnabled() || i.topAxis) {
      let B = gZ(m).tickSize(-O + R + i.gridLineStartPadding).tickFormat(Vv(M));
      if (I !== null) {
        const z = parseInt(I[1], 10);
        if (isNaN(z) || z <= 0)
          ie.warn(
            `Invalid tick interval value: "${I[1]}". Skipping custom tick interval.`
          );
        else {
          const F = I[2], V = n.db.getWeekday() || i.weekday, H = m.domain(), J = H[0], q = H[1];
          if (T(J, q, z, F) <= z5)
            switch (F) {
              case "millisecond":
                B.ticks(md.every(z));
                break;
              case "second":
                B.ticks(Rl.every(z));
                break;
              case "minute":
                B.ticks(up.every(z));
                break;
              case "hour":
                B.ticks(hp.every(z));
                break;
              case "day":
                B.ticks(mu.every(z));
                break;
              case "week":
                B.ticks(SN[V].every(z));
                break;
              case "month":
                B.ticks(fp.every(z));
                break;
            }
        }
      }
      g.append("g").attr("class", "grid").attr("transform", "translate(" + A + ", " + R + ")").call(B).selectAll("text").style("text-anchor", "middle").attr("fill", "#000").attr("stroke", "none").attr("font-size", 10);
    }
  }
  x(E, "makeGrid");
  function L(A, R) {
    let _ = 0;
    const O = Object.keys(f).map((P) => [P, f[P]]);
    g.append("g").selectAll("text").data(O).enter().append(function(P) {
      const S = P[0].split(at.lineBreakRegex), M = -(S.length - 1) / 2, N = l.createElementNS("http://www.w3.org/2000/svg", "text");
      N.setAttribute("dy", M + "em");
      for (const [D, I] of S.entries()) {
        const B = l.createElementNS("http://www.w3.org/2000/svg", "tspan");
        B.setAttribute("alignment-baseline", "central"), B.setAttribute("x", "10"), D > 0 && B.setAttribute("dy", "1em"), B.textContent = I, N.appendChild(B);
      }
      return N;
    }).attr("x", 10).attr("y", function(P, S) {
      if (S > 0)
        for (let M = 0; M < S; M++)
          return _ += O[S - 1][1], P[1] * A / 2 + _ * A + R;
      else
        return P[1] * A / 2 + R;
    }).attr("font-size", i.sectionFontSize).attr("class", function(P) {
      for (const [S, M] of d.entries())
        if (P[0] === M)
          return "sectionTitle sectionTitle" + S % i.numberSectionStyles;
      return "sectionTitle";
    });
  }
  x(L, "vertLabels");
  function k(A, R, _, O) {
    const P = n.db.getTodayMarker();
    if (P === "off")
      return;
    const S = g.append("g").attr("class", "today"), M = /* @__PURE__ */ new Date(), N = S.append("line");
    N.attr("x1", m(M) + A).attr("x2", m(M) + A).attr("y1", i.titleTopMargin).attr("y2", O - i.titleTopMargin).attr("class", "today"), P !== "" && N.attr("style", P.replace(/,/g, ";"));
  }
  x(k, "drawToday");
  function C(A) {
    const R = {}, _ = [];
    for (let O = 0, P = A.length; O < P; ++O)
      Object.prototype.hasOwnProperty.call(R, A[O]) || (R[A[O]] = !0, _.push(A[O]));
    return _;
  }
  x(C, "checkUnique");
}, "draw"), YMe = {
  setConf: HMe,
  draw: WMe
}, XMe = /* @__PURE__ */ x((t) => `
  .mermaid-main-font {
        font-family: ${t.fontFamily};
  }

  .exclude-range {
    fill: ${t.excludeBkgColor};
  }

  .section {
    stroke: none;
    opacity: 0.2;
  }

  .section0 {
    fill: ${t.sectionBkgColor};
  }

  .section2 {
    fill: ${t.sectionBkgColor2};
  }

  .section1,
  .section3 {
    fill: ${t.altSectionBkgColor};
    opacity: 0.2;
  }

  .sectionTitle0 {
    fill: ${t.titleColor};
  }

  .sectionTitle1 {
    fill: ${t.titleColor};
  }

  .sectionTitle2 {
    fill: ${t.titleColor};
  }

  .sectionTitle3 {
    fill: ${t.titleColor};
  }

  .sectionTitle {
    text-anchor: start;
    font-family: ${t.fontFamily};
  }


  /* Grid and axis */

  .grid .tick {
    stroke: ${t.gridColor};
    opacity: 0.8;
    shape-rendering: crispEdges;
  }

  .grid .tick text {
    font-family: ${t.fontFamily};
    fill: ${t.textColor};
  }

  .grid path {
    stroke-width: 0;
  }


  /* Today line */

  .today {
    fill: none;
    stroke: ${t.todayLineColor};
    stroke-width: 2px;
  }


  /* Task styling */

  /* Default task */

  .task {
    stroke-width: 2;
  }

  .taskText {
    text-anchor: middle;
    font-family: ${t.fontFamily};
  }

  .taskTextOutsideRight {
    fill: ${t.taskTextDarkColor};
    text-anchor: start;
    font-family: ${t.fontFamily};
  }

  .taskTextOutsideLeft {
    fill: ${t.taskTextDarkColor};
    text-anchor: end;
  }


  /* Special case clickable */

  .task.clickable {
    cursor: pointer;
  }

  .taskText.clickable {
    cursor: pointer;
    fill: ${t.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideLeft.clickable {
    cursor: pointer;
    fill: ${t.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideRight.clickable {
    cursor: pointer;
    fill: ${t.taskTextClickableColor} !important;
    font-weight: bold;
  }


  /* Specific task settings for the sections*/

  .taskText0,
  .taskText1,
  .taskText2,
  .taskText3 {
    fill: ${t.taskTextColor};
  }

  .task0,
  .task1,
  .task2,
  .task3 {
    fill: ${t.taskBkgColor};
    stroke: ${t.taskBorderColor};
  }

  .taskTextOutside0,
  .taskTextOutside2
  {
    fill: ${t.taskTextOutsideColor};
  }

  .taskTextOutside1,
  .taskTextOutside3 {
    fill: ${t.taskTextOutsideColor};
  }


  /* Active task */

  .active0,
  .active1,
  .active2,
  .active3 {
    fill: ${t.activeTaskBkgColor};
    stroke: ${t.activeTaskBorderColor};
  }

  .activeText0,
  .activeText1,
  .activeText2,
  .activeText3 {
    fill: ${t.taskTextDarkColor} !important;
  }


  /* Completed task */

  .done0,
  .done1,
  .done2,
  .done3 {
    stroke: ${t.doneTaskBorderColor};
    fill: ${t.doneTaskBkgColor};
    stroke-width: 2;
  }

  .doneText0,
  .doneText1,
  .doneText2,
  .doneText3 {
    fill: ${t.taskTextDarkColor} !important;
  }


  /* Tasks on the critical line */

  .crit0,
  .crit1,
  .crit2,
  .crit3 {
    stroke: ${t.critBorderColor};
    fill: ${t.critBkgColor};
    stroke-width: 2;
  }

  .activeCrit0,
  .activeCrit1,
  .activeCrit2,
  .activeCrit3 {
    stroke: ${t.critBorderColor};
    fill: ${t.activeTaskBkgColor};
    stroke-width: 2;
  }

  .doneCrit0,
  .doneCrit1,
  .doneCrit2,
  .doneCrit3 {
    stroke: ${t.critBorderColor};
    fill: ${t.doneTaskBkgColor};
    stroke-width: 2;
    cursor: pointer;
    shape-rendering: crispEdges;
  }

  .milestone {
    transform: rotate(45deg) scale(0.8,0.8);
  }

  .milestoneText {
    font-style: italic;
  }
  .doneCritText0,
  .doneCritText1,
  .doneCritText2,
  .doneCritText3 {
    fill: ${t.taskTextDarkColor} !important;
  }

  .vert {
    stroke: ${t.vertLineColor};
  }

  .vertText {
    font-size: 15px;
    text-anchor: middle;
    fill: ${t.vertLineColor} !important;
  }

  .activeCritText0,
  .activeCritText1,
  .activeCritText2,
  .activeCritText3 {
    fill: ${t.taskTextDarkColor} !important;
  }

  .titleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${t.titleColor || t.textColor};
    font-family: ${t.fontFamily};
  }
`, "getStyles"), jMe = XMe, KMe = {
  parser: oMe,
  db: UMe,
  renderer: YMe,
  styles: jMe
};
const ZMe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: KMe
}, Symbol.toStringTag, { value: "Module" }));
var QMe = {
  parse: /* @__PURE__ */ x(async (t) => {
    const e = await Lc("info", t);
    ie.debug(e);
  }, "parse")
}, JMe = {
  version: X5.version + ""
}, eNe = /* @__PURE__ */ x(() => JMe.version, "getVersion"), tNe = {
  getVersion: eNe
}, rNe = /* @__PURE__ */ x((t, e, r) => {
  ie.debug(`rendering info diagram
` + t);
  const n = ll(e);
  Xi(n, 100, 400, !0), n.append("g").append("text").attr("x", 100).attr("y", 40).attr("class", "version").attr("font-size", 32).style("text-anchor", "middle").text(`v${r}`);
}, "draw"), nNe = { draw: rNe }, iNe = {
  parser: QMe,
  db: tNe,
  renderer: nNe
};
const aNe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: iNe
}, Symbol.toStringTag, { value: "Module" }));
var sNe = ur.pie, E7 = {
  sections: /* @__PURE__ */ new Map(),
  showData: !1
}, v2 = E7.sections, k7 = E7.showData, oNe = structuredClone(sNe), lNe = /* @__PURE__ */ x(() => structuredClone(oNe), "getConfig"), cNe = /* @__PURE__ */ x(() => {
  v2 = /* @__PURE__ */ new Map(), k7 = E7.showData, _n();
}, "clear"), uNe = /* @__PURE__ */ x(({ label: t, value: e }) => {
  if (e < 0)
    throw new Error(
      `"${t}" has invalid value: ${e}. Negative values are not allowed in pie charts. All slice values must be >= 0.`
    );
  v2.has(t) || (v2.set(t, e), ie.debug(`added new section: ${t}, with value: ${e}`));
}, "addSection"), hNe = /* @__PURE__ */ x(() => v2, "getSections"), dNe = /* @__PURE__ */ x((t) => {
  k7 = t;
}, "setShowData"), fNe = /* @__PURE__ */ x(() => k7, "getShowData"), oY = {
  getConfig: lNe,
  clear: cNe,
  setDiagramTitle: Zn,
  getDiagramTitle: Ln,
  setAccTitle: Cn,
  getAccTitle: Gn,
  setAccDescription: Vn,
  getAccDescription: Un,
  addSection: uNe,
  getSections: hNe,
  setShowData: dNe,
  getShowData: fNe
}, pNe = /* @__PURE__ */ x((t, e) => {
  nh(t, e), e.setShowData(t.showData), t.sections.map(e.addSection);
}, "populateDb"), gNe = {
  parse: /* @__PURE__ */ x(async (t) => {
    const e = await Lc("pie", t);
    ie.debug(e), pNe(e, oY);
  }, "parse")
}, mNe = /* @__PURE__ */ x((t) => `
  .pieCircle{
    stroke: ${t.pieStrokeColor};
    stroke-width : ${t.pieStrokeWidth};
    opacity : ${t.pieOpacity};
  }
  .pieOuterCircle{
    stroke: ${t.pieOuterStrokeColor};
    stroke-width: ${t.pieOuterStrokeWidth};
    fill: none;
  }
  .pieTitleText {
    text-anchor: middle;
    font-size: ${t.pieTitleTextSize};
    fill: ${t.pieTitleTextColor};
    font-family: ${t.fontFamily};
  }
  .slice {
    font-family: ${t.fontFamily};
    fill: ${t.pieSectionTextColor};
    font-size:${t.pieSectionTextSize};
    // fill: white;
  }
  .legend text {
    fill: ${t.pieLegendTextColor};
    font-family: ${t.fontFamily};
    font-size: ${t.pieLegendTextSize};
  }
`, "getStyles"), vNe = mNe, yNe = /* @__PURE__ */ x((t) => {
  const e = [...t.values()].reduce((i, a) => i + a, 0), r = [...t.entries()].map(([i, a]) => ({ label: i, value: a })).filter((i) => i.value / e * 100 >= 1).sort((i, a) => a.value - i.value);
  return gne().value((i) => i.value)(r);
}, "createPieArcs"), xNe = /* @__PURE__ */ x((t, e, r, n) => {
  ie.debug(`rendering pie chart
` + t);
  const i = n.db, a = we(), s = Hi(i.getConfig(), a.pie), o = 40, l = 18, u = 4, h = 450, d = h, f = ll(e), p = f.append("g");
  p.attr("transform", "translate(" + d / 2 + "," + h / 2 + ")");
  const { themeVariables: g } = a;
  let [m] = ju(g.pieOuterStrokeWidth);
  m ??= 2;
  const v = s.textPosition, y = Math.min(d, h) / 2 - o, b = yd().innerRadius(0).outerRadius(y), w = yd().innerRadius(y * v).outerRadius(y * v);
  p.append("circle").attr("cx", 0).attr("cy", 0).attr("r", y + m / 2).attr("class", "pieOuterCircle");
  const T = i.getSections(), E = yNe(T), L = [
    g.pie1,
    g.pie2,
    g.pie3,
    g.pie4,
    g.pie5,
    g.pie6,
    g.pie7,
    g.pie8,
    g.pie9,
    g.pie10,
    g.pie11,
    g.pie12
  ];
  let k = 0;
  T.forEach((S) => {
    k += S;
  });
  const C = E.filter((S) => (S.data.value / k * 100).toFixed(0) !== "0"), A = hu(L);
  p.selectAll("mySlices").data(C).enter().append("path").attr("d", b).attr("fill", (S) => A(S.data.label)).attr("class", "pieCircle"), p.selectAll("mySlices").data(C).enter().append("text").text((S) => (S.data.value / k * 100).toFixed(0) + "%").attr("transform", (S) => "translate(" + w.centroid(S) + ")").style("text-anchor", "middle").attr("class", "slice"), p.append("text").text(i.getDiagramTitle()).attr("x", 0).attr("y", -400 / 2).attr("class", "pieTitleText");
  const R = [...T.entries()].map(([S, M]) => ({
    label: S,
    value: M
  })), _ = p.selectAll(".legend").data(R).enter().append("g").attr("class", "legend").attr("transform", (S, M) => {
    const N = l + u, D = N * R.length / 2, I = 12 * l, B = M * N - D;
    return "translate(" + I + "," + B + ")";
  });
  _.append("rect").attr("width", l).attr("height", l).style("fill", (S) => A(S.label)).style("stroke", (S) => A(S.label)), _.append("text").attr("x", l + u).attr("y", l - u).text((S) => i.getShowData() ? `${S.label} [${S.value}]` : S.label);
  const O = Math.max(
    ..._.selectAll("text").nodes().map((S) => S?.getBoundingClientRect().width ?? 0)
  ), P = d + o + l + u + O;
  f.attr("viewBox", `0 0 ${P} ${h}`), Xi(f, h, P, s.useMaxWidth);
}, "draw"), bNe = { draw: xNe }, wNe = {
  parser: gNe,
  db: oY,
  renderer: bNe,
  styles: vNe
};
const TNe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: wNe
}, Symbol.toStringTag, { value: "Module" }));
var _6 = (function() {
  var t = /* @__PURE__ */ x(function(ce, $, oe, se) {
    for (oe = oe || {}, se = ce.length; se--; oe[ce[se]] = $) ;
    return oe;
  }, "o"), e = [1, 3], r = [1, 4], n = [1, 5], i = [1, 6], a = [1, 7], s = [1, 4, 5, 10, 12, 13, 14, 18, 25, 35, 37, 39, 41, 42, 48, 50, 51, 52, 53, 54, 55, 56, 57, 60, 61, 63, 64, 65, 66, 67], o = [1, 4, 5, 10, 12, 13, 14, 18, 25, 28, 35, 37, 39, 41, 42, 48, 50, 51, 52, 53, 54, 55, 56, 57, 60, 61, 63, 64, 65, 66, 67], l = [55, 56, 57], u = [2, 36], h = [1, 37], d = [1, 36], f = [1, 38], p = [1, 35], g = [1, 43], m = [1, 41], v = [1, 14], y = [1, 23], b = [1, 18], w = [1, 19], T = [1, 20], E = [1, 21], L = [1, 22], k = [1, 24], C = [1, 25], A = [1, 26], R = [1, 27], _ = [1, 28], O = [1, 29], P = [1, 32], S = [1, 33], M = [1, 34], N = [1, 39], D = [1, 40], I = [1, 42], B = [1, 44], z = [1, 62], F = [1, 61], V = [4, 5, 8, 10, 12, 13, 14, 18, 44, 47, 49, 55, 56, 57, 63, 64, 65, 66, 67], H = [1, 65], J = [1, 66], q = [1, 67], ae = [1, 68], re = [1, 69], pe = [1, 70], K = [1, 71], Z = [1, 72], X = [1, 73], Y = [1, 74], ee = [1, 75], j = [1, 76], fe = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 18], te = [1, 90], Ae = [1, 91], W = [1, 92], De = [1, 99], ue = [1, 93], ze = [1, 96], Ge = [1, 94], Ve = [1, 95], ke = [1, 97], Oe = [1, 98], Se = [1, 102], _e = [10, 55, 56, 57], $e = [4, 5, 6, 8, 10, 11, 13, 17, 18, 19, 20, 55, 56, 57], me = {
    trace: /* @__PURE__ */ x(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, idStringToken: 3, ALPHA: 4, NUM: 5, NODE_STRING: 6, DOWN: 7, MINUS: 8, DEFAULT: 9, COMMA: 10, COLON: 11, AMP: 12, BRKT: 13, MULT: 14, UNICODE_TEXT: 15, styleComponent: 16, UNIT: 17, SPACE: 18, STYLE: 19, PCT: 20, idString: 21, style: 22, stylesOpt: 23, classDefStatement: 24, CLASSDEF: 25, start: 26, eol: 27, QUADRANT: 28, document: 29, line: 30, statement: 31, axisDetails: 32, quadrantDetails: 33, points: 34, title: 35, title_value: 36, acc_title: 37, acc_title_value: 38, acc_descr: 39, acc_descr_value: 40, acc_descr_multiline_value: 41, section: 42, text: 43, point_start: 44, point_x: 45, point_y: 46, class_name: 47, "X-AXIS": 48, "AXIS-TEXT-DELIMITER": 49, "Y-AXIS": 50, QUADRANT_1: 51, QUADRANT_2: 52, QUADRANT_3: 53, QUADRANT_4: 54, NEWLINE: 55, SEMI: 56, EOF: 57, alphaNumToken: 58, textNoTagsToken: 59, STR: 60, MD_STR: 61, alphaNum: 62, PUNCTUATION: 63, PLUS: 64, EQUALS: 65, DOT: 66, UNDERSCORE: 67, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "ALPHA", 5: "NUM", 6: "NODE_STRING", 7: "DOWN", 8: "MINUS", 9: "DEFAULT", 10: "COMMA", 11: "COLON", 12: "AMP", 13: "BRKT", 14: "MULT", 15: "UNICODE_TEXT", 17: "UNIT", 18: "SPACE", 19: "STYLE", 20: "PCT", 25: "CLASSDEF", 28: "QUADRANT", 35: "title", 36: "title_value", 37: "acc_title", 38: "acc_title_value", 39: "acc_descr", 40: "acc_descr_value", 41: "acc_descr_multiline_value", 42: "section", 44: "point_start", 45: "point_x", 46: "point_y", 47: "class_name", 48: "X-AXIS", 49: "AXIS-TEXT-DELIMITER", 50: "Y-AXIS", 51: "QUADRANT_1", 52: "QUADRANT_2", 53: "QUADRANT_3", 54: "QUADRANT_4", 55: "NEWLINE", 56: "SEMI", 57: "EOF", 60: "STR", 61: "MD_STR", 63: "PUNCTUATION", 64: "PLUS", 65: "EQUALS", 66: "DOT", 67: "UNDERSCORE" },
    productions_: [0, [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [21, 1], [21, 2], [22, 1], [22, 2], [23, 1], [23, 3], [24, 5], [26, 2], [26, 2], [26, 2], [29, 0], [29, 2], [30, 2], [31, 0], [31, 1], [31, 2], [31, 1], [31, 1], [31, 1], [31, 2], [31, 2], [31, 2], [31, 1], [31, 1], [34, 4], [34, 5], [34, 5], [34, 6], [32, 4], [32, 3], [32, 2], [32, 4], [32, 3], [32, 2], [33, 2], [33, 2], [33, 2], [33, 2], [27, 1], [27, 1], [27, 1], [43, 1], [43, 2], [43, 1], [43, 1], [62, 1], [62, 2], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [59, 1], [59, 1], [59, 1]],
    performAction: /* @__PURE__ */ x(function($, oe, se, ge, he, be, Ce) {
      var Te = be.length - 1;
      switch (he) {
        case 23:
          this.$ = be[Te];
          break;
        case 24:
          this.$ = be[Te - 1] + "" + be[Te];
          break;
        case 26:
          this.$ = be[Te - 1] + be[Te];
          break;
        case 27:
          this.$ = [be[Te].trim()];
          break;
        case 28:
          be[Te - 2].push(be[Te].trim()), this.$ = be[Te - 2];
          break;
        case 29:
          this.$ = be[Te - 4], ge.addClass(be[Te - 2], be[Te]);
          break;
        case 37:
          this.$ = [];
          break;
        case 42:
          this.$ = be[Te].trim(), ge.setDiagramTitle(this.$);
          break;
        case 43:
          this.$ = be[Te].trim(), ge.setAccTitle(this.$);
          break;
        case 44:
        case 45:
          this.$ = be[Te].trim(), ge.setAccDescription(this.$);
          break;
        case 46:
          ge.addSection(be[Te].substr(8)), this.$ = be[Te].substr(8);
          break;
        case 47:
          ge.addPoint(be[Te - 3], "", be[Te - 1], be[Te], []);
          break;
        case 48:
          ge.addPoint(be[Te - 4], be[Te - 3], be[Te - 1], be[Te], []);
          break;
        case 49:
          ge.addPoint(be[Te - 4], "", be[Te - 2], be[Te - 1], be[Te]);
          break;
        case 50:
          ge.addPoint(be[Te - 5], be[Te - 4], be[Te - 2], be[Te - 1], be[Te]);
          break;
        case 51:
          ge.setXAxisLeftText(be[Te - 2]), ge.setXAxisRightText(be[Te]);
          break;
        case 52:
          be[Te - 1].text += "  ", ge.setXAxisLeftText(be[Te - 1]);
          break;
        case 53:
          ge.setXAxisLeftText(be[Te]);
          break;
        case 54:
          ge.setYAxisBottomText(be[Te - 2]), ge.setYAxisTopText(be[Te]);
          break;
        case 55:
          be[Te - 1].text += "  ", ge.setYAxisBottomText(be[Te - 1]);
          break;
        case 56:
          ge.setYAxisBottomText(be[Te]);
          break;
        case 57:
          ge.setQuadrant1Text(be[Te]);
          break;
        case 58:
          ge.setQuadrant2Text(be[Te]);
          break;
        case 59:
          ge.setQuadrant3Text(be[Te]);
          break;
        case 60:
          ge.setQuadrant4Text(be[Te]);
          break;
        case 64:
          this.$ = { text: be[Te], type: "text" };
          break;
        case 65:
          this.$ = { text: be[Te - 1].text + "" + be[Te], type: be[Te - 1].type };
          break;
        case 66:
          this.$ = { text: be[Te], type: "text" };
          break;
        case 67:
          this.$ = { text: be[Te], type: "markdown" };
          break;
        case 68:
          this.$ = be[Te];
          break;
        case 69:
          this.$ = be[Te - 1] + "" + be[Te];
          break;
      }
    }, "anonymous"),
    table: [{ 18: e, 26: 1, 27: 2, 28: r, 55: n, 56: i, 57: a }, { 1: [3] }, { 18: e, 26: 8, 27: 2, 28: r, 55: n, 56: i, 57: a }, { 18: e, 26: 9, 27: 2, 28: r, 55: n, 56: i, 57: a }, t(s, [2, 33], { 29: 10 }), t(o, [2, 61]), t(o, [2, 62]), t(o, [2, 63]), { 1: [2, 30] }, { 1: [2, 31] }, t(l, u, { 30: 11, 31: 12, 24: 13, 32: 15, 33: 16, 34: 17, 43: 30, 58: 31, 1: [2, 32], 4: h, 5: d, 10: f, 12: p, 13: g, 14: m, 18: v, 25: y, 35: b, 37: w, 39: T, 41: E, 42: L, 48: k, 50: C, 51: A, 52: R, 53: _, 54: O, 60: P, 61: S, 63: M, 64: N, 65: D, 66: I, 67: B }), t(s, [2, 34]), { 27: 45, 55: n, 56: i, 57: a }, t(l, [2, 37]), t(l, u, { 24: 13, 32: 15, 33: 16, 34: 17, 43: 30, 58: 31, 31: 46, 4: h, 5: d, 10: f, 12: p, 13: g, 14: m, 18: v, 25: y, 35: b, 37: w, 39: T, 41: E, 42: L, 48: k, 50: C, 51: A, 52: R, 53: _, 54: O, 60: P, 61: S, 63: M, 64: N, 65: D, 66: I, 67: B }), t(l, [2, 39]), t(l, [2, 40]), t(l, [2, 41]), { 36: [1, 47] }, { 38: [1, 48] }, { 40: [1, 49] }, t(l, [2, 45]), t(l, [2, 46]), { 18: [1, 50] }, { 4: h, 5: d, 10: f, 12: p, 13: g, 14: m, 43: 51, 58: 31, 60: P, 61: S, 63: M, 64: N, 65: D, 66: I, 67: B }, { 4: h, 5: d, 10: f, 12: p, 13: g, 14: m, 43: 52, 58: 31, 60: P, 61: S, 63: M, 64: N, 65: D, 66: I, 67: B }, { 4: h, 5: d, 10: f, 12: p, 13: g, 14: m, 43: 53, 58: 31, 60: P, 61: S, 63: M, 64: N, 65: D, 66: I, 67: B }, { 4: h, 5: d, 10: f, 12: p, 13: g, 14: m, 43: 54, 58: 31, 60: P, 61: S, 63: M, 64: N, 65: D, 66: I, 67: B }, { 4: h, 5: d, 10: f, 12: p, 13: g, 14: m, 43: 55, 58: 31, 60: P, 61: S, 63: M, 64: N, 65: D, 66: I, 67: B }, { 4: h, 5: d, 10: f, 12: p, 13: g, 14: m, 43: 56, 58: 31, 60: P, 61: S, 63: M, 64: N, 65: D, 66: I, 67: B }, { 4: h, 5: d, 8: z, 10: f, 12: p, 13: g, 14: m, 18: F, 44: [1, 57], 47: [1, 58], 58: 60, 59: 59, 63: M, 64: N, 65: D, 66: I, 67: B }, t(V, [2, 64]), t(V, [2, 66]), t(V, [2, 67]), t(V, [2, 70]), t(V, [2, 71]), t(V, [2, 72]), t(V, [2, 73]), t(V, [2, 74]), t(V, [2, 75]), t(V, [2, 76]), t(V, [2, 77]), t(V, [2, 78]), t(V, [2, 79]), t(V, [2, 80]), t(s, [2, 35]), t(l, [2, 38]), t(l, [2, 42]), t(l, [2, 43]), t(l, [2, 44]), { 3: 64, 4: H, 5: J, 6: q, 7: ae, 8: re, 9: pe, 10: K, 11: Z, 12: X, 13: Y, 14: ee, 15: j, 21: 63 }, t(l, [2, 53], { 59: 59, 58: 60, 4: h, 5: d, 8: z, 10: f, 12: p, 13: g, 14: m, 18: F, 49: [1, 77], 63: M, 64: N, 65: D, 66: I, 67: B }), t(l, [2, 56], { 59: 59, 58: 60, 4: h, 5: d, 8: z, 10: f, 12: p, 13: g, 14: m, 18: F, 49: [1, 78], 63: M, 64: N, 65: D, 66: I, 67: B }), t(l, [2, 57], { 59: 59, 58: 60, 4: h, 5: d, 8: z, 10: f, 12: p, 13: g, 14: m, 18: F, 63: M, 64: N, 65: D, 66: I, 67: B }), t(l, [2, 58], { 59: 59, 58: 60, 4: h, 5: d, 8: z, 10: f, 12: p, 13: g, 14: m, 18: F, 63: M, 64: N, 65: D, 66: I, 67: B }), t(l, [2, 59], { 59: 59, 58: 60, 4: h, 5: d, 8: z, 10: f, 12: p, 13: g, 14: m, 18: F, 63: M, 64: N, 65: D, 66: I, 67: B }), t(l, [2, 60], { 59: 59, 58: 60, 4: h, 5: d, 8: z, 10: f, 12: p, 13: g, 14: m, 18: F, 63: M, 64: N, 65: D, 66: I, 67: B }), { 45: [1, 79] }, { 44: [1, 80] }, t(V, [2, 65]), t(V, [2, 81]), t(V, [2, 82]), t(V, [2, 83]), { 3: 82, 4: H, 5: J, 6: q, 7: ae, 8: re, 9: pe, 10: K, 11: Z, 12: X, 13: Y, 14: ee, 15: j, 18: [1, 81] }, t(fe, [2, 23]), t(fe, [2, 1]), t(fe, [2, 2]), t(fe, [2, 3]), t(fe, [2, 4]), t(fe, [2, 5]), t(fe, [2, 6]), t(fe, [2, 7]), t(fe, [2, 8]), t(fe, [2, 9]), t(fe, [2, 10]), t(fe, [2, 11]), t(fe, [2, 12]), t(l, [2, 52], { 58: 31, 43: 83, 4: h, 5: d, 10: f, 12: p, 13: g, 14: m, 60: P, 61: S, 63: M, 64: N, 65: D, 66: I, 67: B }), t(l, [2, 55], { 58: 31, 43: 84, 4: h, 5: d, 10: f, 12: p, 13: g, 14: m, 60: P, 61: S, 63: M, 64: N, 65: D, 66: I, 67: B }), { 46: [1, 85] }, { 45: [1, 86] }, { 4: te, 5: Ae, 6: W, 8: De, 11: ue, 13: ze, 16: 89, 17: Ge, 18: Ve, 19: ke, 20: Oe, 22: 88, 23: 87 }, t(fe, [2, 24]), t(l, [2, 51], { 59: 59, 58: 60, 4: h, 5: d, 8: z, 10: f, 12: p, 13: g, 14: m, 18: F, 63: M, 64: N, 65: D, 66: I, 67: B }), t(l, [2, 54], { 59: 59, 58: 60, 4: h, 5: d, 8: z, 10: f, 12: p, 13: g, 14: m, 18: F, 63: M, 64: N, 65: D, 66: I, 67: B }), t(l, [2, 47], { 22: 88, 16: 89, 23: 100, 4: te, 5: Ae, 6: W, 8: De, 11: ue, 13: ze, 17: Ge, 18: Ve, 19: ke, 20: Oe }), { 46: [1, 101] }, t(l, [2, 29], { 10: Se }), t(_e, [2, 27], { 16: 103, 4: te, 5: Ae, 6: W, 8: De, 11: ue, 13: ze, 17: Ge, 18: Ve, 19: ke, 20: Oe }), t($e, [2, 25]), t($e, [2, 13]), t($e, [2, 14]), t($e, [2, 15]), t($e, [2, 16]), t($e, [2, 17]), t($e, [2, 18]), t($e, [2, 19]), t($e, [2, 20]), t($e, [2, 21]), t($e, [2, 22]), t(l, [2, 49], { 10: Se }), t(l, [2, 48], { 22: 88, 16: 89, 23: 104, 4: te, 5: Ae, 6: W, 8: De, 11: ue, 13: ze, 17: Ge, 18: Ve, 19: ke, 20: Oe }), { 4: te, 5: Ae, 6: W, 8: De, 11: ue, 13: ze, 16: 89, 17: Ge, 18: Ve, 19: ke, 20: Oe, 22: 105 }, t($e, [2, 26]), t(l, [2, 50], { 10: Se }), t(_e, [2, 28], { 16: 103, 4: te, 5: Ae, 6: W, 8: De, 11: ue, 13: ze, 17: Ge, 18: Ve, 19: ke, 20: Oe })],
    defaultActions: { 8: [2, 30], 9: [2, 31] },
    parseError: /* @__PURE__ */ x(function($, oe) {
      if (oe.recoverable)
        this.trace($);
      else {
        var se = new Error($);
        throw se.hash = oe, se;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ x(function($) {
      var oe = this, se = [0], ge = [], he = [null], be = [], Ce = this.table, Te = "", Me = 0, Xe = 0, We = 2, Ke = 1, Ze = be.slice.call(arguments, 1), Pe = Object.create(this.lexer), He = { yy: {} };
      for (var ht in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, ht) && (He.yy[ht] = this.yy[ht]);
      Pe.setInput($, He.yy), He.yy.lexer = Pe, He.yy.parser = this, typeof Pe.yylloc > "u" && (Pe.yylloc = {});
      var st = Pe.yylloc;
      be.push(st);
      var Ue = Pe.options && Pe.options.ranges;
      typeof He.yy.parseError == "function" ? this.parseError = He.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Et(Ht) {
        se.length = se.length - 2 * Ht, he.length = he.length - Ht, be.length = be.length - Ht;
      }
      x(Et, "popStack");
      function qe() {
        var Ht;
        return Ht = ge.pop() || Pe.lex() || Ke, typeof Ht != "number" && (Ht instanceof Array && (ge = Ht, Ht = ge.pop()), Ht = oe.symbols_[Ht] || Ht), Ht;
      }
      x(qe, "lex");
      for (var rt, ct, ut, nt, xt = {}, Qt, Dt, rr, xr; ; ) {
        if (ct = se[se.length - 1], this.defaultActions[ct] ? ut = this.defaultActions[ct] : ((rt === null || typeof rt > "u") && (rt = qe()), ut = Ce[ct] && Ce[ct][rt]), typeof ut > "u" || !ut.length || !ut[0]) {
          var nr = "";
          xr = [];
          for (Qt in Ce[ct])
            this.terminals_[Qt] && Qt > We && xr.push("'" + this.terminals_[Qt] + "'");
          Pe.showPosition ? nr = "Parse error on line " + (Me + 1) + `:
` + Pe.showPosition() + `
Expecting ` + xr.join(", ") + ", got '" + (this.terminals_[rt] || rt) + "'" : nr = "Parse error on line " + (Me + 1) + ": Unexpected " + (rt == Ke ? "end of input" : "'" + (this.terminals_[rt] || rt) + "'"), this.parseError(nr, {
            text: Pe.match,
            token: this.terminals_[rt] || rt,
            line: Pe.yylineno,
            loc: st,
            expected: xr
          });
        }
        if (ut[0] instanceof Array && ut.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + ct + ", token: " + rt);
        switch (ut[0]) {
          case 1:
            se.push(rt), he.push(Pe.yytext), be.push(Pe.yylloc), se.push(ut[1]), rt = null, Xe = Pe.yyleng, Te = Pe.yytext, Me = Pe.yylineno, st = Pe.yylloc;
            break;
          case 2:
            if (Dt = this.productions_[ut[1]][1], xt.$ = he[he.length - Dt], xt._$ = {
              first_line: be[be.length - (Dt || 1)].first_line,
              last_line: be[be.length - 1].last_line,
              first_column: be[be.length - (Dt || 1)].first_column,
              last_column: be[be.length - 1].last_column
            }, Ue && (xt._$.range = [
              be[be.length - (Dt || 1)].range[0],
              be[be.length - 1].range[1]
            ]), nt = this.performAction.apply(xt, [
              Te,
              Xe,
              Me,
              He.yy,
              ut[1],
              he,
              be
            ].concat(Ze)), typeof nt < "u")
              return nt;
            Dt && (se = se.slice(0, -1 * Dt * 2), he = he.slice(0, -1 * Dt), be = be.slice(0, -1 * Dt)), se.push(this.productions_[ut[1]][0]), he.push(xt.$), be.push(xt._$), rr = Ce[se[se.length - 2]][se[se.length - 1]], se.push(rr);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, Ne = /* @__PURE__ */ (function() {
    var ce = {
      EOF: 1,
      parseError: /* @__PURE__ */ x(function(oe, se) {
        if (this.yy.parser)
          this.yy.parser.parseError(oe, se);
        else
          throw new Error(oe);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ x(function($, oe) {
        return this.yy = oe || this.yy || {}, this._input = $, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ x(function() {
        var $ = this._input[0];
        this.yytext += $, this.yyleng++, this.offset++, this.match += $, this.matched += $;
        var oe = $.match(/(?:\r\n?|\n).*/g);
        return oe ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), $;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ x(function($) {
        var oe = $.length, se = $.split(/(?:\r\n?|\n)/g);
        this._input = $ + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - oe), this.offset -= oe;
        var ge = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), se.length - 1 && (this.yylineno -= se.length - 1);
        var he = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: se ? (se.length === ge.length ? this.yylloc.first_column : 0) + ge[ge.length - se.length].length - se[0].length : this.yylloc.first_column - oe
        }, this.options.ranges && (this.yylloc.range = [he[0], he[0] + this.yyleng - oe]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ x(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ x(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ x(function($) {
        this.unput(this.match.slice($));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ x(function() {
        var $ = this.matched.substr(0, this.matched.length - this.match.length);
        return ($.length > 20 ? "..." : "") + $.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ x(function() {
        var $ = this.match;
        return $.length < 20 && ($ += this._input.substr(0, 20 - $.length)), ($.substr(0, 20) + ($.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ x(function() {
        var $ = this.pastInput(), oe = new Array($.length + 1).join("-");
        return $ + this.upcomingInput() + `
` + oe + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ x(function($, oe) {
        var se, ge, he;
        if (this.options.backtrack_lexer && (he = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (he.yylloc.range = this.yylloc.range.slice(0))), ge = $[0].match(/(?:\r\n?|\n).*/g), ge && (this.yylineno += ge.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: ge ? ge[ge.length - 1].length - ge[ge.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + $[0].length
        }, this.yytext += $[0], this.match += $[0], this.matches = $, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice($[0].length), this.matched += $[0], se = this.performAction.call(this, this.yy, this, oe, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), se)
          return se;
        if (this._backtrack) {
          for (var be in he)
            this[be] = he[be];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ x(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var $, oe, se, ge;
        this._more || (this.yytext = "", this.match = "");
        for (var he = this._currentRules(), be = 0; be < he.length; be++)
          if (se = this._input.match(this.rules[he[be]]), se && (!oe || se[0].length > oe[0].length)) {
            if (oe = se, ge = be, this.options.backtrack_lexer) {
              if ($ = this.test_match(se, he[be]), $ !== !1)
                return $;
              if (this._backtrack) {
                oe = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return oe ? ($ = this.test_match(oe, he[ge]), $ !== !1 ? $ : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ x(function() {
        var oe = this.next();
        return oe || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ x(function(oe) {
        this.conditionStack.push(oe);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ x(function() {
        var oe = this.conditionStack.length - 1;
        return oe > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ x(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ x(function(oe) {
        return oe = this.conditionStack.length - 1 - Math.abs(oe || 0), oe >= 0 ? this.conditionStack[oe] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ x(function(oe) {
        this.begin(oe);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ x(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ x(function(oe, se, ge, he) {
        switch (ge) {
          case 0:
            break;
          case 1:
            break;
          case 2:
            return 55;
          case 3:
            break;
          case 4:
            return this.begin("title"), 35;
          case 5:
            return this.popState(), "title_value";
          case 6:
            return this.begin("acc_title"), 37;
          case 7:
            return this.popState(), "acc_title_value";
          case 8:
            return this.begin("acc_descr"), 39;
          case 9:
            return this.popState(), "acc_descr_value";
          case 10:
            this.begin("acc_descr_multiline");
            break;
          case 11:
            this.popState();
            break;
          case 12:
            return "acc_descr_multiline_value";
          case 13:
            return 48;
          case 14:
            return 50;
          case 15:
            return 49;
          case 16:
            return 51;
          case 17:
            return 52;
          case 18:
            return 53;
          case 19:
            return 54;
          case 20:
            return 25;
          case 21:
            this.begin("md_string");
            break;
          case 22:
            return "MD_STR";
          case 23:
            this.popState();
            break;
          case 24:
            this.begin("string");
            break;
          case 25:
            this.popState();
            break;
          case 26:
            return "STR";
          case 27:
            this.begin("class_name");
            break;
          case 28:
            return this.popState(), 47;
          case 29:
            return this.begin("point_start"), 44;
          case 30:
            return this.begin("point_x"), 45;
          case 31:
            this.popState();
            break;
          case 32:
            this.popState(), this.begin("point_y");
            break;
          case 33:
            return this.popState(), 46;
          case 34:
            return 28;
          case 35:
            return 4;
          case 36:
            return 11;
          case 37:
            return 64;
          case 38:
            return 10;
          case 39:
            return 65;
          case 40:
            return 65;
          case 41:
            return 14;
          case 42:
            return 13;
          case 43:
            return 67;
          case 44:
            return 66;
          case 45:
            return 12;
          case 46:
            return 8;
          case 47:
            return 5;
          case 48:
            return 18;
          case 49:
            return 56;
          case 50:
            return 63;
          case 51:
            return 57;
        }
      }, "anonymous"),
      rules: [/^(?:%%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n\r]+)/i, /^(?:%%[^\n]*)/i, /^(?:title\b)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?: *x-axis *)/i, /^(?: *y-axis *)/i, /^(?: *--+> *)/i, /^(?: *quadrant-1 *)/i, /^(?: *quadrant-2 *)/i, /^(?: *quadrant-3 *)/i, /^(?: *quadrant-4 *)/i, /^(?:classDef\b)/i, /^(?:["][`])/i, /^(?:[^`"]+)/i, /^(?:[`]["])/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?::::)/i, /^(?:^\w+)/i, /^(?:\s*:\s*\[\s*)/i, /^(?:(1)|(0(.\d+)?))/i, /^(?:\s*\] *)/i, /^(?:\s*,\s*)/i, /^(?:(1)|(0(.\d+)?))/i, /^(?: *quadrantChart *)/i, /^(?:[A-Za-z]+)/i, /^(?::)/i, /^(?:\+)/i, /^(?:,)/i, /^(?:=)/i, /^(?:=)/i, /^(?:\*)/i, /^(?:#)/i, /^(?:[\_])/i, /^(?:\.)/i, /^(?:&)/i, /^(?:-)/i, /^(?:[0-9]+)/i, /^(?:\s)/i, /^(?:;)/i, /^(?:[!"#$%&'*+,-.`?\\_/])/i, /^(?:$)/i],
      conditions: { class_name: { rules: [28], inclusive: !1 }, point_y: { rules: [33], inclusive: !1 }, point_x: { rules: [32], inclusive: !1 }, point_start: { rules: [30, 31], inclusive: !1 }, acc_descr_multiline: { rules: [11, 12], inclusive: !1 }, acc_descr: { rules: [9], inclusive: !1 }, acc_title: { rules: [7], inclusive: !1 }, title: { rules: [5], inclusive: !1 }, md_string: { rules: [22, 23], inclusive: !1 }, string: { rules: [25, 26], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 6, 8, 10, 13, 14, 15, 16, 17, 18, 19, 20, 21, 24, 27, 29, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], inclusive: !0 } }
    };
    return ce;
  })();
  me.lexer = Ne;
  function Q() {
    this.yy = {};
  }
  return x(Q, "Parser"), Q.prototype = me, me.Parser = Q, new Q();
})();
_6.parser = _6;
var ENe = _6, Ni = M2(), kNe = class {
  constructor() {
    this.classes = /* @__PURE__ */ new Map(), this.config = this.getDefaultConfig(), this.themeConfig = this.getDefaultThemeConfig(), this.data = this.getDefaultData();
  }
  static {
    x(this, "QuadrantBuilder");
  }
  getDefaultData() {
    return {
      titleText: "",
      quadrant1Text: "",
      quadrant2Text: "",
      quadrant3Text: "",
      quadrant4Text: "",
      xAxisLeftText: "",
      xAxisRightText: "",
      yAxisBottomText: "",
      yAxisTopText: "",
      points: []
    };
  }
  getDefaultConfig() {
    return {
      showXAxis: !0,
      showYAxis: !0,
      showTitle: !0,
      chartHeight: ur.quadrantChart?.chartWidth || 500,
      chartWidth: ur.quadrantChart?.chartHeight || 500,
      titlePadding: ur.quadrantChart?.titlePadding || 10,
      titleFontSize: ur.quadrantChart?.titleFontSize || 20,
      quadrantPadding: ur.quadrantChart?.quadrantPadding || 5,
      xAxisLabelPadding: ur.quadrantChart?.xAxisLabelPadding || 5,
      yAxisLabelPadding: ur.quadrantChart?.yAxisLabelPadding || 5,
      xAxisLabelFontSize: ur.quadrantChart?.xAxisLabelFontSize || 16,
      yAxisLabelFontSize: ur.quadrantChart?.yAxisLabelFontSize || 16,
      quadrantLabelFontSize: ur.quadrantChart?.quadrantLabelFontSize || 16,
      quadrantTextTopPadding: ur.quadrantChart?.quadrantTextTopPadding || 5,
      pointTextPadding: ur.quadrantChart?.pointTextPadding || 5,
      pointLabelFontSize: ur.quadrantChart?.pointLabelFontSize || 12,
      pointRadius: ur.quadrantChart?.pointRadius || 5,
      xAxisPosition: ur.quadrantChart?.xAxisPosition || "top",
      yAxisPosition: ur.quadrantChart?.yAxisPosition || "left",
      quadrantInternalBorderStrokeWidth: ur.quadrantChart?.quadrantInternalBorderStrokeWidth || 1,
      quadrantExternalBorderStrokeWidth: ur.quadrantChart?.quadrantExternalBorderStrokeWidth || 2
    };
  }
  getDefaultThemeConfig() {
    return {
      quadrant1Fill: Ni.quadrant1Fill,
      quadrant2Fill: Ni.quadrant2Fill,
      quadrant3Fill: Ni.quadrant3Fill,
      quadrant4Fill: Ni.quadrant4Fill,
      quadrant1TextFill: Ni.quadrant1TextFill,
      quadrant2TextFill: Ni.quadrant2TextFill,
      quadrant3TextFill: Ni.quadrant3TextFill,
      quadrant4TextFill: Ni.quadrant4TextFill,
      quadrantPointFill: Ni.quadrantPointFill,
      quadrantPointTextFill: Ni.quadrantPointTextFill,
      quadrantXAxisTextFill: Ni.quadrantXAxisTextFill,
      quadrantYAxisTextFill: Ni.quadrantYAxisTextFill,
      quadrantTitleFill: Ni.quadrantTitleFill,
      quadrantInternalBorderStrokeFill: Ni.quadrantInternalBorderStrokeFill,
      quadrantExternalBorderStrokeFill: Ni.quadrantExternalBorderStrokeFill
    };
  }
  clear() {
    this.config = this.getDefaultConfig(), this.themeConfig = this.getDefaultThemeConfig(), this.data = this.getDefaultData(), this.classes = /* @__PURE__ */ new Map(), ie.info("clear called");
  }
  setData(t) {
    this.data = { ...this.data, ...t };
  }
  addPoints(t) {
    this.data.points = [...t, ...this.data.points];
  }
  addClass(t, e) {
    this.classes.set(t, e);
  }
  setConfig(t) {
    ie.trace("setConfig called with: ", t), this.config = { ...this.config, ...t };
  }
  setThemeConfig(t) {
    ie.trace("setThemeConfig called with: ", t), this.themeConfig = { ...this.themeConfig, ...t };
  }
  calculateSpace(t, e, r, n) {
    const i = this.config.xAxisLabelPadding * 2 + this.config.xAxisLabelFontSize, a = {
      top: t === "top" && e ? i : 0,
      bottom: t === "bottom" && e ? i : 0
    }, s = this.config.yAxisLabelPadding * 2 + this.config.yAxisLabelFontSize, o = {
      left: this.config.yAxisPosition === "left" && r ? s : 0,
      right: this.config.yAxisPosition === "right" && r ? s : 0
    }, l = this.config.titleFontSize + this.config.titlePadding * 2, u = {
      top: n ? l : 0
    }, h = this.config.quadrantPadding + o.left, d = this.config.quadrantPadding + a.top + u.top, f = this.config.chartWidth - this.config.quadrantPadding * 2 - o.left - o.right, p = this.config.chartHeight - this.config.quadrantPadding * 2 - a.top - a.bottom - u.top, g = f / 2, m = p / 2;
    return {
      xAxisSpace: a,
      yAxisSpace: o,
      titleSpace: u,
      quadrantSpace: {
        quadrantLeft: h,
        quadrantTop: d,
        quadrantWidth: f,
        quadrantHalfWidth: g,
        quadrantHeight: p,
        quadrantHalfHeight: m
      }
    };
  }
  getAxisLabels(t, e, r, n) {
    const { quadrantSpace: i, titleSpace: a } = n, {
      quadrantHalfHeight: s,
      quadrantHeight: o,
      quadrantLeft: l,
      quadrantHalfWidth: u,
      quadrantTop: h,
      quadrantWidth: d
    } = i, f = !!this.data.xAxisRightText, p = !!this.data.yAxisTopText, g = [];
    return this.data.xAxisLeftText && e && g.push({
      text: this.data.xAxisLeftText,
      fill: this.themeConfig.quadrantXAxisTextFill,
      x: l + (f ? u / 2 : 0),
      y: t === "top" ? this.config.xAxisLabelPadding + a.top : this.config.xAxisLabelPadding + h + o + this.config.quadrantPadding,
      fontSize: this.config.xAxisLabelFontSize,
      verticalPos: f ? "center" : "left",
      horizontalPos: "top",
      rotation: 0
    }), this.data.xAxisRightText && e && g.push({
      text: this.data.xAxisRightText,
      fill: this.themeConfig.quadrantXAxisTextFill,
      x: l + u + (f ? u / 2 : 0),
      y: t === "top" ? this.config.xAxisLabelPadding + a.top : this.config.xAxisLabelPadding + h + o + this.config.quadrantPadding,
      fontSize: this.config.xAxisLabelFontSize,
      verticalPos: f ? "center" : "left",
      horizontalPos: "top",
      rotation: 0
    }), this.data.yAxisBottomText && r && g.push({
      text: this.data.yAxisBottomText,
      fill: this.themeConfig.quadrantYAxisTextFill,
      x: this.config.yAxisPosition === "left" ? this.config.yAxisLabelPadding : this.config.yAxisLabelPadding + l + d + this.config.quadrantPadding,
      y: h + o - (p ? s / 2 : 0),
      fontSize: this.config.yAxisLabelFontSize,
      verticalPos: p ? "center" : "left",
      horizontalPos: "top",
      rotation: -90
    }), this.data.yAxisTopText && r && g.push({
      text: this.data.yAxisTopText,
      fill: this.themeConfig.quadrantYAxisTextFill,
      x: this.config.yAxisPosition === "left" ? this.config.yAxisLabelPadding : this.config.yAxisLabelPadding + l + d + this.config.quadrantPadding,
      y: h + s - (p ? s / 2 : 0),
      fontSize: this.config.yAxisLabelFontSize,
      verticalPos: p ? "center" : "left",
      horizontalPos: "top",
      rotation: -90
    }), g;
  }
  getQuadrants(t) {
    const { quadrantSpace: e } = t, { quadrantHalfHeight: r, quadrantLeft: n, quadrantHalfWidth: i, quadrantTop: a } = e, s = [
      {
        text: {
          text: this.data.quadrant1Text,
          fill: this.themeConfig.quadrant1TextFill,
          x: 0,
          y: 0,
          fontSize: this.config.quadrantLabelFontSize,
          verticalPos: "center",
          horizontalPos: "middle",
          rotation: 0
        },
        x: n + i,
        y: a,
        width: i,
        height: r,
        fill: this.themeConfig.quadrant1Fill
      },
      {
        text: {
          text: this.data.quadrant2Text,
          fill: this.themeConfig.quadrant2TextFill,
          x: 0,
          y: 0,
          fontSize: this.config.quadrantLabelFontSize,
          verticalPos: "center",
          horizontalPos: "middle",
          rotation: 0
        },
        x: n,
        y: a,
        width: i,
        height: r,
        fill: this.themeConfig.quadrant2Fill
      },
      {
        text: {
          text: this.data.quadrant3Text,
          fill: this.themeConfig.quadrant3TextFill,
          x: 0,
          y: 0,
          fontSize: this.config.quadrantLabelFontSize,
          verticalPos: "center",
          horizontalPos: "middle",
          rotation: 0
        },
        x: n,
        y: a + r,
        width: i,
        height: r,
        fill: this.themeConfig.quadrant3Fill
      },
      {
        text: {
          text: this.data.quadrant4Text,
          fill: this.themeConfig.quadrant4TextFill,
          x: 0,
          y: 0,
          fontSize: this.config.quadrantLabelFontSize,
          verticalPos: "center",
          horizontalPos: "middle",
          rotation: 0
        },
        x: n + i,
        y: a + r,
        width: i,
        height: r,
        fill: this.themeConfig.quadrant4Fill
      }
    ];
    for (const o of s)
      o.text.x = o.x + o.width / 2, this.data.points.length === 0 ? (o.text.y = o.y + o.height / 2, o.text.horizontalPos = "middle") : (o.text.y = o.y + this.config.quadrantTextTopPadding, o.text.horizontalPos = "top");
    return s;
  }
  getQuadrantPoints(t) {
    const { quadrantSpace: e } = t, { quadrantHeight: r, quadrantLeft: n, quadrantTop: i, quadrantWidth: a } = e, s = gd().domain([0, 1]).range([n, a + n]), o = gd().domain([0, 1]).range([r + i, i]);
    return this.data.points.map((u) => {
      const h = this.classes.get(u.className);
      return h && (u = { ...h, ...u }), {
        x: s(u.x),
        y: o(u.y),
        fill: u.color ?? this.themeConfig.quadrantPointFill,
        radius: u.radius ?? this.config.pointRadius,
        text: {
          text: u.text,
          fill: this.themeConfig.quadrantPointTextFill,
          x: s(u.x),
          y: o(u.y) + this.config.pointTextPadding,
          verticalPos: "center",
          horizontalPos: "top",
          fontSize: this.config.pointLabelFontSize,
          rotation: 0
        },
        strokeColor: u.strokeColor ?? this.themeConfig.quadrantPointFill,
        strokeWidth: u.strokeWidth ?? "0px"
      };
    });
  }
  getBorders(t) {
    const e = this.config.quadrantExternalBorderStrokeWidth / 2, { quadrantSpace: r } = t, {
      quadrantHalfHeight: n,
      quadrantHeight: i,
      quadrantLeft: a,
      quadrantHalfWidth: s,
      quadrantTop: o,
      quadrantWidth: l
    } = r;
    return [
      // top border
      {
        strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
        strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
        x1: a - e,
        y1: o,
        x2: a + l + e,
        y2: o
      },
      // right border
      {
        strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
        strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
        x1: a + l,
        y1: o + e,
        x2: a + l,
        y2: o + i - e
      },
      // bottom border
      {
        strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
        strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
        x1: a - e,
        y1: o + i,
        x2: a + l + e,
        y2: o + i
      },
      // left border
      {
        strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
        strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
        x1: a,
        y1: o + e,
        x2: a,
        y2: o + i - e
      },
      // vertical inner border
      {
        strokeFill: this.themeConfig.quadrantInternalBorderStrokeFill,
        strokeWidth: this.config.quadrantInternalBorderStrokeWidth,
        x1: a + s,
        y1: o + e,
        x2: a + s,
        y2: o + i - e
      },
      // horizontal inner border
      {
        strokeFill: this.themeConfig.quadrantInternalBorderStrokeFill,
        strokeWidth: this.config.quadrantInternalBorderStrokeWidth,
        x1: a + e,
        y1: o + n,
        x2: a + l - e,
        y2: o + n
      }
    ];
  }
  getTitle(t) {
    if (t)
      return {
        text: this.data.titleText,
        fill: this.themeConfig.quadrantTitleFill,
        fontSize: this.config.titleFontSize,
        horizontalPos: "top",
        verticalPos: "center",
        rotation: 0,
        y: this.config.titlePadding,
        x: this.config.chartWidth / 2
      };
  }
  build() {
    const t = this.config.showXAxis && !!(this.data.xAxisLeftText || this.data.xAxisRightText), e = this.config.showYAxis && !!(this.data.yAxisTopText || this.data.yAxisBottomText), r = this.config.showTitle && !!this.data.titleText, n = this.data.points.length > 0 ? "bottom" : this.config.xAxisPosition, i = this.calculateSpace(n, t, e, r);
    return {
      points: this.getQuadrantPoints(i),
      quadrants: this.getQuadrants(i),
      axisLabels: this.getAxisLabels(n, t, e, i),
      borderLines: this.getBorders(i),
      title: this.getTitle(r)
    };
  }
}, lm = class extends Error {
  static {
    x(this, "InvalidStyleError");
  }
  constructor(t, e, r) {
    super(`value for ${t} ${e} is invalid, please use a valid ${r}`), this.name = "InvalidStyleError";
  }
};
function L6(t) {
  return !/^#?([\dA-Fa-f]{6}|[\dA-Fa-f]{3})$/.test(t);
}
x(L6, "validateHexCode");
function lY(t) {
  return !/^\d+$/.test(t);
}
x(lY, "validateNumber");
function cY(t) {
  return !/^\d+px$/.test(t);
}
x(cY, "validateSizeInPixels");
var SNe = we();
function wo(t) {
  return dr(t.trim(), SNe);
}
x(wo, "textSanitizer");
var li = new kNe();
function uY(t) {
  li.setData({ quadrant1Text: wo(t.text) });
}
x(uY, "setQuadrant1Text");
function hY(t) {
  li.setData({ quadrant2Text: wo(t.text) });
}
x(hY, "setQuadrant2Text");
function dY(t) {
  li.setData({ quadrant3Text: wo(t.text) });
}
x(dY, "setQuadrant3Text");
function fY(t) {
  li.setData({ quadrant4Text: wo(t.text) });
}
x(fY, "setQuadrant4Text");
function pY(t) {
  li.setData({ xAxisLeftText: wo(t.text) });
}
x(pY, "setXAxisLeftText");
function gY(t) {
  li.setData({ xAxisRightText: wo(t.text) });
}
x(gY, "setXAxisRightText");
function mY(t) {
  li.setData({ yAxisTopText: wo(t.text) });
}
x(mY, "setYAxisTopText");
function vY(t) {
  li.setData({ yAxisBottomText: wo(t.text) });
}
x(vY, "setYAxisBottomText");
function vb(t) {
  const e = {};
  for (const r of t) {
    const [n, i] = r.trim().split(/\s*:\s*/);
    if (n === "radius") {
      if (lY(i))
        throw new lm(n, i, "number");
      e.radius = parseInt(i);
    } else if (n === "color") {
      if (L6(i))
        throw new lm(n, i, "hex code");
      e.color = i;
    } else if (n === "stroke-color") {
      if (L6(i))
        throw new lm(n, i, "hex code");
      e.strokeColor = i;
    } else if (n === "stroke-width") {
      if (cY(i))
        throw new lm(n, i, "number of pixels (eg. 10px)");
      e.strokeWidth = i;
    } else
      throw new Error(`style named ${n} is not supported.`);
  }
  return e;
}
x(vb, "parseStyles");
function yY(t, e, r, n, i) {
  const a = vb(i);
  li.addPoints([
    {
      x: r,
      y: n,
      text: wo(t.text),
      className: e,
      ...a
    }
  ]);
}
x(yY, "addPoint");
function xY(t, e) {
  li.addClass(t, vb(e));
}
x(xY, "addClass");
function bY(t) {
  li.setConfig({ chartWidth: t });
}
x(bY, "setWidth");
function wY(t) {
  li.setConfig({ chartHeight: t });
}
x(wY, "setHeight");
function TY() {
  const t = we(), { themeVariables: e, quadrantChart: r } = t;
  return r && li.setConfig(r), li.setThemeConfig({
    quadrant1Fill: e.quadrant1Fill,
    quadrant2Fill: e.quadrant2Fill,
    quadrant3Fill: e.quadrant3Fill,
    quadrant4Fill: e.quadrant4Fill,
    quadrant1TextFill: e.quadrant1TextFill,
    quadrant2TextFill: e.quadrant2TextFill,
    quadrant3TextFill: e.quadrant3TextFill,
    quadrant4TextFill: e.quadrant4TextFill,
    quadrantPointFill: e.quadrantPointFill,
    quadrantPointTextFill: e.quadrantPointTextFill,
    quadrantXAxisTextFill: e.quadrantXAxisTextFill,
    quadrantYAxisTextFill: e.quadrantYAxisTextFill,
    quadrantExternalBorderStrokeFill: e.quadrantExternalBorderStrokeFill,
    quadrantInternalBorderStrokeFill: e.quadrantInternalBorderStrokeFill,
    quadrantTitleFill: e.quadrantTitleFill
  }), li.setData({ titleText: Ln() }), li.build();
}
x(TY, "getQuadrantData");
var CNe = /* @__PURE__ */ x(function() {
  li.clear(), _n();
}, "clear"), ANe = {
  setWidth: bY,
  setHeight: wY,
  setQuadrant1Text: uY,
  setQuadrant2Text: hY,
  setQuadrant3Text: dY,
  setQuadrant4Text: fY,
  setXAxisLeftText: pY,
  setXAxisRightText: gY,
  setYAxisTopText: mY,
  setYAxisBottomText: vY,
  parseStyles: vb,
  addPoint: yY,
  addClass: xY,
  getQuadrantData: TY,
  clear: CNe,
  setAccTitle: Cn,
  getAccTitle: Gn,
  setDiagramTitle: Zn,
  getDiagramTitle: Ln,
  getAccDescription: Un,
  setAccDescription: Vn
}, _Ne = /* @__PURE__ */ x((t, e, r, n) => {
  function i(C) {
    return C === "top" ? "hanging" : "middle";
  }
  x(i, "getDominantBaseLine");
  function a(C) {
    return C === "left" ? "start" : "middle";
  }
  x(a, "getTextAnchor");
  function s(C) {
    return `translate(${C.x}, ${C.y}) rotate(${C.rotation || 0})`;
  }
  x(s, "getTransformation");
  const o = we();
  ie.debug(`Rendering quadrant chart
` + t);
  const l = o.securityLevel;
  let u;
  l === "sandbox" && (u = Qe("#i" + e));
  const d = Qe(l === "sandbox" ? u.nodes()[0].contentDocument.body : "body").select(`[id="${e}"]`), f = d.append("g").attr("class", "main"), p = o.quadrantChart?.chartWidth ?? 500, g = o.quadrantChart?.chartHeight ?? 500;
  Xi(d, g, p, o.quadrantChart?.useMaxWidth ?? !0), d.attr("viewBox", "0 0 " + p + " " + g), n.db.setHeight(g), n.db.setWidth(p);
  const m = n.db.getQuadrantData(), v = f.append("g").attr("class", "quadrants"), y = f.append("g").attr("class", "border"), b = f.append("g").attr("class", "data-points"), w = f.append("g").attr("class", "labels"), T = f.append("g").attr("class", "title");
  m.title && T.append("text").attr("x", 0).attr("y", 0).attr("fill", m.title.fill).attr("font-size", m.title.fontSize).attr("dominant-baseline", i(m.title.horizontalPos)).attr("text-anchor", a(m.title.verticalPos)).attr("transform", s(m.title)).text(m.title.text), m.borderLines && y.selectAll("line").data(m.borderLines).enter().append("line").attr("x1", (C) => C.x1).attr("y1", (C) => C.y1).attr("x2", (C) => C.x2).attr("y2", (C) => C.y2).style("stroke", (C) => C.strokeFill).style("stroke-width", (C) => C.strokeWidth);
  const E = v.selectAll("g.quadrant").data(m.quadrants).enter().append("g").attr("class", "quadrant");
  E.append("rect").attr("x", (C) => C.x).attr("y", (C) => C.y).attr("width", (C) => C.width).attr("height", (C) => C.height).attr("fill", (C) => C.fill), E.append("text").attr("x", 0).attr("y", 0).attr("fill", (C) => C.text.fill).attr("font-size", (C) => C.text.fontSize).attr(
    "dominant-baseline",
    (C) => i(C.text.horizontalPos)
  ).attr("text-anchor", (C) => a(C.text.verticalPos)).attr("transform", (C) => s(C.text)).text((C) => C.text.text), w.selectAll("g.label").data(m.axisLabels).enter().append("g").attr("class", "label").append("text").attr("x", 0).attr("y", 0).text((C) => C.text).attr("fill", (C) => C.fill).attr("font-size", (C) => C.fontSize).attr("dominant-baseline", (C) => i(C.horizontalPos)).attr("text-anchor", (C) => a(C.verticalPos)).attr("transform", (C) => s(C));
  const k = b.selectAll("g.data-point").data(m.points).enter().append("g").attr("class", "data-point");
  k.append("circle").attr("cx", (C) => C.x).attr("cy", (C) => C.y).attr("r", (C) => C.radius).attr("fill", (C) => C.fill).attr("stroke", (C) => C.strokeColor).attr("stroke-width", (C) => C.strokeWidth), k.append("text").attr("x", 0).attr("y", 0).text((C) => C.text.text).attr("fill", (C) => C.text.fill).attr("font-size", (C) => C.text.fontSize).attr(
    "dominant-baseline",
    (C) => i(C.text.horizontalPos)
  ).attr("text-anchor", (C) => a(C.text.verticalPos)).attr("transform", (C) => s(C.text));
}, "draw"), LNe = {
  draw: _Ne
}, RNe = {
  parser: ENe,
  db: ANe,
  renderer: LNe,
  styles: /* @__PURE__ */ x(() => "", "styles")
};
const MNe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: RNe
}, Symbol.toStringTag, { value: "Module" }));
var R6 = (function() {
  var t = /* @__PURE__ */ x(function(M, N, D, I) {
    for (D = D || {}, I = M.length; I--; D[M[I]] = N) ;
    return D;
  }, "o"), e = [1, 10, 12, 14, 16, 18, 19, 21, 23], r = [2, 6], n = [1, 3], i = [1, 5], a = [1, 6], s = [1, 7], o = [1, 5, 10, 12, 14, 16, 18, 19, 21, 23, 34, 35, 36], l = [1, 25], u = [1, 26], h = [1, 28], d = [1, 29], f = [1, 30], p = [1, 31], g = [1, 32], m = [1, 33], v = [1, 34], y = [1, 35], b = [1, 36], w = [1, 37], T = [1, 43], E = [1, 42], L = [1, 47], k = [1, 50], C = [1, 10, 12, 14, 16, 18, 19, 21, 23, 34, 35, 36], A = [1, 10, 12, 14, 16, 18, 19, 21, 23, 24, 26, 27, 28, 34, 35, 36], R = [1, 10, 12, 14, 16, 18, 19, 21, 23, 24, 26, 27, 28, 34, 35, 36, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50], _ = [1, 64], O = {
    trace: /* @__PURE__ */ x(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, eol: 4, XYCHART: 5, chartConfig: 6, document: 7, CHART_ORIENTATION: 8, statement: 9, title: 10, text: 11, X_AXIS: 12, parseXAxis: 13, Y_AXIS: 14, parseYAxis: 15, LINE: 16, plotData: 17, BAR: 18, acc_title: 19, acc_title_value: 20, acc_descr: 21, acc_descr_value: 22, acc_descr_multiline_value: 23, SQUARE_BRACES_START: 24, commaSeparatedNumbers: 25, SQUARE_BRACES_END: 26, NUMBER_WITH_DECIMAL: 27, COMMA: 28, xAxisData: 29, bandData: 30, ARROW_DELIMITER: 31, commaSeparatedTexts: 32, yAxisData: 33, NEWLINE: 34, SEMI: 35, EOF: 36, alphaNum: 37, STR: 38, MD_STR: 39, alphaNumToken: 40, AMP: 41, NUM: 42, ALPHA: 43, PLUS: 44, EQUALS: 45, MULT: 46, DOT: 47, BRKT: 48, MINUS: 49, UNDERSCORE: 50, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 5: "XYCHART", 8: "CHART_ORIENTATION", 10: "title", 12: "X_AXIS", 14: "Y_AXIS", 16: "LINE", 18: "BAR", 19: "acc_title", 20: "acc_title_value", 21: "acc_descr", 22: "acc_descr_value", 23: "acc_descr_multiline_value", 24: "SQUARE_BRACES_START", 26: "SQUARE_BRACES_END", 27: "NUMBER_WITH_DECIMAL", 28: "COMMA", 31: "ARROW_DELIMITER", 34: "NEWLINE", 35: "SEMI", 36: "EOF", 38: "STR", 39: "MD_STR", 41: "AMP", 42: "NUM", 43: "ALPHA", 44: "PLUS", 45: "EQUALS", 46: "MULT", 47: "DOT", 48: "BRKT", 49: "MINUS", 50: "UNDERSCORE" },
    productions_: [0, [3, 2], [3, 3], [3, 2], [3, 1], [6, 1], [7, 0], [7, 2], [9, 2], [9, 2], [9, 2], [9, 2], [9, 2], [9, 3], [9, 2], [9, 3], [9, 2], [9, 2], [9, 1], [17, 3], [25, 3], [25, 1], [13, 1], [13, 2], [13, 1], [29, 1], [29, 3], [30, 3], [32, 3], [32, 1], [15, 1], [15, 2], [15, 1], [33, 3], [4, 1], [4, 1], [4, 1], [11, 1], [11, 1], [11, 1], [37, 1], [37, 2], [40, 1], [40, 1], [40, 1], [40, 1], [40, 1], [40, 1], [40, 1], [40, 1], [40, 1], [40, 1]],
    performAction: /* @__PURE__ */ x(function(N, D, I, B, z, F, V) {
      var H = F.length - 1;
      switch (z) {
        case 5:
          B.setOrientation(F[H]);
          break;
        case 9:
          B.setDiagramTitle(F[H].text.trim());
          break;
        case 12:
          B.setLineData({ text: "", type: "text" }, F[H]);
          break;
        case 13:
          B.setLineData(F[H - 1], F[H]);
          break;
        case 14:
          B.setBarData({ text: "", type: "text" }, F[H]);
          break;
        case 15:
          B.setBarData(F[H - 1], F[H]);
          break;
        case 16:
          this.$ = F[H].trim(), B.setAccTitle(this.$);
          break;
        case 17:
        case 18:
          this.$ = F[H].trim(), B.setAccDescription(this.$);
          break;
        case 19:
          this.$ = F[H - 1];
          break;
        case 20:
          this.$ = [Number(F[H - 2]), ...F[H]];
          break;
        case 21:
          this.$ = [Number(F[H])];
          break;
        case 22:
          B.setXAxisTitle(F[H]);
          break;
        case 23:
          B.setXAxisTitle(F[H - 1]);
          break;
        case 24:
          B.setXAxisTitle({ type: "text", text: "" });
          break;
        case 25:
          B.setXAxisBand(F[H]);
          break;
        case 26:
          B.setXAxisRangeData(Number(F[H - 2]), Number(F[H]));
          break;
        case 27:
          this.$ = F[H - 1];
          break;
        case 28:
          this.$ = [F[H - 2], ...F[H]];
          break;
        case 29:
          this.$ = [F[H]];
          break;
        case 30:
          B.setYAxisTitle(F[H]);
          break;
        case 31:
          B.setYAxisTitle(F[H - 1]);
          break;
        case 32:
          B.setYAxisTitle({ type: "text", text: "" });
          break;
        case 33:
          B.setYAxisRangeData(Number(F[H - 2]), Number(F[H]));
          break;
        case 37:
          this.$ = { text: F[H], type: "text" };
          break;
        case 38:
          this.$ = { text: F[H], type: "text" };
          break;
        case 39:
          this.$ = { text: F[H], type: "markdown" };
          break;
        case 40:
          this.$ = F[H];
          break;
        case 41:
          this.$ = F[H - 1] + "" + F[H];
          break;
      }
    }, "anonymous"),
    table: [t(e, r, { 3: 1, 4: 2, 7: 4, 5: n, 34: i, 35: a, 36: s }), { 1: [3] }, t(e, r, { 4: 2, 7: 4, 3: 8, 5: n, 34: i, 35: a, 36: s }), t(e, r, { 4: 2, 7: 4, 6: 9, 3: 10, 5: n, 8: [1, 11], 34: i, 35: a, 36: s }), { 1: [2, 4], 9: 12, 10: [1, 13], 12: [1, 14], 14: [1, 15], 16: [1, 16], 18: [1, 17], 19: [1, 18], 21: [1, 19], 23: [1, 20] }, t(o, [2, 34]), t(o, [2, 35]), t(o, [2, 36]), { 1: [2, 1] }, t(e, r, { 4: 2, 7: 4, 3: 21, 5: n, 34: i, 35: a, 36: s }), { 1: [2, 3] }, t(o, [2, 5]), t(e, [2, 7], { 4: 22, 34: i, 35: a, 36: s }), { 11: 23, 37: 24, 38: l, 39: u, 40: 27, 41: h, 42: d, 43: f, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: w }, { 11: 39, 13: 38, 24: T, 27: E, 29: 40, 30: 41, 37: 24, 38: l, 39: u, 40: 27, 41: h, 42: d, 43: f, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: w }, { 11: 45, 15: 44, 27: L, 33: 46, 37: 24, 38: l, 39: u, 40: 27, 41: h, 42: d, 43: f, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: w }, { 11: 49, 17: 48, 24: k, 37: 24, 38: l, 39: u, 40: 27, 41: h, 42: d, 43: f, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: w }, { 11: 52, 17: 51, 24: k, 37: 24, 38: l, 39: u, 40: 27, 41: h, 42: d, 43: f, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: w }, { 20: [1, 53] }, { 22: [1, 54] }, t(C, [2, 18]), { 1: [2, 2] }, t(C, [2, 8]), t(C, [2, 9]), t(A, [2, 37], { 40: 55, 41: h, 42: d, 43: f, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: w }), t(A, [2, 38]), t(A, [2, 39]), t(R, [2, 40]), t(R, [2, 42]), t(R, [2, 43]), t(R, [2, 44]), t(R, [2, 45]), t(R, [2, 46]), t(R, [2, 47]), t(R, [2, 48]), t(R, [2, 49]), t(R, [2, 50]), t(R, [2, 51]), t(C, [2, 10]), t(C, [2, 22], { 30: 41, 29: 56, 24: T, 27: E }), t(C, [2, 24]), t(C, [2, 25]), { 31: [1, 57] }, { 11: 59, 32: 58, 37: 24, 38: l, 39: u, 40: 27, 41: h, 42: d, 43: f, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: w }, t(C, [2, 11]), t(C, [2, 30], { 33: 60, 27: L }), t(C, [2, 32]), { 31: [1, 61] }, t(C, [2, 12]), { 17: 62, 24: k }, { 25: 63, 27: _ }, t(C, [2, 14]), { 17: 65, 24: k }, t(C, [2, 16]), t(C, [2, 17]), t(R, [2, 41]), t(C, [2, 23]), { 27: [1, 66] }, { 26: [1, 67] }, { 26: [2, 29], 28: [1, 68] }, t(C, [2, 31]), { 27: [1, 69] }, t(C, [2, 13]), { 26: [1, 70] }, { 26: [2, 21], 28: [1, 71] }, t(C, [2, 15]), t(C, [2, 26]), t(C, [2, 27]), { 11: 59, 32: 72, 37: 24, 38: l, 39: u, 40: 27, 41: h, 42: d, 43: f, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: w }, t(C, [2, 33]), t(C, [2, 19]), { 25: 73, 27: _ }, { 26: [2, 28] }, { 26: [2, 20] }],
    defaultActions: { 8: [2, 1], 10: [2, 3], 21: [2, 2], 72: [2, 28], 73: [2, 20] },
    parseError: /* @__PURE__ */ x(function(N, D) {
      if (D.recoverable)
        this.trace(N);
      else {
        var I = new Error(N);
        throw I.hash = D, I;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ x(function(N) {
      var D = this, I = [0], B = [], z = [null], F = [], V = this.table, H = "", J = 0, q = 0, ae = 2, re = 1, pe = F.slice.call(arguments, 1), K = Object.create(this.lexer), Z = { yy: {} };
      for (var X in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, X) && (Z.yy[X] = this.yy[X]);
      K.setInput(N, Z.yy), Z.yy.lexer = K, Z.yy.parser = this, typeof K.yylloc > "u" && (K.yylloc = {});
      var Y = K.yylloc;
      F.push(Y);
      var ee = K.options && K.options.ranges;
      typeof Z.yy.parseError == "function" ? this.parseError = Z.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function j(Se) {
        I.length = I.length - 2 * Se, z.length = z.length - Se, F.length = F.length - Se;
      }
      x(j, "popStack");
      function fe() {
        var Se;
        return Se = B.pop() || K.lex() || re, typeof Se != "number" && (Se instanceof Array && (B = Se, Se = B.pop()), Se = D.symbols_[Se] || Se), Se;
      }
      x(fe, "lex");
      for (var te, Ae, W, De, ue = {}, ze, Ge, Ve, ke; ; ) {
        if (Ae = I[I.length - 1], this.defaultActions[Ae] ? W = this.defaultActions[Ae] : ((te === null || typeof te > "u") && (te = fe()), W = V[Ae] && V[Ae][te]), typeof W > "u" || !W.length || !W[0]) {
          var Oe = "";
          ke = [];
          for (ze in V[Ae])
            this.terminals_[ze] && ze > ae && ke.push("'" + this.terminals_[ze] + "'");
          K.showPosition ? Oe = "Parse error on line " + (J + 1) + `:
` + K.showPosition() + `
Expecting ` + ke.join(", ") + ", got '" + (this.terminals_[te] || te) + "'" : Oe = "Parse error on line " + (J + 1) + ": Unexpected " + (te == re ? "end of input" : "'" + (this.terminals_[te] || te) + "'"), this.parseError(Oe, {
            text: K.match,
            token: this.terminals_[te] || te,
            line: K.yylineno,
            loc: Y,
            expected: ke
          });
        }
        if (W[0] instanceof Array && W.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Ae + ", token: " + te);
        switch (W[0]) {
          case 1:
            I.push(te), z.push(K.yytext), F.push(K.yylloc), I.push(W[1]), te = null, q = K.yyleng, H = K.yytext, J = K.yylineno, Y = K.yylloc;
            break;
          case 2:
            if (Ge = this.productions_[W[1]][1], ue.$ = z[z.length - Ge], ue._$ = {
              first_line: F[F.length - (Ge || 1)].first_line,
              last_line: F[F.length - 1].last_line,
              first_column: F[F.length - (Ge || 1)].first_column,
              last_column: F[F.length - 1].last_column
            }, ee && (ue._$.range = [
              F[F.length - (Ge || 1)].range[0],
              F[F.length - 1].range[1]
            ]), De = this.performAction.apply(ue, [
              H,
              q,
              J,
              Z.yy,
              W[1],
              z,
              F
            ].concat(pe)), typeof De < "u")
              return De;
            Ge && (I = I.slice(0, -1 * Ge * 2), z = z.slice(0, -1 * Ge), F = F.slice(0, -1 * Ge)), I.push(this.productions_[W[1]][0]), z.push(ue.$), F.push(ue._$), Ve = V[I[I.length - 2]][I[I.length - 1]], I.push(Ve);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, P = /* @__PURE__ */ (function() {
    var M = {
      EOF: 1,
      parseError: /* @__PURE__ */ x(function(D, I) {
        if (this.yy.parser)
          this.yy.parser.parseError(D, I);
        else
          throw new Error(D);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ x(function(N, D) {
        return this.yy = D || this.yy || {}, this._input = N, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ x(function() {
        var N = this._input[0];
        this.yytext += N, this.yyleng++, this.offset++, this.match += N, this.matched += N;
        var D = N.match(/(?:\r\n?|\n).*/g);
        return D ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), N;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ x(function(N) {
        var D = N.length, I = N.split(/(?:\r\n?|\n)/g);
        this._input = N + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - D), this.offset -= D;
        var B = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), I.length - 1 && (this.yylineno -= I.length - 1);
        var z = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: I ? (I.length === B.length ? this.yylloc.first_column : 0) + B[B.length - I.length].length - I[0].length : this.yylloc.first_column - D
        }, this.options.ranges && (this.yylloc.range = [z[0], z[0] + this.yyleng - D]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ x(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ x(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ x(function(N) {
        this.unput(this.match.slice(N));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ x(function() {
        var N = this.matched.substr(0, this.matched.length - this.match.length);
        return (N.length > 20 ? "..." : "") + N.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ x(function() {
        var N = this.match;
        return N.length < 20 && (N += this._input.substr(0, 20 - N.length)), (N.substr(0, 20) + (N.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ x(function() {
        var N = this.pastInput(), D = new Array(N.length + 1).join("-");
        return N + this.upcomingInput() + `
` + D + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ x(function(N, D) {
        var I, B, z;
        if (this.options.backtrack_lexer && (z = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (z.yylloc.range = this.yylloc.range.slice(0))), B = N[0].match(/(?:\r\n?|\n).*/g), B && (this.yylineno += B.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: B ? B[B.length - 1].length - B[B.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + N[0].length
        }, this.yytext += N[0], this.match += N[0], this.matches = N, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(N[0].length), this.matched += N[0], I = this.performAction.call(this, this.yy, this, D, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), I)
          return I;
        if (this._backtrack) {
          for (var F in z)
            this[F] = z[F];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ x(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var N, D, I, B;
        this._more || (this.yytext = "", this.match = "");
        for (var z = this._currentRules(), F = 0; F < z.length; F++)
          if (I = this._input.match(this.rules[z[F]]), I && (!D || I[0].length > D[0].length)) {
            if (D = I, B = F, this.options.backtrack_lexer) {
              if (N = this.test_match(I, z[F]), N !== !1)
                return N;
              if (this._backtrack) {
                D = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return D ? (N = this.test_match(D, z[B]), N !== !1 ? N : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ x(function() {
        var D = this.next();
        return D || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ x(function(D) {
        this.conditionStack.push(D);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ x(function() {
        var D = this.conditionStack.length - 1;
        return D > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ x(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ x(function(D) {
        return D = this.conditionStack.length - 1 - Math.abs(D || 0), D >= 0 ? this.conditionStack[D] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ x(function(D) {
        this.begin(D);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ x(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ x(function(D, I, B, z) {
        switch (B) {
          case 0:
            break;
          case 1:
            break;
          case 2:
            return this.popState(), 34;
          case 3:
            return this.popState(), 34;
          case 4:
            return 34;
          case 5:
            break;
          case 6:
            return 10;
          case 7:
            return this.pushState("acc_title"), 19;
          case 8:
            return this.popState(), "acc_title_value";
          case 9:
            return this.pushState("acc_descr"), 21;
          case 10:
            return this.popState(), "acc_descr_value";
          case 11:
            this.pushState("acc_descr_multiline");
            break;
          case 12:
            this.popState();
            break;
          case 13:
            return "acc_descr_multiline_value";
          case 14:
            return 5;
          case 15:
            return 5;
          case 16:
            return 8;
          case 17:
            return this.pushState("axis_data"), "X_AXIS";
          case 18:
            return this.pushState("axis_data"), "Y_AXIS";
          case 19:
            return this.pushState("axis_band_data"), 24;
          case 20:
            return 31;
          case 21:
            return this.pushState("data"), 16;
          case 22:
            return this.pushState("data"), 18;
          case 23:
            return this.pushState("data_inner"), 24;
          case 24:
            return 27;
          case 25:
            return this.popState(), 26;
          case 26:
            this.popState();
            break;
          case 27:
            this.pushState("string");
            break;
          case 28:
            this.popState();
            break;
          case 29:
            return "STR";
          case 30:
            return 24;
          case 31:
            return 26;
          case 32:
            return 43;
          case 33:
            return "COLON";
          case 34:
            return 44;
          case 35:
            return 28;
          case 36:
            return 45;
          case 37:
            return 46;
          case 38:
            return 48;
          case 39:
            return 50;
          case 40:
            return 47;
          case 41:
            return 41;
          case 42:
            return 49;
          case 43:
            return 42;
          case 44:
            break;
          case 45:
            return 35;
          case 46:
            return 36;
        }
      }, "anonymous"),
      rules: [/^(?:%%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:(\r?\n))/i, /^(?:(\r?\n))/i, /^(?:[\n\r]+)/i, /^(?:%%[^\n]*)/i, /^(?:title\b)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:\{)/i, /^(?:[^\}]*)/i, /^(?:xychart-beta\b)/i, /^(?:xychart\b)/i, /^(?:(?:vertical|horizontal))/i, /^(?:x-axis\b)/i, /^(?:y-axis\b)/i, /^(?:\[)/i, /^(?:-->)/i, /^(?:line\b)/i, /^(?:bar\b)/i, /^(?:\[)/i, /^(?:[+-]?(?:\d+(?:\.\d+)?|\.\d+))/i, /^(?:\])/i, /^(?:(?:`\)                                    \{ this\.pushState\(md_string\); \}\n<md_string>\(\?:\(\?!`"\)\.\)\+                  \{ return MD_STR; \}\n<md_string>\(\?:`))/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:\[)/i, /^(?:\])/i, /^(?:[A-Za-z]+)/i, /^(?::)/i, /^(?:\+)/i, /^(?:,)/i, /^(?:=)/i, /^(?:\*)/i, /^(?:#)/i, /^(?:[\_])/i, /^(?:\.)/i, /^(?:&)/i, /^(?:-)/i, /^(?:[0-9]+)/i, /^(?:\s+)/i, /^(?:;)/i, /^(?:$)/i],
      conditions: { data_inner: { rules: [0, 1, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46], inclusive: !0 }, data: { rules: [0, 1, 3, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 23, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46], inclusive: !0 }, axis_band_data: { rules: [0, 1, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46], inclusive: !0 }, axis_data: { rules: [0, 1, 2, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46], inclusive: !0 }, acc_descr_multiline: { rules: [12, 13], inclusive: !1 }, acc_descr: { rules: [10], inclusive: !1 }, acc_title: { rules: [8], inclusive: !1 }, title: { rules: [], inclusive: !1 }, md_string: { rules: [], inclusive: !1 }, string: { rules: [28, 29], inclusive: !1 }, INITIAL: { rules: [0, 1, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46], inclusive: !0 } }
    };
    return M;
  })();
  O.lexer = P;
  function S() {
    this.yy = {};
  }
  return x(S, "Parser"), S.prototype = O, O.Parser = S, new S();
})();
R6.parser = R6;
var NNe = R6;
function M6(t) {
  return t.type === "bar";
}
x(M6, "isBarPlot");
function S7(t) {
  return t.type === "band";
}
x(S7, "isBandAxisData");
function cd(t) {
  return t.type === "linear";
}
x(cd, "isLinearAxisData");
var EY = class {
  constructor(t) {
    this.parentGroup = t;
  }
  static {
    x(this, "TextDimensionCalculatorWithFont");
  }
  getMaxDimension(t, e) {
    if (!this.parentGroup)
      return {
        width: t.reduce((i, a) => Math.max(a.length, i), 0) * e,
        height: e
      };
    const r = {
      width: 0,
      height: 0
    }, n = this.parentGroup.append("g").attr("visibility", "hidden").attr("font-size", e);
    for (const i of t) {
      const a = $B(n, 1, i), s = a ? a.width : i.length * e, o = a ? a.height : e;
      r.width = Math.max(r.width, s), r.height = Math.max(r.height, o);
    }
    return n.remove(), r;
  }
}, CN = 0.7, AN = 0.2, kY = class {
  constructor(t, e, r, n) {
    this.axisConfig = t, this.title = e, this.textDimensionCalculator = r, this.axisThemeConfig = n, this.boundingRect = { x: 0, y: 0, width: 0, height: 0 }, this.axisPosition = "left", this.showTitle = !1, this.showLabel = !1, this.showTick = !1, this.showAxisLine = !1, this.outerPadding = 0, this.titleTextHeight = 0, this.labelTextHeight = 0, this.range = [0, 10], this.boundingRect = { x: 0, y: 0, width: 0, height: 0 }, this.axisPosition = "left";
  }
  static {
    x(this, "BaseAxis");
  }
  setRange(t) {
    this.range = t, this.axisPosition === "left" || this.axisPosition === "right" ? this.boundingRect.height = t[1] - t[0] : this.boundingRect.width = t[1] - t[0], this.recalculateScale();
  }
  getRange() {
    return [this.range[0] + this.outerPadding, this.range[1] - this.outerPadding];
  }
  setAxisPosition(t) {
    this.axisPosition = t, this.setRange(this.range);
  }
  getTickDistance() {
    const t = this.getRange();
    return Math.abs(t[0] - t[1]) / this.getTickValues().length;
  }
  getAxisOuterPadding() {
    return this.outerPadding;
  }
  getLabelDimension() {
    return this.textDimensionCalculator.getMaxDimension(
      this.getTickValues().map((t) => t.toString()),
      this.axisConfig.labelFontSize
    );
  }
  recalculateOuterPaddingToDrawBar() {
    CN * this.getTickDistance() > this.outerPadding * 2 && (this.outerPadding = Math.floor(CN * this.getTickDistance() / 2)), this.recalculateScale();
  }
  calculateSpaceIfDrawnHorizontally(t) {
    let e = t.height;
    if (this.axisConfig.showAxisLine && e > this.axisConfig.axisLineWidth && (e -= this.axisConfig.axisLineWidth, this.showAxisLine = !0), this.axisConfig.showLabel) {
      const r = this.getLabelDimension(), n = AN * t.width;
      this.outerPadding = Math.min(r.width / 2, n);
      const i = r.height + this.axisConfig.labelPadding * 2;
      this.labelTextHeight = r.height, i <= e && (e -= i, this.showLabel = !0);
    }
    if (this.axisConfig.showTick && e >= this.axisConfig.tickLength && (this.showTick = !0, e -= this.axisConfig.tickLength), this.axisConfig.showTitle && this.title) {
      const r = this.textDimensionCalculator.getMaxDimension(
        [this.title],
        this.axisConfig.titleFontSize
      ), n = r.height + this.axisConfig.titlePadding * 2;
      this.titleTextHeight = r.height, n <= e && (e -= n, this.showTitle = !0);
    }
    this.boundingRect.width = t.width, this.boundingRect.height = t.height - e;
  }
  calculateSpaceIfDrawnVertical(t) {
    let e = t.width;
    if (this.axisConfig.showAxisLine && e > this.axisConfig.axisLineWidth && (e -= this.axisConfig.axisLineWidth, this.showAxisLine = !0), this.axisConfig.showLabel) {
      const r = this.getLabelDimension(), n = AN * t.height;
      this.outerPadding = Math.min(r.height / 2, n);
      const i = r.width + this.axisConfig.labelPadding * 2;
      i <= e && (e -= i, this.showLabel = !0);
    }
    if (this.axisConfig.showTick && e >= this.axisConfig.tickLength && (this.showTick = !0, e -= this.axisConfig.tickLength), this.axisConfig.showTitle && this.title) {
      const r = this.textDimensionCalculator.getMaxDimension(
        [this.title],
        this.axisConfig.titleFontSize
      ), n = r.height + this.axisConfig.titlePadding * 2;
      this.titleTextHeight = r.height, n <= e && (e -= n, this.showTitle = !0);
    }
    this.boundingRect.width = t.width - e, this.boundingRect.height = t.height;
  }
  calculateSpace(t) {
    return this.axisPosition === "left" || this.axisPosition === "right" ? this.calculateSpaceIfDrawnVertical(t) : this.calculateSpaceIfDrawnHorizontally(t), this.recalculateScale(), {
      width: this.boundingRect.width,
      height: this.boundingRect.height
    };
  }
  setBoundingBoxXY(t) {
    this.boundingRect.x = t.x, this.boundingRect.y = t.y;
  }
  getDrawableElementsForLeftAxis() {
    const t = [];
    if (this.showAxisLine) {
      const e = this.boundingRect.x + this.boundingRect.width - this.axisConfig.axisLineWidth / 2;
      t.push({
        type: "path",
        groupTexts: ["left-axis", "axisl-line"],
        data: [
          {
            path: `M ${e},${this.boundingRect.y} L ${e},${this.boundingRect.y + this.boundingRect.height} `,
            strokeFill: this.axisThemeConfig.axisLineColor,
            strokeWidth: this.axisConfig.axisLineWidth
          }
        ]
      });
    }
    if (this.showLabel && t.push({
      type: "text",
      groupTexts: ["left-axis", "label"],
      data: this.getTickValues().map((e) => ({
        text: e.toString(),
        x: this.boundingRect.x + this.boundingRect.width - (this.showLabel ? this.axisConfig.labelPadding : 0) - (this.showTick ? this.axisConfig.tickLength : 0) - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0),
        y: this.getScaleValue(e),
        fill: this.axisThemeConfig.labelColor,
        fontSize: this.axisConfig.labelFontSize,
        rotation: 0,
        verticalPos: "middle",
        horizontalPos: "right"
      }))
    }), this.showTick) {
      const e = this.boundingRect.x + this.boundingRect.width - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0);
      t.push({
        type: "path",
        groupTexts: ["left-axis", "ticks"],
        data: this.getTickValues().map((r) => ({
          path: `M ${e},${this.getScaleValue(r)} L ${e - this.axisConfig.tickLength},${this.getScaleValue(r)}`,
          strokeFill: this.axisThemeConfig.tickColor,
          strokeWidth: this.axisConfig.tickWidth
        }))
      });
    }
    return this.showTitle && t.push({
      type: "text",
      groupTexts: ["left-axis", "title"],
      data: [
        {
          text: this.title,
          x: this.boundingRect.x + this.axisConfig.titlePadding,
          y: this.boundingRect.y + this.boundingRect.height / 2,
          fill: this.axisThemeConfig.titleColor,
          fontSize: this.axisConfig.titleFontSize,
          rotation: 270,
          verticalPos: "top",
          horizontalPos: "center"
        }
      ]
    }), t;
  }
  getDrawableElementsForBottomAxis() {
    const t = [];
    if (this.showAxisLine) {
      const e = this.boundingRect.y + this.axisConfig.axisLineWidth / 2;
      t.push({
        type: "path",
        groupTexts: ["bottom-axis", "axis-line"],
        data: [
          {
            path: `M ${this.boundingRect.x},${e} L ${this.boundingRect.x + this.boundingRect.width},${e}`,
            strokeFill: this.axisThemeConfig.axisLineColor,
            strokeWidth: this.axisConfig.axisLineWidth
          }
        ]
      });
    }
    if (this.showLabel && t.push({
      type: "text",
      groupTexts: ["bottom-axis", "label"],
      data: this.getTickValues().map((e) => ({
        text: e.toString(),
        x: this.getScaleValue(e),
        y: this.boundingRect.y + this.axisConfig.labelPadding + (this.showTick ? this.axisConfig.tickLength : 0) + (this.showAxisLine ? this.axisConfig.axisLineWidth : 0),
        fill: this.axisThemeConfig.labelColor,
        fontSize: this.axisConfig.labelFontSize,
        rotation: 0,
        verticalPos: "top",
        horizontalPos: "center"
      }))
    }), this.showTick) {
      const e = this.boundingRect.y + (this.showAxisLine ? this.axisConfig.axisLineWidth : 0);
      t.push({
        type: "path",
        groupTexts: ["bottom-axis", "ticks"],
        data: this.getTickValues().map((r) => ({
          path: `M ${this.getScaleValue(r)},${e} L ${this.getScaleValue(r)},${e + this.axisConfig.tickLength}`,
          strokeFill: this.axisThemeConfig.tickColor,
          strokeWidth: this.axisConfig.tickWidth
        }))
      });
    }
    return this.showTitle && t.push({
      type: "text",
      groupTexts: ["bottom-axis", "title"],
      data: [
        {
          text: this.title,
          x: this.range[0] + (this.range[1] - this.range[0]) / 2,
          y: this.boundingRect.y + this.boundingRect.height - this.axisConfig.titlePadding - this.titleTextHeight,
          fill: this.axisThemeConfig.titleColor,
          fontSize: this.axisConfig.titleFontSize,
          rotation: 0,
          verticalPos: "top",
          horizontalPos: "center"
        }
      ]
    }), t;
  }
  getDrawableElementsForTopAxis() {
    const t = [];
    if (this.showAxisLine) {
      const e = this.boundingRect.y + this.boundingRect.height - this.axisConfig.axisLineWidth / 2;
      t.push({
        type: "path",
        groupTexts: ["top-axis", "axis-line"],
        data: [
          {
            path: `M ${this.boundingRect.x},${e} L ${this.boundingRect.x + this.boundingRect.width},${e}`,
            strokeFill: this.axisThemeConfig.axisLineColor,
            strokeWidth: this.axisConfig.axisLineWidth
          }
        ]
      });
    }
    if (this.showLabel && t.push({
      type: "text",
      groupTexts: ["top-axis", "label"],
      data: this.getTickValues().map((e) => ({
        text: e.toString(),
        x: this.getScaleValue(e),
        y: this.boundingRect.y + (this.showTitle ? this.titleTextHeight + this.axisConfig.titlePadding * 2 : 0) + this.axisConfig.labelPadding,
        fill: this.axisThemeConfig.labelColor,
        fontSize: this.axisConfig.labelFontSize,
        rotation: 0,
        verticalPos: "top",
        horizontalPos: "center"
      }))
    }), this.showTick) {
      const e = this.boundingRect.y;
      t.push({
        type: "path",
        groupTexts: ["top-axis", "ticks"],
        data: this.getTickValues().map((r) => ({
          path: `M ${this.getScaleValue(r)},${e + this.boundingRect.height - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0)} L ${this.getScaleValue(r)},${e + this.boundingRect.height - this.axisConfig.tickLength - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0)}`,
          strokeFill: this.axisThemeConfig.tickColor,
          strokeWidth: this.axisConfig.tickWidth
        }))
      });
    }
    return this.showTitle && t.push({
      type: "text",
      groupTexts: ["top-axis", "title"],
      data: [
        {
          text: this.title,
          x: this.boundingRect.x + this.boundingRect.width / 2,
          y: this.boundingRect.y + this.axisConfig.titlePadding,
          fill: this.axisThemeConfig.titleColor,
          fontSize: this.axisConfig.titleFontSize,
          rotation: 0,
          verticalPos: "top",
          horizontalPos: "center"
        }
      ]
    }), t;
  }
  getDrawableElements() {
    if (this.axisPosition === "left")
      return this.getDrawableElementsForLeftAxis();
    if (this.axisPosition === "right")
      throw Error("Drawing of right axis is not implemented");
    return this.axisPosition === "bottom" ? this.getDrawableElementsForBottomAxis() : this.axisPosition === "top" ? this.getDrawableElementsForTopAxis() : [];
  }
}, INe = class extends kY {
  static {
    x(this, "BandAxis");
  }
  constructor(t, e, r, n, i) {
    super(t, n, i, e), this.categories = r, this.scale = vw().domain(this.categories).range(this.getRange());
  }
  setRange(t) {
    super.setRange(t);
  }
  recalculateScale() {
    this.scale = vw().domain(this.categories).range(this.getRange()).paddingInner(1).paddingOuter(0).align(0.5), ie.trace("BandAxis axis final categories, range: ", this.categories, this.getRange());
  }
  getTickValues() {
    return this.categories;
  }
  getScaleValue(t) {
    return this.scale(t) ?? this.getRange()[0];
  }
}, DNe = class extends kY {
  static {
    x(this, "LinearAxis");
  }
  constructor(t, e, r, n, i) {
    super(t, n, i, e), this.domain = r, this.scale = gd().domain(this.domain).range(this.getRange());
  }
  getTickValues() {
    return this.scale.ticks();
  }
  recalculateScale() {
    const t = [...this.domain];
    this.axisPosition === "left" && t.reverse(), this.scale = gd().domain(t).range(this.getRange());
  }
  getScaleValue(t) {
    return this.scale(t);
  }
};
function N6(t, e, r, n) {
  const i = new EY(n);
  return S7(t) ? new INe(
    e,
    r,
    t.categories,
    t.title,
    i
  ) : new DNe(
    e,
    r,
    [t.min, t.max],
    t.title,
    i
  );
}
x(N6, "getAxis");
var ONe = class {
  constructor(t, e, r, n) {
    this.textDimensionCalculator = t, this.chartConfig = e, this.chartData = r, this.chartThemeConfig = n, this.boundingRect = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    }, this.showChartTitle = !1;
  }
  static {
    x(this, "ChartTitle");
  }
  setBoundingBoxXY(t) {
    this.boundingRect.x = t.x, this.boundingRect.y = t.y;
  }
  calculateSpace(t) {
    const e = this.textDimensionCalculator.getMaxDimension(
      [this.chartData.title],
      this.chartConfig.titleFontSize
    ), r = Math.max(e.width, t.width), n = e.height + 2 * this.chartConfig.titlePadding;
    return e.width <= r && e.height <= n && this.chartConfig.showTitle && this.chartData.title && (this.boundingRect.width = r, this.boundingRect.height = n, this.showChartTitle = !0), {
      width: this.boundingRect.width,
      height: this.boundingRect.height
    };
  }
  getDrawableElements() {
    const t = [];
    return this.showChartTitle && t.push({
      groupTexts: ["chart-title"],
      type: "text",
      data: [
        {
          fontSize: this.chartConfig.titleFontSize,
          text: this.chartData.title,
          verticalPos: "middle",
          horizontalPos: "center",
          x: this.boundingRect.x + this.boundingRect.width / 2,
          y: this.boundingRect.y + this.boundingRect.height / 2,
          fill: this.chartThemeConfig.titleColor,
          rotation: 0
        }
      ]
    }), t;
  }
};
function SY(t, e, r, n) {
  const i = new EY(n);
  return new ONe(i, t, e, r);
}
x(SY, "getChartTitleComponent");
var PNe = class {
  constructor(t, e, r, n, i) {
    this.plotData = t, this.xAxis = e, this.yAxis = r, this.orientation = n, this.plotIndex = i;
  }
  static {
    x(this, "LinePlot");
  }
  getDrawableElement() {
    const t = this.plotData.data.map((r) => [
      this.xAxis.getScaleValue(r[0]),
      this.yAxis.getScaleValue(r[1])
    ]);
    let e;
    return this.orientation === "horizontal" ? e = gp().y((r) => r[0]).x((r) => r[1])(t) : e = gp().x((r) => r[0]).y((r) => r[1])(t), e ? [
      {
        groupTexts: ["plot", `line-plot-${this.plotIndex}`],
        type: "path",
        data: [
          {
            path: e,
            strokeFill: this.plotData.strokeFill,
            strokeWidth: this.plotData.strokeWidth
          }
        ]
      }
    ] : [];
  }
}, BNe = class {
  constructor(t, e, r, n, i, a) {
    this.barData = t, this.boundingRect = e, this.xAxis = r, this.yAxis = n, this.orientation = i, this.plotIndex = a;
  }
  static {
    x(this, "BarPlot");
  }
  getDrawableElement() {
    const t = this.barData.data.map((i) => [
      this.xAxis.getScaleValue(i[0]),
      this.yAxis.getScaleValue(i[1])
    ]), r = Math.min(this.xAxis.getAxisOuterPadding() * 2, this.xAxis.getTickDistance()) * (1 - 0.05), n = r / 2;
    return this.orientation === "horizontal" ? [
      {
        groupTexts: ["plot", `bar-plot-${this.plotIndex}`],
        type: "rect",
        data: t.map((i) => ({
          x: this.boundingRect.x,
          y: i[0] - n,
          height: r,
          width: i[1] - this.boundingRect.x,
          fill: this.barData.fill,
          strokeWidth: 0,
          strokeFill: this.barData.fill
        }))
      }
    ] : [
      {
        groupTexts: ["plot", `bar-plot-${this.plotIndex}`],
        type: "rect",
        data: t.map((i) => ({
          x: i[0] - n,
          y: i[1],
          width: r,
          height: this.boundingRect.y + this.boundingRect.height - i[1],
          fill: this.barData.fill,
          strokeWidth: 0,
          strokeFill: this.barData.fill
        }))
      }
    ];
  }
}, FNe = class {
  constructor(t, e, r) {
    this.chartConfig = t, this.chartData = e, this.chartThemeConfig = r, this.boundingRect = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
  static {
    x(this, "BasePlot");
  }
  setAxes(t, e) {
    this.xAxis = t, this.yAxis = e;
  }
  setBoundingBoxXY(t) {
    this.boundingRect.x = t.x, this.boundingRect.y = t.y;
  }
  calculateSpace(t) {
    return this.boundingRect.width = t.width, this.boundingRect.height = t.height, {
      width: this.boundingRect.width,
      height: this.boundingRect.height
    };
  }
  getDrawableElements() {
    if (!(this.xAxis && this.yAxis))
      throw Error("Axes must be passed to render Plots");
    const t = [];
    for (const [e, r] of this.chartData.plots.entries())
      switch (r.type) {
        case "line":
          {
            const n = new PNe(
              r,
              this.xAxis,
              this.yAxis,
              this.chartConfig.chartOrientation,
              e
            );
            t.push(...n.getDrawableElement());
          }
          break;
        case "bar":
          {
            const n = new BNe(
              r,
              this.boundingRect,
              this.xAxis,
              this.yAxis,
              this.chartConfig.chartOrientation,
              e
            );
            t.push(...n.getDrawableElement());
          }
          break;
      }
    return t;
  }
};
function CY(t, e, r) {
  return new FNe(t, e, r);
}
x(CY, "getPlotComponent");
var $Ne = class {
  constructor(t, e, r, n) {
    this.chartConfig = t, this.chartData = e, this.componentStore = {
      title: SY(t, e, r, n),
      plot: CY(t, e, r),
      xAxis: N6(
        e.xAxis,
        t.xAxis,
        {
          titleColor: r.xAxisTitleColor,
          labelColor: r.xAxisLabelColor,
          tickColor: r.xAxisTickColor,
          axisLineColor: r.xAxisLineColor
        },
        n
      ),
      yAxis: N6(
        e.yAxis,
        t.yAxis,
        {
          titleColor: r.yAxisTitleColor,
          labelColor: r.yAxisLabelColor,
          tickColor: r.yAxisTickColor,
          axisLineColor: r.yAxisLineColor
        },
        n
      )
    };
  }
  static {
    x(this, "Orchestrator");
  }
  calculateVerticalSpace() {
    let t = this.chartConfig.width, e = this.chartConfig.height, r = 0, n = 0, i = Math.floor(t * this.chartConfig.plotReservedSpacePercent / 100), a = Math.floor(
      e * this.chartConfig.plotReservedSpacePercent / 100
    ), s = this.componentStore.plot.calculateSpace({
      width: i,
      height: a
    });
    t -= s.width, e -= s.height, s = this.componentStore.title.calculateSpace({
      width: this.chartConfig.width,
      height: e
    }), n = s.height, e -= s.height, this.componentStore.xAxis.setAxisPosition("bottom"), s = this.componentStore.xAxis.calculateSpace({
      width: t,
      height: e
    }), e -= s.height, this.componentStore.yAxis.setAxisPosition("left"), s = this.componentStore.yAxis.calculateSpace({
      width: t,
      height: e
    }), r = s.width, t -= s.width, t > 0 && (i += t, t = 0), e > 0 && (a += e, e = 0), this.componentStore.plot.calculateSpace({
      width: i,
      height: a
    }), this.componentStore.plot.setBoundingBoxXY({ x: r, y: n }), this.componentStore.xAxis.setRange([r, r + i]), this.componentStore.xAxis.setBoundingBoxXY({ x: r, y: n + a }), this.componentStore.yAxis.setRange([n, n + a]), this.componentStore.yAxis.setBoundingBoxXY({ x: 0, y: n }), this.chartData.plots.some((o) => M6(o)) && this.componentStore.xAxis.recalculateOuterPaddingToDrawBar();
  }
  calculateHorizontalSpace() {
    let t = this.chartConfig.width, e = this.chartConfig.height, r = 0, n = 0, i = 0, a = Math.floor(t * this.chartConfig.plotReservedSpacePercent / 100), s = Math.floor(
      e * this.chartConfig.plotReservedSpacePercent / 100
    ), o = this.componentStore.plot.calculateSpace({
      width: a,
      height: s
    });
    t -= o.width, e -= o.height, o = this.componentStore.title.calculateSpace({
      width: this.chartConfig.width,
      height: e
    }), r = o.height, e -= o.height, this.componentStore.xAxis.setAxisPosition("left"), o = this.componentStore.xAxis.calculateSpace({
      width: t,
      height: e
    }), t -= o.width, n = o.width, this.componentStore.yAxis.setAxisPosition("top"), o = this.componentStore.yAxis.calculateSpace({
      width: t,
      height: e
    }), e -= o.height, i = r + o.height, t > 0 && (a += t, t = 0), e > 0 && (s += e, e = 0), this.componentStore.plot.calculateSpace({
      width: a,
      height: s
    }), this.componentStore.plot.setBoundingBoxXY({ x: n, y: i }), this.componentStore.yAxis.setRange([n, n + a]), this.componentStore.yAxis.setBoundingBoxXY({ x: n, y: r }), this.componentStore.xAxis.setRange([i, i + s]), this.componentStore.xAxis.setBoundingBoxXY({ x: 0, y: i }), this.chartData.plots.some((l) => M6(l)) && this.componentStore.xAxis.recalculateOuterPaddingToDrawBar();
  }
  calculateSpace() {
    this.chartConfig.chartOrientation === "horizontal" ? this.calculateHorizontalSpace() : this.calculateVerticalSpace();
  }
  getDrawableElement() {
    this.calculateSpace();
    const t = [];
    this.componentStore.plot.setAxes(this.componentStore.xAxis, this.componentStore.yAxis);
    for (const e of Object.values(this.componentStore))
      t.push(...e.getDrawableElements());
    return t;
  }
}, zNe = class {
  static {
    x(this, "XYChartBuilder");
  }
  static build(t, e, r, n) {
    return new $Ne(t, e, r, n).getDrawableElement();
  }
}, Zp = 0, AY, Qp = _7(), Jp = A7(), Cr = L7(), I6 = Jp.plotColorPalette.split(",").map((t) => t.trim()), yb = !1, C7 = !1;
function A7() {
  const t = M2(), e = pr();
  return Hi(t.xyChart, e.themeVariables.xyChart);
}
x(A7, "getChartDefaultThemeConfig");
function _7() {
  const t = pr();
  return Hi(
    ur.xyChart,
    t.xyChart
  );
}
x(_7, "getChartDefaultConfig");
function L7() {
  return {
    yAxis: {
      type: "linear",
      title: "",
      min: 1 / 0,
      max: -1 / 0
    },
    xAxis: {
      type: "band",
      title: "",
      categories: []
    },
    title: "",
    plots: []
  };
}
x(L7, "getChartDefaultData");
function xb(t) {
  const e = pr();
  return dr(t.trim(), e);
}
x(xb, "textSanitizer");
function _Y(t) {
  AY = t;
}
x(_Y, "setTmpSVGG");
function LY(t) {
  t === "horizontal" ? Qp.chartOrientation = "horizontal" : Qp.chartOrientation = "vertical";
}
x(LY, "setOrientation");
function RY(t) {
  Cr.xAxis.title = xb(t.text);
}
x(RY, "setXAxisTitle");
function R7(t, e) {
  Cr.xAxis = { type: "linear", title: Cr.xAxis.title, min: t, max: e }, yb = !0;
}
x(R7, "setXAxisRangeData");
function MY(t) {
  Cr.xAxis = {
    type: "band",
    title: Cr.xAxis.title,
    categories: t.map((e) => xb(e.text))
  }, yb = !0;
}
x(MY, "setXAxisBand");
function NY(t) {
  Cr.yAxis.title = xb(t.text);
}
x(NY, "setYAxisTitle");
function IY(t, e) {
  Cr.yAxis = { type: "linear", title: Cr.yAxis.title, min: t, max: e }, C7 = !0;
}
x(IY, "setYAxisRangeData");
function DY(t) {
  const e = Math.min(...t), r = Math.max(...t), n = cd(Cr.yAxis) ? Cr.yAxis.min : 1 / 0, i = cd(Cr.yAxis) ? Cr.yAxis.max : -1 / 0;
  Cr.yAxis = {
    type: "linear",
    title: Cr.yAxis.title,
    min: Math.min(n, e),
    max: Math.max(i, r)
  };
}
x(DY, "setYAxisRangeFromPlotData");
function M7(t) {
  let e = [];
  if (t.length === 0)
    return e;
  if (!yb) {
    const r = cd(Cr.xAxis) ? Cr.xAxis.min : 1 / 0, n = cd(Cr.xAxis) ? Cr.xAxis.max : -1 / 0;
    R7(Math.min(r, 1), Math.max(n, t.length));
  }
  if (C7 || DY(t), S7(Cr.xAxis) && (e = Cr.xAxis.categories.map((r, n) => [r, t[n]])), cd(Cr.xAxis)) {
    const r = Cr.xAxis.min, n = Cr.xAxis.max, i = (n - r) / (t.length - 1), a = [];
    for (let s = r; s <= n; s += i)
      a.push(`${s}`);
    e = a.map((s, o) => [s, t[o]]);
  }
  return e;
}
x(M7, "transformDataWithoutCategory");
function N7(t) {
  return I6[t === 0 ? 0 : t % I6.length];
}
x(N7, "getPlotColorFromPalette");
function OY(t, e) {
  const r = M7(e);
  Cr.plots.push({
    type: "line",
    strokeFill: N7(Zp),
    strokeWidth: 2,
    data: r
  }), Zp++;
}
x(OY, "setLineData");
function PY(t, e) {
  const r = M7(e);
  Cr.plots.push({
    type: "bar",
    fill: N7(Zp),
    data: r
  }), Zp++;
}
x(PY, "setBarData");
function BY() {
  if (Cr.plots.length === 0)
    throw Error("No Plot to render, please provide a plot with some data");
  return Cr.title = Ln(), zNe.build(Qp, Cr, Jp, AY);
}
x(BY, "getDrawableElem");
function FY() {
  return Jp;
}
x(FY, "getChartThemeConfig");
function $Y() {
  return Qp;
}
x($Y, "getChartConfig");
function zY() {
  return Cr;
}
x(zY, "getXYChartData");
var GNe = /* @__PURE__ */ x(function() {
  _n(), Zp = 0, Qp = _7(), Cr = L7(), Jp = A7(), I6 = Jp.plotColorPalette.split(",").map((t) => t.trim()), yb = !1, C7 = !1;
}, "clear"), VNe = {
  getDrawableElem: BY,
  clear: GNe,
  setAccTitle: Cn,
  getAccTitle: Gn,
  setDiagramTitle: Zn,
  getDiagramTitle: Ln,
  getAccDescription: Un,
  setAccDescription: Vn,
  setOrientation: LY,
  setXAxisTitle: RY,
  setXAxisRangeData: R7,
  setXAxisBand: MY,
  setYAxisTitle: NY,
  setYAxisRangeData: IY,
  setLineData: OY,
  setBarData: PY,
  setTmpSVGG: _Y,
  getChartThemeConfig: FY,
  getChartConfig: $Y,
  getXYChartData: zY
}, UNe = /* @__PURE__ */ x((t, e, r, n) => {
  const i = n.db, a = i.getChartThemeConfig(), s = i.getChartConfig(), o = i.getXYChartData().plots[0].data.map((y) => y[1]);
  function l(y) {
    return y === "top" ? "text-before-edge" : "middle";
  }
  x(l, "getDominantBaseLine");
  function u(y) {
    return y === "left" ? "start" : y === "right" ? "end" : "middle";
  }
  x(u, "getTextAnchor");
  function h(y) {
    return `translate(${y.x}, ${y.y}) rotate(${y.rotation || 0})`;
  }
  x(h, "getTextTransformation"), ie.debug(`Rendering xychart chart
` + t);
  const d = ll(e), f = d.append("g").attr("class", "main"), p = f.append("rect").attr("width", s.width).attr("height", s.height).attr("class", "background");
  Xi(d, s.height, s.width, !0), d.attr("viewBox", `0 0 ${s.width} ${s.height}`), p.attr("fill", a.backgroundColor), i.setTmpSVGG(d.append("g").attr("class", "mermaid-tmp-group"));
  const g = i.getDrawableElem(), m = {};
  function v(y) {
    let b = f, w = "";
    for (const [T] of y.entries()) {
      let E = f;
      T > 0 && m[w] && (E = m[w]), w += y[T], b = m[w], b || (b = m[w] = E.append("g").attr("class", y[T]));
    }
    return b;
  }
  x(v, "getGroup");
  for (const y of g) {
    if (y.data.length === 0)
      continue;
    const b = v(y.groupTexts);
    switch (y.type) {
      case "rect":
        if (b.selectAll("rect").data(y.data).enter().append("rect").attr("x", (w) => w.x).attr("y", (w) => w.y).attr("width", (w) => w.width).attr("height", (w) => w.height).attr("fill", (w) => w.fill).attr("stroke", (w) => w.strokeFill).attr("stroke-width", (w) => w.strokeWidth), s.showDataLabel)
          if (s.chartOrientation === "horizontal") {
            let w = function(C, A) {
              const { data: R, label: _ } = C;
              return A * _.length * T <= R.width - 10;
            };
            x(w, "fitsHorizontally");
            const T = 0.7, E = y.data.map((C, A) => ({ data: C, label: o[A].toString() })).filter((C) => C.data.width > 0 && C.data.height > 0), L = E.map((C) => {
              const { data: A } = C;
              let R = A.height * 0.7;
              for (; !w(C, R) && R > 0; )
                R -= 1;
              return R;
            }), k = Math.floor(Math.min(...L));
            b.selectAll("text").data(E).enter().append("text").attr("x", (C) => C.data.x + C.data.width - 10).attr("y", (C) => C.data.y + C.data.height / 2).attr("text-anchor", "end").attr("dominant-baseline", "middle").attr("fill", "black").attr("font-size", `${k}px`).text((C) => C.label);
          } else {
            let w = function(C, A, R) {
              const { data: _, label: O } = C, S = A * O.length * 0.7, M = _.x + _.width / 2, N = M - S / 2, D = M + S / 2, I = N >= _.x && D <= _.x + _.width, B = _.y + R + A <= _.y + _.height;
              return I && B;
            };
            x(w, "fitsInBar");
            const T = 10, E = y.data.map((C, A) => ({ data: C, label: o[A].toString() })).filter((C) => C.data.width > 0 && C.data.height > 0), L = E.map((C) => {
              const { data: A, label: R } = C;
              let _ = A.width / (R.length * 0.7);
              for (; !w(C, _, T) && _ > 0; )
                _ -= 1;
              return _;
            }), k = Math.floor(Math.min(...L));
            b.selectAll("text").data(E).enter().append("text").attr("x", (C) => C.data.x + C.data.width / 2).attr("y", (C) => C.data.y + T).attr("text-anchor", "middle").attr("dominant-baseline", "hanging").attr("fill", "black").attr("font-size", `${k}px`).text((C) => C.label);
          }
        break;
      case "text":
        b.selectAll("text").data(y.data).enter().append("text").attr("x", 0).attr("y", 0).attr("fill", (w) => w.fill).attr("font-size", (w) => w.fontSize).attr("dominant-baseline", (w) => l(w.verticalPos)).attr("text-anchor", (w) => u(w.horizontalPos)).attr("transform", (w) => h(w)).text((w) => w.text);
        break;
      case "path":
        b.selectAll("path").data(y.data).enter().append("path").attr("d", (w) => w.path).attr("fill", (w) => w.fill ? w.fill : "none").attr("stroke", (w) => w.strokeFill).attr("stroke-width", (w) => w.strokeWidth);
        break;
    }
  }
}, "draw"), HNe = {
  draw: UNe
}, qNe = {
  parser: NNe,
  db: VNe,
  renderer: HNe
};
const WNe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: qNe
}, Symbol.toStringTag, { value: "Module" }));
var D6 = (function() {
  var t = /* @__PURE__ */ x(function(me, Ne, Q, ce) {
    for (Q = Q || {}, ce = me.length; ce--; Q[me[ce]] = Ne) ;
    return Q;
  }, "o"), e = [1, 3], r = [1, 4], n = [1, 5], i = [1, 6], a = [5, 6, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72, 74, 77, 89, 90], s = [1, 22], o = [2, 7], l = [1, 26], u = [1, 27], h = [1, 28], d = [1, 29], f = [1, 33], p = [1, 34], g = [1, 35], m = [1, 36], v = [1, 37], y = [1, 38], b = [1, 24], w = [1, 31], T = [1, 32], E = [1, 30], L = [1, 39], k = [1, 40], C = [5, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72, 74, 77, 89, 90], A = [1, 61], R = [89, 90], _ = [5, 8, 9, 11, 13, 21, 22, 23, 24, 27, 29, 41, 42, 43, 44, 45, 46, 54, 61, 63, 72, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90], O = [27, 29], P = [1, 70], S = [1, 71], M = [1, 72], N = [1, 73], D = [1, 74], I = [1, 75], B = [1, 76], z = [1, 83], F = [1, 80], V = [1, 84], H = [1, 85], J = [1, 86], q = [1, 87], ae = [1, 88], re = [1, 89], pe = [1, 90], K = [1, 91], Z = [1, 92], X = [5, 8, 9, 11, 13, 21, 22, 23, 24, 27, 41, 42, 43, 44, 45, 46, 54, 72, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90], Y = [63, 64], ee = [1, 101], j = [5, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72, 74, 76, 77, 89, 90], fe = [5, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90], te = [1, 110], Ae = [1, 106], W = [1, 107], De = [1, 108], ue = [1, 109], ze = [1, 111], Ge = [1, 116], Ve = [1, 117], ke = [1, 114], Oe = [1, 115], Se = {
    trace: /* @__PURE__ */ x(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, directive: 4, NEWLINE: 5, RD: 6, diagram: 7, EOF: 8, acc_title: 9, acc_title_value: 10, acc_descr: 11, acc_descr_value: 12, acc_descr_multiline_value: 13, requirementDef: 14, elementDef: 15, relationshipDef: 16, direction: 17, styleStatement: 18, classDefStatement: 19, classStatement: 20, direction_tb: 21, direction_bt: 22, direction_rl: 23, direction_lr: 24, requirementType: 25, requirementName: 26, STRUCT_START: 27, requirementBody: 28, STYLE_SEPARATOR: 29, idList: 30, ID: 31, COLONSEP: 32, id: 33, TEXT: 34, text: 35, RISK: 36, riskLevel: 37, VERIFYMTHD: 38, verifyType: 39, STRUCT_STOP: 40, REQUIREMENT: 41, FUNCTIONAL_REQUIREMENT: 42, INTERFACE_REQUIREMENT: 43, PERFORMANCE_REQUIREMENT: 44, PHYSICAL_REQUIREMENT: 45, DESIGN_CONSTRAINT: 46, LOW_RISK: 47, MED_RISK: 48, HIGH_RISK: 49, VERIFY_ANALYSIS: 50, VERIFY_DEMONSTRATION: 51, VERIFY_INSPECTION: 52, VERIFY_TEST: 53, ELEMENT: 54, elementName: 55, elementBody: 56, TYPE: 57, type: 58, DOCREF: 59, ref: 60, END_ARROW_L: 61, relationship: 62, LINE: 63, END_ARROW_R: 64, CONTAINS: 65, COPIES: 66, DERIVES: 67, SATISFIES: 68, VERIFIES: 69, REFINES: 70, TRACES: 71, CLASSDEF: 72, stylesOpt: 73, CLASS: 74, ALPHA: 75, COMMA: 76, STYLE: 77, style: 78, styleComponent: 79, NUM: 80, COLON: 81, UNIT: 82, SPACE: 83, BRKT: 84, PCT: 85, MINUS: 86, LABEL: 87, SEMICOLON: 88, unqString: 89, qString: 90, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 5: "NEWLINE", 6: "RD", 8: "EOF", 9: "acc_title", 10: "acc_title_value", 11: "acc_descr", 12: "acc_descr_value", 13: "acc_descr_multiline_value", 21: "direction_tb", 22: "direction_bt", 23: "direction_rl", 24: "direction_lr", 27: "STRUCT_START", 29: "STYLE_SEPARATOR", 31: "ID", 32: "COLONSEP", 34: "TEXT", 36: "RISK", 38: "VERIFYMTHD", 40: "STRUCT_STOP", 41: "REQUIREMENT", 42: "FUNCTIONAL_REQUIREMENT", 43: "INTERFACE_REQUIREMENT", 44: "PERFORMANCE_REQUIREMENT", 45: "PHYSICAL_REQUIREMENT", 46: "DESIGN_CONSTRAINT", 47: "LOW_RISK", 48: "MED_RISK", 49: "HIGH_RISK", 50: "VERIFY_ANALYSIS", 51: "VERIFY_DEMONSTRATION", 52: "VERIFY_INSPECTION", 53: "VERIFY_TEST", 54: "ELEMENT", 57: "TYPE", 59: "DOCREF", 61: "END_ARROW_L", 63: "LINE", 64: "END_ARROW_R", 65: "CONTAINS", 66: "COPIES", 67: "DERIVES", 68: "SATISFIES", 69: "VERIFIES", 70: "REFINES", 71: "TRACES", 72: "CLASSDEF", 74: "CLASS", 75: "ALPHA", 76: "COMMA", 77: "STYLE", 80: "NUM", 81: "COLON", 82: "UNIT", 83: "SPACE", 84: "BRKT", 85: "PCT", 86: "MINUS", 87: "LABEL", 88: "SEMICOLON", 89: "unqString", 90: "qString" },
    productions_: [0, [3, 3], [3, 2], [3, 4], [4, 2], [4, 2], [4, 1], [7, 0], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [17, 1], [17, 1], [17, 1], [17, 1], [14, 5], [14, 7], [28, 5], [28, 5], [28, 5], [28, 5], [28, 2], [28, 1], [25, 1], [25, 1], [25, 1], [25, 1], [25, 1], [25, 1], [37, 1], [37, 1], [37, 1], [39, 1], [39, 1], [39, 1], [39, 1], [15, 5], [15, 7], [56, 5], [56, 5], [56, 2], [56, 1], [16, 5], [16, 5], [62, 1], [62, 1], [62, 1], [62, 1], [62, 1], [62, 1], [62, 1], [19, 3], [20, 3], [20, 3], [30, 1], [30, 3], [30, 1], [30, 3], [18, 3], [73, 1], [73, 3], [78, 1], [78, 2], [79, 1], [79, 1], [79, 1], [79, 1], [79, 1], [79, 1], [79, 1], [79, 1], [79, 1], [79, 1], [26, 1], [26, 1], [33, 1], [33, 1], [35, 1], [35, 1], [55, 1], [55, 1], [58, 1], [58, 1], [60, 1], [60, 1]],
    performAction: /* @__PURE__ */ x(function(Ne, Q, ce, $, oe, se, ge) {
      var he = se.length - 1;
      switch (oe) {
        case 4:
          this.$ = se[he].trim(), $.setAccTitle(this.$);
          break;
        case 5:
        case 6:
          this.$ = se[he].trim(), $.setAccDescription(this.$);
          break;
        case 7:
          this.$ = [];
          break;
        case 17:
          $.setDirection("TB");
          break;
        case 18:
          $.setDirection("BT");
          break;
        case 19:
          $.setDirection("RL");
          break;
        case 20:
          $.setDirection("LR");
          break;
        case 21:
          $.addRequirement(se[he - 3], se[he - 4]);
          break;
        case 22:
          $.addRequirement(se[he - 5], se[he - 6]), $.setClass([se[he - 5]], se[he - 3]);
          break;
        case 23:
          $.setNewReqId(se[he - 2]);
          break;
        case 24:
          $.setNewReqText(se[he - 2]);
          break;
        case 25:
          $.setNewReqRisk(se[he - 2]);
          break;
        case 26:
          $.setNewReqVerifyMethod(se[he - 2]);
          break;
        case 29:
          this.$ = $.RequirementType.REQUIREMENT;
          break;
        case 30:
          this.$ = $.RequirementType.FUNCTIONAL_REQUIREMENT;
          break;
        case 31:
          this.$ = $.RequirementType.INTERFACE_REQUIREMENT;
          break;
        case 32:
          this.$ = $.RequirementType.PERFORMANCE_REQUIREMENT;
          break;
        case 33:
          this.$ = $.RequirementType.PHYSICAL_REQUIREMENT;
          break;
        case 34:
          this.$ = $.RequirementType.DESIGN_CONSTRAINT;
          break;
        case 35:
          this.$ = $.RiskLevel.LOW_RISK;
          break;
        case 36:
          this.$ = $.RiskLevel.MED_RISK;
          break;
        case 37:
          this.$ = $.RiskLevel.HIGH_RISK;
          break;
        case 38:
          this.$ = $.VerifyType.VERIFY_ANALYSIS;
          break;
        case 39:
          this.$ = $.VerifyType.VERIFY_DEMONSTRATION;
          break;
        case 40:
          this.$ = $.VerifyType.VERIFY_INSPECTION;
          break;
        case 41:
          this.$ = $.VerifyType.VERIFY_TEST;
          break;
        case 42:
          $.addElement(se[he - 3]);
          break;
        case 43:
          $.addElement(se[he - 5]), $.setClass([se[he - 5]], se[he - 3]);
          break;
        case 44:
          $.setNewElementType(se[he - 2]);
          break;
        case 45:
          $.setNewElementDocRef(se[he - 2]);
          break;
        case 48:
          $.addRelationship(se[he - 2], se[he], se[he - 4]);
          break;
        case 49:
          $.addRelationship(se[he - 2], se[he - 4], se[he]);
          break;
        case 50:
          this.$ = $.Relationships.CONTAINS;
          break;
        case 51:
          this.$ = $.Relationships.COPIES;
          break;
        case 52:
          this.$ = $.Relationships.DERIVES;
          break;
        case 53:
          this.$ = $.Relationships.SATISFIES;
          break;
        case 54:
          this.$ = $.Relationships.VERIFIES;
          break;
        case 55:
          this.$ = $.Relationships.REFINES;
          break;
        case 56:
          this.$ = $.Relationships.TRACES;
          break;
        case 57:
          this.$ = se[he - 2], $.defineClass(se[he - 1], se[he]);
          break;
        case 58:
          $.setClass(se[he - 1], se[he]);
          break;
        case 59:
          $.setClass([se[he - 2]], se[he]);
          break;
        case 60:
        case 62:
          this.$ = [se[he]];
          break;
        case 61:
        case 63:
          this.$ = se[he - 2].concat([se[he]]);
          break;
        case 64:
          this.$ = se[he - 2], $.setCssStyle(se[he - 1], se[he]);
          break;
        case 65:
          this.$ = [se[he]];
          break;
        case 66:
          se[he - 2].push(se[he]), this.$ = se[he - 2];
          break;
        case 68:
          this.$ = se[he - 1] + se[he];
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: 2, 6: e, 9: r, 11: n, 13: i }, { 1: [3] }, { 3: 8, 4: 2, 5: [1, 7], 6: e, 9: r, 11: n, 13: i }, { 5: [1, 9] }, { 10: [1, 10] }, { 12: [1, 11] }, t(a, [2, 6]), { 3: 12, 4: 2, 6: e, 9: r, 11: n, 13: i }, { 1: [2, 2] }, { 4: 17, 5: s, 7: 13, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: d, 25: 23, 33: 25, 41: f, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: w, 74: T, 77: E, 89: L, 90: k }, t(a, [2, 4]), t(a, [2, 5]), { 1: [2, 1] }, { 8: [1, 41] }, { 4: 17, 5: s, 7: 42, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: d, 25: 23, 33: 25, 41: f, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: w, 74: T, 77: E, 89: L, 90: k }, { 4: 17, 5: s, 7: 43, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: d, 25: 23, 33: 25, 41: f, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: w, 74: T, 77: E, 89: L, 90: k }, { 4: 17, 5: s, 7: 44, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: d, 25: 23, 33: 25, 41: f, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: w, 74: T, 77: E, 89: L, 90: k }, { 4: 17, 5: s, 7: 45, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: d, 25: 23, 33: 25, 41: f, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: w, 74: T, 77: E, 89: L, 90: k }, { 4: 17, 5: s, 7: 46, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: d, 25: 23, 33: 25, 41: f, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: w, 74: T, 77: E, 89: L, 90: k }, { 4: 17, 5: s, 7: 47, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: d, 25: 23, 33: 25, 41: f, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: w, 74: T, 77: E, 89: L, 90: k }, { 4: 17, 5: s, 7: 48, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: d, 25: 23, 33: 25, 41: f, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: w, 74: T, 77: E, 89: L, 90: k }, { 4: 17, 5: s, 7: 49, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: d, 25: 23, 33: 25, 41: f, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: w, 74: T, 77: E, 89: L, 90: k }, { 4: 17, 5: s, 7: 50, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: d, 25: 23, 33: 25, 41: f, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: w, 74: T, 77: E, 89: L, 90: k }, { 26: 51, 89: [1, 52], 90: [1, 53] }, { 55: 54, 89: [1, 55], 90: [1, 56] }, { 29: [1, 59], 61: [1, 57], 63: [1, 58] }, t(C, [2, 17]), t(C, [2, 18]), t(C, [2, 19]), t(C, [2, 20]), { 30: 60, 33: 62, 75: A, 89: L, 90: k }, { 30: 63, 33: 62, 75: A, 89: L, 90: k }, { 30: 64, 33: 62, 75: A, 89: L, 90: k }, t(R, [2, 29]), t(R, [2, 30]), t(R, [2, 31]), t(R, [2, 32]), t(R, [2, 33]), t(R, [2, 34]), t(_, [2, 81]), t(_, [2, 82]), { 1: [2, 3] }, { 8: [2, 8] }, { 8: [2, 9] }, { 8: [2, 10] }, { 8: [2, 11] }, { 8: [2, 12] }, { 8: [2, 13] }, { 8: [2, 14] }, { 8: [2, 15] }, { 8: [2, 16] }, { 27: [1, 65], 29: [1, 66] }, t(O, [2, 79]), t(O, [2, 80]), { 27: [1, 67], 29: [1, 68] }, t(O, [2, 85]), t(O, [2, 86]), { 62: 69, 65: P, 66: S, 67: M, 68: N, 69: D, 70: I, 71: B }, { 62: 77, 65: P, 66: S, 67: M, 68: N, 69: D, 70: I, 71: B }, { 30: 78, 33: 62, 75: A, 89: L, 90: k }, { 73: 79, 75: z, 76: F, 78: 81, 79: 82, 80: V, 81: H, 82: J, 83: q, 84: ae, 85: re, 86: pe, 87: K, 88: Z }, t(X, [2, 60]), t(X, [2, 62]), { 73: 93, 75: z, 76: F, 78: 81, 79: 82, 80: V, 81: H, 82: J, 83: q, 84: ae, 85: re, 86: pe, 87: K, 88: Z }, { 30: 94, 33: 62, 75: A, 76: F, 89: L, 90: k }, { 5: [1, 95] }, { 30: 96, 33: 62, 75: A, 89: L, 90: k }, { 5: [1, 97] }, { 30: 98, 33: 62, 75: A, 89: L, 90: k }, { 63: [1, 99] }, t(Y, [2, 50]), t(Y, [2, 51]), t(Y, [2, 52]), t(Y, [2, 53]), t(Y, [2, 54]), t(Y, [2, 55]), t(Y, [2, 56]), { 64: [1, 100] }, t(C, [2, 59], { 76: F }), t(C, [2, 64], { 76: ee }), { 33: 103, 75: [1, 102], 89: L, 90: k }, t(j, [2, 65], { 79: 104, 75: z, 80: V, 81: H, 82: J, 83: q, 84: ae, 85: re, 86: pe, 87: K, 88: Z }), t(fe, [2, 67]), t(fe, [2, 69]), t(fe, [2, 70]), t(fe, [2, 71]), t(fe, [2, 72]), t(fe, [2, 73]), t(fe, [2, 74]), t(fe, [2, 75]), t(fe, [2, 76]), t(fe, [2, 77]), t(fe, [2, 78]), t(C, [2, 57], { 76: ee }), t(C, [2, 58], { 76: F }), { 5: te, 28: 105, 31: Ae, 34: W, 36: De, 38: ue, 40: ze }, { 27: [1, 112], 76: F }, { 5: Ge, 40: Ve, 56: 113, 57: ke, 59: Oe }, { 27: [1, 118], 76: F }, { 33: 119, 89: L, 90: k }, { 33: 120, 89: L, 90: k }, { 75: z, 78: 121, 79: 82, 80: V, 81: H, 82: J, 83: q, 84: ae, 85: re, 86: pe, 87: K, 88: Z }, t(X, [2, 61]), t(X, [2, 63]), t(fe, [2, 68]), t(C, [2, 21]), { 32: [1, 122] }, { 32: [1, 123] }, { 32: [1, 124] }, { 32: [1, 125] }, { 5: te, 28: 126, 31: Ae, 34: W, 36: De, 38: ue, 40: ze }, t(C, [2, 28]), { 5: [1, 127] }, t(C, [2, 42]), { 32: [1, 128] }, { 32: [1, 129] }, { 5: Ge, 40: Ve, 56: 130, 57: ke, 59: Oe }, t(C, [2, 47]), { 5: [1, 131] }, t(C, [2, 48]), t(C, [2, 49]), t(j, [2, 66], { 79: 104, 75: z, 80: V, 81: H, 82: J, 83: q, 84: ae, 85: re, 86: pe, 87: K, 88: Z }), { 33: 132, 89: L, 90: k }, { 35: 133, 89: [1, 134], 90: [1, 135] }, { 37: 136, 47: [1, 137], 48: [1, 138], 49: [1, 139] }, { 39: 140, 50: [1, 141], 51: [1, 142], 52: [1, 143], 53: [1, 144] }, t(C, [2, 27]), { 5: te, 28: 145, 31: Ae, 34: W, 36: De, 38: ue, 40: ze }, { 58: 146, 89: [1, 147], 90: [1, 148] }, { 60: 149, 89: [1, 150], 90: [1, 151] }, t(C, [2, 46]), { 5: Ge, 40: Ve, 56: 152, 57: ke, 59: Oe }, { 5: [1, 153] }, { 5: [1, 154] }, { 5: [2, 83] }, { 5: [2, 84] }, { 5: [1, 155] }, { 5: [2, 35] }, { 5: [2, 36] }, { 5: [2, 37] }, { 5: [1, 156] }, { 5: [2, 38] }, { 5: [2, 39] }, { 5: [2, 40] }, { 5: [2, 41] }, t(C, [2, 22]), { 5: [1, 157] }, { 5: [2, 87] }, { 5: [2, 88] }, { 5: [1, 158] }, { 5: [2, 89] }, { 5: [2, 90] }, t(C, [2, 43]), { 5: te, 28: 159, 31: Ae, 34: W, 36: De, 38: ue, 40: ze }, { 5: te, 28: 160, 31: Ae, 34: W, 36: De, 38: ue, 40: ze }, { 5: te, 28: 161, 31: Ae, 34: W, 36: De, 38: ue, 40: ze }, { 5: te, 28: 162, 31: Ae, 34: W, 36: De, 38: ue, 40: ze }, { 5: Ge, 40: Ve, 56: 163, 57: ke, 59: Oe }, { 5: Ge, 40: Ve, 56: 164, 57: ke, 59: Oe }, t(C, [2, 23]), t(C, [2, 24]), t(C, [2, 25]), t(C, [2, 26]), t(C, [2, 44]), t(C, [2, 45])],
    defaultActions: { 8: [2, 2], 12: [2, 1], 41: [2, 3], 42: [2, 8], 43: [2, 9], 44: [2, 10], 45: [2, 11], 46: [2, 12], 47: [2, 13], 48: [2, 14], 49: [2, 15], 50: [2, 16], 134: [2, 83], 135: [2, 84], 137: [2, 35], 138: [2, 36], 139: [2, 37], 141: [2, 38], 142: [2, 39], 143: [2, 40], 144: [2, 41], 147: [2, 87], 148: [2, 88], 150: [2, 89], 151: [2, 90] },
    parseError: /* @__PURE__ */ x(function(Ne, Q) {
      if (Q.recoverable)
        this.trace(Ne);
      else {
        var ce = new Error(Ne);
        throw ce.hash = Q, ce;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ x(function(Ne) {
      var Q = this, ce = [0], $ = [], oe = [null], se = [], ge = this.table, he = "", be = 0, Ce = 0, Te = 2, Me = 1, Xe = se.slice.call(arguments, 1), We = Object.create(this.lexer), Ke = { yy: {} };
      for (var Ze in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, Ze) && (Ke.yy[Ze] = this.yy[Ze]);
      We.setInput(Ne, Ke.yy), Ke.yy.lexer = We, Ke.yy.parser = this, typeof We.yylloc > "u" && (We.yylloc = {});
      var Pe = We.yylloc;
      se.push(Pe);
      var He = We.options && We.options.ranges;
      typeof Ke.yy.parseError == "function" ? this.parseError = Ke.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function ht(rr) {
        ce.length = ce.length - 2 * rr, oe.length = oe.length - rr, se.length = se.length - rr;
      }
      x(ht, "popStack");
      function st() {
        var rr;
        return rr = $.pop() || We.lex() || Me, typeof rr != "number" && (rr instanceof Array && ($ = rr, rr = $.pop()), rr = Q.symbols_[rr] || rr), rr;
      }
      x(st, "lex");
      for (var Ue, Et, qe, rt, ct = {}, ut, nt, xt, Qt; ; ) {
        if (Et = ce[ce.length - 1], this.defaultActions[Et] ? qe = this.defaultActions[Et] : ((Ue === null || typeof Ue > "u") && (Ue = st()), qe = ge[Et] && ge[Et][Ue]), typeof qe > "u" || !qe.length || !qe[0]) {
          var Dt = "";
          Qt = [];
          for (ut in ge[Et])
            this.terminals_[ut] && ut > Te && Qt.push("'" + this.terminals_[ut] + "'");
          We.showPosition ? Dt = "Parse error on line " + (be + 1) + `:
` + We.showPosition() + `
Expecting ` + Qt.join(", ") + ", got '" + (this.terminals_[Ue] || Ue) + "'" : Dt = "Parse error on line " + (be + 1) + ": Unexpected " + (Ue == Me ? "end of input" : "'" + (this.terminals_[Ue] || Ue) + "'"), this.parseError(Dt, {
            text: We.match,
            token: this.terminals_[Ue] || Ue,
            line: We.yylineno,
            loc: Pe,
            expected: Qt
          });
        }
        if (qe[0] instanceof Array && qe.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Et + ", token: " + Ue);
        switch (qe[0]) {
          case 1:
            ce.push(Ue), oe.push(We.yytext), se.push(We.yylloc), ce.push(qe[1]), Ue = null, Ce = We.yyleng, he = We.yytext, be = We.yylineno, Pe = We.yylloc;
            break;
          case 2:
            if (nt = this.productions_[qe[1]][1], ct.$ = oe[oe.length - nt], ct._$ = {
              first_line: se[se.length - (nt || 1)].first_line,
              last_line: se[se.length - 1].last_line,
              first_column: se[se.length - (nt || 1)].first_column,
              last_column: se[se.length - 1].last_column
            }, He && (ct._$.range = [
              se[se.length - (nt || 1)].range[0],
              se[se.length - 1].range[1]
            ]), rt = this.performAction.apply(ct, [
              he,
              Ce,
              be,
              Ke.yy,
              qe[1],
              oe,
              se
            ].concat(Xe)), typeof rt < "u")
              return rt;
            nt && (ce = ce.slice(0, -1 * nt * 2), oe = oe.slice(0, -1 * nt), se = se.slice(0, -1 * nt)), ce.push(this.productions_[qe[1]][0]), oe.push(ct.$), se.push(ct._$), xt = ge[ce[ce.length - 2]][ce[ce.length - 1]], ce.push(xt);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, _e = /* @__PURE__ */ (function() {
    var me = {
      EOF: 1,
      parseError: /* @__PURE__ */ x(function(Q, ce) {
        if (this.yy.parser)
          this.yy.parser.parseError(Q, ce);
        else
          throw new Error(Q);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ x(function(Ne, Q) {
        return this.yy = Q || this.yy || {}, this._input = Ne, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ x(function() {
        var Ne = this._input[0];
        this.yytext += Ne, this.yyleng++, this.offset++, this.match += Ne, this.matched += Ne;
        var Q = Ne.match(/(?:\r\n?|\n).*/g);
        return Q ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), Ne;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ x(function(Ne) {
        var Q = Ne.length, ce = Ne.split(/(?:\r\n?|\n)/g);
        this._input = Ne + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - Q), this.offset -= Q;
        var $ = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), ce.length - 1 && (this.yylineno -= ce.length - 1);
        var oe = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: ce ? (ce.length === $.length ? this.yylloc.first_column : 0) + $[$.length - ce.length].length - ce[0].length : this.yylloc.first_column - Q
        }, this.options.ranges && (this.yylloc.range = [oe[0], oe[0] + this.yyleng - Q]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ x(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ x(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ x(function(Ne) {
        this.unput(this.match.slice(Ne));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ x(function() {
        var Ne = this.matched.substr(0, this.matched.length - this.match.length);
        return (Ne.length > 20 ? "..." : "") + Ne.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ x(function() {
        var Ne = this.match;
        return Ne.length < 20 && (Ne += this._input.substr(0, 20 - Ne.length)), (Ne.substr(0, 20) + (Ne.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ x(function() {
        var Ne = this.pastInput(), Q = new Array(Ne.length + 1).join("-");
        return Ne + this.upcomingInput() + `
` + Q + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ x(function(Ne, Q) {
        var ce, $, oe;
        if (this.options.backtrack_lexer && (oe = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (oe.yylloc.range = this.yylloc.range.slice(0))), $ = Ne[0].match(/(?:\r\n?|\n).*/g), $ && (this.yylineno += $.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: $ ? $[$.length - 1].length - $[$.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + Ne[0].length
        }, this.yytext += Ne[0], this.match += Ne[0], this.matches = Ne, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(Ne[0].length), this.matched += Ne[0], ce = this.performAction.call(this, this.yy, this, Q, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), ce)
          return ce;
        if (this._backtrack) {
          for (var se in oe)
            this[se] = oe[se];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ x(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var Ne, Q, ce, $;
        this._more || (this.yytext = "", this.match = "");
        for (var oe = this._currentRules(), se = 0; se < oe.length; se++)
          if (ce = this._input.match(this.rules[oe[se]]), ce && (!Q || ce[0].length > Q[0].length)) {
            if (Q = ce, $ = se, this.options.backtrack_lexer) {
              if (Ne = this.test_match(ce, oe[se]), Ne !== !1)
                return Ne;
              if (this._backtrack) {
                Q = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return Q ? (Ne = this.test_match(Q, oe[$]), Ne !== !1 ? Ne : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ x(function() {
        var Q = this.next();
        return Q || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ x(function(Q) {
        this.conditionStack.push(Q);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ x(function() {
        var Q = this.conditionStack.length - 1;
        return Q > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ x(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ x(function(Q) {
        return Q = this.conditionStack.length - 1 - Math.abs(Q || 0), Q >= 0 ? this.conditionStack[Q] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ x(function(Q) {
        this.begin(Q);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ x(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ x(function(Q, ce, $, oe) {
        switch ($) {
          case 0:
            return "title";
          case 1:
            return this.begin("acc_title"), 9;
          case 2:
            return this.popState(), "acc_title_value";
          case 3:
            return this.begin("acc_descr"), 11;
          case 4:
            return this.popState(), "acc_descr_value";
          case 5:
            this.begin("acc_descr_multiline");
            break;
          case 6:
            this.popState();
            break;
          case 7:
            return "acc_descr_multiline_value";
          case 8:
            return 21;
          case 9:
            return 22;
          case 10:
            return 23;
          case 11:
            return 24;
          case 12:
            return 5;
          case 13:
            break;
          case 14:
            break;
          case 15:
            break;
          case 16:
            return 8;
          case 17:
            return 6;
          case 18:
            return 27;
          case 19:
            return 40;
          case 20:
            return 29;
          case 21:
            return 32;
          case 22:
            return 31;
          case 23:
            return 34;
          case 24:
            return 36;
          case 25:
            return 38;
          case 26:
            return 41;
          case 27:
            return 42;
          case 28:
            return 43;
          case 29:
            return 44;
          case 30:
            return 45;
          case 31:
            return 46;
          case 32:
            return 47;
          case 33:
            return 48;
          case 34:
            return 49;
          case 35:
            return 50;
          case 36:
            return 51;
          case 37:
            return 52;
          case 38:
            return 53;
          case 39:
            return 54;
          case 40:
            return 65;
          case 41:
            return 66;
          case 42:
            return 67;
          case 43:
            return 68;
          case 44:
            return 69;
          case 45:
            return 70;
          case 46:
            return 71;
          case 47:
            return 57;
          case 48:
            return 59;
          case 49:
            return this.begin("style"), 77;
          case 50:
            return 75;
          case 51:
            return 81;
          case 52:
            return 88;
          case 53:
            return "PERCENT";
          case 54:
            return 86;
          case 55:
            return 84;
          case 56:
            break;
          case 57:
            this.begin("string");
            break;
          case 58:
            this.popState();
            break;
          case 59:
            return this.begin("style"), 72;
          case 60:
            return this.begin("style"), 74;
          case 61:
            return 61;
          case 62:
            return 64;
          case 63:
            return 63;
          case 64:
            this.begin("string");
            break;
          case 65:
            this.popState();
            break;
          case 66:
            return "qString";
          case 67:
            return ce.yytext = ce.yytext.trim(), 89;
          case 68:
            return 75;
          case 69:
            return 80;
          case 70:
            return 76;
        }
      }, "anonymous"),
      rules: [/^(?:title\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:(\r?\n)+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:$)/i, /^(?:requirementDiagram\b)/i, /^(?:\{)/i, /^(?:\})/i, /^(?::{3})/i, /^(?::)/i, /^(?:id\b)/i, /^(?:text\b)/i, /^(?:risk\b)/i, /^(?:verifyMethod\b)/i, /^(?:requirement\b)/i, /^(?:functionalRequirement\b)/i, /^(?:interfaceRequirement\b)/i, /^(?:performanceRequirement\b)/i, /^(?:physicalRequirement\b)/i, /^(?:designConstraint\b)/i, /^(?:low\b)/i, /^(?:medium\b)/i, /^(?:high\b)/i, /^(?:analysis\b)/i, /^(?:demonstration\b)/i, /^(?:inspection\b)/i, /^(?:test\b)/i, /^(?:element\b)/i, /^(?:contains\b)/i, /^(?:copies\b)/i, /^(?:derives\b)/i, /^(?:satisfies\b)/i, /^(?:verifies\b)/i, /^(?:refines\b)/i, /^(?:traces\b)/i, /^(?:type\b)/i, /^(?:docref\b)/i, /^(?:style\b)/i, /^(?:\w+)/i, /^(?::)/i, /^(?:;)/i, /^(?:%)/i, /^(?:-)/i, /^(?:#)/i, /^(?: )/i, /^(?:["])/i, /^(?:\n)/i, /^(?:classDef\b)/i, /^(?:class\b)/i, /^(?:<-)/i, /^(?:->)/i, /^(?:-)/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[\w][^:,\r\n\{\<\>\-\=]*)/i, /^(?:\w+)/i, /^(?:[0-9]+)/i, /^(?:,)/i],
      conditions: { acc_descr_multiline: { rules: [6, 7, 68, 69, 70], inclusive: !1 }, acc_descr: { rules: [4, 68, 69, 70], inclusive: !1 }, acc_title: { rules: [2, 68, 69, 70], inclusive: !1 }, style: { rules: [50, 51, 52, 53, 54, 55, 56, 57, 58, 68, 69, 70], inclusive: !1 }, unqString: { rules: [68, 69, 70], inclusive: !1 }, token: { rules: [68, 69, 70], inclusive: !1 }, string: { rules: [65, 66, 68, 69, 70], inclusive: !1 }, INITIAL: { rules: [0, 1, 3, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 59, 60, 61, 62, 63, 64, 67, 68, 69, 70], inclusive: !0 } }
    };
    return me;
  })();
  Se.lexer = _e;
  function $e() {
    this.yy = {};
  }
  return x($e, "Parser"), $e.prototype = Se, Se.Parser = $e, new $e();
})();
D6.parser = D6;
var YNe = D6, XNe = class {
  constructor() {
    this.relations = [], this.latestRequirement = this.getInitialRequirement(), this.requirements = /* @__PURE__ */ new Map(), this.latestElement = this.getInitialElement(), this.elements = /* @__PURE__ */ new Map(), this.classes = /* @__PURE__ */ new Map(), this.direction = "TB", this.RequirementType = {
      REQUIREMENT: "Requirement",
      FUNCTIONAL_REQUIREMENT: "Functional Requirement",
      INTERFACE_REQUIREMENT: "Interface Requirement",
      PERFORMANCE_REQUIREMENT: "Performance Requirement",
      PHYSICAL_REQUIREMENT: "Physical Requirement",
      DESIGN_CONSTRAINT: "Design Constraint"
    }, this.RiskLevel = {
      LOW_RISK: "Low",
      MED_RISK: "Medium",
      HIGH_RISK: "High"
    }, this.VerifyType = {
      VERIFY_ANALYSIS: "Analysis",
      VERIFY_DEMONSTRATION: "Demonstration",
      VERIFY_INSPECTION: "Inspection",
      VERIFY_TEST: "Test"
    }, this.Relationships = {
      CONTAINS: "contains",
      COPIES: "copies",
      DERIVES: "derives",
      SATISFIES: "satisfies",
      VERIFIES: "verifies",
      REFINES: "refines",
      TRACES: "traces"
    }, this.setAccTitle = Cn, this.getAccTitle = Gn, this.setAccDescription = Vn, this.getAccDescription = Un, this.setDiagramTitle = Zn, this.getDiagramTitle = Ln, this.getConfig = /* @__PURE__ */ x(() => we().requirement, "getConfig"), this.clear(), this.setDirection = this.setDirection.bind(this), this.addRequirement = this.addRequirement.bind(this), this.setNewReqId = this.setNewReqId.bind(this), this.setNewReqRisk = this.setNewReqRisk.bind(this), this.setNewReqText = this.setNewReqText.bind(this), this.setNewReqVerifyMethod = this.setNewReqVerifyMethod.bind(this), this.addElement = this.addElement.bind(this), this.setNewElementType = this.setNewElementType.bind(this), this.setNewElementDocRef = this.setNewElementDocRef.bind(this), this.addRelationship = this.addRelationship.bind(this), this.setCssStyle = this.setCssStyle.bind(this), this.setClass = this.setClass.bind(this), this.defineClass = this.defineClass.bind(this), this.setAccTitle = this.setAccTitle.bind(this), this.setAccDescription = this.setAccDescription.bind(this);
  }
  static {
    x(this, "RequirementDB");
  }
  getDirection() {
    return this.direction;
  }
  setDirection(t) {
    this.direction = t;
  }
  resetLatestRequirement() {
    this.latestRequirement = this.getInitialRequirement();
  }
  resetLatestElement() {
    this.latestElement = this.getInitialElement();
  }
  getInitialRequirement() {
    return {
      requirementId: "",
      text: "",
      risk: "",
      verifyMethod: "",
      name: "",
      type: "",
      cssStyles: [],
      classes: ["default"]
    };
  }
  getInitialElement() {
    return {
      name: "",
      type: "",
      docRef: "",
      cssStyles: [],
      classes: ["default"]
    };
  }
  addRequirement(t, e) {
    return this.requirements.has(t) || this.requirements.set(t, {
      name: t,
      type: e,
      requirementId: this.latestRequirement.requirementId,
      text: this.latestRequirement.text,
      risk: this.latestRequirement.risk,
      verifyMethod: this.latestRequirement.verifyMethod,
      cssStyles: [],
      classes: ["default"]
    }), this.resetLatestRequirement(), this.requirements.get(t);
  }
  getRequirements() {
    return this.requirements;
  }
  setNewReqId(t) {
    this.latestRequirement !== void 0 && (this.latestRequirement.requirementId = t);
  }
  setNewReqText(t) {
    this.latestRequirement !== void 0 && (this.latestRequirement.text = t);
  }
  setNewReqRisk(t) {
    this.latestRequirement !== void 0 && (this.latestRequirement.risk = t);
  }
  setNewReqVerifyMethod(t) {
    this.latestRequirement !== void 0 && (this.latestRequirement.verifyMethod = t);
  }
  addElement(t) {
    return this.elements.has(t) || (this.elements.set(t, {
      name: t,
      type: this.latestElement.type,
      docRef: this.latestElement.docRef,
      cssStyles: [],
      classes: ["default"]
    }), ie.info("Added new element: ", t)), this.resetLatestElement(), this.elements.get(t);
  }
  getElements() {
    return this.elements;
  }
  setNewElementType(t) {
    this.latestElement !== void 0 && (this.latestElement.type = t);
  }
  setNewElementDocRef(t) {
    this.latestElement !== void 0 && (this.latestElement.docRef = t);
  }
  addRelationship(t, e, r) {
    this.relations.push({
      type: t,
      src: e,
      dst: r
    });
  }
  getRelationships() {
    return this.relations;
  }
  clear() {
    this.relations = [], this.resetLatestRequirement(), this.requirements = /* @__PURE__ */ new Map(), this.resetLatestElement(), this.elements = /* @__PURE__ */ new Map(), this.classes = /* @__PURE__ */ new Map(), _n();
  }
  setCssStyle(t, e) {
    for (const r of t) {
      const n = this.requirements.get(r) ?? this.elements.get(r);
      if (!e || !n)
        return;
      for (const i of e)
        i.includes(",") ? n.cssStyles.push(...i.split(",")) : n.cssStyles.push(i);
    }
  }
  setClass(t, e) {
    for (const r of t) {
      const n = this.requirements.get(r) ?? this.elements.get(r);
      if (n)
        for (const i of e) {
          n.classes.push(i);
          const a = this.classes.get(i)?.styles;
          a && n.cssStyles.push(...a);
        }
    }
  }
  defineClass(t, e) {
    for (const r of t) {
      let n = this.classes.get(r);
      n === void 0 && (n = { id: r, styles: [], textStyles: [] }, this.classes.set(r, n)), e && e.forEach(function(i) {
        if (/color/.exec(i)) {
          const a = i.replace("fill", "bgFill");
          n.textStyles.push(a);
        }
        n.styles.push(i);
      }), this.requirements.forEach((i) => {
        i.classes.includes(r) && i.cssStyles.push(...e.flatMap((a) => a.split(",")));
      }), this.elements.forEach((i) => {
        i.classes.includes(r) && i.cssStyles.push(...e.flatMap((a) => a.split(",")));
      });
    }
  }
  getClasses() {
    return this.classes;
  }
  getData() {
    const t = we(), e = [], r = [];
    for (const n of this.requirements.values()) {
      const i = n;
      i.id = n.name, i.cssStyles = n.cssStyles, i.cssClasses = n.classes.join(" "), i.shape = "requirementBox", i.look = t.look, e.push(i);
    }
    for (const n of this.elements.values()) {
      const i = n;
      i.shape = "requirementBox", i.look = t.look, i.id = n.name, i.cssStyles = n.cssStyles, i.cssClasses = n.classes.join(" "), e.push(i);
    }
    for (const n of this.relations) {
      let i = 0;
      const a = n.type === this.Relationships.CONTAINS, s = {
        id: `${n.src}-${n.dst}-${i}`,
        start: this.requirements.get(n.src)?.name ?? this.elements.get(n.src)?.name,
        end: this.requirements.get(n.dst)?.name ?? this.elements.get(n.dst)?.name,
        label: `&lt;&lt;${n.type}&gt;&gt;`,
        classes: "relationshipLine",
        style: ["fill:none", a ? "" : "stroke-dasharray: 10,7"],
        labelpos: "c",
        thickness: "normal",
        type: "normal",
        pattern: a ? "normal" : "dashed",
        arrowTypeStart: a ? "requirement_contains" : "",
        arrowTypeEnd: a ? "" : "requirement_arrow",
        look: t.look
      };
      r.push(s), i++;
    }
    return { nodes: e, edges: r, other: {}, config: t, direction: this.getDirection() };
  }
}, jNe = /* @__PURE__ */ x((t) => `

  marker {
    fill: ${t.relationColor};
    stroke: ${t.relationColor};
  }

  marker.cross {
    stroke: ${t.lineColor};
  }

  svg {
    font-family: ${t.fontFamily};
    font-size: ${t.fontSize};
  }

  .reqBox {
    fill: ${t.requirementBackground};
    fill-opacity: 1.0;
    stroke: ${t.requirementBorderColor};
    stroke-width: ${t.requirementBorderSize};
  }
  
  .reqTitle, .reqLabel{
    fill:  ${t.requirementTextColor};
  }
  .reqLabelBox {
    fill: ${t.relationLabelBackground};
    fill-opacity: 1.0;
  }

  .req-title-line {
    stroke: ${t.requirementBorderColor};
    stroke-width: ${t.requirementBorderSize};
  }
  .relationshipLine {
    stroke: ${t.relationColor};
    stroke-width: 1;
  }
  .relationshipLabel {
    fill: ${t.relationLabelColor};
  }
  .divider {
    stroke: ${t.nodeBorder};
    stroke-width: 1;
  }
  .label {
    font-family: ${t.fontFamily};
    color: ${t.nodeTextColor || t.textColor};
  }
  .label text,span {
    fill: ${t.nodeTextColor || t.textColor};
    color: ${t.nodeTextColor || t.textColor};
  }
  .labelBkg {
    background-color: ${t.edgeLabelBackground};
  }

`, "getStyles"), KNe = jNe, GY = {};
A2(GY, {
  draw: () => ZNe
});
var ZNe = /* @__PURE__ */ x(async function(t, e, r, n) {
  ie.info("REF0:"), ie.info("Drawing requirement diagram (unified)", e);
  const { securityLevel: i, state: a, layout: s } = we(), o = n.db.getData(), l = lf(e, i);
  o.type = n.type, o.layoutAlgorithm = mg(s), o.nodeSpacing = a?.nodeSpacing ?? 50, o.rankSpacing = a?.rankSpacing ?? 50, o.markers = ["requirement_contains", "requirement_arrow"], o.diagramId = e, await Kd(o, l);
  const u = 8;
  Zt.insertTitle(
    l,
    "requirementDiagramTitleText",
    a?.titleTopMargin ?? 25,
    n.db.getDiagramTitle()
  ), rh(l, u, "requirementDiagram", a?.useMaxWidth ?? !0);
}, "draw"), QNe = {
  parser: YNe,
  get db() {
    return new XNe();
  },
  renderer: GY,
  styles: KNe
};
const JNe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: QNe
}, Symbol.toStringTag, { value: "Module" }));
var O6 = (function() {
  var t = /* @__PURE__ */ x(function(Z, X, Y, ee) {
    for (Y = Y || {}, ee = Z.length; ee--; Y[Z[ee]] = X) ;
    return Y;
  }, "o"), e = [1, 2], r = [1, 3], n = [1, 4], i = [2, 4], a = [1, 9], s = [1, 11], o = [1, 13], l = [1, 14], u = [1, 16], h = [1, 17], d = [1, 18], f = [1, 24], p = [1, 25], g = [1, 26], m = [1, 27], v = [1, 28], y = [1, 29], b = [1, 30], w = [1, 31], T = [1, 32], E = [1, 33], L = [1, 34], k = [1, 35], C = [1, 36], A = [1, 37], R = [1, 38], _ = [1, 39], O = [1, 41], P = [1, 42], S = [1, 43], M = [1, 44], N = [1, 45], D = [1, 46], I = [1, 4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 47, 48, 49, 50, 52, 53, 55, 60, 61, 62, 63, 71], B = [2, 71], z = [4, 5, 16, 50, 52, 53], F = [4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 50, 52, 53, 55, 60, 61, 62, 63, 71], V = [4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 49, 50, 52, 53, 55, 60, 61, 62, 63, 71], H = [4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 48, 50, 52, 53, 55, 60, 61, 62, 63, 71], J = [4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 47, 50, 52, 53, 55, 60, 61, 62, 63, 71], q = [69, 70, 71], ae = [1, 127], re = {
    trace: /* @__PURE__ */ x(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, SPACE: 4, NEWLINE: 5, SD: 6, document: 7, line: 8, statement: 9, box_section: 10, box_line: 11, participant_statement: 12, create: 13, box: 14, restOfLine: 15, end: 16, signal: 17, autonumber: 18, NUM: 19, off: 20, activate: 21, actor: 22, deactivate: 23, note_statement: 24, links_statement: 25, link_statement: 26, properties_statement: 27, details_statement: 28, title: 29, legacy_title: 30, acc_title: 31, acc_title_value: 32, acc_descr: 33, acc_descr_value: 34, acc_descr_multiline_value: 35, loop: 36, rect: 37, opt: 38, alt: 39, else_sections: 40, par: 41, par_sections: 42, par_over: 43, critical: 44, option_sections: 45, break: 46, option: 47, and: 48, else: 49, participant: 50, AS: 51, participant_actor: 52, destroy: 53, actor_with_config: 54, note: 55, placement: 56, text2: 57, over: 58, actor_pair: 59, links: 60, link: 61, properties: 62, details: 63, spaceList: 64, ",": 65, left_of: 66, right_of: 67, signaltype: 68, "+": 69, "-": 70, ACTOR: 71, config_object: 72, CONFIG_START: 73, CONFIG_CONTENT: 74, CONFIG_END: 75, SOLID_OPEN_ARROW: 76, DOTTED_OPEN_ARROW: 77, SOLID_ARROW: 78, BIDIRECTIONAL_SOLID_ARROW: 79, DOTTED_ARROW: 80, BIDIRECTIONAL_DOTTED_ARROW: 81, SOLID_CROSS: 82, DOTTED_CROSS: 83, SOLID_POINT: 84, DOTTED_POINT: 85, TXT: 86, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "SPACE", 5: "NEWLINE", 6: "SD", 13: "create", 14: "box", 15: "restOfLine", 16: "end", 18: "autonumber", 19: "NUM", 20: "off", 21: "activate", 23: "deactivate", 29: "title", 30: "legacy_title", 31: "acc_title", 32: "acc_title_value", 33: "acc_descr", 34: "acc_descr_value", 35: "acc_descr_multiline_value", 36: "loop", 37: "rect", 38: "opt", 39: "alt", 41: "par", 43: "par_over", 44: "critical", 46: "break", 47: "option", 48: "and", 49: "else", 50: "participant", 51: "AS", 52: "participant_actor", 53: "destroy", 55: "note", 58: "over", 60: "links", 61: "link", 62: "properties", 63: "details", 65: ",", 66: "left_of", 67: "right_of", 69: "+", 70: "-", 71: "ACTOR", 73: "CONFIG_START", 74: "CONFIG_CONTENT", 75: "CONFIG_END", 76: "SOLID_OPEN_ARROW", 77: "DOTTED_OPEN_ARROW", 78: "SOLID_ARROW", 79: "BIDIRECTIONAL_SOLID_ARROW", 80: "DOTTED_ARROW", 81: "BIDIRECTIONAL_DOTTED_ARROW", 82: "SOLID_CROSS", 83: "DOTTED_CROSS", 84: "SOLID_POINT", 85: "DOTTED_POINT", 86: "TXT" },
    productions_: [0, [3, 2], [3, 2], [3, 2], [7, 0], [7, 2], [8, 2], [8, 1], [8, 1], [10, 0], [10, 2], [11, 2], [11, 1], [11, 1], [9, 1], [9, 2], [9, 4], [9, 2], [9, 4], [9, 3], [9, 3], [9, 2], [9, 3], [9, 3], [9, 2], [9, 2], [9, 2], [9, 2], [9, 2], [9, 1], [9, 1], [9, 2], [9, 2], [9, 1], [9, 4], [9, 4], [9, 4], [9, 4], [9, 4], [9, 4], [9, 4], [9, 4], [45, 1], [45, 4], [42, 1], [42, 4], [40, 1], [40, 4], [12, 5], [12, 3], [12, 5], [12, 3], [12, 3], [12, 3], [24, 4], [24, 4], [25, 3], [26, 3], [27, 3], [28, 3], [64, 2], [64, 1], [59, 3], [59, 1], [56, 1], [56, 1], [17, 5], [17, 5], [17, 4], [54, 2], [72, 3], [22, 1], [68, 1], [68, 1], [68, 1], [68, 1], [68, 1], [68, 1], [68, 1], [68, 1], [68, 1], [68, 1], [57, 1]],
    performAction: /* @__PURE__ */ x(function(X, Y, ee, j, fe, te, Ae) {
      var W = te.length - 1;
      switch (fe) {
        case 3:
          return j.apply(te[W]), te[W];
        case 4:
        case 9:
          this.$ = [];
          break;
        case 5:
        case 10:
          te[W - 1].push(te[W]), this.$ = te[W - 1];
          break;
        case 6:
        case 7:
        case 11:
        case 12:
          this.$ = te[W];
          break;
        case 8:
        case 13:
          this.$ = [];
          break;
        case 15:
          te[W].type = "createParticipant", this.$ = te[W];
          break;
        case 16:
          te[W - 1].unshift({ type: "boxStart", boxData: j.parseBoxData(te[W - 2]) }), te[W - 1].push({ type: "boxEnd", boxText: te[W - 2] }), this.$ = te[W - 1];
          break;
        case 18:
          this.$ = { type: "sequenceIndex", sequenceIndex: Number(te[W - 2]), sequenceIndexStep: Number(te[W - 1]), sequenceVisible: !0, signalType: j.LINETYPE.AUTONUMBER };
          break;
        case 19:
          this.$ = { type: "sequenceIndex", sequenceIndex: Number(te[W - 1]), sequenceIndexStep: 1, sequenceVisible: !0, signalType: j.LINETYPE.AUTONUMBER };
          break;
        case 20:
          this.$ = { type: "sequenceIndex", sequenceVisible: !1, signalType: j.LINETYPE.AUTONUMBER };
          break;
        case 21:
          this.$ = { type: "sequenceIndex", sequenceVisible: !0, signalType: j.LINETYPE.AUTONUMBER };
          break;
        case 22:
          this.$ = { type: "activeStart", signalType: j.LINETYPE.ACTIVE_START, actor: te[W - 1].actor };
          break;
        case 23:
          this.$ = { type: "activeEnd", signalType: j.LINETYPE.ACTIVE_END, actor: te[W - 1].actor };
          break;
        case 29:
          j.setDiagramTitle(te[W].substring(6)), this.$ = te[W].substring(6);
          break;
        case 30:
          j.setDiagramTitle(te[W].substring(7)), this.$ = te[W].substring(7);
          break;
        case 31:
          this.$ = te[W].trim(), j.setAccTitle(this.$);
          break;
        case 32:
        case 33:
          this.$ = te[W].trim(), j.setAccDescription(this.$);
          break;
        case 34:
          te[W - 1].unshift({ type: "loopStart", loopText: j.parseMessage(te[W - 2]), signalType: j.LINETYPE.LOOP_START }), te[W - 1].push({ type: "loopEnd", loopText: te[W - 2], signalType: j.LINETYPE.LOOP_END }), this.$ = te[W - 1];
          break;
        case 35:
          te[W - 1].unshift({ type: "rectStart", color: j.parseMessage(te[W - 2]), signalType: j.LINETYPE.RECT_START }), te[W - 1].push({ type: "rectEnd", color: j.parseMessage(te[W - 2]), signalType: j.LINETYPE.RECT_END }), this.$ = te[W - 1];
          break;
        case 36:
          te[W - 1].unshift({ type: "optStart", optText: j.parseMessage(te[W - 2]), signalType: j.LINETYPE.OPT_START }), te[W - 1].push({ type: "optEnd", optText: j.parseMessage(te[W - 2]), signalType: j.LINETYPE.OPT_END }), this.$ = te[W - 1];
          break;
        case 37:
          te[W - 1].unshift({ type: "altStart", altText: j.parseMessage(te[W - 2]), signalType: j.LINETYPE.ALT_START }), te[W - 1].push({ type: "altEnd", signalType: j.LINETYPE.ALT_END }), this.$ = te[W - 1];
          break;
        case 38:
          te[W - 1].unshift({ type: "parStart", parText: j.parseMessage(te[W - 2]), signalType: j.LINETYPE.PAR_START }), te[W - 1].push({ type: "parEnd", signalType: j.LINETYPE.PAR_END }), this.$ = te[W - 1];
          break;
        case 39:
          te[W - 1].unshift({ type: "parStart", parText: j.parseMessage(te[W - 2]), signalType: j.LINETYPE.PAR_OVER_START }), te[W - 1].push({ type: "parEnd", signalType: j.LINETYPE.PAR_END }), this.$ = te[W - 1];
          break;
        case 40:
          te[W - 1].unshift({ type: "criticalStart", criticalText: j.parseMessage(te[W - 2]), signalType: j.LINETYPE.CRITICAL_START }), te[W - 1].push({ type: "criticalEnd", signalType: j.LINETYPE.CRITICAL_END }), this.$ = te[W - 1];
          break;
        case 41:
          te[W - 1].unshift({ type: "breakStart", breakText: j.parseMessage(te[W - 2]), signalType: j.LINETYPE.BREAK_START }), te[W - 1].push({ type: "breakEnd", optText: j.parseMessage(te[W - 2]), signalType: j.LINETYPE.BREAK_END }), this.$ = te[W - 1];
          break;
        case 43:
          this.$ = te[W - 3].concat([{ type: "option", optionText: j.parseMessage(te[W - 1]), signalType: j.LINETYPE.CRITICAL_OPTION }, te[W]]);
          break;
        case 45:
          this.$ = te[W - 3].concat([{ type: "and", parText: j.parseMessage(te[W - 1]), signalType: j.LINETYPE.PAR_AND }, te[W]]);
          break;
        case 47:
          this.$ = te[W - 3].concat([{ type: "else", altText: j.parseMessage(te[W - 1]), signalType: j.LINETYPE.ALT_ELSE }, te[W]]);
          break;
        case 48:
          te[W - 3].draw = "participant", te[W - 3].type = "addParticipant", te[W - 3].description = j.parseMessage(te[W - 1]), this.$ = te[W - 3];
          break;
        case 49:
          te[W - 1].draw = "participant", te[W - 1].type = "addParticipant", this.$ = te[W - 1];
          break;
        case 50:
          te[W - 3].draw = "actor", te[W - 3].type = "addParticipant", te[W - 3].description = j.parseMessage(te[W - 1]), this.$ = te[W - 3];
          break;
        case 51:
          te[W - 1].draw = "actor", te[W - 1].type = "addParticipant", this.$ = te[W - 1];
          break;
        case 52:
          te[W - 1].type = "destroyParticipant", this.$ = te[W - 1];
          break;
        case 53:
          te[W - 1].draw = "participant", te[W - 1].type = "addParticipant", this.$ = te[W - 1];
          break;
        case 54:
          this.$ = [te[W - 1], { type: "addNote", placement: te[W - 2], actor: te[W - 1].actor, text: te[W] }];
          break;
        case 55:
          te[W - 2] = [].concat(te[W - 1], te[W - 1]).slice(0, 2), te[W - 2][0] = te[W - 2][0].actor, te[W - 2][1] = te[W - 2][1].actor, this.$ = [te[W - 1], { type: "addNote", placement: j.PLACEMENT.OVER, actor: te[W - 2].slice(0, 2), text: te[W] }];
          break;
        case 56:
          this.$ = [te[W - 1], { type: "addLinks", actor: te[W - 1].actor, text: te[W] }];
          break;
        case 57:
          this.$ = [te[W - 1], { type: "addALink", actor: te[W - 1].actor, text: te[W] }];
          break;
        case 58:
          this.$ = [te[W - 1], { type: "addProperties", actor: te[W - 1].actor, text: te[W] }];
          break;
        case 59:
          this.$ = [te[W - 1], { type: "addDetails", actor: te[W - 1].actor, text: te[W] }];
          break;
        case 62:
          this.$ = [te[W - 2], te[W]];
          break;
        case 63:
          this.$ = te[W];
          break;
        case 64:
          this.$ = j.PLACEMENT.LEFTOF;
          break;
        case 65:
          this.$ = j.PLACEMENT.RIGHTOF;
          break;
        case 66:
          this.$ = [
            te[W - 4],
            te[W - 1],
            { type: "addMessage", from: te[W - 4].actor, to: te[W - 1].actor, signalType: te[W - 3], msg: te[W], activate: !0 },
            { type: "activeStart", signalType: j.LINETYPE.ACTIVE_START, actor: te[W - 1].actor }
          ];
          break;
        case 67:
          this.$ = [
            te[W - 4],
            te[W - 1],
            { type: "addMessage", from: te[W - 4].actor, to: te[W - 1].actor, signalType: te[W - 3], msg: te[W] },
            { type: "activeEnd", signalType: j.LINETYPE.ACTIVE_END, actor: te[W - 4].actor }
          ];
          break;
        case 68:
          this.$ = [te[W - 3], te[W - 1], { type: "addMessage", from: te[W - 3].actor, to: te[W - 1].actor, signalType: te[W - 2], msg: te[W] }];
          break;
        case 69:
          this.$ = {
            type: "addParticipant",
            actor: te[W - 1],
            config: te[W]
          };
          break;
        case 70:
          this.$ = te[W - 1].trim();
          break;
        case 71:
          this.$ = { type: "addParticipant", actor: te[W] };
          break;
        case 72:
          this.$ = j.LINETYPE.SOLID_OPEN;
          break;
        case 73:
          this.$ = j.LINETYPE.DOTTED_OPEN;
          break;
        case 74:
          this.$ = j.LINETYPE.SOLID;
          break;
        case 75:
          this.$ = j.LINETYPE.BIDIRECTIONAL_SOLID;
          break;
        case 76:
          this.$ = j.LINETYPE.DOTTED;
          break;
        case 77:
          this.$ = j.LINETYPE.BIDIRECTIONAL_DOTTED;
          break;
        case 78:
          this.$ = j.LINETYPE.SOLID_CROSS;
          break;
        case 79:
          this.$ = j.LINETYPE.DOTTED_CROSS;
          break;
        case 80:
          this.$ = j.LINETYPE.SOLID_POINT;
          break;
        case 81:
          this.$ = j.LINETYPE.DOTTED_POINT;
          break;
        case 82:
          this.$ = j.parseMessage(te[W].trim().substring(1));
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: e, 5: r, 6: n }, { 1: [3] }, { 3: 5, 4: e, 5: r, 6: n }, { 3: 6, 4: e, 5: r, 6: n }, t([1, 4, 5, 13, 14, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 50, 52, 53, 55, 60, 61, 62, 63, 71], i, { 7: 7 }), { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3], 4: a, 5: s, 8: 8, 9: 10, 12: 12, 13: o, 14: l, 17: 15, 18: u, 21: h, 22: 40, 23: d, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: f, 30: p, 31: g, 33: m, 35: v, 36: y, 37: b, 38: w, 39: T, 41: E, 43: L, 44: k, 46: C, 50: A, 52: R, 53: _, 55: O, 60: P, 61: S, 62: M, 63: N, 71: D }, t(I, [2, 5]), { 9: 47, 12: 12, 13: o, 14: l, 17: 15, 18: u, 21: h, 22: 40, 23: d, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: f, 30: p, 31: g, 33: m, 35: v, 36: y, 37: b, 38: w, 39: T, 41: E, 43: L, 44: k, 46: C, 50: A, 52: R, 53: _, 55: O, 60: P, 61: S, 62: M, 63: N, 71: D }, t(I, [2, 7]), t(I, [2, 8]), t(I, [2, 14]), { 12: 48, 50: A, 52: R, 53: _ }, { 15: [1, 49] }, { 5: [1, 50] }, { 5: [1, 53], 19: [1, 51], 20: [1, 52] }, { 22: 54, 71: D }, { 22: 55, 71: D }, { 5: [1, 56] }, { 5: [1, 57] }, { 5: [1, 58] }, { 5: [1, 59] }, { 5: [1, 60] }, t(I, [2, 29]), t(I, [2, 30]), { 32: [1, 61] }, { 34: [1, 62] }, t(I, [2, 33]), { 15: [1, 63] }, { 15: [1, 64] }, { 15: [1, 65] }, { 15: [1, 66] }, { 15: [1, 67] }, { 15: [1, 68] }, { 15: [1, 69] }, { 15: [1, 70] }, { 22: 71, 54: 72, 71: [1, 73] }, { 22: 74, 71: D }, { 22: 75, 71: D }, { 68: 76, 76: [1, 77], 77: [1, 78], 78: [1, 79], 79: [1, 80], 80: [1, 81], 81: [1, 82], 82: [1, 83], 83: [1, 84], 84: [1, 85], 85: [1, 86] }, { 56: 87, 58: [1, 88], 66: [1, 89], 67: [1, 90] }, { 22: 91, 71: D }, { 22: 92, 71: D }, { 22: 93, 71: D }, { 22: 94, 71: D }, t([5, 51, 65, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86], B), t(I, [2, 6]), t(I, [2, 15]), t(z, [2, 9], { 10: 95 }), t(I, [2, 17]), { 5: [1, 97], 19: [1, 96] }, { 5: [1, 98] }, t(I, [2, 21]), { 5: [1, 99] }, { 5: [1, 100] }, t(I, [2, 24]), t(I, [2, 25]), t(I, [2, 26]), t(I, [2, 27]), t(I, [2, 28]), t(I, [2, 31]), t(I, [2, 32]), t(F, i, { 7: 101 }), t(F, i, { 7: 102 }), t(F, i, { 7: 103 }), t(V, i, { 40: 104, 7: 105 }), t(H, i, { 42: 106, 7: 107 }), t(H, i, { 7: 107, 42: 108 }), t(J, i, { 45: 109, 7: 110 }), t(F, i, { 7: 111 }), { 5: [1, 113], 51: [1, 112] }, { 5: [1, 114] }, t([5, 51], B, { 72: 115, 73: [1, 116] }), { 5: [1, 118], 51: [1, 117] }, { 5: [1, 119] }, { 22: 122, 69: [1, 120], 70: [1, 121], 71: D }, t(q, [2, 72]), t(q, [2, 73]), t(q, [2, 74]), t(q, [2, 75]), t(q, [2, 76]), t(q, [2, 77]), t(q, [2, 78]), t(q, [2, 79]), t(q, [2, 80]), t(q, [2, 81]), { 22: 123, 71: D }, { 22: 125, 59: 124, 71: D }, { 71: [2, 64] }, { 71: [2, 65] }, { 57: 126, 86: ae }, { 57: 128, 86: ae }, { 57: 129, 86: ae }, { 57: 130, 86: ae }, { 4: [1, 133], 5: [1, 135], 11: 132, 12: 134, 16: [1, 131], 50: A, 52: R, 53: _ }, { 5: [1, 136] }, t(I, [2, 19]), t(I, [2, 20]), t(I, [2, 22]), t(I, [2, 23]), { 4: a, 5: s, 8: 8, 9: 10, 12: 12, 13: o, 14: l, 16: [1, 137], 17: 15, 18: u, 21: h, 22: 40, 23: d, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: f, 30: p, 31: g, 33: m, 35: v, 36: y, 37: b, 38: w, 39: T, 41: E, 43: L, 44: k, 46: C, 50: A, 52: R, 53: _, 55: O, 60: P, 61: S, 62: M, 63: N, 71: D }, { 4: a, 5: s, 8: 8, 9: 10, 12: 12, 13: o, 14: l, 16: [1, 138], 17: 15, 18: u, 21: h, 22: 40, 23: d, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: f, 30: p, 31: g, 33: m, 35: v, 36: y, 37: b, 38: w, 39: T, 41: E, 43: L, 44: k, 46: C, 50: A, 52: R, 53: _, 55: O, 60: P, 61: S, 62: M, 63: N, 71: D }, { 4: a, 5: s, 8: 8, 9: 10, 12: 12, 13: o, 14: l, 16: [1, 139], 17: 15, 18: u, 21: h, 22: 40, 23: d, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: f, 30: p, 31: g, 33: m, 35: v, 36: y, 37: b, 38: w, 39: T, 41: E, 43: L, 44: k, 46: C, 50: A, 52: R, 53: _, 55: O, 60: P, 61: S, 62: M, 63: N, 71: D }, { 16: [1, 140] }, { 4: a, 5: s, 8: 8, 9: 10, 12: 12, 13: o, 14: l, 16: [2, 46], 17: 15, 18: u, 21: h, 22: 40, 23: d, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: f, 30: p, 31: g, 33: m, 35: v, 36: y, 37: b, 38: w, 39: T, 41: E, 43: L, 44: k, 46: C, 49: [1, 141], 50: A, 52: R, 53: _, 55: O, 60: P, 61: S, 62: M, 63: N, 71: D }, { 16: [1, 142] }, { 4: a, 5: s, 8: 8, 9: 10, 12: 12, 13: o, 14: l, 16: [2, 44], 17: 15, 18: u, 21: h, 22: 40, 23: d, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: f, 30: p, 31: g, 33: m, 35: v, 36: y, 37: b, 38: w, 39: T, 41: E, 43: L, 44: k, 46: C, 48: [1, 143], 50: A, 52: R, 53: _, 55: O, 60: P, 61: S, 62: M, 63: N, 71: D }, { 16: [1, 144] }, { 16: [1, 145] }, { 4: a, 5: s, 8: 8, 9: 10, 12: 12, 13: o, 14: l, 16: [2, 42], 17: 15, 18: u, 21: h, 22: 40, 23: d, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: f, 30: p, 31: g, 33: m, 35: v, 36: y, 37: b, 38: w, 39: T, 41: E, 43: L, 44: k, 46: C, 47: [1, 146], 50: A, 52: R, 53: _, 55: O, 60: P, 61: S, 62: M, 63: N, 71: D }, { 4: a, 5: s, 8: 8, 9: 10, 12: 12, 13: o, 14: l, 16: [1, 147], 17: 15, 18: u, 21: h, 22: 40, 23: d, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: f, 30: p, 31: g, 33: m, 35: v, 36: y, 37: b, 38: w, 39: T, 41: E, 43: L, 44: k, 46: C, 50: A, 52: R, 53: _, 55: O, 60: P, 61: S, 62: M, 63: N, 71: D }, { 15: [1, 148] }, t(I, [2, 49]), t(I, [2, 53]), { 5: [2, 69] }, { 74: [1, 149] }, { 15: [1, 150] }, t(I, [2, 51]), t(I, [2, 52]), { 22: 151, 71: D }, { 22: 152, 71: D }, { 57: 153, 86: ae }, { 57: 154, 86: ae }, { 57: 155, 86: ae }, { 65: [1, 156], 86: [2, 63] }, { 5: [2, 56] }, { 5: [2, 82] }, { 5: [2, 57] }, { 5: [2, 58] }, { 5: [2, 59] }, t(I, [2, 16]), t(z, [2, 10]), { 12: 157, 50: A, 52: R, 53: _ }, t(z, [2, 12]), t(z, [2, 13]), t(I, [2, 18]), t(I, [2, 34]), t(I, [2, 35]), t(I, [2, 36]), t(I, [2, 37]), { 15: [1, 158] }, t(I, [2, 38]), { 15: [1, 159] }, t(I, [2, 39]), t(I, [2, 40]), { 15: [1, 160] }, t(I, [2, 41]), { 5: [1, 161] }, { 75: [1, 162] }, { 5: [1, 163] }, { 57: 164, 86: ae }, { 57: 165, 86: ae }, { 5: [2, 68] }, { 5: [2, 54] }, { 5: [2, 55] }, { 22: 166, 71: D }, t(z, [2, 11]), t(V, i, { 7: 105, 40: 167 }), t(H, i, { 7: 107, 42: 168 }), t(J, i, { 7: 110, 45: 169 }), t(I, [2, 48]), { 5: [2, 70] }, t(I, [2, 50]), { 5: [2, 66] }, { 5: [2, 67] }, { 86: [2, 62] }, { 16: [2, 47] }, { 16: [2, 45] }, { 16: [2, 43] }],
    defaultActions: { 5: [2, 1], 6: [2, 2], 89: [2, 64], 90: [2, 65], 115: [2, 69], 126: [2, 56], 127: [2, 82], 128: [2, 57], 129: [2, 58], 130: [2, 59], 153: [2, 68], 154: [2, 54], 155: [2, 55], 162: [2, 70], 164: [2, 66], 165: [2, 67], 166: [2, 62], 167: [2, 47], 168: [2, 45], 169: [2, 43] },
    parseError: /* @__PURE__ */ x(function(X, Y) {
      if (Y.recoverable)
        this.trace(X);
      else {
        var ee = new Error(X);
        throw ee.hash = Y, ee;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ x(function(X) {
      var Y = this, ee = [0], j = [], fe = [null], te = [], Ae = this.table, W = "", De = 0, ue = 0, ze = 2, Ge = 1, Ve = te.slice.call(arguments, 1), ke = Object.create(this.lexer), Oe = { yy: {} };
      for (var Se in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, Se) && (Oe.yy[Se] = this.yy[Se]);
      ke.setInput(X, Oe.yy), Oe.yy.lexer = ke, Oe.yy.parser = this, typeof ke.yylloc > "u" && (ke.yylloc = {});
      var _e = ke.yylloc;
      te.push(_e);
      var $e = ke.options && ke.options.ranges;
      typeof Oe.yy.parseError == "function" ? this.parseError = Oe.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function me(Me) {
        ee.length = ee.length - 2 * Me, fe.length = fe.length - Me, te.length = te.length - Me;
      }
      x(me, "popStack");
      function Ne() {
        var Me;
        return Me = j.pop() || ke.lex() || Ge, typeof Me != "number" && (Me instanceof Array && (j = Me, Me = j.pop()), Me = Y.symbols_[Me] || Me), Me;
      }
      x(Ne, "lex");
      for (var Q, ce, $, oe, se = {}, ge, he, be, Ce; ; ) {
        if (ce = ee[ee.length - 1], this.defaultActions[ce] ? $ = this.defaultActions[ce] : ((Q === null || typeof Q > "u") && (Q = Ne()), $ = Ae[ce] && Ae[ce][Q]), typeof $ > "u" || !$.length || !$[0]) {
          var Te = "";
          Ce = [];
          for (ge in Ae[ce])
            this.terminals_[ge] && ge > ze && Ce.push("'" + this.terminals_[ge] + "'");
          ke.showPosition ? Te = "Parse error on line " + (De + 1) + `:
` + ke.showPosition() + `
Expecting ` + Ce.join(", ") + ", got '" + (this.terminals_[Q] || Q) + "'" : Te = "Parse error on line " + (De + 1) + ": Unexpected " + (Q == Ge ? "end of input" : "'" + (this.terminals_[Q] || Q) + "'"), this.parseError(Te, {
            text: ke.match,
            token: this.terminals_[Q] || Q,
            line: ke.yylineno,
            loc: _e,
            expected: Ce
          });
        }
        if ($[0] instanceof Array && $.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + ce + ", token: " + Q);
        switch ($[0]) {
          case 1:
            ee.push(Q), fe.push(ke.yytext), te.push(ke.yylloc), ee.push($[1]), Q = null, ue = ke.yyleng, W = ke.yytext, De = ke.yylineno, _e = ke.yylloc;
            break;
          case 2:
            if (he = this.productions_[$[1]][1], se.$ = fe[fe.length - he], se._$ = {
              first_line: te[te.length - (he || 1)].first_line,
              last_line: te[te.length - 1].last_line,
              first_column: te[te.length - (he || 1)].first_column,
              last_column: te[te.length - 1].last_column
            }, $e && (se._$.range = [
              te[te.length - (he || 1)].range[0],
              te[te.length - 1].range[1]
            ]), oe = this.performAction.apply(se, [
              W,
              ue,
              De,
              Oe.yy,
              $[1],
              fe,
              te
            ].concat(Ve)), typeof oe < "u")
              return oe;
            he && (ee = ee.slice(0, -1 * he * 2), fe = fe.slice(0, -1 * he), te = te.slice(0, -1 * he)), ee.push(this.productions_[$[1]][0]), fe.push(se.$), te.push(se._$), be = Ae[ee[ee.length - 2]][ee[ee.length - 1]], ee.push(be);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, pe = /* @__PURE__ */ (function() {
    var Z = {
      EOF: 1,
      parseError: /* @__PURE__ */ x(function(Y, ee) {
        if (this.yy.parser)
          this.yy.parser.parseError(Y, ee);
        else
          throw new Error(Y);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ x(function(X, Y) {
        return this.yy = Y || this.yy || {}, this._input = X, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ x(function() {
        var X = this._input[0];
        this.yytext += X, this.yyleng++, this.offset++, this.match += X, this.matched += X;
        var Y = X.match(/(?:\r\n?|\n).*/g);
        return Y ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), X;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ x(function(X) {
        var Y = X.length, ee = X.split(/(?:\r\n?|\n)/g);
        this._input = X + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - Y), this.offset -= Y;
        var j = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), ee.length - 1 && (this.yylineno -= ee.length - 1);
        var fe = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: ee ? (ee.length === j.length ? this.yylloc.first_column : 0) + j[j.length - ee.length].length - ee[0].length : this.yylloc.first_column - Y
        }, this.options.ranges && (this.yylloc.range = [fe[0], fe[0] + this.yyleng - Y]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ x(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ x(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ x(function(X) {
        this.unput(this.match.slice(X));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ x(function() {
        var X = this.matched.substr(0, this.matched.length - this.match.length);
        return (X.length > 20 ? "..." : "") + X.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ x(function() {
        var X = this.match;
        return X.length < 20 && (X += this._input.substr(0, 20 - X.length)), (X.substr(0, 20) + (X.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ x(function() {
        var X = this.pastInput(), Y = new Array(X.length + 1).join("-");
        return X + this.upcomingInput() + `
` + Y + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ x(function(X, Y) {
        var ee, j, fe;
        if (this.options.backtrack_lexer && (fe = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (fe.yylloc.range = this.yylloc.range.slice(0))), j = X[0].match(/(?:\r\n?|\n).*/g), j && (this.yylineno += j.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: j ? j[j.length - 1].length - j[j.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + X[0].length
        }, this.yytext += X[0], this.match += X[0], this.matches = X, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(X[0].length), this.matched += X[0], ee = this.performAction.call(this, this.yy, this, Y, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), ee)
          return ee;
        if (this._backtrack) {
          for (var te in fe)
            this[te] = fe[te];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ x(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var X, Y, ee, j;
        this._more || (this.yytext = "", this.match = "");
        for (var fe = this._currentRules(), te = 0; te < fe.length; te++)
          if (ee = this._input.match(this.rules[fe[te]]), ee && (!Y || ee[0].length > Y[0].length)) {
            if (Y = ee, j = te, this.options.backtrack_lexer) {
              if (X = this.test_match(ee, fe[te]), X !== !1)
                return X;
              if (this._backtrack) {
                Y = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return Y ? (X = this.test_match(Y, fe[j]), X !== !1 ? X : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ x(function() {
        var Y = this.next();
        return Y || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ x(function(Y) {
        this.conditionStack.push(Y);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ x(function() {
        var Y = this.conditionStack.length - 1;
        return Y > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ x(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ x(function(Y) {
        return Y = this.conditionStack.length - 1 - Math.abs(Y || 0), Y >= 0 ? this.conditionStack[Y] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ x(function(Y) {
        this.begin(Y);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ x(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ x(function(Y, ee, j, fe) {
        switch (j) {
          case 0:
            return 5;
          case 1:
            break;
          case 2:
            break;
          case 3:
            break;
          case 4:
            break;
          case 5:
            break;
          case 6:
            return 19;
          case 7:
            return this.begin("CONFIG"), 73;
          case 8:
            return 74;
          case 9:
            return this.popState(), this.popState(), 75;
          case 10:
            return ee.yytext = ee.yytext.trim(), 71;
          case 11:
            return ee.yytext = ee.yytext.trim(), this.begin("ALIAS"), 71;
          case 12:
            return this.begin("LINE"), 14;
          case 13:
            return this.begin("ID"), 50;
          case 14:
            return this.begin("ID"), 52;
          case 15:
            return 13;
          case 16:
            return this.begin("ID"), 53;
          case 17:
            return ee.yytext = ee.yytext.trim(), this.begin("ALIAS"), 71;
          case 18:
            return this.popState(), this.popState(), this.begin("LINE"), 51;
          case 19:
            return this.popState(), this.popState(), 5;
          case 20:
            return this.begin("LINE"), 36;
          case 21:
            return this.begin("LINE"), 37;
          case 22:
            return this.begin("LINE"), 38;
          case 23:
            return this.begin("LINE"), 39;
          case 24:
            return this.begin("LINE"), 49;
          case 25:
            return this.begin("LINE"), 41;
          case 26:
            return this.begin("LINE"), 43;
          case 27:
            return this.begin("LINE"), 48;
          case 28:
            return this.begin("LINE"), 44;
          case 29:
            return this.begin("LINE"), 47;
          case 30:
            return this.begin("LINE"), 46;
          case 31:
            return this.popState(), 15;
          case 32:
            return 16;
          case 33:
            return 66;
          case 34:
            return 67;
          case 35:
            return 60;
          case 36:
            return 61;
          case 37:
            return 62;
          case 38:
            return 63;
          case 39:
            return 58;
          case 40:
            return 55;
          case 41:
            return this.begin("ID"), 21;
          case 42:
            return this.begin("ID"), 23;
          case 43:
            return 29;
          case 44:
            return 30;
          case 45:
            return this.begin("acc_title"), 31;
          case 46:
            return this.popState(), "acc_title_value";
          case 47:
            return this.begin("acc_descr"), 33;
          case 48:
            return this.popState(), "acc_descr_value";
          case 49:
            this.begin("acc_descr_multiline");
            break;
          case 50:
            this.popState();
            break;
          case 51:
            return "acc_descr_multiline_value";
          case 52:
            return 6;
          case 53:
            return 18;
          case 54:
            return 20;
          case 55:
            return 65;
          case 56:
            return 5;
          case 57:
            return ee.yytext = ee.yytext.trim(), 71;
          case 58:
            return 78;
          case 59:
            return 79;
          case 60:
            return 80;
          case 61:
            return 81;
          case 62:
            return 76;
          case 63:
            return 77;
          case 64:
            return 82;
          case 65:
            return 83;
          case 66:
            return 84;
          case 67:
            return 85;
          case 68:
            return 86;
          case 69:
            return 86;
          case 70:
            return 69;
          case 71:
            return 70;
          case 72:
            return 5;
          case 73:
            return "INVALID";
        }
      }, "anonymous"),
      rules: [/^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:((?!\n)\s)+)/i, /^(?:#[^\n]*)/i, /^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[0-9]+(?=[ \n]+))/i, /^(?:@\{)/i, /^(?:[^\}]+)/i, /^(?:\})/i, /^(?:[^\<->\->:\n,;@\s]+(?=@\{))/i, /^(?:[^\<->\->:\n,;@]+?([\-]*[^\<->\->:\n,;@]+?)*?(?=((?!\n)\s)+as(?!\n)\s|[#\n;]|$))/i, /^(?:box\b)/i, /^(?:participant\b)/i, /^(?:actor\b)/i, /^(?:create\b)/i, /^(?:destroy\b)/i, /^(?:[^<\->\->:\n,;]+?([\-]*[^<\->\->:\n,;]+?)*?(?=((?!\n)\s)+as(?!\n)\s|[#\n;]|$))/i, /^(?:as\b)/i, /^(?:(?:))/i, /^(?:loop\b)/i, /^(?:rect\b)/i, /^(?:opt\b)/i, /^(?:alt\b)/i, /^(?:else\b)/i, /^(?:par\b)/i, /^(?:par_over\b)/i, /^(?:and\b)/i, /^(?:critical\b)/i, /^(?:option\b)/i, /^(?:break\b)/i, /^(?:(?:[:]?(?:no)?wrap)?[^#\n;]*)/i, /^(?:end\b)/i, /^(?:left of\b)/i, /^(?:right of\b)/i, /^(?:links\b)/i, /^(?:link\b)/i, /^(?:properties\b)/i, /^(?:details\b)/i, /^(?:over\b)/i, /^(?:note\b)/i, /^(?:activate\b)/i, /^(?:deactivate\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:title:\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:sequenceDiagram\b)/i, /^(?:autonumber\b)/i, /^(?:off\b)/i, /^(?:,)/i, /^(?:;)/i, /^(?:[^+<\->\->:\n,;]+((?!(-x|--x|-\)|--\)))[\-]*[^\+<\->\->:\n,;]+)*)/i, /^(?:->>)/i, /^(?:<<->>)/i, /^(?:-->>)/i, /^(?:<<-->>)/i, /^(?:->)/i, /^(?:-->)/i, /^(?:-[x])/i, /^(?:--[x])/i, /^(?:-[\)])/i, /^(?:--[\)])/i, /^(?::(?:(?:no)?wrap)?[^#\n;]*)/i, /^(?::)/i, /^(?:\+)/i, /^(?:-)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { acc_descr_multiline: { rules: [50, 51], inclusive: !1 }, acc_descr: { rules: [48], inclusive: !1 }, acc_title: { rules: [46], inclusive: !1 }, ID: { rules: [2, 3, 7, 10, 11, 17], inclusive: !1 }, ALIAS: { rules: [2, 3, 18, 19], inclusive: !1 }, LINE: { rules: [2, 3, 31], inclusive: !1 }, CONFIG: { rules: [8, 9], inclusive: !1 }, CONFIG_DATA: { rules: [], inclusive: !1 }, INITIAL: { rules: [0, 1, 3, 4, 5, 6, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 47, 49, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73], inclusive: !0 } }
    };
    return Z;
  })();
  re.lexer = pe;
  function K() {
    this.yy = {};
  }
  return x(K, "Parser"), K.prototype = re, re.Parser = K, new K();
})();
O6.parser = O6;
var eIe = O6, tIe = {
  SOLID: 0,
  DOTTED: 1,
  NOTE: 2,
  SOLID_CROSS: 3,
  DOTTED_CROSS: 4,
  SOLID_OPEN: 5,
  DOTTED_OPEN: 6,
  LOOP_START: 10,
  LOOP_END: 11,
  ALT_START: 12,
  ALT_ELSE: 13,
  ALT_END: 14,
  OPT_START: 15,
  OPT_END: 16,
  ACTIVE_START: 17,
  ACTIVE_END: 18,
  PAR_START: 19,
  PAR_AND: 20,
  PAR_END: 21,
  RECT_START: 22,
  RECT_END: 23,
  SOLID_POINT: 24,
  DOTTED_POINT: 25,
  AUTONUMBER: 26,
  CRITICAL_START: 27,
  CRITICAL_OPTION: 28,
  CRITICAL_END: 29,
  BREAK_START: 30,
  BREAK_END: 31,
  PAR_OVER_START: 32,
  BIDIRECTIONAL_SOLID: 33,
  BIDIRECTIONAL_DOTTED: 34
}, rIe = {
  FILLED: 0,
  OPEN: 1
}, nIe = {
  LEFTOF: 0,
  RIGHTOF: 1,
  OVER: 2
}, cm = {
  ACTOR: "actor",
  CONTROL: "control",
  DATABASE: "database",
  ENTITY: "entity"
}, iIe = class {
  constructor() {
    this.state = new bH(() => ({
      prevActor: void 0,
      actors: /* @__PURE__ */ new Map(),
      createdActors: /* @__PURE__ */ new Map(),
      destroyedActors: /* @__PURE__ */ new Map(),
      boxes: [],
      messages: [],
      notes: [],
      sequenceNumbersEnabled: !1,
      wrapEnabled: void 0,
      currentBox: void 0,
      lastCreated: void 0,
      lastDestroyed: void 0
    })), this.setAccTitle = Cn, this.setAccDescription = Vn, this.setDiagramTitle = Zn, this.getAccTitle = Gn, this.getAccDescription = Un, this.getDiagramTitle = Ln, this.apply = this.apply.bind(this), this.parseBoxData = this.parseBoxData.bind(this), this.parseMessage = this.parseMessage.bind(this), this.clear(), this.setWrap(we().wrap), this.LINETYPE = tIe, this.ARROWTYPE = rIe, this.PLACEMENT = nIe;
  }
  static {
    x(this, "SequenceDB");
  }
  addBox(t) {
    this.state.records.boxes.push({
      name: t.text,
      wrap: t.wrap ?? this.autoWrap(),
      fill: t.color,
      actorKeys: []
    }), this.state.records.currentBox = this.state.records.boxes.slice(-1)[0];
  }
  addActor(t, e, r, n, i) {
    let a = this.state.records.currentBox, s;
    if (i !== void 0) {
      let l;
      i.includes(`
`) ? l = i + `
` : l = `{
` + i + `
}`, s = q2(l, { schema: H2 });
    }
    n = s?.type ?? n;
    const o = this.state.records.actors.get(t);
    if (o) {
      if (this.state.records.currentBox && o.box && this.state.records.currentBox !== o.box)
        throw new Error(
          `A same participant should only be defined in one Box: ${o.name} can't be in '${o.box.name}' and in '${this.state.records.currentBox.name}' at the same time.`
        );
      if (a = o.box ? o.box : this.state.records.currentBox, o.box = a, o && e === o.name && r == null)
        return;
    }
    if (r?.text == null && (r = { text: e, type: n }), (n == null || r.text == null) && (r = { text: e, type: n }), this.state.records.actors.set(t, {
      box: a,
      name: e,
      description: r.text,
      wrap: r.wrap ?? this.autoWrap(),
      prevActor: this.state.records.prevActor,
      links: {},
      properties: {},
      actorCnt: null,
      rectData: null,
      type: n ?? "participant"
    }), this.state.records.prevActor) {
      const l = this.state.records.actors.get(this.state.records.prevActor);
      l && (l.nextActor = t);
    }
    this.state.records.currentBox && this.state.records.currentBox.actorKeys.push(t), this.state.records.prevActor = t;
  }
  activationCount(t) {
    let e, r = 0;
    if (!t)
      return 0;
    for (e = 0; e < this.state.records.messages.length; e++)
      this.state.records.messages[e].type === this.LINETYPE.ACTIVE_START && this.state.records.messages[e].from === t && r++, this.state.records.messages[e].type === this.LINETYPE.ACTIVE_END && this.state.records.messages[e].from === t && r--;
    return r;
  }
  addMessage(t, e, r, n) {
    this.state.records.messages.push({
      id: this.state.records.messages.length.toString(),
      from: t,
      to: e,
      message: r.text,
      wrap: r.wrap ?? this.autoWrap(),
      answer: n
    });
  }
  addSignal(t, e, r, n, i = !1) {
    if (n === this.LINETYPE.ACTIVE_END && this.activationCount(t ?? "") < 1) {
      const s = new Error("Trying to inactivate an inactive participant (" + t + ")");
      throw s.hash = {
        text: "->>-",
        token: "->>-",
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ["'ACTIVE_PARTICIPANT'"]
      }, s;
    }
    return this.state.records.messages.push({
      id: this.state.records.messages.length.toString(),
      from: t,
      to: e,
      message: r?.text ?? "",
      wrap: r?.wrap ?? this.autoWrap(),
      type: n,
      activate: i
    }), !0;
  }
  hasAtLeastOneBox() {
    return this.state.records.boxes.length > 0;
  }
  hasAtLeastOneBoxWithTitle() {
    return this.state.records.boxes.some((t) => t.name);
  }
  getMessages() {
    return this.state.records.messages;
  }
  getBoxes() {
    return this.state.records.boxes;
  }
  getActors() {
    return this.state.records.actors;
  }
  getCreatedActors() {
    return this.state.records.createdActors;
  }
  getDestroyedActors() {
    return this.state.records.destroyedActors;
  }
  getActor(t) {
    return this.state.records.actors.get(t);
  }
  getActorKeys() {
    return [...this.state.records.actors.keys()];
  }
  enableSequenceNumbers() {
    this.state.records.sequenceNumbersEnabled = !0;
  }
  disableSequenceNumbers() {
    this.state.records.sequenceNumbersEnabled = !1;
  }
  showSequenceNumbers() {
    return this.state.records.sequenceNumbersEnabled;
  }
  setWrap(t) {
    this.state.records.wrapEnabled = t;
  }
  extractWrap(t) {
    if (t === void 0)
      return {};
    t = t.trim();
    const e = /^:?wrap:/.exec(t) !== null ? !0 : /^:?nowrap:/.exec(t) !== null ? !1 : void 0;
    return { cleanedText: (e === void 0 ? t : t.replace(/^:?(?:no)?wrap:/, "")).trim(), wrap: e };
  }
  autoWrap() {
    return this.state.records.wrapEnabled !== void 0 ? this.state.records.wrapEnabled : we().sequence?.wrap ?? !1;
  }
  clear() {
    this.state.reset(), _n();
  }
  parseMessage(t) {
    const e = t.trim(), { wrap: r, cleanedText: n } = this.extractWrap(e), i = {
      text: n,
      wrap: r
    };
    return ie.debug(`parseMessage: ${JSON.stringify(i)}`), i;
  }
  // We expect the box statement to be color first then description
  // The color can be rgb,rgba,hsl,hsla, or css code names  #hex codes are not supported for now because of the way the char # is handled
  // We extract first segment as color, the rest of the line is considered as text
  parseBoxData(t) {
    const e = /^((?:rgba?|hsla?)\s*\(.*\)|\w*)(.*)$/.exec(t);
    let r = e?.[1] ? e[1].trim() : "transparent", n = e?.[2] ? e[2].trim() : void 0;
    if (window?.CSS)
      window.CSS.supports("color", r) || (r = "transparent", n = t.trim());
    else {
      const s = new Option().style;
      s.color = r, s.color !== r && (r = "transparent", n = t.trim());
    }
    const { wrap: i, cleanedText: a } = this.extractWrap(n);
    return {
      text: a ? dr(a, we()) : void 0,
      color: r,
      wrap: i
    };
  }
  addNote(t, e, r) {
    const n = {
      actor: t,
      placement: e,
      message: r.text,
      wrap: r.wrap ?? this.autoWrap()
    }, i = [].concat(t, t);
    this.state.records.notes.push(n), this.state.records.messages.push({
      id: this.state.records.messages.length.toString(),
      from: i[0],
      to: i[1],
      message: r.text,
      wrap: r.wrap ?? this.autoWrap(),
      type: this.LINETYPE.NOTE,
      placement: e
    });
  }
  addLinks(t, e) {
    const r = this.getActor(t);
    try {
      let n = dr(e.text, we());
      n = n.replace(/&equals;/g, "="), n = n.replace(/&amp;/g, "&");
      const i = JSON.parse(n);
      this.insertLinks(r, i);
    } catch (n) {
      ie.error("error while parsing actor link text", n);
    }
  }
  addALink(t, e) {
    const r = this.getActor(t);
    try {
      const n = {};
      let i = dr(e.text, we());
      const a = i.indexOf("@");
      i = i.replace(/&equals;/g, "="), i = i.replace(/&amp;/g, "&");
      const s = i.slice(0, a - 1).trim(), o = i.slice(a + 1).trim();
      n[s] = o, this.insertLinks(r, n);
    } catch (n) {
      ie.error("error while parsing actor link text", n);
    }
  }
  insertLinks(t, e) {
    if (t.links == null)
      t.links = e;
    else
      for (const r in e)
        t.links[r] = e[r];
  }
  addProperties(t, e) {
    const r = this.getActor(t);
    try {
      const n = dr(e.text, we()), i = JSON.parse(n);
      this.insertProperties(r, i);
    } catch (n) {
      ie.error("error while parsing actor properties text", n);
    }
  }
  insertProperties(t, e) {
    if (t.properties == null)
      t.properties = e;
    else
      for (const r in e)
        t.properties[r] = e[r];
  }
  boxEnd() {
    this.state.records.currentBox = void 0;
  }
  addDetails(t, e) {
    const r = this.getActor(t), n = document.getElementById(e.text);
    try {
      const i = n.innerHTML, a = JSON.parse(i);
      a.properties && this.insertProperties(r, a.properties), a.links && this.insertLinks(r, a.links);
    } catch (i) {
      ie.error("error while parsing actor details text", i);
    }
  }
  getActorProperty(t, e) {
    if (t?.properties !== void 0)
      return t.properties[e];
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-redundant-type-constituents
  apply(t) {
    if (Array.isArray(t))
      t.forEach((e) => {
        this.apply(e);
      });
    else
      switch (t.type) {
        case "sequenceIndex":
          this.state.records.messages.push({
            id: this.state.records.messages.length.toString(),
            from: void 0,
            to: void 0,
            message: {
              start: t.sequenceIndex,
              step: t.sequenceIndexStep,
              visible: t.sequenceVisible
            },
            wrap: !1,
            type: t.signalType
          });
          break;
        case "addParticipant":
          this.addActor(t.actor, t.actor, t.description, t.draw, t.config);
          break;
        case "createParticipant":
          if (this.state.records.actors.has(t.actor))
            throw new Error(
              "It is not possible to have actors with the same id, even if one is destroyed before the next is created. Use 'AS' aliases to simulate the behavior"
            );
          this.state.records.lastCreated = t.actor, this.addActor(t.actor, t.actor, t.description, t.draw, t.config), this.state.records.createdActors.set(t.actor, this.state.records.messages.length);
          break;
        case "destroyParticipant":
          this.state.records.lastDestroyed = t.actor, this.state.records.destroyedActors.set(t.actor, this.state.records.messages.length);
          break;
        case "activeStart":
          this.addSignal(t.actor, void 0, void 0, t.signalType);
          break;
        case "activeEnd":
          this.addSignal(t.actor, void 0, void 0, t.signalType);
          break;
        case "addNote":
          this.addNote(t.actor, t.placement, t.text);
          break;
        case "addLinks":
          this.addLinks(t.actor, t.text);
          break;
        case "addALink":
          this.addALink(t.actor, t.text);
          break;
        case "addProperties":
          this.addProperties(t.actor, t.text);
          break;
        case "addDetails":
          this.addDetails(t.actor, t.text);
          break;
        case "addMessage":
          if (this.state.records.lastCreated) {
            if (t.to !== this.state.records.lastCreated)
              throw new Error(
                "The created participant " + this.state.records.lastCreated.name + " does not have an associated creating message after its declaration. Please check the sequence diagram."
              );
            this.state.records.lastCreated = void 0;
          } else if (this.state.records.lastDestroyed) {
            if (t.to !== this.state.records.lastDestroyed && t.from !== this.state.records.lastDestroyed)
              throw new Error(
                "The destroyed participant " + this.state.records.lastDestroyed.name + " does not have an associated destroying message after its declaration. Please check the sequence diagram."
              );
            this.state.records.lastDestroyed = void 0;
          }
          this.addSignal(t.from, t.to, t.msg, t.signalType, t.activate);
          break;
        case "boxStart":
          this.addBox(t.boxData);
          break;
        case "boxEnd":
          this.boxEnd();
          break;
        case "loopStart":
          this.addSignal(void 0, void 0, t.loopText, t.signalType);
          break;
        case "loopEnd":
          this.addSignal(void 0, void 0, void 0, t.signalType);
          break;
        case "rectStart":
          this.addSignal(void 0, void 0, t.color, t.signalType);
          break;
        case "rectEnd":
          this.addSignal(void 0, void 0, void 0, t.signalType);
          break;
        case "optStart":
          this.addSignal(void 0, void 0, t.optText, t.signalType);
          break;
        case "optEnd":
          this.addSignal(void 0, void 0, void 0, t.signalType);
          break;
        case "altStart":
          this.addSignal(void 0, void 0, t.altText, t.signalType);
          break;
        case "else":
          this.addSignal(void 0, void 0, t.altText, t.signalType);
          break;
        case "altEnd":
          this.addSignal(void 0, void 0, void 0, t.signalType);
          break;
        case "setAccTitle":
          Cn(t.text);
          break;
        case "parStart":
          this.addSignal(void 0, void 0, t.parText, t.signalType);
          break;
        case "and":
          this.addSignal(void 0, void 0, t.parText, t.signalType);
          break;
        case "parEnd":
          this.addSignal(void 0, void 0, void 0, t.signalType);
          break;
        case "criticalStart":
          this.addSignal(void 0, void 0, t.criticalText, t.signalType);
          break;
        case "option":
          this.addSignal(void 0, void 0, t.optionText, t.signalType);
          break;
        case "criticalEnd":
          this.addSignal(void 0, void 0, void 0, t.signalType);
          break;
        case "breakStart":
          this.addSignal(void 0, void 0, t.breakText, t.signalType);
          break;
        case "breakEnd":
          this.addSignal(void 0, void 0, void 0, t.signalType);
          break;
      }
  }
  getConfig() {
    return we().sequence;
  }
}, aIe = /* @__PURE__ */ x((t) => `.actor {
    stroke: ${t.actorBorder};
    fill: ${t.actorBkg};
  }

  text.actor > tspan {
    fill: ${t.actorTextColor};
    stroke: none;
  }

  .actor-line {
    stroke: ${t.actorLineColor};
  }
  
  .innerArc {
    stroke-width: 1.5;
    stroke-dasharray: none;
  }

  .messageLine0 {
    stroke-width: 1.5;
    stroke-dasharray: none;
    stroke: ${t.signalColor};
  }

  .messageLine1 {
    stroke-width: 1.5;
    stroke-dasharray: 2, 2;
    stroke: ${t.signalColor};
  }

  #arrowhead path {
    fill: ${t.signalColor};
    stroke: ${t.signalColor};
  }

  .sequenceNumber {
    fill: ${t.sequenceNumberColor};
  }

  #sequencenumber {
    fill: ${t.signalColor};
  }

  #crosshead path {
    fill: ${t.signalColor};
    stroke: ${t.signalColor};
  }

  .messageText {
    fill: ${t.signalTextColor};
    stroke: none;
  }

  .labelBox {
    stroke: ${t.labelBoxBorderColor};
    fill: ${t.labelBoxBkgColor};
  }

  .labelText, .labelText > tspan {
    fill: ${t.labelTextColor};
    stroke: none;
  }

  .loopText, .loopText > tspan {
    fill: ${t.loopTextColor};
    stroke: none;
  }

  .loopLine {
    stroke-width: 2px;
    stroke-dasharray: 2, 2;
    stroke: ${t.labelBoxBorderColor};
    fill: ${t.labelBoxBorderColor};
  }

  .note {
    //stroke: #decc93;
    stroke: ${t.noteBorderColor};
    fill: ${t.noteBkgColor};
  }

  .noteText, .noteText > tspan {
    fill: ${t.noteTextColor};
    stroke: none;
  }

  .activation0 {
    fill: ${t.activationBkgColor};
    stroke: ${t.activationBorderColor};
  }

  .activation1 {
    fill: ${t.activationBkgColor};
    stroke: ${t.activationBorderColor};
  }

  .activation2 {
    fill: ${t.activationBkgColor};
    stroke: ${t.activationBorderColor};
  }

  .actorPopupMenu {
    position: absolute;
  }

  .actorPopupMenuPanel {
    position: absolute;
    fill: ${t.actorBkg};
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    filter: drop-shadow(3px 5px 2px rgb(0 0 0 / 0.4));
}
  .actor-man line {
    stroke: ${t.actorBorder};
    fill: ${t.actorBkg};
  }
  .actor-man circle, line {
    stroke: ${t.actorBorder};
    fill: ${t.actorBkg};
    stroke-width: 2px;
  }

`, "getStyles"), sIe = aIe, cu = 36, Rc = "actor-top", Mc = "actor-bottom", bb = "actor-box", cc = "actor-man", eg = /* @__PURE__ */ x(function(t, e) {
  return Ux(t, e);
}, "drawRect"), oIe = /* @__PURE__ */ x(function(t, e, r, n, i) {
  if (e.links === void 0 || e.links === null || Object.keys(e.links).length === 0)
    return { height: 0, width: 0 };
  const a = e.links, s = e.actorCnt, o = e.rectData;
  var l = "none";
  i && (l = "block !important");
  const u = t.append("g");
  u.attr("id", "actor" + s + "_popup"), u.attr("class", "actorPopupMenu"), u.attr("display", l);
  var h = "";
  o.class !== void 0 && (h = " " + o.class);
  let d = o.width > r ? o.width : r;
  const f = u.append("rect");
  if (f.attr("class", "actorPopupMenuPanel" + h), f.attr("x", o.x), f.attr("y", o.height), f.attr("fill", o.fill), f.attr("stroke", o.stroke), f.attr("width", d), f.attr("height", o.height), f.attr("rx", o.rx), f.attr("ry", o.ry), a != null) {
    var p = 20;
    for (let v in a) {
      var g = u.append("a"), m = Uu.sanitizeUrl(a[v]);
      g.attr("xlink:href", m), g.attr("target", "_blank"), LIe(n)(
        v,
        g,
        o.x + 10,
        o.height + p,
        d,
        20,
        { class: "actor" },
        n
      ), p += 30;
    }
  }
  return f.attr("height", p), { height: o.height + p, width: d };
}, "drawPopup"), wb = /* @__PURE__ */ x(function(t) {
  return "var pu = document.getElementById('" + t + "'); if (pu != null) { pu.style.display = pu.style.display == 'block' ? 'none' : 'block'; }";
}, "popupMenuToggle"), y2 = /* @__PURE__ */ x(async function(t, e, r = null) {
  let n = t.append("foreignObject");
  const i = await sg(e.text, pr()), s = n.append("xhtml:div").attr("style", "width: fit-content;").attr("xmlns", "http://www.w3.org/1999/xhtml").html(i).node().getBoundingClientRect();
  if (n.attr("height", Math.round(s.height)).attr("width", Math.round(s.width)), e.class === "noteText") {
    const o = t.node().firstChild;
    o.setAttribute("height", s.height + 2 * e.textMargin);
    const l = o.getBBox();
    n.attr("x", Math.round(l.x + l.width / 2 - s.width / 2)).attr("y", Math.round(l.y + l.height / 2 - s.height / 2));
  } else if (r) {
    let { startx: o, stopx: l, starty: u } = r;
    if (o > l) {
      const h = o;
      o = l, l = h;
    }
    n.attr("x", Math.round(o + Math.abs(o - l) / 2 - s.width / 2)), e.class === "loopText" ? n.attr("y", Math.round(u)) : n.attr("y", Math.round(u - s.height));
  }
  return [n];
}, "drawKatex"), Gd = /* @__PURE__ */ x(function(t, e) {
  let r = 0, n = 0;
  const i = e.text.split(at.lineBreakRegex), [a, s] = ju(e.fontSize);
  let o = [], l = 0, u = /* @__PURE__ */ x(() => e.y, "yfunc");
  if (e.valign !== void 0 && e.textMargin !== void 0 && e.textMargin > 0)
    switch (e.valign) {
      case "top":
      case "start":
        u = /* @__PURE__ */ x(() => Math.round(e.y + e.textMargin), "yfunc");
        break;
      case "middle":
      case "center":
        u = /* @__PURE__ */ x(() => Math.round(e.y + (r + n + e.textMargin) / 2), "yfunc");
        break;
      case "bottom":
      case "end":
        u = /* @__PURE__ */ x(() => Math.round(
          e.y + (r + n + 2 * e.textMargin) - e.textMargin
        ), "yfunc");
        break;
    }
  if (e.anchor !== void 0 && e.textMargin !== void 0 && e.width !== void 0)
    switch (e.anchor) {
      case "left":
      case "start":
        e.x = Math.round(e.x + e.textMargin), e.anchor = "start", e.dominantBaseline = "middle", e.alignmentBaseline = "middle";
        break;
      case "middle":
      case "center":
        e.x = Math.round(e.x + e.width / 2), e.anchor = "middle", e.dominantBaseline = "middle", e.alignmentBaseline = "middle";
        break;
      case "right":
      case "end":
        e.x = Math.round(e.x + e.width - e.textMargin), e.anchor = "end", e.dominantBaseline = "middle", e.alignmentBaseline = "middle";
        break;
    }
  for (let [h, d] of i.entries()) {
    e.textMargin !== void 0 && e.textMargin === 0 && a !== void 0 && (l = h * a);
    const f = t.append("text");
    f.attr("x", e.x), f.attr("y", u()), e.anchor !== void 0 && f.attr("text-anchor", e.anchor).attr("dominant-baseline", e.dominantBaseline).attr("alignment-baseline", e.alignmentBaseline), e.fontFamily !== void 0 && f.style("font-family", e.fontFamily), s !== void 0 && f.style("font-size", s), e.fontWeight !== void 0 && f.style("font-weight", e.fontWeight), e.fill !== void 0 && f.attr("fill", e.fill), e.class !== void 0 && f.attr("class", e.class), e.dy !== void 0 ? f.attr("dy", e.dy) : l !== 0 && f.attr("dy", l);
    const p = d || nB;
    if (e.tspan) {
      const g = f.append("tspan");
      g.attr("x", e.x), e.fill !== void 0 && g.attr("fill", e.fill), g.text(p);
    } else
      f.text(p);
    e.valign !== void 0 && e.textMargin !== void 0 && e.textMargin > 0 && (n += (f._groups || f)[0][0].getBBox().height, r = n), o.push(f);
  }
  return o;
}, "drawText"), VY = /* @__PURE__ */ x(function(t, e) {
  function r(i, a, s, o, l) {
    return i + "," + a + " " + (i + s) + "," + a + " " + (i + s) + "," + (a + o - l) + " " + (i + s - l * 1.2) + "," + (a + o) + " " + i + "," + (a + o);
  }
  x(r, "genPoints");
  const n = t.append("polygon");
  return n.attr("points", r(e.x, e.y, e.width, e.height, 7)), n.attr("class", "labelBox"), e.y = e.y + e.height / 2, Gd(t, e), n;
}, "drawLabel"), or = -1, UY = /* @__PURE__ */ x((t, e, r, n) => {
  t.select && r.forEach((i) => {
    const a = e.get(i), s = t.select("#actor" + a.actorCnt);
    !n.mirrorActors && a.stopy ? s.attr("y2", a.stopy + a.height / 2) : n.mirrorActors && s.attr("y2", a.stopy);
  });
}, "fixLifeLineHeights"), lIe = /* @__PURE__ */ x(function(t, e, r, n) {
  const i = n ? e.stopy : e.starty, a = e.x + e.width / 2, s = i + e.height, o = t.append("g").lower();
  var l = o;
  n || (or++, Object.keys(e.links || {}).length && !r.forceMenus && l.attr("onclick", wb(`actor${or}_popup`)).attr("cursor", "pointer"), l.append("line").attr("id", "actor" + or).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", e.name), l = o.append("g"), e.actorCnt = or, e.links != null && l.attr("id", "root-" + or));
  const u = Ma();
  var h = "actor";
  e.properties?.class ? h = e.properties.class : u.fill = "#eaeaea", n ? h += ` ${Mc}` : h += ` ${Rc}`, u.x = e.x, u.y = i, u.width = e.width, u.height = e.height, u.class = h, u.rx = 3, u.ry = 3, u.name = e.name;
  const d = eg(l, u);
  if (e.rectData = u, e.properties?.icon) {
    const p = e.properties.icon.trim();
    p.charAt(0) === "@" ? yS(l, u.x + u.width - 20, u.y + 10, p.substr(1)) : vS(l, u.x + u.width - 20, u.y + 10, p);
  }
  yl(r, un(e.description))(
    e.description,
    l,
    u.x,
    u.y,
    u.width,
    u.height,
    { class: `actor ${bb}` },
    r
  );
  let f = e.height;
  if (d.node) {
    const p = d.node().getBBox();
    e.height = p.height, f = p.height;
  }
  return f;
}, "drawActorTypeParticipant"), cIe = /* @__PURE__ */ x(function(t, e, r, n) {
  const i = n ? e.stopy : e.starty, a = e.x + e.width / 2, s = i + e.height, o = t.append("g").lower();
  var l = o;
  n || (or++, Object.keys(e.links || {}).length && !r.forceMenus && l.attr("onclick", wb(`actor${or}_popup`)).attr("cursor", "pointer"), l.append("line").attr("id", "actor" + or).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", e.name), l = o.append("g"), e.actorCnt = or, e.links != null && l.attr("id", "root-" + or));
  const u = Ma();
  var h = "actor";
  e.properties?.class ? h = e.properties.class : u.fill = "#eaeaea", n ? h += ` ${Mc}` : h += ` ${Rc}`, u.x = e.x, u.y = i, u.width = e.width, u.height = e.height, u.class = h, u.name = e.name;
  const d = 6, f = {
    ...u,
    x: u.x + -d,
    y: u.y + +d,
    class: "actor"
  }, p = eg(l, u);
  if (eg(l, f), e.rectData = u, e.properties?.icon) {
    const m = e.properties.icon.trim();
    m.charAt(0) === "@" ? yS(l, u.x + u.width - 20, u.y + 10, m.substr(1)) : vS(l, u.x + u.width - 20, u.y + 10, m);
  }
  yl(r, un(e.description))(
    e.description,
    l,
    u.x - d,
    u.y + d,
    u.width,
    u.height,
    { class: `actor ${bb}` },
    r
  );
  let g = e.height;
  if (p.node) {
    const m = p.node().getBBox();
    e.height = m.height, g = m.height;
  }
  return g;
}, "drawActorTypeCollections"), uIe = /* @__PURE__ */ x(function(t, e, r, n) {
  const i = n ? e.stopy : e.starty, a = e.x + e.width / 2, s = i + e.height, o = t.append("g").lower();
  let l = o;
  n || (or++, Object.keys(e.links || {}).length && !r.forceMenus && l.attr("onclick", wb(`actor${or}_popup`)).attr("cursor", "pointer"), l.append("line").attr("id", "actor" + or).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", e.name), l = o.append("g"), e.actorCnt = or, e.links != null && l.attr("id", "root-" + or));
  const u = Ma();
  let h = "actor";
  e.properties?.class ? h = e.properties.class : u.fill = "#eaeaea", n ? h += ` ${Mc}` : h += ` ${Rc}`, u.x = e.x, u.y = i, u.width = e.width, u.height = e.height, u.class = h, u.name = e.name;
  const d = u.height / 2, f = d / (2.5 + u.height / 50), p = l.append("g"), g = l.append("g");
  if (p.append("path").attr(
    "d",
    `M ${u.x},${u.y + d}
    a ${f},${d} 0 0 0 0,${u.height}
    h ${u.width - 2 * f}
    a ${f},${d} 0 0 0 0,-${u.height}
    Z
  `
  ).attr("class", h), g.append("path").attr(
    "d",
    `M ${u.x},${u.y + d}
      a ${f},${d} 0 0 0 0,${u.height}`
  ).attr("stroke", "#666").attr("stroke-width", "1px").attr("class", h), p.attr("transform", `translate(${f}, ${-(u.height / 2)})`), g.attr("transform", `translate(${u.width - f}, ${-u.height / 2})`), e.rectData = u, e.properties?.icon) {
    const y = e.properties.icon.trim(), b = u.x + u.width - 20, w = u.y + 10;
    y.charAt(0) === "@" ? yS(l, b, w, y.substr(1)) : vS(l, b, w, y);
  }
  yl(r, un(e.description))(
    e.description,
    l,
    u.x,
    u.y,
    u.width,
    u.height,
    { class: `actor ${bb}` },
    r
  );
  let m = e.height;
  const v = p.select("path:last-child");
  if (v.node()) {
    const y = v.node().getBBox();
    e.height = y.height, m = y.height;
  }
  return m;
}, "drawActorTypeQueue"), hIe = /* @__PURE__ */ x(function(t, e, r, n) {
  const i = n ? e.stopy : e.starty, a = e.x + e.width / 2, s = i + 75, o = t.append("g").lower();
  n || (or++, o.append("line").attr("id", "actor" + or).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", e.name), e.actorCnt = or);
  const l = t.append("g");
  let u = cc;
  n ? u += ` ${Mc}` : u += ` ${Rc}`, l.attr("class", u), l.attr("name", e.name);
  const h = Ma();
  h.x = e.x, h.y = i, h.fill = "#eaeaea", h.width = e.width, h.height = e.height, h.class = "actor";
  const d = e.x + e.width / 2, f = i + 30, p = 18;
  l.append("defs").append("marker").attr("id", "filled-head-control").attr("refX", 11).attr("refY", 5.8).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "172.5").append("path").attr("d", "M 14.4 5.6 L 7.2 10.4 L 8.8 5.6 L 7.2 0.8 Z"), l.append("circle").attr("cx", d).attr("cy", f).attr("r", p).attr("fill", "#eaeaf7").attr("stroke", "#666").attr("stroke-width", 1.2), l.append("line").attr("marker-end", "url(#filled-head-control)").attr("transform", `translate(${d}, ${f - p})`);
  const g = l.node().getBBox();
  return e.height = g.height + 2 * (r?.sequence?.labelBoxHeight ?? 0), yl(r, un(e.description))(
    e.description,
    l,
    h.x,
    h.y + p + (n ? 5 : 10),
    h.width,
    h.height,
    { class: `actor ${cc}` },
    r
  ), e.height;
}, "drawActorTypeControl"), dIe = /* @__PURE__ */ x(function(t, e, r, n) {
  const i = n ? e.stopy : e.starty, a = e.x + e.width / 2, s = i + 75, o = t.append("g").lower(), l = t.append("g");
  let u = cc;
  n ? u += ` ${Mc}` : u += ` ${Rc}`, l.attr("class", u), l.attr("name", e.name);
  const h = Ma();
  h.x = e.x, h.y = i, h.fill = "#eaeaea", h.width = e.width, h.height = e.height, h.class = "actor";
  const d = e.x + e.width / 2, f = i + (n ? 10 : 25), p = 18;
  l.append("circle").attr("cx", d).attr("cy", f).attr("r", p).attr("width", e.width).attr("height", e.height), l.append("line").attr("x1", d - p).attr("x2", d + p).attr("y1", f + p).attr("y2", f + p).attr("stroke", "#333").attr("stroke-width", 2);
  const g = l.node().getBBox();
  return e.height = g.height + (r?.sequence?.labelBoxHeight ?? 0), n || (or++, o.append("line").attr("id", "actor" + or).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", e.name), e.actorCnt = or), yl(r, un(e.description))(
    e.description,
    l,
    h.x,
    h.y + (n ? (f - i + p - 5) / 2 : (f + p - i) / 2),
    h.width,
    h.height,
    { class: `actor ${cc}` },
    r
  ), n ? l.attr("transform", `translate(0, ${p / 2})`) : l.attr("transform", `translate(0, ${p / 2})`), e.height;
}, "drawActorTypeEntity"), fIe = /* @__PURE__ */ x(function(t, e, r, n) {
  const i = n ? e.stopy : e.starty, a = e.x + e.width / 2, s = i + e.height + 2 * r.boxTextMargin, o = t.append("g").lower();
  let l = o;
  n || (or++, Object.keys(e.links || {}).length && !r.forceMenus && l.attr("onclick", wb(`actor${or}_popup`)).attr("cursor", "pointer"), l.append("line").attr("id", "actor" + or).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", e.name), l = o.append("g"), e.actorCnt = or, e.links != null && l.attr("id", "root-" + or));
  const u = Ma();
  let h = "actor";
  e.properties?.class ? h = e.properties.class : u.fill = "#eaeaea", n ? h += ` ${Mc}` : h += ` ${Rc}`, u.x = e.x, u.y = i, u.width = e.width, u.height = e.height, u.class = h, u.name = e.name, u.x = e.x, u.y = i;
  const d = u.width / 4, f = u.width / 4, p = d / 2, g = p / (2.5 + d / 50), m = l.append("g"), v = `
  M ${u.x},${u.y + g}
  a ${p},${g} 0 0 0 ${d},0
  a ${p},${g} 0 0 0 -${d},0
  l 0,${f - 2 * g}
  a ${p},${g} 0 0 0 ${d},0
  l 0,-${f - 2 * g}
`;
  m.append("path").attr("d", v).attr("fill", "#eaeaea").attr("stroke", "#000").attr("stroke-width", 1).attr("class", h), n ? m.attr("transform", `translate(${d * 1.5}, ${u.height / 4 - 2 * g})`) : m.attr("transform", `translate(${d * 1.5}, ${(u.height + g) / 4})`), e.rectData = u, yl(r, un(e.description))(
    e.description,
    l,
    u.x,
    u.y + (n ? (u.height + f) / 4 : (u.height + g) / 2),
    u.width,
    u.height,
    { class: `actor ${bb}` },
    r
  );
  const y = m.select("path:last-child");
  if (y.node()) {
    const b = y.node().getBBox();
    e.height = b.height + (r.sequence.labelBoxHeight ?? 0);
  }
  return e.height;
}, "drawActorTypeDatabase"), pIe = /* @__PURE__ */ x(function(t, e, r, n) {
  const i = n ? e.stopy : e.starty, a = e.x + e.width / 2, s = i + 80, o = 30, l = t.append("g").lower();
  n || (or++, l.append("line").attr("id", "actor" + or).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", e.name), e.actorCnt = or);
  const u = t.append("g");
  let h = cc;
  n ? h += ` ${Mc}` : h += ` ${Rc}`, u.attr("class", h), u.attr("name", e.name);
  const d = Ma();
  d.x = e.x, d.y = i, d.fill = "#eaeaea", d.width = e.width, d.height = e.height, d.class = "actor", u.append("line").attr("id", "actor-man-torso" + or).attr("x1", e.x + e.width / 2 - o * 2.5).attr("y1", i + 10).attr("x2", e.x + e.width / 2 - 15).attr("y2", i + 10), u.append("line").attr("id", "actor-man-arms" + or).attr("x1", e.x + e.width / 2 - o * 2.5).attr("y1", i + 0).attr("x2", e.x + e.width / 2 - o * 2.5).attr("y2", i + 20), u.append("circle").attr("cx", e.x + e.width / 2).attr("cy", i + 10).attr("r", o);
  const f = u.node().getBBox();
  return e.height = f.height + (r.sequence.labelBoxHeight ?? 0), yl(r, un(e.description))(
    e.description,
    u,
    d.x,
    d.y + (n ? o / 2 - 4 : o / 2 + 3),
    d.width,
    d.height,
    { class: `actor ${cc}` },
    r
  ), n ? u.attr("transform", `translate(0,${o / 2 + 7})`) : u.attr("transform", `translate(0,${o / 2 + 7})`), e.height;
}, "drawActorTypeBoundary"), gIe = /* @__PURE__ */ x(function(t, e, r, n) {
  const i = n ? e.stopy : e.starty, a = e.x + e.width / 2, s = i + 80, o = t.append("g").lower();
  n || (or++, o.append("line").attr("id", "actor" + or).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", e.name), e.actorCnt = or);
  const l = t.append("g");
  let u = cc;
  n ? u += ` ${Mc}` : u += ` ${Rc}`, l.attr("class", u), l.attr("name", e.name);
  const h = Ma();
  h.x = e.x, h.y = i, h.fill = "#eaeaea", h.width = e.width, h.height = e.height, h.class = "actor", h.rx = 3, h.ry = 3, l.append("line").attr("id", "actor-man-torso" + or).attr("x1", a).attr("y1", i + 25).attr("x2", a).attr("y2", i + 45), l.append("line").attr("id", "actor-man-arms" + or).attr("x1", a - cu / 2).attr("y1", i + 33).attr("x2", a + cu / 2).attr("y2", i + 33), l.append("line").attr("x1", a - cu / 2).attr("y1", i + 60).attr("x2", a).attr("y2", i + 45), l.append("line").attr("x1", a).attr("y1", i + 45).attr("x2", a + cu / 2 - 2).attr("y2", i + 60);
  const d = l.append("circle");
  d.attr("cx", e.x + e.width / 2), d.attr("cy", i + 10), d.attr("r", 15), d.attr("width", e.width), d.attr("height", e.height);
  const f = l.node().getBBox();
  return e.height = f.height, yl(r, un(e.description))(
    e.description,
    l,
    h.x,
    h.y + 35,
    h.width,
    h.height,
    { class: `actor ${cc}` },
    r
  ), e.height;
}, "drawActorTypeActor"), mIe = /* @__PURE__ */ x(async function(t, e, r, n) {
  switch (e.type) {
    case "actor":
      return await gIe(t, e, r, n);
    case "participant":
      return await lIe(t, e, r, n);
    case "boundary":
      return await pIe(t, e, r, n);
    case "control":
      return await hIe(t, e, r, n);
    case "entity":
      return await dIe(t, e, r, n);
    case "database":
      return await fIe(t, e, r, n);
    case "collections":
      return await cIe(t, e, r, n);
    case "queue":
      return await uIe(t, e, r, n);
  }
}, "drawActor"), vIe = /* @__PURE__ */ x(function(t, e, r) {
  const i = t.append("g");
  HY(i, e), e.name && yl(r)(
    e.name,
    i,
    e.x,
    e.y + r.boxTextMargin + (e.textMaxHeight || 0) / 2,
    e.width,
    0,
    { class: "text" },
    r
  ), i.lower();
}, "drawBox"), yIe = /* @__PURE__ */ x(function(t) {
  return t.append("g");
}, "anchorElement"), xIe = /* @__PURE__ */ x(function(t, e, r, n, i) {
  const a = Ma(), s = e.anchored;
  a.x = e.startx, a.y = e.starty, a.class = "activation" + i % 3, a.width = e.stopx - e.startx, a.height = r - e.starty, eg(s, a);
}, "drawActivation"), bIe = /* @__PURE__ */ x(async function(t, e, r, n) {
  const {
    boxMargin: i,
    boxTextMargin: a,
    labelBoxHeight: s,
    labelBoxWidth: o,
    messageFontFamily: l,
    messageFontSize: u,
    messageFontWeight: h
  } = n, d = t.append("g"), f = /* @__PURE__ */ x(function(m, v, y, b) {
    return d.append("line").attr("x1", m).attr("y1", v).attr("x2", y).attr("y2", b).attr("class", "loopLine");
  }, "drawLoopLine");
  f(e.startx, e.starty, e.stopx, e.starty), f(e.stopx, e.starty, e.stopx, e.stopy), f(e.startx, e.stopy, e.stopx, e.stopy), f(e.startx, e.starty, e.startx, e.stopy), e.sections !== void 0 && e.sections.forEach(function(m) {
    f(e.startx, m.y, e.stopx, m.y).style(
      "stroke-dasharray",
      "3, 3"
    );
  });
  let p = xS();
  p.text = r, p.x = e.startx, p.y = e.starty, p.fontFamily = l, p.fontSize = u, p.fontWeight = h, p.anchor = "middle", p.valign = "middle", p.tspan = !1, p.width = o || 50, p.height = s || 20, p.textMargin = a, p.class = "labelText", VY(d, p), p = qY(), p.text = e.title, p.x = e.startx + o / 2 + (e.stopx - e.startx) / 2, p.y = e.starty + i + a, p.anchor = "middle", p.valign = "middle", p.textMargin = a, p.class = "loopText", p.fontFamily = l, p.fontSize = u, p.fontWeight = h, p.wrap = !0;
  let g = un(p.text) ? await y2(d, p, e) : Gd(d, p);
  if (e.sectionTitles !== void 0) {
    for (const [m, v] of Object.entries(e.sectionTitles))
      if (v.message) {
        p.text = v.message, p.x = e.startx + (e.stopx - e.startx) / 2, p.y = e.sections[m].y + i + a, p.class = "loopText", p.anchor = "middle", p.valign = "middle", p.tspan = !1, p.fontFamily = l, p.fontSize = u, p.fontWeight = h, p.wrap = e.wrap, un(p.text) ? (e.starty = e.sections[m].y, await y2(d, p, e)) : Gd(d, p);
        let y = Math.round(
          g.map((b) => (b._groups || b)[0][0].getBBox().height).reduce((b, w) => b + w)
        );
        e.sections[m].height += y - (i + a);
      }
  }
  return e.height = Math.round(e.stopy - e.starty), d;
}, "drawLoop"), HY = /* @__PURE__ */ x(function(t, e) {
  lH(t, e);
}, "drawBackgroundRect"), wIe = /* @__PURE__ */ x(function(t) {
  t.append("defs").append("symbol").attr("id", "database").attr("fill-rule", "evenodd").attr("clip-rule", "evenodd").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z"
  );
}, "insertDatabaseIcon"), TIe = /* @__PURE__ */ x(function(t) {
  t.append("defs").append("symbol").attr("id", "computer").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z"
  );
}, "insertComputerIcon"), EIe = /* @__PURE__ */ x(function(t) {
  t.append("defs").append("symbol").attr("id", "clock").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z"
  );
}, "insertClockIcon"), kIe = /* @__PURE__ */ x(function(t) {
  t.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 7.9).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto-start-reverse").append("path").attr("d", "M -1 0 L 10 5 L 0 10 z");
}, "insertArrowHead"), SIe = /* @__PURE__ */ x(function(t) {
  t.append("defs").append("marker").attr("id", "filled-head").attr("refX", 15.5).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, "insertArrowFilledHead"), CIe = /* @__PURE__ */ x(function(t) {
  t.append("defs").append("marker").attr("id", "sequencenumber").attr("refX", 15).attr("refY", 15).attr("markerWidth", 60).attr("markerHeight", 40).attr("orient", "auto").append("circle").attr("cx", 15).attr("cy", 15).attr("r", 6);
}, "insertSequenceNumber"), AIe = /* @__PURE__ */ x(function(t) {
  t.append("defs").append("marker").attr("id", "crosshead").attr("markerWidth", 15).attr("markerHeight", 8).attr("orient", "auto").attr("refX", 4).attr("refY", 4.5).append("path").attr("fill", "none").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1pt").attr("d", "M 1,2 L 6,7 M 6,2 L 1,7");
}, "insertArrowCrossHead"), qY = /* @__PURE__ */ x(function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    anchor: void 0,
    style: "#666",
    width: void 0,
    height: void 0,
    textMargin: 0,
    rx: 0,
    ry: 0,
    tspan: !0,
    valign: void 0
  };
}, "getTextObj"), _Ie = /* @__PURE__ */ x(function() {
  return {
    x: 0,
    y: 0,
    fill: "#EDF2AE",
    stroke: "#666",
    width: 100,
    anchor: "start",
    height: 100,
    rx: 0,
    ry: 0
  };
}, "getNoteRect"), yl = /* @__PURE__ */ (function() {
  function t(a, s, o, l, u, h, d) {
    const f = s.append("text").attr("x", o + u / 2).attr("y", l + h / 2 + 5).style("text-anchor", "middle").text(a);
    i(f, d);
  }
  x(t, "byText");
  function e(a, s, o, l, u, h, d, f) {
    const { actorFontSize: p, actorFontFamily: g, actorFontWeight: m } = f, [v, y] = ju(p), b = a.split(at.lineBreakRegex);
    for (let w = 0; w < b.length; w++) {
      const T = w * v - v * (b.length - 1) / 2, E = s.append("text").attr("x", o + u / 2).attr("y", l).style("text-anchor", "middle").style("font-size", y).style("font-weight", m).style("font-family", g);
      E.append("tspan").attr("x", o + u / 2).attr("dy", T).text(b[w]), E.attr("y", l + h / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), i(E, d);
    }
  }
  x(e, "byTspan");
  function r(a, s, o, l, u, h, d, f) {
    const p = s.append("switch"), m = p.append("foreignObject").attr("x", o).attr("y", l).attr("width", u).attr("height", h).append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    m.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(a), e(a, p, o, l, u, h, d, f), i(m, d);
  }
  x(r, "byFo");
  async function n(a, s, o, l, u, h, d, f) {
    const p = await ag(a, pr()), g = s.append("switch"), v = g.append("foreignObject").attr("x", o + u / 2 - p.width / 2).attr("y", l + h / 2 - p.height / 2).attr("width", p.width).attr("height", p.height).append("xhtml:div").style("height", "100%").style("width", "100%");
    v.append("div").style("text-align", "center").style("vertical-align", "middle").html(await sg(a, pr())), e(a, g, o, l, u, h, d, f), i(v, d);
  }
  x(n, "byKatex");
  function i(a, s) {
    for (const o in s)
      s.hasOwnProperty(o) && a.attr(o, s[o]);
  }
  return x(i, "_setTextAttrs"), function(a, s = !1) {
    return s ? n : a.textPlacement === "fo" ? r : a.textPlacement === "old" ? t : e;
  };
})(), LIe = /* @__PURE__ */ (function() {
  function t(i, a, s, o, l, u, h) {
    const d = a.append("text").attr("x", s).attr("y", o).style("text-anchor", "start").text(i);
    n(d, h);
  }
  x(t, "byText");
  function e(i, a, s, o, l, u, h, d) {
    const { actorFontSize: f, actorFontFamily: p, actorFontWeight: g } = d, m = i.split(at.lineBreakRegex);
    for (let v = 0; v < m.length; v++) {
      const y = v * f - f * (m.length - 1) / 2, b = a.append("text").attr("x", s).attr("y", o).style("text-anchor", "start").style("font-size", f).style("font-weight", g).style("font-family", p);
      b.append("tspan").attr("x", s).attr("dy", y).text(m[v]), b.attr("y", o + u / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), n(b, h);
    }
  }
  x(e, "byTspan");
  function r(i, a, s, o, l, u, h, d) {
    const f = a.append("switch"), g = f.append("foreignObject").attr("x", s).attr("y", o).attr("width", l).attr("height", u).append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    g.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(i), e(i, f, s, o, l, u, h, d), n(g, h);
  }
  x(r, "byFo");
  function n(i, a) {
    for (const s in a)
      a.hasOwnProperty(s) && i.attr(s, a[s]);
  }
  return x(n, "_setTextAttrs"), function(i) {
    return i.textPlacement === "fo" ? r : i.textPlacement === "old" ? t : e;
  };
})(), fn = {
  drawRect: eg,
  drawText: Gd,
  drawLabel: VY,
  drawActor: mIe,
  drawBox: vIe,
  drawPopup: oIe,
  anchorElement: yIe,
  drawActivation: xIe,
  drawLoop: bIe,
  drawBackgroundRect: HY,
  insertArrowHead: kIe,
  insertArrowFilledHead: SIe,
  insertSequenceNumber: CIe,
  insertArrowCrossHead: AIe,
  insertDatabaseIcon: wIe,
  insertComputerIcon: TIe,
  insertClockIcon: EIe,
  getTextObj: qY,
  getNoteRect: _Ie,
  fixLifeLineHeights: UY,
  sanitizeUrl: Uu.sanitizeUrl
}, Re = {}, et = {
  data: {
    startx: void 0,
    stopx: void 0,
    starty: void 0,
    stopy: void 0
  },
  verticalPos: 0,
  sequenceItems: [],
  activations: [],
  models: {
    getHeight: /* @__PURE__ */ x(function() {
      return Math.max.apply(
        null,
        this.actors.length === 0 ? [0] : this.actors.map((t) => t.height || 0)
      ) + (this.loops.length === 0 ? 0 : this.loops.map((t) => t.height || 0).reduce((t, e) => t + e)) + (this.messages.length === 0 ? 0 : this.messages.map((t) => t.height || 0).reduce((t, e) => t + e)) + (this.notes.length === 0 ? 0 : this.notes.map((t) => t.height || 0).reduce((t, e) => t + e));
    }, "getHeight"),
    clear: /* @__PURE__ */ x(function() {
      this.actors = [], this.boxes = [], this.loops = [], this.messages = [], this.notes = [];
    }, "clear"),
    addBox: /* @__PURE__ */ x(function(t) {
      this.boxes.push(t);
    }, "addBox"),
    addActor: /* @__PURE__ */ x(function(t) {
      this.actors.push(t);
    }, "addActor"),
    addLoop: /* @__PURE__ */ x(function(t) {
      this.loops.push(t);
    }, "addLoop"),
    addMessage: /* @__PURE__ */ x(function(t) {
      this.messages.push(t);
    }, "addMessage"),
    addNote: /* @__PURE__ */ x(function(t) {
      this.notes.push(t);
    }, "addNote"),
    lastActor: /* @__PURE__ */ x(function() {
      return this.actors[this.actors.length - 1];
    }, "lastActor"),
    lastLoop: /* @__PURE__ */ x(function() {
      return this.loops[this.loops.length - 1];
    }, "lastLoop"),
    lastMessage: /* @__PURE__ */ x(function() {
      return this.messages[this.messages.length - 1];
    }, "lastMessage"),
    lastNote: /* @__PURE__ */ x(function() {
      return this.notes[this.notes.length - 1];
    }, "lastNote"),
    actors: [],
    boxes: [],
    loops: [],
    messages: [],
    notes: []
  },
  init: /* @__PURE__ */ x(function() {
    this.sequenceItems = [], this.activations = [], this.models.clear(), this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0
    }, this.verticalPos = 0, XY(we());
  }, "init"),
  updateVal: /* @__PURE__ */ x(function(t, e, r, n) {
    t[e] === void 0 ? t[e] = r : t[e] = n(r, t[e]);
  }, "updateVal"),
  updateBounds: /* @__PURE__ */ x(function(t, e, r, n) {
    const i = this;
    let a = 0;
    function s(o) {
      return /* @__PURE__ */ x(function(u) {
        a++;
        const h = i.sequenceItems.length - a + 1;
        i.updateVal(u, "starty", e - h * Re.boxMargin, Math.min), i.updateVal(u, "stopy", n + h * Re.boxMargin, Math.max), i.updateVal(et.data, "startx", t - h * Re.boxMargin, Math.min), i.updateVal(et.data, "stopx", r + h * Re.boxMargin, Math.max), o !== "activation" && (i.updateVal(u, "startx", t - h * Re.boxMargin, Math.min), i.updateVal(u, "stopx", r + h * Re.boxMargin, Math.max), i.updateVal(et.data, "starty", e - h * Re.boxMargin, Math.min), i.updateVal(et.data, "stopy", n + h * Re.boxMargin, Math.max));
      }, "updateItemBounds");
    }
    x(s, "updateFn"), this.sequenceItems.forEach(s()), this.activations.forEach(s("activation"));
  }, "updateBounds"),
  insert: /* @__PURE__ */ x(function(t, e, r, n) {
    const i = at.getMin(t, r), a = at.getMax(t, r), s = at.getMin(e, n), o = at.getMax(e, n);
    this.updateVal(et.data, "startx", i, Math.min), this.updateVal(et.data, "starty", s, Math.min), this.updateVal(et.data, "stopx", a, Math.max), this.updateVal(et.data, "stopy", o, Math.max), this.updateBounds(i, s, a, o);
  }, "insert"),
  newActivation: /* @__PURE__ */ x(function(t, e, r) {
    const n = r.get(t.from), i = Tb(t.from).length || 0, a = n.x + n.width / 2 + (i - 1) * Re.activationWidth / 2;
    this.activations.push({
      startx: a,
      starty: this.verticalPos + 2,
      stopx: a + Re.activationWidth,
      stopy: void 0,
      actor: t.from,
      anchored: fn.anchorElement(e)
    });
  }, "newActivation"),
  endActivation: /* @__PURE__ */ x(function(t) {
    const e = this.activations.map(function(r) {
      return r.actor;
    }).lastIndexOf(t.from);
    return this.activations.splice(e, 1)[0];
  }, "endActivation"),
  createLoop: /* @__PURE__ */ x(function(t = { message: void 0, wrap: !1, width: void 0 }, e) {
    return {
      startx: void 0,
      starty: this.verticalPos,
      stopx: void 0,
      stopy: void 0,
      title: t.message,
      wrap: t.wrap,
      width: t.width,
      height: 0,
      fill: e
    };
  }, "createLoop"),
  newLoop: /* @__PURE__ */ x(function(t = { message: void 0, wrap: !1, width: void 0 }, e) {
    this.sequenceItems.push(this.createLoop(t, e));
  }, "newLoop"),
  endLoop: /* @__PURE__ */ x(function() {
    return this.sequenceItems.pop();
  }, "endLoop"),
  isLoopOverlap: /* @__PURE__ */ x(function() {
    return this.sequenceItems.length ? this.sequenceItems[this.sequenceItems.length - 1].overlap : !1;
  }, "isLoopOverlap"),
  addSectionToLoop: /* @__PURE__ */ x(function(t) {
    const e = this.sequenceItems.pop();
    e.sections = e.sections || [], e.sectionTitles = e.sectionTitles || [], e.sections.push({ y: et.getVerticalPos(), height: 0 }), e.sectionTitles.push(t), this.sequenceItems.push(e);
  }, "addSectionToLoop"),
  saveVerticalPos: /* @__PURE__ */ x(function() {
    this.isLoopOverlap() && (this.savedVerticalPos = this.verticalPos);
  }, "saveVerticalPos"),
  resetVerticalPos: /* @__PURE__ */ x(function() {
    this.isLoopOverlap() && (this.verticalPos = this.savedVerticalPos);
  }, "resetVerticalPos"),
  bumpVerticalPos: /* @__PURE__ */ x(function(t) {
    this.verticalPos = this.verticalPos + t, this.data.stopy = at.getMax(this.data.stopy, this.verticalPos);
  }, "bumpVerticalPos"),
  getVerticalPos: /* @__PURE__ */ x(function() {
    return this.verticalPos;
  }, "getVerticalPos"),
  getBounds: /* @__PURE__ */ x(function() {
    return { bounds: this.data, models: this.models };
  }, "getBounds")
}, RIe = /* @__PURE__ */ x(async function(t, e) {
  et.bumpVerticalPos(Re.boxMargin), e.height = Re.boxMargin, e.starty = et.getVerticalPos();
  const r = Ma();
  r.x = e.startx, r.y = e.starty, r.width = e.width || Re.width, r.class = "note";
  const n = t.append("g"), i = fn.drawRect(n, r), a = xS();
  a.x = e.startx, a.y = e.starty, a.width = r.width, a.dy = "1em", a.text = e.message, a.class = "noteText", a.fontFamily = Re.noteFontFamily, a.fontSize = Re.noteFontSize, a.fontWeight = Re.noteFontWeight, a.anchor = Re.noteAlign, a.textMargin = Re.noteMargin, a.valign = "center";
  const s = un(a.text) ? await y2(n, a) : Gd(n, a), o = Math.round(
    s.map((l) => (l._groups || l)[0][0].getBBox().height).reduce((l, u) => l + u)
  );
  i.attr("height", o + 2 * Re.noteMargin), e.height += o + 2 * Re.noteMargin, et.bumpVerticalPos(o + 2 * Re.noteMargin), e.stopy = e.starty + o + 2 * Re.noteMargin, e.stopx = e.startx + r.width, et.insert(e.startx, e.starty, e.stopx, e.stopy), et.models.addNote(e);
}, "drawNote"), Fu = /* @__PURE__ */ x((t) => ({
  fontFamily: t.messageFontFamily,
  fontSize: t.messageFontSize,
  fontWeight: t.messageFontWeight
}), "messageFont"), Dh = /* @__PURE__ */ x((t) => ({
  fontFamily: t.noteFontFamily,
  fontSize: t.noteFontSize,
  fontWeight: t.noteFontWeight
}), "noteFont"), P6 = /* @__PURE__ */ x((t) => ({
  fontFamily: t.actorFontFamily,
  fontSize: t.actorFontSize,
  fontWeight: t.actorFontWeight
}), "actorFont");
async function WY(t, e) {
  et.bumpVerticalPos(10);
  const { startx: r, stopx: n, message: i } = e, a = at.splitBreaks(i).length, s = un(i), o = s ? await ag(i, we()) : Zt.calculateTextDimensions(i, Fu(Re));
  if (!s) {
    const d = o.height / a;
    e.height += d, et.bumpVerticalPos(d);
  }
  let l, u = o.height - 10;
  const h = o.width;
  if (r === n) {
    l = et.getVerticalPos() + u, Re.rightAngles || (u += Re.boxMargin, l = et.getVerticalPos() + u), u += 30;
    const d = at.getMax(h / 2, Re.width / 2);
    et.insert(
      r - d,
      et.getVerticalPos() - 10 + u,
      n + d,
      et.getVerticalPos() + 30 + u
    );
  } else
    u += Re.boxMargin, l = et.getVerticalPos() + u, et.insert(r, l - 10, n, l);
  return et.bumpVerticalPos(u), e.height += u, e.stopy = e.starty + e.height, et.insert(e.fromBounds, e.starty, e.toBounds, e.stopy), l;
}
x(WY, "boundMessage");
var MIe = /* @__PURE__ */ x(async function(t, e, r, n) {
  const { startx: i, stopx: a, starty: s, message: o, type: l, sequenceIndex: u, sequenceVisible: h } = e, d = Zt.calculateTextDimensions(o, Fu(Re)), f = xS();
  f.x = i, f.y = s + 10, f.width = a - i, f.class = "messageText", f.dy = "1em", f.text = o, f.fontFamily = Re.messageFontFamily, f.fontSize = Re.messageFontSize, f.fontWeight = Re.messageFontWeight, f.anchor = Re.messageAlign, f.valign = "center", f.textMargin = Re.wrapPadding, f.tspan = !1, un(f.text) ? await y2(t, f, { startx: i, stopx: a, starty: r }) : Gd(t, f);
  const p = d.width;
  let g;
  i === a ? Re.rightAngles ? g = t.append("path").attr(
    "d",
    `M  ${i},${r} H ${i + at.getMax(Re.width / 2, p / 2)} V ${r + 25} H ${i}`
  ) : g = t.append("path").attr(
    "d",
    "M " + i + "," + r + " C " + (i + 60) + "," + (r - 10) + " " + (i + 60) + "," + (r + 30) + " " + i + "," + (r + 20)
  ) : (g = t.append("line"), g.attr("x1", i), g.attr("y1", r), g.attr("x2", a), g.attr("y2", r)), l === n.db.LINETYPE.DOTTED || l === n.db.LINETYPE.DOTTED_CROSS || l === n.db.LINETYPE.DOTTED_POINT || l === n.db.LINETYPE.DOTTED_OPEN || l === n.db.LINETYPE.BIDIRECTIONAL_DOTTED ? (g.style("stroke-dasharray", "3, 3"), g.attr("class", "messageLine1")) : g.attr("class", "messageLine0");
  let m = "";
  Re.arrowMarkerAbsolute && (m = I2(!0)), g.attr("stroke-width", 2), g.attr("stroke", "none"), g.style("fill", "none"), (l === n.db.LINETYPE.SOLID || l === n.db.LINETYPE.DOTTED) && g.attr("marker-end", "url(" + m + "#arrowhead)"), (l === n.db.LINETYPE.BIDIRECTIONAL_SOLID || l === n.db.LINETYPE.BIDIRECTIONAL_DOTTED) && (g.attr("marker-start", "url(" + m + "#arrowhead)"), g.attr("marker-end", "url(" + m + "#arrowhead)")), (l === n.db.LINETYPE.SOLID_POINT || l === n.db.LINETYPE.DOTTED_POINT) && g.attr("marker-end", "url(" + m + "#filled-head)"), (l === n.db.LINETYPE.SOLID_CROSS || l === n.db.LINETYPE.DOTTED_CROSS) && g.attr("marker-end", "url(" + m + "#crosshead)"), (h || Re.showSequenceNumbers) && ((l === n.db.LINETYPE.BIDIRECTIONAL_SOLID || l === n.db.LINETYPE.BIDIRECTIONAL_DOTTED) && (i < a ? g.attr("x1", i + 12) : g.attr("x1", i + 6)), t.append("line").attr("x1", i).attr("y1", r).attr("x2", i).attr("y2", r).attr("stroke-width", 0).attr("marker-start", "url(" + m + "#sequencenumber)"), t.append("text").attr("x", i).attr("y", r + 4).attr("font-family", "sans-serif").attr("font-size", "12px").attr("text-anchor", "middle").attr("class", "sequenceNumber").text(u));
}, "drawMessage"), NIe = /* @__PURE__ */ x(function(t, e, r, n, i, a, s) {
  let o = 0, l = 0, u, h = 0;
  for (const d of n) {
    const f = e.get(d), p = f.box;
    u && u != p && (s || et.models.addBox(u), l += Re.boxMargin + u.margin), p && p != u && (s || (p.x = o + l, p.y = i), l += p.margin), f.width = f.width || Re.width, f.height = at.getMax(f.height || Re.height, Re.height), f.margin = f.margin || Re.actorMargin, h = at.getMax(h, f.height), r.get(f.name) && (l += f.width / 2), f.x = o + l, f.starty = et.getVerticalPos(), et.insert(f.x, i, f.x + f.width, f.height), o += f.width + l, f.box && (f.box.width = o + p.margin - f.box.x), l = f.margin, u = f.box, et.models.addActor(f);
  }
  u && !s && et.models.addBox(u), et.bumpVerticalPos(h);
}, "addActorRenderingData"), B6 = /* @__PURE__ */ x(async function(t, e, r, n) {
  if (n) {
    let i = 0;
    et.bumpVerticalPos(Re.boxMargin * 2);
    for (const a of r) {
      const s = e.get(a);
      s.stopy || (s.stopy = et.getVerticalPos());
      const o = await fn.drawActor(t, s, Re, !0);
      i = at.getMax(i, o);
    }
    et.bumpVerticalPos(i + Re.boxMargin);
  } else
    for (const i of r) {
      const a = e.get(i);
      await fn.drawActor(t, a, Re, !1);
    }
}, "drawActors"), YY = /* @__PURE__ */ x(function(t, e, r, n) {
  let i = 0, a = 0;
  for (const s of r) {
    const o = e.get(s), l = DIe(o), u = fn.drawPopup(
      t,
      o,
      l,
      Re,
      Re.forceMenus,
      n
    );
    u.height > i && (i = u.height), u.width + o.x > a && (a = u.width + o.x);
  }
  return { maxHeight: i, maxWidth: a };
}, "drawActorsPopup"), XY = /* @__PURE__ */ x(function(t) {
  mn(Re, t), t.fontFamily && (Re.actorFontFamily = Re.noteFontFamily = Re.messageFontFamily = t.fontFamily), t.fontSize && (Re.actorFontSize = Re.noteFontSize = Re.messageFontSize = t.fontSize), t.fontWeight && (Re.actorFontWeight = Re.noteFontWeight = Re.messageFontWeight = t.fontWeight);
}, "setConf"), Tb = /* @__PURE__ */ x(function(t) {
  return et.activations.filter(function(e) {
    return e.actor === t;
  });
}, "actorActivations"), _N = /* @__PURE__ */ x(function(t, e) {
  const r = e.get(t), n = Tb(t), i = n.reduce(
    function(s, o) {
      return at.getMin(s, o.startx);
    },
    r.x + r.width / 2 - 1
  ), a = n.reduce(
    function(s, o) {
      return at.getMax(s, o.stopx);
    },
    r.x + r.width / 2 + 1
  );
  return [i, a];
}, "activationBounds");
function os(t, e, r, n, i) {
  et.bumpVerticalPos(r);
  let a = n;
  if (e.id && e.message && t[e.id]) {
    const s = t[e.id].width, o = Fu(Re);
    e.message = Zt.wrapLabel(`[${e.message}]`, s - 2 * Re.wrapPadding, o), e.width = s, e.wrap = !0;
    const l = Zt.calculateTextDimensions(e.message, o), u = at.getMax(l.height, Re.labelBoxHeight);
    a = n + u, ie.debug(`${u} - ${e.message}`);
  }
  i(e), et.bumpVerticalPos(a);
}
x(os, "adjustLoopHeightForWrap");
function jY(t, e, r, n, i, a, s) {
  function o(h, d) {
    h.x < i.get(t.from).x ? (et.insert(
      e.stopx - d,
      e.starty,
      e.startx,
      e.stopy + h.height / 2 + Re.noteMargin
    ), e.stopx = e.stopx + d) : (et.insert(
      e.startx,
      e.starty,
      e.stopx + d,
      e.stopy + h.height / 2 + Re.noteMargin
    ), e.stopx = e.stopx - d);
  }
  x(o, "receiverAdjustment");
  function l(h, d) {
    h.x < i.get(t.to).x ? (et.insert(
      e.startx - d,
      e.starty,
      e.stopx,
      e.stopy + h.height / 2 + Re.noteMargin
    ), e.startx = e.startx + d) : (et.insert(
      e.stopx,
      e.starty,
      e.startx + d,
      e.stopy + h.height / 2 + Re.noteMargin
    ), e.startx = e.startx - d);
  }
  x(l, "senderAdjustment");
  const u = [
    cm.ACTOR,
    cm.CONTROL,
    cm.ENTITY,
    cm.DATABASE
  ];
  if (a.get(t.to) == n) {
    const h = i.get(t.to), d = u.includes(h.type) ? cu / 2 + 3 : h.width / 2 + 3;
    o(h, d), h.starty = r - h.height / 2, et.bumpVerticalPos(h.height / 2);
  } else if (s.get(t.from) == n) {
    const h = i.get(t.from);
    if (Re.mirrorActors) {
      const d = u.includes(h.type) ? cu / 2 : h.width / 2;
      l(h, d);
    }
    h.stopy = r - h.height / 2, et.bumpVerticalPos(h.height / 2);
  } else if (s.get(t.to) == n) {
    const h = i.get(t.to);
    if (Re.mirrorActors) {
      const d = u.includes(h.type) ? cu / 2 + 3 : h.width / 2 + 3;
      o(h, d);
    }
    h.stopy = r - h.height / 2, et.bumpVerticalPos(h.height / 2);
  }
}
x(jY, "adjustCreatedDestroyedData");
var IIe = /* @__PURE__ */ x(async function(t, e, r, n) {
  const { securityLevel: i, sequence: a } = we();
  Re = a;
  let s;
  i === "sandbox" && (s = Qe("#i" + e));
  const o = Qe(i === "sandbox" ? s.nodes()[0].contentDocument.body : "body"), l = i === "sandbox" ? s.nodes()[0].contentDocument : document;
  et.init(), ie.debug(n.db);
  const u = i === "sandbox" ? o.select(`[id="${e}"]`) : Qe(`[id="${e}"]`), h = n.db.getActors(), d = n.db.getCreatedActors(), f = n.db.getDestroyedActors(), p = n.db.getBoxes();
  let g = n.db.getActorKeys();
  const m = n.db.getMessages(), v = n.db.getDiagramTitle(), y = n.db.hasAtLeastOneBox(), b = n.db.hasAtLeastOneBoxWithTitle(), w = await KY(h, m, n);
  if (Re.height = await ZY(h, w, p), fn.insertComputerIcon(u), fn.insertDatabaseIcon(u), fn.insertClockIcon(u), y && (et.bumpVerticalPos(Re.boxMargin), b && et.bumpVerticalPos(p[0].textMaxHeight)), Re.hideUnusedParticipants === !0) {
    const I = /* @__PURE__ */ new Set();
    m.forEach((B) => {
      I.add(B.from), I.add(B.to);
    }), g = g.filter((B) => I.has(B));
  }
  NIe(u, h, d, g, 0, m, !1);
  const T = await BIe(m, h, w, n);
  fn.insertArrowHead(u), fn.insertArrowCrossHead(u), fn.insertArrowFilledHead(u), fn.insertSequenceNumber(u);
  function E(I, B) {
    const z = et.endActivation(I);
    z.starty + 18 > B && (z.starty = B - 6, B += 12), fn.drawActivation(
      u,
      z,
      B,
      Re,
      Tb(I.from).length
    ), et.insert(z.startx, B - 10, z.stopx, B);
  }
  x(E, "activeEnd");
  let L = 1, k = 1;
  const C = [], A = [];
  let R = 0;
  for (const I of m) {
    let B, z, F;
    switch (I.type) {
      case n.db.LINETYPE.NOTE:
        et.resetVerticalPos(), z = I.noteModel, await RIe(u, z);
        break;
      case n.db.LINETYPE.ACTIVE_START:
        et.newActivation(I, u, h);
        break;
      case n.db.LINETYPE.ACTIVE_END:
        E(I, et.getVerticalPos());
        break;
      case n.db.LINETYPE.LOOP_START:
        os(
          T,
          I,
          Re.boxMargin,
          Re.boxMargin + Re.boxTextMargin,
          (V) => et.newLoop(V)
        );
        break;
      case n.db.LINETYPE.LOOP_END:
        B = et.endLoop(), await fn.drawLoop(u, B, "loop", Re), et.bumpVerticalPos(B.stopy - et.getVerticalPos()), et.models.addLoop(B);
        break;
      case n.db.LINETYPE.RECT_START:
        os(
          T,
          I,
          Re.boxMargin,
          Re.boxMargin,
          (V) => et.newLoop(void 0, V.message)
        );
        break;
      case n.db.LINETYPE.RECT_END:
        B = et.endLoop(), A.push(B), et.models.addLoop(B), et.bumpVerticalPos(B.stopy - et.getVerticalPos());
        break;
      case n.db.LINETYPE.OPT_START:
        os(
          T,
          I,
          Re.boxMargin,
          Re.boxMargin + Re.boxTextMargin,
          (V) => et.newLoop(V)
        );
        break;
      case n.db.LINETYPE.OPT_END:
        B = et.endLoop(), await fn.drawLoop(u, B, "opt", Re), et.bumpVerticalPos(B.stopy - et.getVerticalPos()), et.models.addLoop(B);
        break;
      case n.db.LINETYPE.ALT_START:
        os(
          T,
          I,
          Re.boxMargin,
          Re.boxMargin + Re.boxTextMargin,
          (V) => et.newLoop(V)
        );
        break;
      case n.db.LINETYPE.ALT_ELSE:
        os(
          T,
          I,
          Re.boxMargin + Re.boxTextMargin,
          Re.boxMargin,
          (V) => et.addSectionToLoop(V)
        );
        break;
      case n.db.LINETYPE.ALT_END:
        B = et.endLoop(), await fn.drawLoop(u, B, "alt", Re), et.bumpVerticalPos(B.stopy - et.getVerticalPos()), et.models.addLoop(B);
        break;
      case n.db.LINETYPE.PAR_START:
      case n.db.LINETYPE.PAR_OVER_START:
        os(
          T,
          I,
          Re.boxMargin,
          Re.boxMargin + Re.boxTextMargin,
          (V) => et.newLoop(V)
        ), et.saveVerticalPos();
        break;
      case n.db.LINETYPE.PAR_AND:
        os(
          T,
          I,
          Re.boxMargin + Re.boxTextMargin,
          Re.boxMargin,
          (V) => et.addSectionToLoop(V)
        );
        break;
      case n.db.LINETYPE.PAR_END:
        B = et.endLoop(), await fn.drawLoop(u, B, "par", Re), et.bumpVerticalPos(B.stopy - et.getVerticalPos()), et.models.addLoop(B);
        break;
      case n.db.LINETYPE.AUTONUMBER:
        L = I.message.start || L, k = I.message.step || k, I.message.visible ? n.db.enableSequenceNumbers() : n.db.disableSequenceNumbers();
        break;
      case n.db.LINETYPE.CRITICAL_START:
        os(
          T,
          I,
          Re.boxMargin,
          Re.boxMargin + Re.boxTextMargin,
          (V) => et.newLoop(V)
        );
        break;
      case n.db.LINETYPE.CRITICAL_OPTION:
        os(
          T,
          I,
          Re.boxMargin + Re.boxTextMargin,
          Re.boxMargin,
          (V) => et.addSectionToLoop(V)
        );
        break;
      case n.db.LINETYPE.CRITICAL_END:
        B = et.endLoop(), await fn.drawLoop(u, B, "critical", Re), et.bumpVerticalPos(B.stopy - et.getVerticalPos()), et.models.addLoop(B);
        break;
      case n.db.LINETYPE.BREAK_START:
        os(
          T,
          I,
          Re.boxMargin,
          Re.boxMargin + Re.boxTextMargin,
          (V) => et.newLoop(V)
        );
        break;
      case n.db.LINETYPE.BREAK_END:
        B = et.endLoop(), await fn.drawLoop(u, B, "break", Re), et.bumpVerticalPos(B.stopy - et.getVerticalPos()), et.models.addLoop(B);
        break;
      default:
        try {
          F = I.msgModel, F.starty = et.getVerticalPos(), F.sequenceIndex = L, F.sequenceVisible = n.db.showSequenceNumbers();
          const V = await WY(u, F);
          jY(
            I,
            F,
            V,
            R,
            h,
            d,
            f
          ), C.push({ messageModel: F, lineStartY: V }), et.models.addMessage(F);
        } catch (V) {
          ie.error("error while drawing message", V);
        }
    }
    [
      n.db.LINETYPE.SOLID_OPEN,
      n.db.LINETYPE.DOTTED_OPEN,
      n.db.LINETYPE.SOLID,
      n.db.LINETYPE.DOTTED,
      n.db.LINETYPE.SOLID_CROSS,
      n.db.LINETYPE.DOTTED_CROSS,
      n.db.LINETYPE.SOLID_POINT,
      n.db.LINETYPE.DOTTED_POINT,
      n.db.LINETYPE.BIDIRECTIONAL_SOLID,
      n.db.LINETYPE.BIDIRECTIONAL_DOTTED
    ].includes(I.type) && (L = L + k), R++;
  }
  ie.debug("createdActors", d), ie.debug("destroyedActors", f), await B6(u, h, g, !1);
  for (const I of C)
    await MIe(u, I.messageModel, I.lineStartY, n);
  Re.mirrorActors && await B6(u, h, g, !0), A.forEach((I) => fn.drawBackgroundRect(u, I)), UY(u, h, g, Re);
  for (const I of et.models.boxes) {
    I.height = et.getVerticalPos() - I.y, et.insert(I.x, I.y, I.x + I.width, I.height);
    const B = Re.boxMargin * 2;
    I.startx = I.x - B, I.starty = I.y - B * 0.25, I.stopx = I.startx + I.width + 2 * B, I.stopy = I.starty + I.height + B * 0.75, I.stroke = "rgb(0,0,0, 0.5)", fn.drawBox(u, I, Re);
  }
  y && et.bumpVerticalPos(Re.boxMargin);
  const _ = YY(u, h, g, l), { bounds: O } = et.getBounds();
  O.startx === void 0 && (O.startx = 0), O.starty === void 0 && (O.starty = 0), O.stopx === void 0 && (O.stopx = 0), O.stopy === void 0 && (O.stopy = 0);
  let P = O.stopy - O.starty;
  P < _.maxHeight && (P = _.maxHeight);
  let S = P + 2 * Re.diagramMarginY;
  Re.mirrorActors && (S = S - Re.boxMargin + Re.bottomMarginAdj);
  let M = O.stopx - O.startx;
  M < _.maxWidth && (M = _.maxWidth);
  const N = M + 2 * Re.diagramMarginX;
  v && u.append("text").text(v).attr("x", (O.stopx - O.startx) / 2 - 2 * Re.diagramMarginX).attr("y", -25), Xi(u, S, N, Re.useMaxWidth);
  const D = v ? 40 : 0;
  u.attr(
    "viewBox",
    O.startx - Re.diagramMarginX + " -" + (Re.diagramMarginY + D) + " " + N + " " + (S + D)
  ), ie.debug("models:", et.models);
}, "draw");
async function KY(t, e, r) {
  const n = {};
  for (const i of e)
    if (t.get(i.to) && t.get(i.from)) {
      const a = t.get(i.to);
      if (i.placement === r.db.PLACEMENT.LEFTOF && !a.prevActor || i.placement === r.db.PLACEMENT.RIGHTOF && !a.nextActor)
        continue;
      const s = i.placement !== void 0, o = !s, l = s ? Dh(Re) : Fu(Re), u = i.wrap ? Zt.wrapLabel(i.message, Re.width - 2 * Re.wrapPadding, l) : i.message, d = (un(u) ? await ag(i.message, we()) : Zt.calculateTextDimensions(u, l)).width + 2 * Re.wrapPadding;
      o && i.from === a.nextActor ? n[i.to] = at.getMax(
        n[i.to] || 0,
        d
      ) : o && i.from === a.prevActor ? n[i.from] = at.getMax(
        n[i.from] || 0,
        d
      ) : o && i.from === i.to ? (n[i.from] = at.getMax(
        n[i.from] || 0,
        d / 2
      ), n[i.to] = at.getMax(
        n[i.to] || 0,
        d / 2
      )) : i.placement === r.db.PLACEMENT.RIGHTOF ? n[i.from] = at.getMax(
        n[i.from] || 0,
        d
      ) : i.placement === r.db.PLACEMENT.LEFTOF ? n[a.prevActor] = at.getMax(
        n[a.prevActor] || 0,
        d
      ) : i.placement === r.db.PLACEMENT.OVER && (a.prevActor && (n[a.prevActor] = at.getMax(
        n[a.prevActor] || 0,
        d / 2
      )), a.nextActor && (n[i.from] = at.getMax(
        n[i.from] || 0,
        d / 2
      )));
    }
  return ie.debug("maxMessageWidthPerActor:", n), n;
}
x(KY, "getMaxMessageWidthPerActor");
var DIe = /* @__PURE__ */ x(function(t) {
  let e = 0;
  const r = P6(Re);
  for (const n in t.links) {
    const a = Zt.calculateTextDimensions(n, r).width + 2 * Re.wrapPadding + 2 * Re.boxMargin;
    e < a && (e = a);
  }
  return e;
}, "getRequiredPopupWidth");
async function ZY(t, e, r) {
  let n = 0;
  for (const a of t.keys()) {
    const s = t.get(a);
    s.wrap && (s.description = Zt.wrapLabel(
      s.description,
      Re.width - 2 * Re.wrapPadding,
      P6(Re)
    ));
    const o = un(s.description) ? await ag(s.description, we()) : Zt.calculateTextDimensions(s.description, P6(Re));
    s.width = s.wrap ? Re.width : at.getMax(Re.width, o.width + 2 * Re.wrapPadding), s.height = s.wrap ? at.getMax(o.height, Re.height) : Re.height, n = at.getMax(n, s.height);
  }
  for (const a in e) {
    const s = t.get(a);
    if (!s)
      continue;
    const o = t.get(s.nextActor);
    if (!o) {
      const d = e[a] + Re.actorMargin - s.width / 2;
      s.margin = at.getMax(d, Re.actorMargin);
      continue;
    }
    const u = e[a] + Re.actorMargin - s.width / 2 - o.width / 2;
    s.margin = at.getMax(u, Re.actorMargin);
  }
  let i = 0;
  return r.forEach((a) => {
    const s = Fu(Re);
    let o = a.actorKeys.reduce((d, f) => d += t.get(f).width + (t.get(f).margin || 0), 0);
    const l = Re.boxMargin * 8;
    o += l, o -= 2 * Re.boxTextMargin, a.wrap && (a.name = Zt.wrapLabel(a.name, o - 2 * Re.wrapPadding, s));
    const u = Zt.calculateTextDimensions(a.name, s);
    i = at.getMax(u.height, i);
    const h = at.getMax(o, u.width + 2 * Re.wrapPadding);
    if (a.margin = Re.boxTextMargin, o < h) {
      const d = (h - o) / 2;
      a.margin += d;
    }
  }), r.forEach((a) => a.textMaxHeight = i), at.getMax(n, Re.height);
}
x(ZY, "calculateActorMargins");
var OIe = /* @__PURE__ */ x(async function(t, e, r) {
  const n = e.get(t.from), i = e.get(t.to), a = n.x, s = i.x, o = t.wrap && t.message;
  let l = un(t.message) ? await ag(t.message, we()) : Zt.calculateTextDimensions(
    o ? Zt.wrapLabel(t.message, Re.width, Dh(Re)) : t.message,
    Dh(Re)
  );
  const u = {
    width: o ? Re.width : at.getMax(Re.width, l.width + 2 * Re.noteMargin),
    height: 0,
    startx: n.x,
    stopx: 0,
    starty: 0,
    stopy: 0,
    message: t.message
  };
  return t.placement === r.db.PLACEMENT.RIGHTOF ? (u.width = o ? at.getMax(Re.width, l.width) : at.getMax(
    n.width / 2 + i.width / 2,
    l.width + 2 * Re.noteMargin
  ), u.startx = a + (n.width + Re.actorMargin) / 2) : t.placement === r.db.PLACEMENT.LEFTOF ? (u.width = o ? at.getMax(Re.width, l.width + 2 * Re.noteMargin) : at.getMax(
    n.width / 2 + i.width / 2,
    l.width + 2 * Re.noteMargin
  ), u.startx = a - u.width + (n.width - Re.actorMargin) / 2) : t.to === t.from ? (l = Zt.calculateTextDimensions(
    o ? Zt.wrapLabel(t.message, at.getMax(Re.width, n.width), Dh(Re)) : t.message,
    Dh(Re)
  ), u.width = o ? at.getMax(Re.width, n.width) : at.getMax(n.width, Re.width, l.width + 2 * Re.noteMargin), u.startx = a + (n.width - u.width) / 2) : (u.width = Math.abs(a + n.width / 2 - (s + i.width / 2)) + Re.actorMargin, u.startx = a < s ? a + n.width / 2 - Re.actorMargin / 2 : s + i.width / 2 - Re.actorMargin / 2), o && (u.message = Zt.wrapLabel(
    t.message,
    u.width - 2 * Re.wrapPadding,
    Dh(Re)
  )), ie.debug(
    `NM:[${u.startx},${u.stopx},${u.starty},${u.stopy}:${u.width},${u.height}=${t.message}]`
  ), u;
}, "buildNoteModel"), PIe = /* @__PURE__ */ x(function(t, e, r) {
  if (![
    r.db.LINETYPE.SOLID_OPEN,
    r.db.LINETYPE.DOTTED_OPEN,
    r.db.LINETYPE.SOLID,
    r.db.LINETYPE.DOTTED,
    r.db.LINETYPE.SOLID_CROSS,
    r.db.LINETYPE.DOTTED_CROSS,
    r.db.LINETYPE.SOLID_POINT,
    r.db.LINETYPE.DOTTED_POINT,
    r.db.LINETYPE.BIDIRECTIONAL_SOLID,
    r.db.LINETYPE.BIDIRECTIONAL_DOTTED
  ].includes(t.type))
    return {};
  const [n, i] = _N(t.from, e), [a, s] = _N(t.to, e), o = n <= a;
  let l = o ? i : n, u = o ? a : s;
  const h = Math.abs(a - s) > 2, d = /* @__PURE__ */ x((m) => o ? -m : m, "adjustValue");
  t.from === t.to ? u = l : (t.activate && !h && (u += d(Re.activationWidth / 2 - 1)), [r.db.LINETYPE.SOLID_OPEN, r.db.LINETYPE.DOTTED_OPEN].includes(t.type) || (u += d(3)), [r.db.LINETYPE.BIDIRECTIONAL_SOLID, r.db.LINETYPE.BIDIRECTIONAL_DOTTED].includes(
    t.type
  ) && (l -= d(3)));
  const f = [n, i, a, s], p = Math.abs(l - u);
  t.wrap && t.message && (t.message = Zt.wrapLabel(
    t.message,
    at.getMax(p + 2 * Re.wrapPadding, Re.width),
    Fu(Re)
  ));
  const g = Zt.calculateTextDimensions(t.message, Fu(Re));
  return {
    width: at.getMax(
      t.wrap ? 0 : g.width + 2 * Re.wrapPadding,
      p + 2 * Re.wrapPadding,
      Re.width
    ),
    height: 0,
    startx: l,
    stopx: u,
    starty: 0,
    stopy: 0,
    message: t.message,
    type: t.type,
    wrap: t.wrap,
    fromBounds: Math.min.apply(null, f),
    toBounds: Math.max.apply(null, f)
  };
}, "buildMessageModel"), BIe = /* @__PURE__ */ x(async function(t, e, r, n) {
  const i = {}, a = [];
  let s, o, l;
  for (const u of t) {
    switch (u.type) {
      case n.db.LINETYPE.LOOP_START:
      case n.db.LINETYPE.ALT_START:
      case n.db.LINETYPE.OPT_START:
      case n.db.LINETYPE.PAR_START:
      case n.db.LINETYPE.PAR_OVER_START:
      case n.db.LINETYPE.CRITICAL_START:
      case n.db.LINETYPE.BREAK_START:
        a.push({
          id: u.id,
          msg: u.message,
          from: Number.MAX_SAFE_INTEGER,
          to: Number.MIN_SAFE_INTEGER,
          width: 0
        });
        break;
      case n.db.LINETYPE.ALT_ELSE:
      case n.db.LINETYPE.PAR_AND:
      case n.db.LINETYPE.CRITICAL_OPTION:
        u.message && (s = a.pop(), i[s.id] = s, i[u.id] = s, a.push(s));
        break;
      case n.db.LINETYPE.LOOP_END:
      case n.db.LINETYPE.ALT_END:
      case n.db.LINETYPE.OPT_END:
      case n.db.LINETYPE.PAR_END:
      case n.db.LINETYPE.CRITICAL_END:
      case n.db.LINETYPE.BREAK_END:
        s = a.pop(), i[s.id] = s;
        break;
      case n.db.LINETYPE.ACTIVE_START:
        {
          const d = e.get(u.from ? u.from : u.to.actor), f = Tb(u.from ? u.from : u.to.actor).length, p = d.x + d.width / 2 + (f - 1) * Re.activationWidth / 2, g = {
            startx: p,
            stopx: p + Re.activationWidth,
            actor: u.from,
            enabled: !0
          };
          et.activations.push(g);
        }
        break;
      case n.db.LINETYPE.ACTIVE_END:
        {
          const d = et.activations.map((f) => f.actor).lastIndexOf(u.from);
          et.activations.splice(d, 1).splice(0, 1);
        }
        break;
    }
    u.placement !== void 0 ? (o = await OIe(u, e, n), u.noteModel = o, a.forEach((d) => {
      s = d, s.from = at.getMin(s.from, o.startx), s.to = at.getMax(s.to, o.startx + o.width), s.width = at.getMax(s.width, Math.abs(s.from - s.to)) - Re.labelBoxWidth;
    })) : (l = PIe(u, e, n), u.msgModel = l, l.startx && l.stopx && a.length > 0 && a.forEach((d) => {
      if (s = d, l.startx === l.stopx) {
        const f = e.get(u.from), p = e.get(u.to);
        s.from = at.getMin(
          f.x - l.width / 2,
          f.x - f.width / 2,
          s.from
        ), s.to = at.getMax(
          p.x + l.width / 2,
          p.x + f.width / 2,
          s.to
        ), s.width = at.getMax(s.width, Math.abs(s.to - s.from)) - Re.labelBoxWidth;
      } else
        s.from = at.getMin(l.startx, s.from), s.to = at.getMax(l.stopx, s.to), s.width = at.getMax(s.width, l.width) - Re.labelBoxWidth;
    }));
  }
  return et.activations = [], ie.debug("Loop type widths:", i), i;
}, "calculateLoopBounds"), FIe = {
  bounds: et,
  drawActors: B6,
  drawActorsPopup: YY,
  setConf: XY,
  draw: IIe
}, $Ie = {
  parser: eIe,
  get db() {
    return new iIe();
  },
  renderer: FIe,
  styles: sIe,
  init: /* @__PURE__ */ x((t) => {
    t.sequence || (t.sequence = {}), t.wrap && (t.sequence.wrap = t.wrap, rw({ sequence: { wrap: t.wrap } }));
  }, "init")
};
const zIe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: $Ie
}, Symbol.toStringTag, { value: "Module" }));
var F6 = (function() {
  var t = /* @__PURE__ */ x(function(Oe, Se, _e, $e) {
    for (_e = _e || {}, $e = Oe.length; $e--; _e[Oe[$e]] = Se) ;
    return _e;
  }, "o"), e = [1, 18], r = [1, 19], n = [1, 20], i = [1, 41], a = [1, 42], s = [1, 26], o = [1, 24], l = [1, 25], u = [1, 32], h = [1, 33], d = [1, 34], f = [1, 45], p = [1, 35], g = [1, 36], m = [1, 37], v = [1, 38], y = [1, 27], b = [1, 28], w = [1, 29], T = [1, 30], E = [1, 31], L = [1, 44], k = [1, 46], C = [1, 43], A = [1, 47], R = [1, 9], _ = [1, 8, 9], O = [1, 58], P = [1, 59], S = [1, 60], M = [1, 61], N = [1, 62], D = [1, 63], I = [1, 64], B = [1, 8, 9, 41], z = [1, 76], F = [1, 8, 9, 12, 13, 22, 39, 41, 44, 68, 69, 70, 71, 72, 73, 74, 79, 81], V = [1, 8, 9, 12, 13, 18, 20, 22, 39, 41, 44, 50, 60, 68, 69, 70, 71, 72, 73, 74, 79, 81, 86, 100, 102, 103], H = [13, 60, 86, 100, 102, 103], J = [13, 60, 73, 74, 86, 100, 102, 103], q = [13, 60, 68, 69, 70, 71, 72, 86, 100, 102, 103], ae = [1, 100], re = [1, 117], pe = [1, 113], K = [1, 109], Z = [1, 115], X = [1, 110], Y = [1, 111], ee = [1, 112], j = [1, 114], fe = [1, 116], te = [22, 48, 60, 61, 82, 86, 87, 88, 89, 90], Ae = [1, 8, 9, 39, 41, 44], W = [1, 8, 9, 22], De = [1, 145], ue = [1, 8, 9, 61], ze = [1, 8, 9, 22, 48, 60, 61, 82, 86, 87, 88, 89, 90], Ge = {
    trace: /* @__PURE__ */ x(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, mermaidDoc: 4, statements: 5, graphConfig: 6, CLASS_DIAGRAM: 7, NEWLINE: 8, EOF: 9, statement: 10, classLabel: 11, SQS: 12, STR: 13, SQE: 14, namespaceName: 15, alphaNumToken: 16, classLiteralName: 17, DOT: 18, className: 19, GENERICTYPE: 20, relationStatement: 21, LABEL: 22, namespaceStatement: 23, classStatement: 24, memberStatement: 25, annotationStatement: 26, clickStatement: 27, styleStatement: 28, cssClassStatement: 29, noteStatement: 30, classDefStatement: 31, direction: 32, acc_title: 33, acc_title_value: 34, acc_descr: 35, acc_descr_value: 36, acc_descr_multiline_value: 37, namespaceIdentifier: 38, STRUCT_START: 39, classStatements: 40, STRUCT_STOP: 41, NAMESPACE: 42, classIdentifier: 43, STYLE_SEPARATOR: 44, members: 45, CLASS: 46, emptyBody: 47, SPACE: 48, ANNOTATION_START: 49, ANNOTATION_END: 50, MEMBER: 51, SEPARATOR: 52, relation: 53, NOTE_FOR: 54, noteText: 55, NOTE: 56, CLASSDEF: 57, classList: 58, stylesOpt: 59, ALPHA: 60, COMMA: 61, direction_tb: 62, direction_bt: 63, direction_rl: 64, direction_lr: 65, relationType: 66, lineType: 67, AGGREGATION: 68, EXTENSION: 69, COMPOSITION: 70, DEPENDENCY: 71, LOLLIPOP: 72, LINE: 73, DOTTED_LINE: 74, CALLBACK: 75, LINK: 76, LINK_TARGET: 77, CLICK: 78, CALLBACK_NAME: 79, CALLBACK_ARGS: 80, HREF: 81, STYLE: 82, CSSCLASS: 83, style: 84, styleComponent: 85, NUM: 86, COLON: 87, UNIT: 88, BRKT: 89, PCT: 90, commentToken: 91, textToken: 92, graphCodeTokens: 93, textNoTagsToken: 94, TAGSTART: 95, TAGEND: 96, "==": 97, "--": 98, DEFAULT: 99, MINUS: 100, keywords: 101, UNICODE_TEXT: 102, BQUOTE_STR: 103, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 7: "CLASS_DIAGRAM", 8: "NEWLINE", 9: "EOF", 12: "SQS", 13: "STR", 14: "SQE", 18: "DOT", 20: "GENERICTYPE", 22: "LABEL", 33: "acc_title", 34: "acc_title_value", 35: "acc_descr", 36: "acc_descr_value", 37: "acc_descr_multiline_value", 39: "STRUCT_START", 41: "STRUCT_STOP", 42: "NAMESPACE", 44: "STYLE_SEPARATOR", 46: "CLASS", 48: "SPACE", 49: "ANNOTATION_START", 50: "ANNOTATION_END", 51: "MEMBER", 52: "SEPARATOR", 54: "NOTE_FOR", 56: "NOTE", 57: "CLASSDEF", 60: "ALPHA", 61: "COMMA", 62: "direction_tb", 63: "direction_bt", 64: "direction_rl", 65: "direction_lr", 68: "AGGREGATION", 69: "EXTENSION", 70: "COMPOSITION", 71: "DEPENDENCY", 72: "LOLLIPOP", 73: "LINE", 74: "DOTTED_LINE", 75: "CALLBACK", 76: "LINK", 77: "LINK_TARGET", 78: "CLICK", 79: "CALLBACK_NAME", 80: "CALLBACK_ARGS", 81: "HREF", 82: "STYLE", 83: "CSSCLASS", 86: "NUM", 87: "COLON", 88: "UNIT", 89: "BRKT", 90: "PCT", 93: "graphCodeTokens", 95: "TAGSTART", 96: "TAGEND", 97: "==", 98: "--", 99: "DEFAULT", 100: "MINUS", 101: "keywords", 102: "UNICODE_TEXT", 103: "BQUOTE_STR" },
    productions_: [0, [3, 1], [3, 1], [4, 1], [6, 4], [5, 1], [5, 2], [5, 3], [11, 3], [15, 1], [15, 1], [15, 3], [15, 2], [19, 1], [19, 3], [19, 1], [19, 2], [19, 2], [19, 2], [10, 1], [10, 2], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [23, 4], [23, 5], [38, 2], [40, 1], [40, 2], [40, 3], [24, 1], [24, 3], [24, 4], [24, 3], [24, 6], [43, 2], [43, 3], [47, 0], [47, 2], [47, 2], [26, 4], [45, 1], [45, 2], [25, 1], [25, 2], [25, 1], [25, 1], [21, 3], [21, 4], [21, 4], [21, 5], [30, 3], [30, 2], [31, 3], [58, 1], [58, 3], [32, 1], [32, 1], [32, 1], [32, 1], [53, 3], [53, 2], [53, 2], [53, 1], [66, 1], [66, 1], [66, 1], [66, 1], [66, 1], [67, 1], [67, 1], [27, 3], [27, 4], [27, 3], [27, 4], [27, 4], [27, 5], [27, 3], [27, 4], [27, 4], [27, 5], [27, 4], [27, 5], [27, 5], [27, 6], [28, 3], [29, 3], [59, 1], [59, 3], [84, 1], [84, 2], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [91, 1], [91, 1], [92, 1], [92, 1], [92, 1], [92, 1], [92, 1], [92, 1], [92, 1], [94, 1], [94, 1], [94, 1], [94, 1], [16, 1], [16, 1], [16, 1], [16, 1], [17, 1], [55, 1]],
    performAction: /* @__PURE__ */ x(function(Se, _e, $e, me, Ne, Q, ce) {
      var $ = Q.length - 1;
      switch (Ne) {
        case 8:
          this.$ = Q[$ - 1];
          break;
        case 9:
        case 10:
        case 13:
        case 15:
          this.$ = Q[$];
          break;
        case 11:
        case 14:
          this.$ = Q[$ - 2] + "." + Q[$];
          break;
        case 12:
        case 16:
          this.$ = Q[$ - 1] + Q[$];
          break;
        case 17:
        case 18:
          this.$ = Q[$ - 1] + "~" + Q[$] + "~";
          break;
        case 19:
          me.addRelation(Q[$]);
          break;
        case 20:
          Q[$ - 1].title = me.cleanupLabel(Q[$]), me.addRelation(Q[$ - 1]);
          break;
        case 31:
          this.$ = Q[$].trim(), me.setAccTitle(this.$);
          break;
        case 32:
        case 33:
          this.$ = Q[$].trim(), me.setAccDescription(this.$);
          break;
        case 34:
          me.addClassesToNamespace(Q[$ - 3], Q[$ - 1]);
          break;
        case 35:
          me.addClassesToNamespace(Q[$ - 4], Q[$ - 1]);
          break;
        case 36:
          this.$ = Q[$], me.addNamespace(Q[$]);
          break;
        case 37:
          this.$ = [Q[$]];
          break;
        case 38:
          this.$ = [Q[$ - 1]];
          break;
        case 39:
          Q[$].unshift(Q[$ - 2]), this.$ = Q[$];
          break;
        case 41:
          me.setCssClass(Q[$ - 2], Q[$]);
          break;
        case 42:
          me.addMembers(Q[$ - 3], Q[$ - 1]);
          break;
        case 44:
          me.setCssClass(Q[$ - 5], Q[$ - 3]), me.addMembers(Q[$ - 5], Q[$ - 1]);
          break;
        case 45:
          this.$ = Q[$], me.addClass(Q[$]);
          break;
        case 46:
          this.$ = Q[$ - 1], me.addClass(Q[$ - 1]), me.setClassLabel(Q[$ - 1], Q[$]);
          break;
        case 50:
          me.addAnnotation(Q[$], Q[$ - 2]);
          break;
        case 51:
        case 64:
          this.$ = [Q[$]];
          break;
        case 52:
          Q[$].push(Q[$ - 1]), this.$ = Q[$];
          break;
        case 53:
          break;
        case 54:
          me.addMember(Q[$ - 1], me.cleanupLabel(Q[$]));
          break;
        case 55:
          break;
        case 56:
          break;
        case 57:
          this.$ = { id1: Q[$ - 2], id2: Q[$], relation: Q[$ - 1], relationTitle1: "none", relationTitle2: "none" };
          break;
        case 58:
          this.$ = { id1: Q[$ - 3], id2: Q[$], relation: Q[$ - 1], relationTitle1: Q[$ - 2], relationTitle2: "none" };
          break;
        case 59:
          this.$ = { id1: Q[$ - 3], id2: Q[$], relation: Q[$ - 2], relationTitle1: "none", relationTitle2: Q[$ - 1] };
          break;
        case 60:
          this.$ = { id1: Q[$ - 4], id2: Q[$], relation: Q[$ - 2], relationTitle1: Q[$ - 3], relationTitle2: Q[$ - 1] };
          break;
        case 61:
          me.addNote(Q[$], Q[$ - 1]);
          break;
        case 62:
          me.addNote(Q[$]);
          break;
        case 63:
          this.$ = Q[$ - 2], me.defineClass(Q[$ - 1], Q[$]);
          break;
        case 65:
          this.$ = Q[$ - 2].concat([Q[$]]);
          break;
        case 66:
          me.setDirection("TB");
          break;
        case 67:
          me.setDirection("BT");
          break;
        case 68:
          me.setDirection("RL");
          break;
        case 69:
          me.setDirection("LR");
          break;
        case 70:
          this.$ = { type1: Q[$ - 2], type2: Q[$], lineType: Q[$ - 1] };
          break;
        case 71:
          this.$ = { type1: "none", type2: Q[$], lineType: Q[$ - 1] };
          break;
        case 72:
          this.$ = { type1: Q[$ - 1], type2: "none", lineType: Q[$] };
          break;
        case 73:
          this.$ = { type1: "none", type2: "none", lineType: Q[$] };
          break;
        case 74:
          this.$ = me.relationType.AGGREGATION;
          break;
        case 75:
          this.$ = me.relationType.EXTENSION;
          break;
        case 76:
          this.$ = me.relationType.COMPOSITION;
          break;
        case 77:
          this.$ = me.relationType.DEPENDENCY;
          break;
        case 78:
          this.$ = me.relationType.LOLLIPOP;
          break;
        case 79:
          this.$ = me.lineType.LINE;
          break;
        case 80:
          this.$ = me.lineType.DOTTED_LINE;
          break;
        case 81:
        case 87:
          this.$ = Q[$ - 2], me.setClickEvent(Q[$ - 1], Q[$]);
          break;
        case 82:
        case 88:
          this.$ = Q[$ - 3], me.setClickEvent(Q[$ - 2], Q[$ - 1]), me.setTooltip(Q[$ - 2], Q[$]);
          break;
        case 83:
          this.$ = Q[$ - 2], me.setLink(Q[$ - 1], Q[$]);
          break;
        case 84:
          this.$ = Q[$ - 3], me.setLink(Q[$ - 2], Q[$ - 1], Q[$]);
          break;
        case 85:
          this.$ = Q[$ - 3], me.setLink(Q[$ - 2], Q[$ - 1]), me.setTooltip(Q[$ - 2], Q[$]);
          break;
        case 86:
          this.$ = Q[$ - 4], me.setLink(Q[$ - 3], Q[$ - 2], Q[$]), me.setTooltip(Q[$ - 3], Q[$ - 1]);
          break;
        case 89:
          this.$ = Q[$ - 3], me.setClickEvent(Q[$ - 2], Q[$ - 1], Q[$]);
          break;
        case 90:
          this.$ = Q[$ - 4], me.setClickEvent(Q[$ - 3], Q[$ - 2], Q[$ - 1]), me.setTooltip(Q[$ - 3], Q[$]);
          break;
        case 91:
          this.$ = Q[$ - 3], me.setLink(Q[$ - 2], Q[$]);
          break;
        case 92:
          this.$ = Q[$ - 4], me.setLink(Q[$ - 3], Q[$ - 1], Q[$]);
          break;
        case 93:
          this.$ = Q[$ - 4], me.setLink(Q[$ - 3], Q[$ - 1]), me.setTooltip(Q[$ - 3], Q[$]);
          break;
        case 94:
          this.$ = Q[$ - 5], me.setLink(Q[$ - 4], Q[$ - 2], Q[$]), me.setTooltip(Q[$ - 4], Q[$ - 1]);
          break;
        case 95:
          this.$ = Q[$ - 2], me.setCssStyle(Q[$ - 1], Q[$]);
          break;
        case 96:
          me.setCssClass(Q[$ - 1], Q[$]);
          break;
        case 97:
          this.$ = [Q[$]];
          break;
        case 98:
          Q[$ - 2].push(Q[$]), this.$ = Q[$ - 2];
          break;
        case 100:
          this.$ = Q[$ - 1] + Q[$];
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: 2, 5: 3, 6: 4, 7: [1, 6], 10: 5, 16: 39, 17: 40, 19: 21, 21: 7, 23: 8, 24: 9, 25: 10, 26: 11, 27: 12, 28: 13, 29: 14, 30: 15, 31: 16, 32: 17, 33: e, 35: r, 37: n, 38: 22, 42: i, 43: 23, 46: a, 49: s, 51: o, 52: l, 54: u, 56: h, 57: d, 60: f, 62: p, 63: g, 64: m, 65: v, 75: y, 76: b, 78: w, 82: T, 83: E, 86: L, 100: k, 102: C, 103: A }, { 1: [3] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, t(R, [2, 5], { 8: [1, 48] }), { 8: [1, 49] }, t(_, [2, 19], { 22: [1, 50] }), t(_, [2, 21]), t(_, [2, 22]), t(_, [2, 23]), t(_, [2, 24]), t(_, [2, 25]), t(_, [2, 26]), t(_, [2, 27]), t(_, [2, 28]), t(_, [2, 29]), t(_, [2, 30]), { 34: [1, 51] }, { 36: [1, 52] }, t(_, [2, 33]), t(_, [2, 53], { 53: 53, 66: 56, 67: 57, 13: [1, 54], 22: [1, 55], 68: O, 69: P, 70: S, 71: M, 72: N, 73: D, 74: I }), { 39: [1, 65] }, t(B, [2, 40], { 39: [1, 67], 44: [1, 66] }), t(_, [2, 55]), t(_, [2, 56]), { 16: 68, 60: f, 86: L, 100: k, 102: C }, { 16: 39, 17: 40, 19: 69, 60: f, 86: L, 100: k, 102: C, 103: A }, { 16: 39, 17: 40, 19: 70, 60: f, 86: L, 100: k, 102: C, 103: A }, { 16: 39, 17: 40, 19: 71, 60: f, 86: L, 100: k, 102: C, 103: A }, { 60: [1, 72] }, { 13: [1, 73] }, { 16: 39, 17: 40, 19: 74, 60: f, 86: L, 100: k, 102: C, 103: A }, { 13: z, 55: 75 }, { 58: 77, 60: [1, 78] }, t(_, [2, 66]), t(_, [2, 67]), t(_, [2, 68]), t(_, [2, 69]), t(F, [2, 13], { 16: 39, 17: 40, 19: 80, 18: [1, 79], 20: [1, 81], 60: f, 86: L, 100: k, 102: C, 103: A }), t(F, [2, 15], { 20: [1, 82] }), { 15: 83, 16: 84, 17: 85, 60: f, 86: L, 100: k, 102: C, 103: A }, { 16: 39, 17: 40, 19: 86, 60: f, 86: L, 100: k, 102: C, 103: A }, t(V, [2, 123]), t(V, [2, 124]), t(V, [2, 125]), t(V, [2, 126]), t([1, 8, 9, 12, 13, 20, 22, 39, 41, 44, 68, 69, 70, 71, 72, 73, 74, 79, 81], [2, 127]), t(R, [2, 6], { 10: 5, 21: 7, 23: 8, 24: 9, 25: 10, 26: 11, 27: 12, 28: 13, 29: 14, 30: 15, 31: 16, 32: 17, 19: 21, 38: 22, 43: 23, 16: 39, 17: 40, 5: 87, 33: e, 35: r, 37: n, 42: i, 46: a, 49: s, 51: o, 52: l, 54: u, 56: h, 57: d, 60: f, 62: p, 63: g, 64: m, 65: v, 75: y, 76: b, 78: w, 82: T, 83: E, 86: L, 100: k, 102: C, 103: A }), { 5: 88, 10: 5, 16: 39, 17: 40, 19: 21, 21: 7, 23: 8, 24: 9, 25: 10, 26: 11, 27: 12, 28: 13, 29: 14, 30: 15, 31: 16, 32: 17, 33: e, 35: r, 37: n, 38: 22, 42: i, 43: 23, 46: a, 49: s, 51: o, 52: l, 54: u, 56: h, 57: d, 60: f, 62: p, 63: g, 64: m, 65: v, 75: y, 76: b, 78: w, 82: T, 83: E, 86: L, 100: k, 102: C, 103: A }, t(_, [2, 20]), t(_, [2, 31]), t(_, [2, 32]), { 13: [1, 90], 16: 39, 17: 40, 19: 89, 60: f, 86: L, 100: k, 102: C, 103: A }, { 53: 91, 66: 56, 67: 57, 68: O, 69: P, 70: S, 71: M, 72: N, 73: D, 74: I }, t(_, [2, 54]), { 67: 92, 73: D, 74: I }, t(H, [2, 73], { 66: 93, 68: O, 69: P, 70: S, 71: M, 72: N }), t(J, [2, 74]), t(J, [2, 75]), t(J, [2, 76]), t(J, [2, 77]), t(J, [2, 78]), t(q, [2, 79]), t(q, [2, 80]), { 8: [1, 95], 24: 96, 40: 94, 43: 23, 46: a }, { 16: 97, 60: f, 86: L, 100: k, 102: C }, { 41: [1, 99], 45: 98, 51: ae }, { 50: [1, 101] }, { 13: [1, 102] }, { 13: [1, 103] }, { 79: [1, 104], 81: [1, 105] }, { 22: re, 48: pe, 59: 106, 60: K, 82: Z, 84: 107, 85: 108, 86: X, 87: Y, 88: ee, 89: j, 90: fe }, { 60: [1, 118] }, { 13: z, 55: 119 }, t(_, [2, 62]), t(_, [2, 128]), { 22: re, 48: pe, 59: 120, 60: K, 61: [1, 121], 82: Z, 84: 107, 85: 108, 86: X, 87: Y, 88: ee, 89: j, 90: fe }, t(te, [2, 64]), { 16: 39, 17: 40, 19: 122, 60: f, 86: L, 100: k, 102: C, 103: A }, t(F, [2, 16]), t(F, [2, 17]), t(F, [2, 18]), { 39: [2, 36] }, { 15: 124, 16: 84, 17: 85, 18: [1, 123], 39: [2, 9], 60: f, 86: L, 100: k, 102: C, 103: A }, { 39: [2, 10] }, t(Ae, [2, 45], { 11: 125, 12: [1, 126] }), t(R, [2, 7]), { 9: [1, 127] }, t(W, [2, 57]), { 16: 39, 17: 40, 19: 128, 60: f, 86: L, 100: k, 102: C, 103: A }, { 13: [1, 130], 16: 39, 17: 40, 19: 129, 60: f, 86: L, 100: k, 102: C, 103: A }, t(H, [2, 72], { 66: 131, 68: O, 69: P, 70: S, 71: M, 72: N }), t(H, [2, 71]), { 41: [1, 132] }, { 24: 96, 40: 133, 43: 23, 46: a }, { 8: [1, 134], 41: [2, 37] }, t(B, [2, 41], { 39: [1, 135] }), { 41: [1, 136] }, t(B, [2, 43]), { 41: [2, 51], 45: 137, 51: ae }, { 16: 39, 17: 40, 19: 138, 60: f, 86: L, 100: k, 102: C, 103: A }, t(_, [2, 81], { 13: [1, 139] }), t(_, [2, 83], { 13: [1, 141], 77: [1, 140] }), t(_, [2, 87], { 13: [1, 142], 80: [1, 143] }), { 13: [1, 144] }, t(_, [2, 95], { 61: De }), t(ue, [2, 97], { 85: 146, 22: re, 48: pe, 60: K, 82: Z, 86: X, 87: Y, 88: ee, 89: j, 90: fe }), t(ze, [2, 99]), t(ze, [2, 101]), t(ze, [2, 102]), t(ze, [2, 103]), t(ze, [2, 104]), t(ze, [2, 105]), t(ze, [2, 106]), t(ze, [2, 107]), t(ze, [2, 108]), t(ze, [2, 109]), t(_, [2, 96]), t(_, [2, 61]), t(_, [2, 63], { 61: De }), { 60: [1, 147] }, t(F, [2, 14]), { 15: 148, 16: 84, 17: 85, 60: f, 86: L, 100: k, 102: C, 103: A }, { 39: [2, 12] }, t(Ae, [2, 46]), { 13: [1, 149] }, { 1: [2, 4] }, t(W, [2, 59]), t(W, [2, 58]), { 16: 39, 17: 40, 19: 150, 60: f, 86: L, 100: k, 102: C, 103: A }, t(H, [2, 70]), t(_, [2, 34]), { 41: [1, 151] }, { 24: 96, 40: 152, 41: [2, 38], 43: 23, 46: a }, { 45: 153, 51: ae }, t(B, [2, 42]), { 41: [2, 52] }, t(_, [2, 50]), t(_, [2, 82]), t(_, [2, 84]), t(_, [2, 85], { 77: [1, 154] }), t(_, [2, 88]), t(_, [2, 89], { 13: [1, 155] }), t(_, [2, 91], { 13: [1, 157], 77: [1, 156] }), { 22: re, 48: pe, 60: K, 82: Z, 84: 158, 85: 108, 86: X, 87: Y, 88: ee, 89: j, 90: fe }, t(ze, [2, 100]), t(te, [2, 65]), { 39: [2, 11] }, { 14: [1, 159] }, t(W, [2, 60]), t(_, [2, 35]), { 41: [2, 39] }, { 41: [1, 160] }, t(_, [2, 86]), t(_, [2, 90]), t(_, [2, 92]), t(_, [2, 93], { 77: [1, 161] }), t(ue, [2, 98], { 85: 146, 22: re, 48: pe, 60: K, 82: Z, 86: X, 87: Y, 88: ee, 89: j, 90: fe }), t(Ae, [2, 8]), t(B, [2, 44]), t(_, [2, 94])],
    defaultActions: { 2: [2, 1], 3: [2, 2], 4: [2, 3], 83: [2, 36], 85: [2, 10], 124: [2, 12], 127: [2, 4], 137: [2, 52], 148: [2, 11], 152: [2, 39] },
    parseError: /* @__PURE__ */ x(function(Se, _e) {
      if (_e.recoverable)
        this.trace(Se);
      else {
        var $e = new Error(Se);
        throw $e.hash = _e, $e;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ x(function(Se) {
      var _e = this, $e = [0], me = [], Ne = [null], Q = [], ce = this.table, $ = "", oe = 0, se = 0, ge = 2, he = 1, be = Q.slice.call(arguments, 1), Ce = Object.create(this.lexer), Te = { yy: {} };
      for (var Me in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, Me) && (Te.yy[Me] = this.yy[Me]);
      Ce.setInput(Se, Te.yy), Te.yy.lexer = Ce, Te.yy.parser = this, typeof Ce.yylloc > "u" && (Ce.yylloc = {});
      var Xe = Ce.yylloc;
      Q.push(Xe);
      var We = Ce.options && Ce.options.ranges;
      typeof Te.yy.parseError == "function" ? this.parseError = Te.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Ke(nt) {
        $e.length = $e.length - 2 * nt, Ne.length = Ne.length - nt, Q.length = Q.length - nt;
      }
      x(Ke, "popStack");
      function Ze() {
        var nt;
        return nt = me.pop() || Ce.lex() || he, typeof nt != "number" && (nt instanceof Array && (me = nt, nt = me.pop()), nt = _e.symbols_[nt] || nt), nt;
      }
      x(Ze, "lex");
      for (var Pe, He, ht, st, Ue = {}, Et, qe, rt, ct; ; ) {
        if (He = $e[$e.length - 1], this.defaultActions[He] ? ht = this.defaultActions[He] : ((Pe === null || typeof Pe > "u") && (Pe = Ze()), ht = ce[He] && ce[He][Pe]), typeof ht > "u" || !ht.length || !ht[0]) {
          var ut = "";
          ct = [];
          for (Et in ce[He])
            this.terminals_[Et] && Et > ge && ct.push("'" + this.terminals_[Et] + "'");
          Ce.showPosition ? ut = "Parse error on line " + (oe + 1) + `:
` + Ce.showPosition() + `
Expecting ` + ct.join(", ") + ", got '" + (this.terminals_[Pe] || Pe) + "'" : ut = "Parse error on line " + (oe + 1) + ": Unexpected " + (Pe == he ? "end of input" : "'" + (this.terminals_[Pe] || Pe) + "'"), this.parseError(ut, {
            text: Ce.match,
            token: this.terminals_[Pe] || Pe,
            line: Ce.yylineno,
            loc: Xe,
            expected: ct
          });
        }
        if (ht[0] instanceof Array && ht.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + He + ", token: " + Pe);
        switch (ht[0]) {
          case 1:
            $e.push(Pe), Ne.push(Ce.yytext), Q.push(Ce.yylloc), $e.push(ht[1]), Pe = null, se = Ce.yyleng, $ = Ce.yytext, oe = Ce.yylineno, Xe = Ce.yylloc;
            break;
          case 2:
            if (qe = this.productions_[ht[1]][1], Ue.$ = Ne[Ne.length - qe], Ue._$ = {
              first_line: Q[Q.length - (qe || 1)].first_line,
              last_line: Q[Q.length - 1].last_line,
              first_column: Q[Q.length - (qe || 1)].first_column,
              last_column: Q[Q.length - 1].last_column
            }, We && (Ue._$.range = [
              Q[Q.length - (qe || 1)].range[0],
              Q[Q.length - 1].range[1]
            ]), st = this.performAction.apply(Ue, [
              $,
              se,
              oe,
              Te.yy,
              ht[1],
              Ne,
              Q
            ].concat(be)), typeof st < "u")
              return st;
            qe && ($e = $e.slice(0, -1 * qe * 2), Ne = Ne.slice(0, -1 * qe), Q = Q.slice(0, -1 * qe)), $e.push(this.productions_[ht[1]][0]), Ne.push(Ue.$), Q.push(Ue._$), rt = ce[$e[$e.length - 2]][$e[$e.length - 1]], $e.push(rt);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, Ve = /* @__PURE__ */ (function() {
    var Oe = {
      EOF: 1,
      parseError: /* @__PURE__ */ x(function(_e, $e) {
        if (this.yy.parser)
          this.yy.parser.parseError(_e, $e);
        else
          throw new Error(_e);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ x(function(Se, _e) {
        return this.yy = _e || this.yy || {}, this._input = Se, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ x(function() {
        var Se = this._input[0];
        this.yytext += Se, this.yyleng++, this.offset++, this.match += Se, this.matched += Se;
        var _e = Se.match(/(?:\r\n?|\n).*/g);
        return _e ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), Se;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ x(function(Se) {
        var _e = Se.length, $e = Se.split(/(?:\r\n?|\n)/g);
        this._input = Se + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - _e), this.offset -= _e;
        var me = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), $e.length - 1 && (this.yylineno -= $e.length - 1);
        var Ne = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: $e ? ($e.length === me.length ? this.yylloc.first_column : 0) + me[me.length - $e.length].length - $e[0].length : this.yylloc.first_column - _e
        }, this.options.ranges && (this.yylloc.range = [Ne[0], Ne[0] + this.yyleng - _e]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ x(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ x(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ x(function(Se) {
        this.unput(this.match.slice(Se));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ x(function() {
        var Se = this.matched.substr(0, this.matched.length - this.match.length);
        return (Se.length > 20 ? "..." : "") + Se.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ x(function() {
        var Se = this.match;
        return Se.length < 20 && (Se += this._input.substr(0, 20 - Se.length)), (Se.substr(0, 20) + (Se.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ x(function() {
        var Se = this.pastInput(), _e = new Array(Se.length + 1).join("-");
        return Se + this.upcomingInput() + `
` + _e + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ x(function(Se, _e) {
        var $e, me, Ne;
        if (this.options.backtrack_lexer && (Ne = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (Ne.yylloc.range = this.yylloc.range.slice(0))), me = Se[0].match(/(?:\r\n?|\n).*/g), me && (this.yylineno += me.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: me ? me[me.length - 1].length - me[me.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + Se[0].length
        }, this.yytext += Se[0], this.match += Se[0], this.matches = Se, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(Se[0].length), this.matched += Se[0], $e = this.performAction.call(this, this.yy, this, _e, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), $e)
          return $e;
        if (this._backtrack) {
          for (var Q in Ne)
            this[Q] = Ne[Q];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ x(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var Se, _e, $e, me;
        this._more || (this.yytext = "", this.match = "");
        for (var Ne = this._currentRules(), Q = 0; Q < Ne.length; Q++)
          if ($e = this._input.match(this.rules[Ne[Q]]), $e && (!_e || $e[0].length > _e[0].length)) {
            if (_e = $e, me = Q, this.options.backtrack_lexer) {
              if (Se = this.test_match($e, Ne[Q]), Se !== !1)
                return Se;
              if (this._backtrack) {
                _e = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return _e ? (Se = this.test_match(_e, Ne[me]), Se !== !1 ? Se : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ x(function() {
        var _e = this.next();
        return _e || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ x(function(_e) {
        this.conditionStack.push(_e);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ x(function() {
        var _e = this.conditionStack.length - 1;
        return _e > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ x(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ x(function(_e) {
        return _e = this.conditionStack.length - 1 - Math.abs(_e || 0), _e >= 0 ? this.conditionStack[_e] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ x(function(_e) {
        this.begin(_e);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ x(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: {},
      performAction: /* @__PURE__ */ x(function(_e, $e, me, Ne) {
        switch (me) {
          case 0:
            return 62;
          case 1:
            return 63;
          case 2:
            return 64;
          case 3:
            return 65;
          case 4:
            break;
          case 5:
            break;
          case 6:
            return this.begin("acc_title"), 33;
          case 7:
            return this.popState(), "acc_title_value";
          case 8:
            return this.begin("acc_descr"), 35;
          case 9:
            return this.popState(), "acc_descr_value";
          case 10:
            this.begin("acc_descr_multiline");
            break;
          case 11:
            this.popState();
            break;
          case 12:
            return "acc_descr_multiline_value";
          case 13:
            return 8;
          case 14:
            break;
          case 15:
            return 7;
          case 16:
            return 7;
          case 17:
            return "EDGE_STATE";
          case 18:
            this.begin("callback_name");
            break;
          case 19:
            this.popState();
            break;
          case 20:
            this.popState(), this.begin("callback_args");
            break;
          case 21:
            return 79;
          case 22:
            this.popState();
            break;
          case 23:
            return 80;
          case 24:
            this.popState();
            break;
          case 25:
            return "STR";
          case 26:
            this.begin("string");
            break;
          case 27:
            return 82;
          case 28:
            return 57;
          case 29:
            return this.begin("namespace"), 42;
          case 30:
            return this.popState(), 8;
          case 31:
            break;
          case 32:
            return this.begin("namespace-body"), 39;
          case 33:
            return this.popState(), 41;
          case 34:
            return "EOF_IN_STRUCT";
          case 35:
            return 8;
          case 36:
            break;
          case 37:
            return "EDGE_STATE";
          case 38:
            return this.begin("class"), 46;
          case 39:
            return this.popState(), 8;
          case 40:
            break;
          case 41:
            return this.popState(), this.popState(), 41;
          case 42:
            return this.begin("class-body"), 39;
          case 43:
            return this.popState(), 41;
          case 44:
            return "EOF_IN_STRUCT";
          case 45:
            return "EDGE_STATE";
          case 46:
            return "OPEN_IN_STRUCT";
          case 47:
            break;
          case 48:
            return "MEMBER";
          case 49:
            return 83;
          case 50:
            return 75;
          case 51:
            return 76;
          case 52:
            return 78;
          case 53:
            return 54;
          case 54:
            return 56;
          case 55:
            return 49;
          case 56:
            return 50;
          case 57:
            return 81;
          case 58:
            this.popState();
            break;
          case 59:
            return "GENERICTYPE";
          case 60:
            this.begin("generic");
            break;
          case 61:
            this.popState();
            break;
          case 62:
            return "BQUOTE_STR";
          case 63:
            this.begin("bqstring");
            break;
          case 64:
            return 77;
          case 65:
            return 77;
          case 66:
            return 77;
          case 67:
            return 77;
          case 68:
            return 69;
          case 69:
            return 69;
          case 70:
            return 71;
          case 71:
            return 71;
          case 72:
            return 70;
          case 73:
            return 68;
          case 74:
            return 72;
          case 75:
            return 73;
          case 76:
            return 74;
          case 77:
            return 22;
          case 78:
            return 44;
          case 79:
            return 100;
          case 80:
            return 18;
          case 81:
            return "PLUS";
          case 82:
            return 87;
          case 83:
            return 61;
          case 84:
            return 89;
          case 85:
            return 89;
          case 86:
            return 90;
          case 87:
            return "EQUALS";
          case 88:
            return "EQUALS";
          case 89:
            return 60;
          case 90:
            return 12;
          case 91:
            return 14;
          case 92:
            return "PUNCTUATION";
          case 93:
            return 86;
          case 94:
            return 102;
          case 95:
            return 48;
          case 96:
            return 48;
          case 97:
            return 9;
        }
      }, "anonymous"),
      rules: [/^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/, /^(?:%%[^\n]*(\r?\n)*)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:classDiagram-v2\b)/, /^(?:classDiagram\b)/, /^(?:\[\*\])/, /^(?:call[\s]+)/, /^(?:\([\s]*\))/, /^(?:\()/, /^(?:[^(]*)/, /^(?:\))/, /^(?:[^)]*)/, /^(?:["])/, /^(?:[^"]*)/, /^(?:["])/, /^(?:style\b)/, /^(?:classDef\b)/, /^(?:namespace\b)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:[{])/, /^(?:[}])/, /^(?:$)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:\[\*\])/, /^(?:class\b)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:[}])/, /^(?:[{])/, /^(?:[}])/, /^(?:$)/, /^(?:\[\*\])/, /^(?:[{])/, /^(?:[\n])/, /^(?:[^{}\n]*)/, /^(?:cssClass\b)/, /^(?:callback\b)/, /^(?:link\b)/, /^(?:click\b)/, /^(?:note for\b)/, /^(?:note\b)/, /^(?:<<)/, /^(?:>>)/, /^(?:href\b)/, /^(?:[~])/, /^(?:[^~]*)/, /^(?:~)/, /^(?:[`])/, /^(?:[^`]+)/, /^(?:[`])/, /^(?:_self\b)/, /^(?:_blank\b)/, /^(?:_parent\b)/, /^(?:_top\b)/, /^(?:\s*<\|)/, /^(?:\s*\|>)/, /^(?:\s*>)/, /^(?:\s*<)/, /^(?:\s*\*)/, /^(?:\s*o\b)/, /^(?:\s*\(\))/, /^(?:--)/, /^(?:\.\.)/, /^(?::{1}[^:\n;]+)/, /^(?::{3})/, /^(?:-)/, /^(?:\.)/, /^(?:\+)/, /^(?::)/, /^(?:,)/, /^(?:#)/, /^(?:#)/, /^(?:%)/, /^(?:=)/, /^(?:=)/, /^(?:\w+)/, /^(?:\[)/, /^(?:\])/, /^(?:[!"#$%&'*+,-.`?\\/])/, /^(?:[0-9]+)/, /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/, /^(?:\s)/, /^(?:\s)/, /^(?:$)/],
      conditions: { "namespace-body": { rules: [26, 33, 34, 35, 36, 37, 38, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, namespace: { rules: [26, 29, 30, 31, 32, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, "class-body": { rules: [26, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, class: { rules: [26, 39, 40, 41, 42, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, acc_descr_multiline: { rules: [11, 12, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, acc_descr: { rules: [9, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, acc_title: { rules: [7, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, callback_args: { rules: [22, 23, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, callback_name: { rules: [19, 20, 21, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, href: { rules: [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, struct: { rules: [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, generic: { rules: [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, bqstring: { rules: [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, string: { rules: [24, 25, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 8, 10, 13, 14, 15, 16, 17, 18, 26, 27, 28, 29, 38, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97], inclusive: !0 } }
    };
    return Oe;
  })();
  Ge.lexer = Ve;
  function ke() {
    this.yy = {};
  }
  return x(ke, "Parser"), ke.prototype = Ge, Ge.Parser = ke, new ke();
})();
F6.parser = F6;
var QY = F6, LN = ["#", "+", "~", "-", ""], RN = class {
  static {
    x(this, "ClassMember");
  }
  constructor(t, e) {
    this.memberType = e, this.visibility = "", this.classifier = "", this.text = "";
    const r = dr(t, we());
    this.parseMember(r);
  }
  getDisplayDetails() {
    let t = this.visibility + Sl(this.id);
    this.memberType === "method" && (t += `(${Sl(this.parameters.trim())})`, this.returnType && (t += " : " + Sl(this.returnType))), t = t.trim();
    const e = this.parseClassifier();
    return {
      displayText: t,
      cssStyle: e
    };
  }
  parseMember(t) {
    let e = "";
    if (this.memberType === "method") {
      const i = /([#+~-])?(.+)\((.*)\)([\s$*])?(.*)([$*])?/.exec(t);
      if (i) {
        const a = i[1] ? i[1].trim() : "";
        if (LN.includes(a) && (this.visibility = a), this.id = i[2], this.parameters = i[3] ? i[3].trim() : "", e = i[4] ? i[4].trim() : "", this.returnType = i[5] ? i[5].trim() : "", e === "") {
          const s = this.returnType.substring(this.returnType.length - 1);
          /[$*]/.exec(s) && (e = s, this.returnType = this.returnType.substring(0, this.returnType.length - 1));
        }
      }
    } else {
      const n = t.length, i = t.substring(0, 1), a = t.substring(n - 1);
      LN.includes(i) && (this.visibility = i), /[$*]/.exec(a) && (e = a), this.id = t.substring(
        this.visibility === "" ? 0 : 1,
        e === "" ? n : n - 1
      );
    }
    this.classifier = e, this.id = this.id.startsWith(" ") ? " " + this.id.trim() : this.id.trim();
    const r = `${this.visibility ? "\\" + this.visibility : ""}${Sl(this.id)}${this.memberType === "method" ? `(${Sl(this.parameters)})${this.returnType ? " : " + Sl(this.returnType) : ""}` : ""}`;
    this.text = r.replaceAll("<", "&lt;").replaceAll(">", "&gt;"), this.text.startsWith("\\&lt;") && (this.text = this.text.replace("\\&lt;", "~"));
  }
  parseClassifier() {
    switch (this.classifier) {
      case "*":
        return "font-style:italic;";
      case "$":
        return "text-decoration:underline;";
      default:
        return "";
    }
  }
}, um = "classId-", MN = 0, Uc = /* @__PURE__ */ x((t) => at.sanitizeText(t, we()), "sanitizeText"), JY = class {
  constructor() {
    this.relations = [], this.classes = /* @__PURE__ */ new Map(), this.styleClasses = /* @__PURE__ */ new Map(), this.notes = [], this.interfaces = [], this.namespaces = /* @__PURE__ */ new Map(), this.namespaceCounter = 0, this.functions = [], this.lineType = {
      LINE: 0,
      DOTTED_LINE: 1
    }, this.relationType = {
      AGGREGATION: 0,
      EXTENSION: 1,
      COMPOSITION: 2,
      DEPENDENCY: 3,
      LOLLIPOP: 4
    }, this.setupToolTips = /* @__PURE__ */ x((t) => {
      let e = Qe(".mermaidTooltip");
      (e._groups || e)[0][0] === null && (e = Qe("body").append("div").attr("class", "mermaidTooltip").style("opacity", 0)), Qe(t).select("svg").selectAll("g.node").on("mouseover", (i) => {
        const a = Qe(i.currentTarget);
        if (a.attr("title") === null)
          return;
        const o = this.getBoundingClientRect();
        e.transition().duration(200).style("opacity", ".9"), e.text(a.attr("title")).style("left", window.scrollX + o.left + (o.right - o.left) / 2 + "px").style("top", window.scrollY + o.top - 14 + document.body.scrollTop + "px"), e.html(e.html().replace(/&lt;br\/&gt;/g, "<br/>")), a.classed("hover", !0);
      }).on("mouseout", (i) => {
        e.transition().duration(500).style("opacity", 0), Qe(i.currentTarget).classed("hover", !1);
      });
    }, "setupToolTips"), this.direction = "TB", this.setAccTitle = Cn, this.getAccTitle = Gn, this.setAccDescription = Vn, this.getAccDescription = Un, this.setDiagramTitle = Zn, this.getDiagramTitle = Ln, this.getConfig = /* @__PURE__ */ x(() => we().class, "getConfig"), this.functions.push(this.setupToolTips.bind(this)), this.clear(), this.addRelation = this.addRelation.bind(this), this.addClassesToNamespace = this.addClassesToNamespace.bind(this), this.addNamespace = this.addNamespace.bind(this), this.setCssClass = this.setCssClass.bind(this), this.addMembers = this.addMembers.bind(this), this.addClass = this.addClass.bind(this), this.setClassLabel = this.setClassLabel.bind(this), this.addAnnotation = this.addAnnotation.bind(this), this.addMember = this.addMember.bind(this), this.cleanupLabel = this.cleanupLabel.bind(this), this.addNote = this.addNote.bind(this), this.defineClass = this.defineClass.bind(this), this.setDirection = this.setDirection.bind(this), this.setLink = this.setLink.bind(this), this.bindFunctions = this.bindFunctions.bind(this), this.clear = this.clear.bind(this), this.setTooltip = this.setTooltip.bind(this), this.setClickEvent = this.setClickEvent.bind(this), this.setCssStyle = this.setCssStyle.bind(this);
  }
  static {
    x(this, "ClassDB");
  }
  splitClassNameAndType(t) {
    const e = at.sanitizeText(t, we());
    let r = "", n = e;
    if (e.indexOf("~") > 0) {
      const i = e.split("~");
      n = Uc(i[0]), r = Uc(i[1]);
    }
    return { className: n, type: r };
  }
  setClassLabel(t, e) {
    const r = at.sanitizeText(t, we());
    e && (e = Uc(e));
    const { className: n } = this.splitClassNameAndType(r);
    this.classes.get(n).label = e, this.classes.get(n).text = `${e}${this.classes.get(n).type ? `<${this.classes.get(n).type}>` : ""}`;
  }
  /**
   * Function called by parser when a node definition has been found.
   *
   * @param id - ID of the class to add
   * @public
   */
  addClass(t) {
    const e = at.sanitizeText(t, we()), { className: r, type: n } = this.splitClassNameAndType(e);
    if (this.classes.has(r))
      return;
    const i = at.sanitizeText(r, we());
    this.classes.set(i, {
      id: i,
      type: n,
      label: i,
      text: `${i}${n ? `&lt;${n}&gt;` : ""}`,
      shape: "classBox",
      cssClasses: "default",
      methods: [],
      members: [],
      annotations: [],
      styles: [],
      domId: um + i + "-" + MN
    }), MN++;
  }
  addInterface(t, e) {
    const r = {
      id: `interface${this.interfaces.length}`,
      label: t,
      classId: e
    };
    this.interfaces.push(r);
  }
  /**
   * Function to lookup domId from id in the graph definition.
   *
   * @param id - class ID to lookup
   * @public
   */
  lookUpDomId(t) {
    const e = at.sanitizeText(t, we());
    if (this.classes.has(e))
      return this.classes.get(e).domId;
    throw new Error("Class not found: " + e);
  }
  clear() {
    this.relations = [], this.classes = /* @__PURE__ */ new Map(), this.notes = [], this.interfaces = [], this.functions = [], this.functions.push(this.setupToolTips.bind(this)), this.namespaces = /* @__PURE__ */ new Map(), this.namespaceCounter = 0, this.direction = "TB", _n();
  }
  getClass(t) {
    return this.classes.get(t);
  }
  getClasses() {
    return this.classes;
  }
  getRelations() {
    return this.relations;
  }
  getNotes() {
    return this.notes;
  }
  addRelation(t) {
    ie.debug("Adding relation: " + JSON.stringify(t));
    const e = [
      this.relationType.LOLLIPOP,
      this.relationType.AGGREGATION,
      this.relationType.COMPOSITION,
      this.relationType.DEPENDENCY,
      this.relationType.EXTENSION
    ];
    t.relation.type1 === this.relationType.LOLLIPOP && !e.includes(t.relation.type2) ? (this.addClass(t.id2), this.addInterface(t.id1, t.id2), t.id1 = `interface${this.interfaces.length - 1}`) : t.relation.type2 === this.relationType.LOLLIPOP && !e.includes(t.relation.type1) ? (this.addClass(t.id1), this.addInterface(t.id2, t.id1), t.id2 = `interface${this.interfaces.length - 1}`) : (this.addClass(t.id1), this.addClass(t.id2)), t.id1 = this.splitClassNameAndType(t.id1).className, t.id2 = this.splitClassNameAndType(t.id2).className, t.relationTitle1 = at.sanitizeText(
      t.relationTitle1.trim(),
      we()
    ), t.relationTitle2 = at.sanitizeText(
      t.relationTitle2.trim(),
      we()
    ), this.relations.push(t);
  }
  /**
   * Adds an annotation to the specified class Annotations mark special properties of the given type
   * (like 'interface' or 'service')
   *
   * @param className - The class name
   * @param annotation - The name of the annotation without any brackets
   * @public
   */
  addAnnotation(t, e) {
    const r = this.splitClassNameAndType(t).className;
    this.classes.get(r).annotations.push(e);
  }
  /**
   * Adds a member to the specified class
   *
   * @param className - The class name
   * @param member - The full name of the member. If the member is enclosed in `<<brackets>>` it is
   *   treated as an annotation If the member is ending with a closing bracket ) it is treated as a
   *   method Otherwise the member will be treated as a normal property
   * @public
   */
  addMember(t, e) {
    this.addClass(t);
    const r = this.splitClassNameAndType(t).className, n = this.classes.get(r);
    if (typeof e == "string") {
      const i = e.trim();
      i.startsWith("<<") && i.endsWith(">>") ? n.annotations.push(Uc(i.substring(2, i.length - 2))) : i.indexOf(")") > 0 ? n.methods.push(new RN(i, "method")) : i && n.members.push(new RN(i, "attribute"));
    }
  }
  addMembers(t, e) {
    Array.isArray(e) && (e.reverse(), e.forEach((r) => this.addMember(t, r)));
  }
  addNote(t, e) {
    const r = {
      id: `note${this.notes.length}`,
      class: e,
      text: t
    };
    this.notes.push(r);
  }
  cleanupLabel(t) {
    return t.startsWith(":") && (t = t.substring(1)), Uc(t.trim());
  }
  /**
   * Called by parser when assigning cssClass to a class
   *
   * @param ids - Comma separated list of ids
   * @param className - Class to add
   */
  setCssClass(t, e) {
    t.split(",").forEach((r) => {
      let n = r;
      /\d/.exec(r[0]) && (n = um + n);
      const i = this.classes.get(n);
      i && (i.cssClasses += " " + e);
    });
  }
  defineClass(t, e) {
    for (const r of t) {
      let n = this.styleClasses.get(r);
      n === void 0 && (n = { id: r, styles: [], textStyles: [] }, this.styleClasses.set(r, n)), e && e.forEach((i) => {
        if (/color/.exec(i)) {
          const a = i.replace("fill", "bgFill");
          n.textStyles.push(a);
        }
        n.styles.push(i);
      }), this.classes.forEach((i) => {
        i.cssClasses.includes(r) && i.styles.push(...e.flatMap((a) => a.split(",")));
      });
    }
  }
  /**
   * Called by parser when a tooltip is found, e.g. a clickable element.
   *
   * @param ids - Comma separated list of ids
   * @param tooltip - Tooltip to add
   */
  setTooltip(t, e) {
    t.split(",").forEach((r) => {
      e !== void 0 && (this.classes.get(r).tooltip = Uc(e));
    });
  }
  getTooltip(t, e) {
    return e && this.namespaces.has(e) ? this.namespaces.get(e).classes.get(t).tooltip : this.classes.get(t).tooltip;
  }
  /**
   * Called by parser when a link is found. Adds the URL to the vertex data.
   *
   * @param ids - Comma separated list of ids
   * @param linkStr - URL to create a link for
   * @param target - Target of the link, _blank by default as originally defined in the svgDraw.js file
   */
  setLink(t, e, r) {
    const n = we();
    t.split(",").forEach((i) => {
      let a = i;
      /\d/.exec(i[0]) && (a = um + a);
      const s = this.classes.get(a);
      s && (s.link = Zt.formatUrl(e, n), n.securityLevel === "sandbox" ? s.linkTarget = "_top" : typeof r == "string" ? s.linkTarget = Uc(r) : s.linkTarget = "_blank");
    }), this.setCssClass(t, "clickable");
  }
  /**
   * Called by parser when a click definition is found. Registers an event handler.
   *
   * @param ids - Comma separated list of ids
   * @param functionName - Function to be called on click
   * @param functionArgs - Function args the function should be called with
   */
  setClickEvent(t, e, r) {
    t.split(",").forEach((n) => {
      this.setClickFunc(n, e, r), this.classes.get(n).haveCallback = !0;
    }), this.setCssClass(t, "clickable");
  }
  setClickFunc(t, e, r) {
    const n = at.sanitizeText(t, we());
    if (we().securityLevel !== "loose" || e === void 0)
      return;
    const a = n;
    if (this.classes.has(a)) {
      const s = this.lookUpDomId(a);
      let o = [];
      if (typeof r == "string") {
        o = r.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
        for (let l = 0; l < o.length; l++) {
          let u = o[l].trim();
          u.startsWith('"') && u.endsWith('"') && (u = u.substr(1, u.length - 2)), o[l] = u;
        }
      }
      o.length === 0 && o.push(s), this.functions.push(() => {
        const l = document.querySelector(`[id="${s}"]`);
        l !== null && l.addEventListener(
          "click",
          () => {
            Zt.runFunc(e, ...o);
          },
          !1
        );
      });
    }
  }
  bindFunctions(t) {
    this.functions.forEach((e) => {
      e(t);
    });
  }
  getDirection() {
    return this.direction;
  }
  setDirection(t) {
    this.direction = t;
  }
  /**
   * Function called by parser when a namespace definition has been found.
   *
   * @param id - ID of the namespace to add
   * @public
   */
  addNamespace(t) {
    this.namespaces.has(t) || (this.namespaces.set(t, {
      id: t,
      classes: /* @__PURE__ */ new Map(),
      children: {},
      domId: um + t + "-" + this.namespaceCounter
    }), this.namespaceCounter++);
  }
  getNamespace(t) {
    return this.namespaces.get(t);
  }
  getNamespaces() {
    return this.namespaces;
  }
  /**
   * Function called by parser when a namespace definition has been found.
   *
   * @param id - ID of the namespace to add
   * @param classNames - IDs of the class to add
   * @public
   */
  addClassesToNamespace(t, e) {
    if (this.namespaces.has(t))
      for (const r of e) {
        const { className: n } = this.splitClassNameAndType(r);
        this.classes.get(n).parent = t, this.namespaces.get(t).classes.set(n, this.classes.get(n));
      }
  }
  setCssStyle(t, e) {
    const r = this.classes.get(t);
    if (!(!e || !r))
      for (const n of e)
        n.includes(",") ? r.styles.push(...n.split(",")) : r.styles.push(n);
  }
  /**
   * Gets the arrow marker for a type index
   *
   * @param type - The type to look for
   * @returns The arrow marker
   */
  getArrowMarker(t) {
    let e;
    switch (t) {
      case 0:
        e = "aggregation";
        break;
      case 1:
        e = "extension";
        break;
      case 2:
        e = "composition";
        break;
      case 3:
        e = "dependency";
        break;
      case 4:
        e = "lollipop";
        break;
      default:
        e = "none";
    }
    return e;
  }
  getData() {
    const t = [], e = [], r = we();
    for (const i of this.namespaces.keys()) {
      const a = this.namespaces.get(i);
      if (a) {
        const s = {
          id: a.id,
          label: a.id,
          isGroup: !0,
          padding: r.class.padding ?? 16,
          // parent node must be one of [rect, roundedWithTitle, noteGroup, divider]
          shape: "rect",
          cssStyles: ["fill: none", "stroke: black"],
          look: r.look
        };
        t.push(s);
      }
    }
    for (const i of this.classes.keys()) {
      const a = this.classes.get(i);
      if (a) {
        const s = a;
        s.parentId = a.parent, s.look = r.look, t.push(s);
      }
    }
    let n = 0;
    for (const i of this.notes) {
      n++;
      const a = {
        id: i.id,
        label: i.text,
        isGroup: !1,
        shape: "note",
        padding: r.class.padding ?? 6,
        cssStyles: [
          "text-align: left",
          "white-space: nowrap",
          `fill: ${r.themeVariables.noteBkgColor}`,
          `stroke: ${r.themeVariables.noteBorderColor}`
        ],
        look: r.look
      };
      t.push(a);
      const s = this.classes.get(i.class)?.id ?? "";
      if (s) {
        const o = {
          id: `edgeNote${n}`,
          start: i.id,
          end: s,
          type: "normal",
          thickness: "normal",
          classes: "relation",
          arrowTypeStart: "none",
          arrowTypeEnd: "none",
          arrowheadStyle: "",
          labelStyle: [""],
          style: ["fill: none"],
          pattern: "dotted",
          look: r.look
        };
        e.push(o);
      }
    }
    for (const i of this.interfaces) {
      const a = {
        id: i.id,
        label: i.label,
        isGroup: !1,
        shape: "rect",
        cssStyles: ["opacity: 0;"],
        look: r.look
      };
      t.push(a);
    }
    n = 0;
    for (const i of this.relations) {
      n++;
      const a = {
        id: Kh(i.id1, i.id2, {
          prefix: "id",
          counter: n
        }),
        start: i.id1,
        end: i.id2,
        type: "normal",
        label: i.title,
        labelpos: "c",
        thickness: "normal",
        classes: "relation",
        arrowTypeStart: this.getArrowMarker(i.relation.type1),
        arrowTypeEnd: this.getArrowMarker(i.relation.type2),
        startLabelRight: i.relationTitle1 === "none" ? "" : i.relationTitle1,
        endLabelLeft: i.relationTitle2 === "none" ? "" : i.relationTitle2,
        arrowheadStyle: "",
        labelStyle: ["display: inline-block"],
        style: i.style || "",
        pattern: i.relation.lineType == 1 ? "dashed" : "solid",
        look: r.look
      };
      e.push(a);
    }
    return { nodes: t, edges: e, other: {}, config: r, direction: this.getDirection() };
  }
}, GIe = /* @__PURE__ */ x((t) => `g.classGroup text {
  fill: ${t.nodeBorder || t.classText};
  stroke: none;
  font-family: ${t.fontFamily};
  font-size: 10px;

  .title {
    font-weight: bolder;
  }

}

.nodeLabel, .edgeLabel {
  color: ${t.classText};
}
.edgeLabel .label rect {
  fill: ${t.mainBkg};
}
.label text {
  fill: ${t.classText};
}

.labelBkg {
  background: ${t.mainBkg};
}
.edgeLabel .label span {
  background: ${t.mainBkg};
}

.classTitle {
  font-weight: bolder;
}
.node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${t.mainBkg};
    stroke: ${t.nodeBorder};
    stroke-width: 1px;
  }


.divider {
  stroke: ${t.nodeBorder};
  stroke-width: 1;
}

g.clickable {
  cursor: pointer;
}

g.classGroup rect {
  fill: ${t.mainBkg};
  stroke: ${t.nodeBorder};
}

g.classGroup line {
  stroke: ${t.nodeBorder};
  stroke-width: 1;
}

.classLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${t.mainBkg};
  opacity: 0.5;
}

.classLabel .label {
  fill: ${t.nodeBorder};
  font-size: 10px;
}

.relation {
  stroke: ${t.lineColor};
  stroke-width: 1;
  fill: none;
}

.dashed-line{
  stroke-dasharray: 3;
}

.dotted-line{
  stroke-dasharray: 1 2;
}

#compositionStart, .composition {
  fill: ${t.lineColor} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#compositionEnd, .composition {
  fill: ${t.lineColor} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${t.lineColor} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${t.lineColor} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#extensionStart, .extension {
  fill: transparent !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#extensionEnd, .extension {
  fill: transparent !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#aggregationStart, .aggregation {
  fill: transparent !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#aggregationEnd, .aggregation {
  fill: transparent !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#lollipopStart, .lollipop {
  fill: ${t.mainBkg} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#lollipopEnd, .lollipop {
  fill: ${t.mainBkg} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

.edgeTerminals {
  font-size: 11px;
  line-height: initial;
}

.classTitleText {
  text-anchor: middle;
  font-size: 18px;
  fill: ${t.textColor};
}
  ${Dg()}
`, "getStyles"), eX = GIe, VIe = /* @__PURE__ */ x((t, e = "TB") => {
  if (!t.doc)
    return e;
  let r = e;
  for (const n of t.doc)
    n.stmt === "dir" && (r = n.value);
  return r;
}, "getDir"), UIe = /* @__PURE__ */ x(function(t, e) {
  return e.db.getClasses();
}, "getClasses"), HIe = /* @__PURE__ */ x(async function(t, e, r, n) {
  ie.info("REF0:"), ie.info("Drawing class diagram (v3)", e);
  const { securityLevel: i, state: a, layout: s } = we(), o = n.db.getData(), l = lf(e, i);
  o.type = n.type, o.layoutAlgorithm = mg(s), o.nodeSpacing = a?.nodeSpacing || 50, o.rankSpacing = a?.rankSpacing || 50, o.markers = ["aggregation", "extension", "composition", "dependency", "lollipop"], o.diagramId = e, await Kd(o, l);
  const u = 8;
  Zt.insertTitle(
    l,
    "classDiagramTitleText",
    a?.titleTopMargin ?? 25,
    n.db.getDiagramTitle()
  ), rh(l, u, "classDiagram", a?.useMaxWidth ?? !0);
}, "draw"), tX = {
  getClasses: UIe,
  draw: HIe,
  getDir: VIe
}, qIe = {
  parser: QY,
  get db() {
    return new JY();
  },
  renderer: tX,
  styles: eX,
  init: /* @__PURE__ */ x((t) => {
    t.class || (t.class = {}), t.class.arrowMarkerAbsolute = t.arrowMarkerAbsolute;
  }, "init")
};
const WIe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: qIe
}, Symbol.toStringTag, { value: "Module" }));
var YIe = {
  parser: QY,
  get db() {
    return new JY();
  },
  renderer: tX,
  styles: eX,
  init: /* @__PURE__ */ x((t) => {
    t.class || (t.class = {}), t.class.arrowMarkerAbsolute = t.arrowMarkerAbsolute;
  }, "init")
};
const XIe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: YIe
}, Symbol.toStringTag, { value: "Module" }));
var $6 = (function() {
  var t = /* @__PURE__ */ x(function(B, z, F, V) {
    for (F = F || {}, V = B.length; V--; F[B[V]] = z) ;
    return F;
  }, "o"), e = [1, 2], r = [1, 3], n = [1, 4], i = [2, 4], a = [1, 9], s = [1, 11], o = [1, 16], l = [1, 17], u = [1, 18], h = [1, 19], d = [1, 33], f = [1, 20], p = [1, 21], g = [1, 22], m = [1, 23], v = [1, 24], y = [1, 26], b = [1, 27], w = [1, 28], T = [1, 29], E = [1, 30], L = [1, 31], k = [1, 32], C = [1, 35], A = [1, 36], R = [1, 37], _ = [1, 38], O = [1, 34], P = [1, 4, 5, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 41, 45, 48, 51, 52, 53, 54, 57], S = [1, 4, 5, 14, 15, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 39, 40, 41, 45, 48, 51, 52, 53, 54, 57], M = [4, 5, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 41, 45, 48, 51, 52, 53, 54, 57], N = {
    trace: /* @__PURE__ */ x(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, SPACE: 4, NL: 5, SD: 6, document: 7, line: 8, statement: 9, classDefStatement: 10, styleStatement: 11, cssClassStatement: 12, idStatement: 13, DESCR: 14, "-->": 15, HIDE_EMPTY: 16, scale: 17, WIDTH: 18, COMPOSIT_STATE: 19, STRUCT_START: 20, STRUCT_STOP: 21, STATE_DESCR: 22, AS: 23, ID: 24, FORK: 25, JOIN: 26, CHOICE: 27, CONCURRENT: 28, note: 29, notePosition: 30, NOTE_TEXT: 31, direction: 32, acc_title: 33, acc_title_value: 34, acc_descr: 35, acc_descr_value: 36, acc_descr_multiline_value: 37, CLICK: 38, STRING: 39, HREF: 40, classDef: 41, CLASSDEF_ID: 42, CLASSDEF_STYLEOPTS: 43, DEFAULT: 44, style: 45, STYLE_IDS: 46, STYLEDEF_STYLEOPTS: 47, class: 48, CLASSENTITY_IDS: 49, STYLECLASS: 50, direction_tb: 51, direction_bt: 52, direction_rl: 53, direction_lr: 54, eol: 55, ";": 56, EDGE_STATE: 57, STYLE_SEPARATOR: 58, left_of: 59, right_of: 60, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "SPACE", 5: "NL", 6: "SD", 14: "DESCR", 15: "-->", 16: "HIDE_EMPTY", 17: "scale", 18: "WIDTH", 19: "COMPOSIT_STATE", 20: "STRUCT_START", 21: "STRUCT_STOP", 22: "STATE_DESCR", 23: "AS", 24: "ID", 25: "FORK", 26: "JOIN", 27: "CHOICE", 28: "CONCURRENT", 29: "note", 31: "NOTE_TEXT", 33: "acc_title", 34: "acc_title_value", 35: "acc_descr", 36: "acc_descr_value", 37: "acc_descr_multiline_value", 38: "CLICK", 39: "STRING", 40: "HREF", 41: "classDef", 42: "CLASSDEF_ID", 43: "CLASSDEF_STYLEOPTS", 44: "DEFAULT", 45: "style", 46: "STYLE_IDS", 47: "STYLEDEF_STYLEOPTS", 48: "class", 49: "CLASSENTITY_IDS", 50: "STYLECLASS", 51: "direction_tb", 52: "direction_bt", 53: "direction_rl", 54: "direction_lr", 56: ";", 57: "EDGE_STATE", 58: "STYLE_SEPARATOR", 59: "left_of", 60: "right_of" },
    productions_: [0, [3, 2], [3, 2], [3, 2], [7, 0], [7, 2], [8, 2], [8, 1], [8, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 2], [9, 3], [9, 4], [9, 1], [9, 2], [9, 1], [9, 4], [9, 3], [9, 6], [9, 1], [9, 1], [9, 1], [9, 1], [9, 4], [9, 4], [9, 1], [9, 2], [9, 2], [9, 1], [9, 5], [9, 5], [10, 3], [10, 3], [11, 3], [12, 3], [32, 1], [32, 1], [32, 1], [32, 1], [55, 1], [55, 1], [13, 1], [13, 1], [13, 3], [13, 3], [30, 1], [30, 1]],
    performAction: /* @__PURE__ */ x(function(z, F, V, H, J, q, ae) {
      var re = q.length - 1;
      switch (J) {
        case 3:
          return H.setRootDoc(q[re]), q[re];
        case 4:
          this.$ = [];
          break;
        case 5:
          q[re] != "nl" && (q[re - 1].push(q[re]), this.$ = q[re - 1]);
          break;
        case 6:
        case 7:
          this.$ = q[re];
          break;
        case 8:
          this.$ = "nl";
          break;
        case 12:
          this.$ = q[re];
          break;
        case 13:
          const X = q[re - 1];
          X.description = H.trimColon(q[re]), this.$ = X;
          break;
        case 14:
          this.$ = { stmt: "relation", state1: q[re - 2], state2: q[re] };
          break;
        case 15:
          const Y = H.trimColon(q[re]);
          this.$ = { stmt: "relation", state1: q[re - 3], state2: q[re - 1], description: Y };
          break;
        case 19:
          this.$ = { stmt: "state", id: q[re - 3], type: "default", description: "", doc: q[re - 1] };
          break;
        case 20:
          var pe = q[re], K = q[re - 2].trim();
          if (q[re].match(":")) {
            var Z = q[re].split(":");
            pe = Z[0], K = [K, Z[1]];
          }
          this.$ = { stmt: "state", id: pe, type: "default", description: K };
          break;
        case 21:
          this.$ = { stmt: "state", id: q[re - 3], type: "default", description: q[re - 5], doc: q[re - 1] };
          break;
        case 22:
          this.$ = { stmt: "state", id: q[re], type: "fork" };
          break;
        case 23:
          this.$ = { stmt: "state", id: q[re], type: "join" };
          break;
        case 24:
          this.$ = { stmt: "state", id: q[re], type: "choice" };
          break;
        case 25:
          this.$ = { stmt: "state", id: H.getDividerId(), type: "divider" };
          break;
        case 26:
          this.$ = { stmt: "state", id: q[re - 1].trim(), note: { position: q[re - 2].trim(), text: q[re].trim() } };
          break;
        case 29:
          this.$ = q[re].trim(), H.setAccTitle(this.$);
          break;
        case 30:
        case 31:
          this.$ = q[re].trim(), H.setAccDescription(this.$);
          break;
        case 32:
          this.$ = {
            stmt: "click",
            id: q[re - 3],
            url: q[re - 2],
            tooltip: q[re - 1]
          };
          break;
        case 33:
          this.$ = {
            stmt: "click",
            id: q[re - 3],
            url: q[re - 1],
            tooltip: ""
          };
          break;
        case 34:
        case 35:
          this.$ = { stmt: "classDef", id: q[re - 1].trim(), classes: q[re].trim() };
          break;
        case 36:
          this.$ = { stmt: "style", id: q[re - 1].trim(), styleClass: q[re].trim() };
          break;
        case 37:
          this.$ = { stmt: "applyClass", id: q[re - 1].trim(), styleClass: q[re].trim() };
          break;
        case 38:
          H.setDirection("TB"), this.$ = { stmt: "dir", value: "TB" };
          break;
        case 39:
          H.setDirection("BT"), this.$ = { stmt: "dir", value: "BT" };
          break;
        case 40:
          H.setDirection("RL"), this.$ = { stmt: "dir", value: "RL" };
          break;
        case 41:
          H.setDirection("LR"), this.$ = { stmt: "dir", value: "LR" };
          break;
        case 44:
        case 45:
          this.$ = { stmt: "state", id: q[re].trim(), type: "default", description: "" };
          break;
        case 46:
          this.$ = { stmt: "state", id: q[re - 2].trim(), classes: [q[re].trim()], type: "default", description: "" };
          break;
        case 47:
          this.$ = { stmt: "state", id: q[re - 2].trim(), classes: [q[re].trim()], type: "default", description: "" };
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: e, 5: r, 6: n }, { 1: [3] }, { 3: 5, 4: e, 5: r, 6: n }, { 3: 6, 4: e, 5: r, 6: n }, t([1, 4, 5, 16, 17, 19, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 41, 45, 48, 51, 52, 53, 54, 57], i, { 7: 7 }), { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3], 4: a, 5: s, 8: 8, 9: 10, 10: 12, 11: 13, 12: 14, 13: 15, 16: o, 17: l, 19: u, 22: h, 24: d, 25: f, 26: p, 27: g, 28: m, 29: v, 32: 25, 33: y, 35: b, 37: w, 38: T, 41: E, 45: L, 48: k, 51: C, 52: A, 53: R, 54: _, 57: O }, t(P, [2, 5]), { 9: 39, 10: 12, 11: 13, 12: 14, 13: 15, 16: o, 17: l, 19: u, 22: h, 24: d, 25: f, 26: p, 27: g, 28: m, 29: v, 32: 25, 33: y, 35: b, 37: w, 38: T, 41: E, 45: L, 48: k, 51: C, 52: A, 53: R, 54: _, 57: O }, t(P, [2, 7]), t(P, [2, 8]), t(P, [2, 9]), t(P, [2, 10]), t(P, [2, 11]), t(P, [2, 12], { 14: [1, 40], 15: [1, 41] }), t(P, [2, 16]), { 18: [1, 42] }, t(P, [2, 18], { 20: [1, 43] }), { 23: [1, 44] }, t(P, [2, 22]), t(P, [2, 23]), t(P, [2, 24]), t(P, [2, 25]), { 30: 45, 31: [1, 46], 59: [1, 47], 60: [1, 48] }, t(P, [2, 28]), { 34: [1, 49] }, { 36: [1, 50] }, t(P, [2, 31]), { 13: 51, 24: d, 57: O }, { 42: [1, 52], 44: [1, 53] }, { 46: [1, 54] }, { 49: [1, 55] }, t(S, [2, 44], { 58: [1, 56] }), t(S, [2, 45], { 58: [1, 57] }), t(P, [2, 38]), t(P, [2, 39]), t(P, [2, 40]), t(P, [2, 41]), t(P, [2, 6]), t(P, [2, 13]), { 13: 58, 24: d, 57: O }, t(P, [2, 17]), t(M, i, { 7: 59 }), { 24: [1, 60] }, { 24: [1, 61] }, { 23: [1, 62] }, { 24: [2, 48] }, { 24: [2, 49] }, t(P, [2, 29]), t(P, [2, 30]), { 39: [1, 63], 40: [1, 64] }, { 43: [1, 65] }, { 43: [1, 66] }, { 47: [1, 67] }, { 50: [1, 68] }, { 24: [1, 69] }, { 24: [1, 70] }, t(P, [2, 14], { 14: [1, 71] }), { 4: a, 5: s, 8: 8, 9: 10, 10: 12, 11: 13, 12: 14, 13: 15, 16: o, 17: l, 19: u, 21: [1, 72], 22: h, 24: d, 25: f, 26: p, 27: g, 28: m, 29: v, 32: 25, 33: y, 35: b, 37: w, 38: T, 41: E, 45: L, 48: k, 51: C, 52: A, 53: R, 54: _, 57: O }, t(P, [2, 20], { 20: [1, 73] }), { 31: [1, 74] }, { 24: [1, 75] }, { 39: [1, 76] }, { 39: [1, 77] }, t(P, [2, 34]), t(P, [2, 35]), t(P, [2, 36]), t(P, [2, 37]), t(S, [2, 46]), t(S, [2, 47]), t(P, [2, 15]), t(P, [2, 19]), t(M, i, { 7: 78 }), t(P, [2, 26]), t(P, [2, 27]), { 5: [1, 79] }, { 5: [1, 80] }, { 4: a, 5: s, 8: 8, 9: 10, 10: 12, 11: 13, 12: 14, 13: 15, 16: o, 17: l, 19: u, 21: [1, 81], 22: h, 24: d, 25: f, 26: p, 27: g, 28: m, 29: v, 32: 25, 33: y, 35: b, 37: w, 38: T, 41: E, 45: L, 48: k, 51: C, 52: A, 53: R, 54: _, 57: O }, t(P, [2, 32]), t(P, [2, 33]), t(P, [2, 21])],
    defaultActions: { 5: [2, 1], 6: [2, 2], 47: [2, 48], 48: [2, 49] },
    parseError: /* @__PURE__ */ x(function(z, F) {
      if (F.recoverable)
        this.trace(z);
      else {
        var V = new Error(z);
        throw V.hash = F, V;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ x(function(z) {
      var F = this, V = [0], H = [], J = [null], q = [], ae = this.table, re = "", pe = 0, K = 0, Z = 2, X = 1, Y = q.slice.call(arguments, 1), ee = Object.create(this.lexer), j = { yy: {} };
      for (var fe in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, fe) && (j.yy[fe] = this.yy[fe]);
      ee.setInput(z, j.yy), j.yy.lexer = ee, j.yy.parser = this, typeof ee.yylloc > "u" && (ee.yylloc = {});
      var te = ee.yylloc;
      q.push(te);
      var Ae = ee.options && ee.options.ranges;
      typeof j.yy.parseError == "function" ? this.parseError = j.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function W(Ne) {
        V.length = V.length - 2 * Ne, J.length = J.length - Ne, q.length = q.length - Ne;
      }
      x(W, "popStack");
      function De() {
        var Ne;
        return Ne = H.pop() || ee.lex() || X, typeof Ne != "number" && (Ne instanceof Array && (H = Ne, Ne = H.pop()), Ne = F.symbols_[Ne] || Ne), Ne;
      }
      x(De, "lex");
      for (var ue, ze, Ge, Ve, ke = {}, Oe, Se, _e, $e; ; ) {
        if (ze = V[V.length - 1], this.defaultActions[ze] ? Ge = this.defaultActions[ze] : ((ue === null || typeof ue > "u") && (ue = De()), Ge = ae[ze] && ae[ze][ue]), typeof Ge > "u" || !Ge.length || !Ge[0]) {
          var me = "";
          $e = [];
          for (Oe in ae[ze])
            this.terminals_[Oe] && Oe > Z && $e.push("'" + this.terminals_[Oe] + "'");
          ee.showPosition ? me = "Parse error on line " + (pe + 1) + `:
` + ee.showPosition() + `
Expecting ` + $e.join(", ") + ", got '" + (this.terminals_[ue] || ue) + "'" : me = "Parse error on line " + (pe + 1) + ": Unexpected " + (ue == X ? "end of input" : "'" + (this.terminals_[ue] || ue) + "'"), this.parseError(me, {
            text: ee.match,
            token: this.terminals_[ue] || ue,
            line: ee.yylineno,
            loc: te,
            expected: $e
          });
        }
        if (Ge[0] instanceof Array && Ge.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + ze + ", token: " + ue);
        switch (Ge[0]) {
          case 1:
            V.push(ue), J.push(ee.yytext), q.push(ee.yylloc), V.push(Ge[1]), ue = null, K = ee.yyleng, re = ee.yytext, pe = ee.yylineno, te = ee.yylloc;
            break;
          case 2:
            if (Se = this.productions_[Ge[1]][1], ke.$ = J[J.length - Se], ke._$ = {
              first_line: q[q.length - (Se || 1)].first_line,
              last_line: q[q.length - 1].last_line,
              first_column: q[q.length - (Se || 1)].first_column,
              last_column: q[q.length - 1].last_column
            }, Ae && (ke._$.range = [
              q[q.length - (Se || 1)].range[0],
              q[q.length - 1].range[1]
            ]), Ve = this.performAction.apply(ke, [
              re,
              K,
              pe,
              j.yy,
              Ge[1],
              J,
              q
            ].concat(Y)), typeof Ve < "u")
              return Ve;
            Se && (V = V.slice(0, -1 * Se * 2), J = J.slice(0, -1 * Se), q = q.slice(0, -1 * Se)), V.push(this.productions_[Ge[1]][0]), J.push(ke.$), q.push(ke._$), _e = ae[V[V.length - 2]][V[V.length - 1]], V.push(_e);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, D = /* @__PURE__ */ (function() {
    var B = {
      EOF: 1,
      parseError: /* @__PURE__ */ x(function(F, V) {
        if (this.yy.parser)
          this.yy.parser.parseError(F, V);
        else
          throw new Error(F);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ x(function(z, F) {
        return this.yy = F || this.yy || {}, this._input = z, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ x(function() {
        var z = this._input[0];
        this.yytext += z, this.yyleng++, this.offset++, this.match += z, this.matched += z;
        var F = z.match(/(?:\r\n?|\n).*/g);
        return F ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), z;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ x(function(z) {
        var F = z.length, V = z.split(/(?:\r\n?|\n)/g);
        this._input = z + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - F), this.offset -= F;
        var H = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), V.length - 1 && (this.yylineno -= V.length - 1);
        var J = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: V ? (V.length === H.length ? this.yylloc.first_column : 0) + H[H.length - V.length].length - V[0].length : this.yylloc.first_column - F
        }, this.options.ranges && (this.yylloc.range = [J[0], J[0] + this.yyleng - F]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ x(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ x(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ x(function(z) {
        this.unput(this.match.slice(z));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ x(function() {
        var z = this.matched.substr(0, this.matched.length - this.match.length);
        return (z.length > 20 ? "..." : "") + z.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ x(function() {
        var z = this.match;
        return z.length < 20 && (z += this._input.substr(0, 20 - z.length)), (z.substr(0, 20) + (z.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ x(function() {
        var z = this.pastInput(), F = new Array(z.length + 1).join("-");
        return z + this.upcomingInput() + `
` + F + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ x(function(z, F) {
        var V, H, J;
        if (this.options.backtrack_lexer && (J = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (J.yylloc.range = this.yylloc.range.slice(0))), H = z[0].match(/(?:\r\n?|\n).*/g), H && (this.yylineno += H.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: H ? H[H.length - 1].length - H[H.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + z[0].length
        }, this.yytext += z[0], this.match += z[0], this.matches = z, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(z[0].length), this.matched += z[0], V = this.performAction.call(this, this.yy, this, F, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), V)
          return V;
        if (this._backtrack) {
          for (var q in J)
            this[q] = J[q];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ x(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var z, F, V, H;
        this._more || (this.yytext = "", this.match = "");
        for (var J = this._currentRules(), q = 0; q < J.length; q++)
          if (V = this._input.match(this.rules[J[q]]), V && (!F || V[0].length > F[0].length)) {
            if (F = V, H = q, this.options.backtrack_lexer) {
              if (z = this.test_match(V, J[q]), z !== !1)
                return z;
              if (this._backtrack) {
                F = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return F ? (z = this.test_match(F, J[H]), z !== !1 ? z : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ x(function() {
        var F = this.next();
        return F || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ x(function(F) {
        this.conditionStack.push(F);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ x(function() {
        var F = this.conditionStack.length - 1;
        return F > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ x(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ x(function(F) {
        return F = this.conditionStack.length - 1 - Math.abs(F || 0), F >= 0 ? this.conditionStack[F] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ x(function(F) {
        this.begin(F);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ x(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ x(function(F, V, H, J) {
        switch (H) {
          case 0:
            return 38;
          case 1:
            return 40;
          case 2:
            return 39;
          case 3:
            return 44;
          case 4:
            return 51;
          case 5:
            return 52;
          case 6:
            return 53;
          case 7:
            return 54;
          case 8:
            break;
          case 9:
            break;
          case 10:
            return 5;
          case 11:
            break;
          case 12:
            break;
          case 13:
            break;
          case 14:
            break;
          case 15:
            return this.pushState("SCALE"), 17;
          case 16:
            return 18;
          case 17:
            this.popState();
            break;
          case 18:
            return this.begin("acc_title"), 33;
          case 19:
            return this.popState(), "acc_title_value";
          case 20:
            return this.begin("acc_descr"), 35;
          case 21:
            return this.popState(), "acc_descr_value";
          case 22:
            this.begin("acc_descr_multiline");
            break;
          case 23:
            this.popState();
            break;
          case 24:
            return "acc_descr_multiline_value";
          case 25:
            return this.pushState("CLASSDEF"), 41;
          case 26:
            return this.popState(), this.pushState("CLASSDEFID"), "DEFAULT_CLASSDEF_ID";
          case 27:
            return this.popState(), this.pushState("CLASSDEFID"), 42;
          case 28:
            return this.popState(), 43;
          case 29:
            return this.pushState("CLASS"), 48;
          case 30:
            return this.popState(), this.pushState("CLASS_STYLE"), 49;
          case 31:
            return this.popState(), 50;
          case 32:
            return this.pushState("STYLE"), 45;
          case 33:
            return this.popState(), this.pushState("STYLEDEF_STYLES"), 46;
          case 34:
            return this.popState(), 47;
          case 35:
            return this.pushState("SCALE"), 17;
          case 36:
            return 18;
          case 37:
            this.popState();
            break;
          case 38:
            this.pushState("STATE");
            break;
          case 39:
            return this.popState(), V.yytext = V.yytext.slice(0, -8).trim(), 25;
          case 40:
            return this.popState(), V.yytext = V.yytext.slice(0, -8).trim(), 26;
          case 41:
            return this.popState(), V.yytext = V.yytext.slice(0, -10).trim(), 27;
          case 42:
            return this.popState(), V.yytext = V.yytext.slice(0, -8).trim(), 25;
          case 43:
            return this.popState(), V.yytext = V.yytext.slice(0, -8).trim(), 26;
          case 44:
            return this.popState(), V.yytext = V.yytext.slice(0, -10).trim(), 27;
          case 45:
            return 51;
          case 46:
            return 52;
          case 47:
            return 53;
          case 48:
            return 54;
          case 49:
            this.pushState("STATE_STRING");
            break;
          case 50:
            return this.pushState("STATE_ID"), "AS";
          case 51:
            return this.popState(), "ID";
          case 52:
            this.popState();
            break;
          case 53:
            return "STATE_DESCR";
          case 54:
            return 19;
          case 55:
            this.popState();
            break;
          case 56:
            return this.popState(), this.pushState("struct"), 20;
          case 57:
            break;
          case 58:
            return this.popState(), 21;
          case 59:
            break;
          case 60:
            return this.begin("NOTE"), 29;
          case 61:
            return this.popState(), this.pushState("NOTE_ID"), 59;
          case 62:
            return this.popState(), this.pushState("NOTE_ID"), 60;
          case 63:
            this.popState(), this.pushState("FLOATING_NOTE");
            break;
          case 64:
            return this.popState(), this.pushState("FLOATING_NOTE_ID"), "AS";
          case 65:
            break;
          case 66:
            return "NOTE_TEXT";
          case 67:
            return this.popState(), "ID";
          case 68:
            return this.popState(), this.pushState("NOTE_TEXT"), 24;
          case 69:
            return this.popState(), V.yytext = V.yytext.substr(2).trim(), 31;
          case 70:
            return this.popState(), V.yytext = V.yytext.slice(0, -8).trim(), 31;
          case 71:
            return 6;
          case 72:
            return 6;
          case 73:
            return 16;
          case 74:
            return 57;
          case 75:
            return 24;
          case 76:
            return V.yytext = V.yytext.trim(), 14;
          case 77:
            return 15;
          case 78:
            return 28;
          case 79:
            return 58;
          case 80:
            return 5;
          case 81:
            return "INVALID";
        }
      }, "anonymous"),
      rules: [/^(?:click\b)/i, /^(?:href\b)/i, /^(?:"[^"]*")/i, /^(?:default\b)/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:%%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:[\s]+)/i, /^(?:((?!\n)\s)+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:scale\s+)/i, /^(?:\d+)/i, /^(?:\s+width\b)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:classDef\s+)/i, /^(?:DEFAULT\s+)/i, /^(?:\w+\s+)/i, /^(?:[^\n]*)/i, /^(?:class\s+)/i, /^(?:(\w+)+((,\s*\w+)*))/i, /^(?:[^\n]*)/i, /^(?:style\s+)/i, /^(?:[\w,]+\s+)/i, /^(?:[^\n]*)/i, /^(?:scale\s+)/i, /^(?:\d+)/i, /^(?:\s+width\b)/i, /^(?:state\s+)/i, /^(?:.*<<fork>>)/i, /^(?:.*<<join>>)/i, /^(?:.*<<choice>>)/i, /^(?:.*\[\[fork\]\])/i, /^(?:.*\[\[join\]\])/i, /^(?:.*\[\[choice\]\])/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:["])/i, /^(?:\s*as\s+)/i, /^(?:[^\n\{]*)/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[^\n\s\{]+)/i, /^(?:\n)/i, /^(?:\{)/i, /^(?:%%(?!\{)[^\n]*)/i, /^(?:\})/i, /^(?:[\n])/i, /^(?:note\s+)/i, /^(?:left of\b)/i, /^(?:right of\b)/i, /^(?:")/i, /^(?:\s*as\s*)/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[^\n]*)/i, /^(?:\s*[^:\n\s\-]+)/i, /^(?:\s*:[^:\n;]+)/i, /^(?:[\s\S]*?end note\b)/i, /^(?:stateDiagram\s+)/i, /^(?:stateDiagram-v2\s+)/i, /^(?:hide empty description\b)/i, /^(?:\[\*\])/i, /^(?:[^:\n\s\-\{]+)/i, /^(?:\s*:[^:\n;]+)/i, /^(?:-->)/i, /^(?:--)/i, /^(?::::)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { LINE: { rules: [12, 13], inclusive: !1 }, struct: { rules: [12, 13, 25, 29, 32, 38, 45, 46, 47, 48, 57, 58, 59, 60, 74, 75, 76, 77, 78], inclusive: !1 }, FLOATING_NOTE_ID: { rules: [67], inclusive: !1 }, FLOATING_NOTE: { rules: [64, 65, 66], inclusive: !1 }, NOTE_TEXT: { rules: [69, 70], inclusive: !1 }, NOTE_ID: { rules: [68], inclusive: !1 }, NOTE: { rules: [61, 62, 63], inclusive: !1 }, STYLEDEF_STYLEOPTS: { rules: [], inclusive: !1 }, STYLEDEF_STYLES: { rules: [34], inclusive: !1 }, STYLE_IDS: { rules: [], inclusive: !1 }, STYLE: { rules: [33], inclusive: !1 }, CLASS_STYLE: { rules: [31], inclusive: !1 }, CLASS: { rules: [30], inclusive: !1 }, CLASSDEFID: { rules: [28], inclusive: !1 }, CLASSDEF: { rules: [26, 27], inclusive: !1 }, acc_descr_multiline: { rules: [23, 24], inclusive: !1 }, acc_descr: { rules: [21], inclusive: !1 }, acc_title: { rules: [19], inclusive: !1 }, SCALE: { rules: [16, 17, 36, 37], inclusive: !1 }, ALIAS: { rules: [], inclusive: !1 }, STATE_ID: { rules: [51], inclusive: !1 }, STATE_STRING: { rules: [52, 53], inclusive: !1 }, FORK_STATE: { rules: [], inclusive: !1 }, STATE: { rules: [12, 13, 39, 40, 41, 42, 43, 44, 49, 50, 54, 55, 56], inclusive: !1 }, ID: { rules: [12, 13], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 18, 20, 22, 25, 29, 32, 35, 38, 56, 60, 71, 72, 73, 74, 75, 76, 77, 79, 80, 81], inclusive: !0 } }
    };
    return B;
  })();
  N.lexer = D;
  function I() {
    this.yy = {};
  }
  return x(I, "Parser"), I.prototype = N, N.Parser = I, new I();
})();
$6.parser = $6;
var rX = $6, jIe = "TB", nX = "TB", NN = "dir", Oh = "state", Ah = "root", z6 = "relation", KIe = "classDef", ZIe = "style", QIe = "applyClass", ap = "default", iX = "divider", aX = "fill:none", sX = "fill: #333", oX = "c", lX = "text", cX = "normal", G5 = "rect", V5 = "rectWithTitle", JIe = "stateStart", eDe = "stateEnd", IN = "divider", DN = "roundedWithTitle", tDe = "note", rDe = "noteGroup", Kg = "statediagram", nDe = "state", iDe = `${Kg}-${nDe}`, uX = "transition", aDe = "note", sDe = "note-edge", oDe = `${uX} ${sDe}`, lDe = `${Kg}-${aDe}`, cDe = "cluster", uDe = `${Kg}-${cDe}`, hDe = "cluster-alt", dDe = `${Kg}-${hDe}`, hX = "parent", dX = "note", fDe = "state", I7 = "----", pDe = `${I7}${dX}`, ON = `${I7}${hX}`, fX = /* @__PURE__ */ x((t, e = nX) => {
  if (!t.doc)
    return e;
  let r = e;
  for (const n of t.doc)
    n.stmt === "dir" && (r = n.value);
  return r;
}, "getDir"), gDe = /* @__PURE__ */ x(function(t, e) {
  return e.db.getClasses();
}, "getClasses"), mDe = /* @__PURE__ */ x(async function(t, e, r, n) {
  ie.info("REF0:"), ie.info("Drawing state diagram (v2)", e);
  const { securityLevel: i, state: a, layout: s } = we();
  n.db.extract(n.db.getRootDocV2());
  const o = n.db.getData(), l = lf(e, i);
  o.type = n.type, o.layoutAlgorithm = s, o.nodeSpacing = a?.nodeSpacing || 50, o.rankSpacing = a?.rankSpacing || 50, o.markers = ["barb"], o.diagramId = e, await Kd(o, l);
  const u = 8;
  try {
    (typeof n.db.getLinks == "function" ? n.db.getLinks() : /* @__PURE__ */ new Map()).forEach((d, f) => {
      const p = typeof f == "string" ? f : typeof f?.id == "string" ? f.id : "";
      if (!p) {
        ie.warn(" Invalid or missing stateId from key:", JSON.stringify(f));
        return;
      }
      const g = l.node()?.querySelectorAll("g");
      let m;
      if (g?.forEach((w) => {
        w.textContent?.trim() === p && (m = w);
      }), !m) {
        ie.warn(" Could not find node matching text:", p);
        return;
      }
      const v = m.parentNode;
      if (!v) {
        ie.warn(" Node has no parent, cannot wrap:", p);
        return;
      }
      const y = document.createElementNS("http://www.w3.org/2000/svg", "a"), b = d.url.replace(/^"+|"+$/g, "");
      if (y.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", b), y.setAttribute("target", "_blank"), d.tooltip) {
        const w = d.tooltip.replace(/^"+|"+$/g, "");
        y.setAttribute("title", w);
      }
      v.replaceChild(y, m), y.appendChild(m), ie.info(" Wrapped node in <a> tag for:", p, d.url);
    });
  } catch (h) {
    ie.error(" Error injecting clickable links:", h);
  }
  Zt.insertTitle(
    l,
    "statediagramTitleText",
    a?.titleTopMargin ?? 25,
    n.db.getDiagramTitle()
  ), rh(l, u, Kg, a?.useMaxWidth ?? !0);
}, "draw"), vDe = {
  getClasses: gDe,
  draw: mDe,
  getDir: fX
}, vv = /* @__PURE__ */ new Map(), Ll = 0;
function yv(t = "", e = 0, r = "", n = I7) {
  const i = r !== null && r.length > 0 ? `${n}${r}` : "";
  return `${fDe}-${t}${i}-${e}`;
}
x(yv, "stateDomId");
var yDe = /* @__PURE__ */ x((t, e, r, n, i, a, s, o) => {
  ie.trace("items", e), e.forEach((l) => {
    switch (l.stmt) {
      case Oh:
        V0(t, l, r, n, i, a, s, o);
        break;
      case ap:
        V0(t, l, r, n, i, a, s, o);
        break;
      case z6:
        {
          V0(
            t,
            l.state1,
            r,
            n,
            i,
            a,
            s,
            o
          ), V0(
            t,
            l.state2,
            r,
            n,
            i,
            a,
            s,
            o
          );
          const u = {
            id: "edge" + Ll,
            start: l.state1.id,
            end: l.state2.id,
            arrowhead: "normal",
            arrowTypeEnd: "arrow_barb",
            style: aX,
            labelStyle: "",
            label: at.sanitizeText(l.description ?? "", we()),
            arrowheadStyle: sX,
            labelpos: oX,
            labelType: lX,
            thickness: cX,
            classes: uX,
            look: s
          };
          i.push(u), Ll++;
        }
        break;
    }
  });
}, "setupDoc"), PN = /* @__PURE__ */ x((t, e = nX) => {
  let r = e;
  if (t.doc)
    for (const n of t.doc)
      n.stmt === "dir" && (r = n.value);
  return r;
}, "getDir");
function G0(t, e, r) {
  if (!e.id || e.id === "</join></fork>" || e.id === "</choice>")
    return;
  e.cssClasses && (Array.isArray(e.cssCompiledStyles) || (e.cssCompiledStyles = []), e.cssClasses.split(" ").forEach((i) => {
    const a = r.get(i);
    a && (e.cssCompiledStyles = [...e.cssCompiledStyles ?? [], ...a.styles]);
  }));
  const n = t.find((i) => i.id === e.id);
  n ? Object.assign(n, e) : t.push(e);
}
x(G0, "insertOrUpdateNode");
function pX(t) {
  return t?.classes?.join(" ") ?? "";
}
x(pX, "getClassesFromDbInfo");
function gX(t) {
  return t?.styles ?? [];
}
x(gX, "getStylesFromDbInfo");
var V0 = /* @__PURE__ */ x((t, e, r, n, i, a, s, o) => {
  const l = e.id, u = r.get(l), h = pX(u), d = gX(u), f = we();
  if (ie.info("dataFetcher parsedItem", e, u, d), l !== "root") {
    let p = G5;
    e.start === !0 ? p = JIe : e.start === !1 && (p = eDe), e.type !== ap && (p = e.type), vv.get(l) || vv.set(l, {
      id: l,
      shape: p,
      description: at.sanitizeText(l, f),
      cssClasses: `${h} ${iDe}`,
      cssStyles: d
    });
    const g = vv.get(l);
    e.description && (Array.isArray(g.description) ? (g.shape = V5, g.description.push(e.description)) : g.description?.length && g.description.length > 0 ? (g.shape = V5, g.description === l ? g.description = [e.description] : g.description = [g.description, e.description]) : (g.shape = G5, g.description = e.description), g.description = at.sanitizeTextOrArray(g.description, f)), g.description?.length === 1 && g.shape === V5 && (g.type === "group" ? g.shape = DN : g.shape = G5), !g.type && e.doc && (ie.info("Setting cluster for XCX", l, PN(e)), g.type = "group", g.isGroup = !0, g.dir = PN(e), g.shape = e.type === iX ? IN : DN, g.cssClasses = `${g.cssClasses} ${uDe} ${a ? dDe : ""}`);
    const m = {
      labelStyle: "",
      shape: g.shape,
      label: g.description,
      cssClasses: g.cssClasses,
      cssCompiledStyles: [],
      cssStyles: g.cssStyles,
      id: l,
      dir: g.dir,
      domId: yv(l, Ll),
      type: g.type,
      isGroup: g.type === "group",
      padding: 8,
      rx: 10,
      ry: 10,
      look: s
    };
    if (m.shape === IN && (m.label = ""), t && t.id !== "root" && (ie.trace("Setting node ", l, " to be child of its parent ", t.id), m.parentId = t.id), m.centerLabel = !0, e.note) {
      const v = {
        labelStyle: "",
        shape: tDe,
        label: e.note.text,
        cssClasses: lDe,
        // useHtmlLabels: false,
        cssStyles: [],
        cssCompiledStyles: [],
        id: l + pDe + "-" + Ll,
        domId: yv(l, Ll, dX),
        type: g.type,
        isGroup: g.type === "group",
        padding: f.flowchart?.padding,
        look: s,
        position: e.note.position
      }, y = l + ON, b = {
        labelStyle: "",
        shape: rDe,
        label: e.note.text,
        cssClasses: g.cssClasses,
        cssStyles: [],
        id: l + ON,
        domId: yv(l, Ll, hX),
        type: "group",
        isGroup: !0,
        padding: 16,
        //getConfig().flowchart.padding
        look: s,
        position: e.note.position
      };
      Ll++, b.id = y, v.parentId = y, G0(n, b, o), G0(n, v, o), G0(n, m, o);
      let w = l, T = v.id;
      e.note.position === "left of" && (w = v.id, T = l), i.push({
        id: w + "-" + T,
        start: w,
        end: T,
        arrowhead: "none",
        arrowTypeEnd: "",
        style: aX,
        labelStyle: "",
        classes: oDe,
        arrowheadStyle: sX,
        labelpos: oX,
        labelType: lX,
        thickness: cX,
        look: s
      });
    } else
      G0(n, m, o);
  }
  e.doc && (ie.trace("Adding nodes children "), yDe(e, e.doc, r, n, i, !a, s, o));
}, "dataFetcher"), xDe = /* @__PURE__ */ x(() => {
  vv.clear(), Ll = 0;
}, "reset"), Ii = {
  START_NODE: "[*]",
  START_TYPE: "start",
  END_NODE: "[*]",
  END_TYPE: "end",
  COLOR_KEYWORD: "color",
  FILL_KEYWORD: "fill",
  BG_FILL: "bgFill",
  STYLECLASS_SEP: ","
}, BN = /* @__PURE__ */ x(() => /* @__PURE__ */ new Map(), "newClassesList"), FN = /* @__PURE__ */ x(() => ({
  relations: [],
  states: /* @__PURE__ */ new Map(),
  documents: {}
}), "newDoc"), hm = /* @__PURE__ */ x((t) => JSON.parse(JSON.stringify(t)), "clone"), Jc = class {
  constructor(t) {
    this.version = t, this.nodes = [], this.edges = [], this.rootDoc = [], this.classes = BN(), this.documents = { root: FN() }, this.currentDocument = this.documents.root, this.startEndCount = 0, this.dividerCnt = 0, this.links = /* @__PURE__ */ new Map(), this.getAccTitle = Gn, this.setAccTitle = Cn, this.getAccDescription = Un, this.setAccDescription = Vn, this.setDiagramTitle = Zn, this.getDiagramTitle = Ln, this.clear(), this.setRootDoc = this.setRootDoc.bind(this), this.getDividerId = this.getDividerId.bind(this), this.setDirection = this.setDirection.bind(this), this.trimColon = this.trimColon.bind(this);
  }
  static {
    x(this, "StateDB");
  }
  static {
    this.relationType = {
      AGGREGATION: 0,
      EXTENSION: 1,
      COMPOSITION: 2,
      DEPENDENCY: 3
    };
  }
  /**
   * Convert all of the statements (stmts) that were parsed into states and relationships.
   * This is done because a state diagram may have nested sections,
   * where each section is a 'document' and has its own set of statements.
   * Ex: the section within a fork has its own statements, and incoming and outgoing statements
   * refer to the fork as a whole (document).
   * See the parser grammar:  the definition of a document is a document then a 'line', where a line can be a statement.
   * This will push the statement into the list of statements for the current document.
   */
  extract(t) {
    this.clear(!0);
    for (const n of Array.isArray(t) ? t : t.doc)
      switch (n.stmt) {
        case Oh:
          this.addState(n.id.trim(), n.type, n.doc, n.description, n.note);
          break;
        case z6:
          this.addRelation(n.state1, n.state2, n.description);
          break;
        case KIe:
          this.addStyleClass(n.id.trim(), n.classes);
          break;
        case ZIe:
          this.handleStyleDef(n);
          break;
        case QIe:
          this.setCssClass(n.id.trim(), n.styleClass);
          break;
        case "click":
          this.addLink(n.id, n.url, n.tooltip);
          break;
      }
    const e = this.getStates(), r = we();
    xDe(), V0(
      void 0,
      this.getRootDocV2(),
      e,
      this.nodes,
      this.edges,
      !0,
      r.look,
      this.classes
    );
    for (const n of this.nodes)
      if (Array.isArray(n.label)) {
        if (n.description = n.label.slice(1), n.isGroup && n.description.length > 0)
          throw new Error(
            `Group nodes can only have label. Remove the additional description for node [${n.id}]`
          );
        n.label = n.label[0];
      }
  }
  handleStyleDef(t) {
    const e = t.id.trim().split(","), r = t.styleClass.split(",");
    for (const n of e) {
      let i = this.getState(n);
      if (!i) {
        const a = n.trim();
        this.addState(a), i = this.getState(a);
      }
      i && (i.styles = r.map((a) => a.replace(/;/g, "")?.trim()));
    }
  }
  setRootDoc(t) {
    ie.info("Setting root doc", t), this.rootDoc = t, this.version === 1 ? this.extract(t) : this.extract(this.getRootDocV2());
  }
  docTranslator(t, e, r) {
    if (e.stmt === z6) {
      this.docTranslator(t, e.state1, !0), this.docTranslator(t, e.state2, !1);
      return;
    }
    if (e.stmt === Oh && (e.id === Ii.START_NODE ? (e.id = t.id + (r ? "_start" : "_end"), e.start = r) : e.id = e.id.trim()), e.stmt !== Ah && e.stmt !== Oh || !e.doc)
      return;
    const n = [];
    let i = [];
    for (const a of e.doc)
      if (a.type === iX) {
        const s = hm(a);
        s.doc = hm(i), n.push(s), i = [];
      } else
        i.push(a);
    if (n.length > 0 && i.length > 0) {
      const a = {
        stmt: Oh,
        id: cB(),
        type: "divider",
        doc: hm(i)
      };
      n.push(hm(a)), e.doc = n;
    }
    e.doc.forEach((a) => this.docTranslator(e, a, !0));
  }
  getRootDocV2() {
    return this.docTranslator(
      { id: Ah, stmt: Ah },
      { id: Ah, stmt: Ah, doc: this.rootDoc },
      !0
    ), { id: Ah, doc: this.rootDoc };
  }
  /**
   * Function called by parser when a node definition has been found.
   *
   * @param descr - description for the state. Can be a string or a list or strings
   * @param classes - class styles to apply to this state. Can be a string (1 style) or an array of styles. If it's just 1 class, convert it to an array of that 1 class.
   * @param styles - styles to apply to this state. Can be a string (1 style) or an array of styles. If it's just 1 style, convert it to an array of that 1 style.
   * @param textStyles - text styles to apply to this state. Can be a string (1 text test) or an array of text styles. If it's just 1 text style, convert it to an array of that 1 text style.
   */
  addState(t, e = ap, r = void 0, n = void 0, i = void 0, a = void 0, s = void 0, o = void 0) {
    const l = t?.trim();
    if (!this.currentDocument.states.has(l))
      ie.info("Adding state ", l, n), this.currentDocument.states.set(l, {
        stmt: Oh,
        id: l,
        descriptions: [],
        type: e,
        doc: r,
        note: i,
        classes: [],
        styles: [],
        textStyles: []
      });
    else {
      const u = this.currentDocument.states.get(l);
      if (!u)
        throw new Error(`State not found: ${l}`);
      u.doc || (u.doc = r), u.type || (u.type = e);
    }
    if (n && (ie.info("Setting state description", l, n), (Array.isArray(n) ? n : [n]).forEach((h) => this.addDescription(l, h.trim()))), i) {
      const u = this.currentDocument.states.get(l);
      if (!u)
        throw new Error(`State not found: ${l}`);
      u.note = i, u.note.text = at.sanitizeText(u.note.text, we());
    }
    a && (ie.info("Setting state classes", l, a), (Array.isArray(a) ? a : [a]).forEach((h) => this.setCssClass(l, h.trim()))), s && (ie.info("Setting state styles", l, s), (Array.isArray(s) ? s : [s]).forEach((h) => this.setStyle(l, h.trim()))), o && (ie.info("Setting state styles", l, s), (Array.isArray(o) ? o : [o]).forEach((h) => this.setTextStyle(l, h.trim())));
  }
  clear(t) {
    this.nodes = [], this.edges = [], this.documents = { root: FN() }, this.currentDocument = this.documents.root, this.startEndCount = 0, this.classes = BN(), t || (this.links = /* @__PURE__ */ new Map(), _n());
  }
  getState(t) {
    return this.currentDocument.states.get(t);
  }
  getStates() {
    return this.currentDocument.states;
  }
  logDocuments() {
    ie.info("Documents = ", this.documents);
  }
  getRelations() {
    return this.currentDocument.relations;
  }
  /**
   * Adds a clickable link to a state.
   */
  addLink(t, e, r) {
    this.links.set(t, { url: e, tooltip: r }), ie.warn("Adding link", t, e, r);
  }
  /**
   * Get all registered links.
   */
  getLinks() {
    return this.links;
  }
  /**
   * If the id is a start node ( [*] ), then return a new id constructed from
   * the start node name and the current start node count.
   * else return the given id
   */
  startIdIfNeeded(t = "") {
    return t === Ii.START_NODE ? (this.startEndCount++, `${Ii.START_TYPE}${this.startEndCount}`) : t;
  }
  /**
   * If the id is a start node ( [*] ), then return the start type ('start')
   * else return the given type
   */
  startTypeIfNeeded(t = "", e = ap) {
    return t === Ii.START_NODE ? Ii.START_TYPE : e;
  }
  /**
   * If the id is an end node ( [*] ), then return a new id constructed from
   * the end node name and the current start_end node count.
   * else return the given id
   */
  endIdIfNeeded(t = "") {
    return t === Ii.END_NODE ? (this.startEndCount++, `${Ii.END_TYPE}${this.startEndCount}`) : t;
  }
  /**
   * If the id is an end node ( [*] ), then return the end type
   * else return the given type
   *
   */
  endTypeIfNeeded(t = "", e = ap) {
    return t === Ii.END_NODE ? Ii.END_TYPE : e;
  }
  addRelationObjs(t, e, r = "") {
    const n = this.startIdIfNeeded(t.id.trim()), i = this.startTypeIfNeeded(t.id.trim(), t.type), a = this.startIdIfNeeded(e.id.trim()), s = this.startTypeIfNeeded(e.id.trim(), e.type);
    this.addState(
      n,
      i,
      t.doc,
      t.description,
      t.note,
      t.classes,
      t.styles,
      t.textStyles
    ), this.addState(
      a,
      s,
      e.doc,
      e.description,
      e.note,
      e.classes,
      e.styles,
      e.textStyles
    ), this.currentDocument.relations.push({
      id1: n,
      id2: a,
      relationTitle: at.sanitizeText(r, we())
    });
  }
  /**
   * Add a relation between two items.  The items may be full objects or just the string id of a state.
   */
  addRelation(t, e, r) {
    if (typeof t == "object" && typeof e == "object")
      this.addRelationObjs(t, e, r);
    else if (typeof t == "string" && typeof e == "string") {
      const n = this.startIdIfNeeded(t.trim()), i = this.startTypeIfNeeded(t), a = this.endIdIfNeeded(e.trim()), s = this.endTypeIfNeeded(e);
      this.addState(n, i), this.addState(a, s), this.currentDocument.relations.push({
        id1: n,
        id2: a,
        relationTitle: r ? at.sanitizeText(r, we()) : void 0
      });
    }
  }
  addDescription(t, e) {
    const r = this.currentDocument.states.get(t), n = e.startsWith(":") ? e.replace(":", "").trim() : e;
    r?.descriptions?.push(at.sanitizeText(n, we()));
  }
  cleanupLabel(t) {
    return t.startsWith(":") ? t.slice(2).trim() : t.trim();
  }
  getDividerId() {
    return this.dividerCnt++, `divider-id-${this.dividerCnt}`;
  }
  /**
   * Called when the parser comes across a (style) class definition
   * @example classDef my-style fill:#f96;
   *
   * @param id - the id of this (style) class
   * @param styleAttributes - the string with 1 or more style attributes (each separated by a comma)
   */
  addStyleClass(t, e = "") {
    this.classes.has(t) || this.classes.set(t, { id: t, styles: [], textStyles: [] });
    const r = this.classes.get(t);
    e && r && e.split(Ii.STYLECLASS_SEP).forEach((n) => {
      const i = n.replace(/([^;]*);/, "$1").trim();
      if (RegExp(Ii.COLOR_KEYWORD).exec(n)) {
        const s = i.replace(Ii.FILL_KEYWORD, Ii.BG_FILL).replace(Ii.COLOR_KEYWORD, Ii.FILL_KEYWORD);
        r.textStyles.push(s);
      }
      r.styles.push(i);
    });
  }
  getClasses() {
    return this.classes;
  }
  /**
   * Add a (style) class or css class to a state with the given id.
   * If the state isn't already in the list of known states, add it.
   * Might be called by parser when a style class or CSS class should be applied to a state
   *
   * @param itemIds - The id or a list of ids of the item(s) to apply the css class to
   * @param cssClassName - CSS class name
   */
  setCssClass(t, e) {
    t.split(",").forEach((r) => {
      let n = this.getState(r);
      if (!n) {
        const i = r.trim();
        this.addState(i), n = this.getState(i);
      }
      n?.classes?.push(e);
    });
  }
  /**
   * Add a style to a state with the given id.
   * @example style stateId fill:#f9f,stroke:#333,stroke-width:4px
   *   where 'style' is the keyword
   *   stateId is the id of a state
   *   the rest of the string is the styleText (all of the attributes to be applied to the state)
   *
   * @param itemId - The id of item to apply the style to
   * @param styleText - the text of the attributes for the style
   */
  setStyle(t, e) {
    this.getState(t)?.styles?.push(e);
  }
  /**
   * Add a text style to a state with the given id
   *
   * @param itemId - The id of item to apply the css class to
   * @param cssClassName - CSS class name
   */
  setTextStyle(t, e) {
    this.getState(t)?.textStyles?.push(e);
  }
  /**
   * Finds the direction statement in the root document.
   * @returns the direction statement if present
   */
  getDirectionStatement() {
    return this.rootDoc.find((t) => t.stmt === NN);
  }
  getDirection() {
    return this.getDirectionStatement()?.value ?? jIe;
  }
  setDirection(t) {
    const e = this.getDirectionStatement();
    e ? e.value = t : this.rootDoc.unshift({ stmt: NN, value: t });
  }
  trimColon(t) {
    return t.startsWith(":") ? t.slice(1).trim() : t.trim();
  }
  getData() {
    const t = we();
    return {
      nodes: this.nodes,
      edges: this.edges,
      other: {},
      config: t,
      direction: fX(this.getRootDocV2())
    };
  }
  getConfig() {
    return we().state;
  }
}, bDe = /* @__PURE__ */ x((t) => `
defs #statediagram-barbEnd {
    fill: ${t.transitionColor};
    stroke: ${t.transitionColor};
  }
g.stateGroup text {
  fill: ${t.nodeBorder};
  stroke: none;
  font-size: 10px;
}
g.stateGroup text {
  fill: ${t.textColor};
  stroke: none;
  font-size: 10px;

}
g.stateGroup .state-title {
  font-weight: bolder;
  fill: ${t.stateLabelColor};
}

g.stateGroup rect {
  fill: ${t.mainBkg};
  stroke: ${t.nodeBorder};
}

g.stateGroup line {
  stroke: ${t.lineColor};
  stroke-width: 1;
}

.transition {
  stroke: ${t.transitionColor};
  stroke-width: 1;
  fill: none;
}

.stateGroup .composit {
  fill: ${t.background};
  border-bottom: 1px
}

.stateGroup .alt-composit {
  fill: #e0e0e0;
  border-bottom: 1px
}

.state-note {
  stroke: ${t.noteBorderColor};
  fill: ${t.noteBkgColor};

  text {
    fill: ${t.noteTextColor};
    stroke: none;
    font-size: 10px;
  }
}

.stateLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${t.mainBkg};
  opacity: 0.5;
}

.edgeLabel .label rect {
  fill: ${t.labelBackgroundColor};
  opacity: 0.5;
}
.edgeLabel {
  background-color: ${t.edgeLabelBackground};
  p {
    background-color: ${t.edgeLabelBackground};
  }
  rect {
    opacity: 0.5;
    background-color: ${t.edgeLabelBackground};
    fill: ${t.edgeLabelBackground};
  }
  text-align: center;
}
.edgeLabel .label text {
  fill: ${t.transitionLabelColor || t.tertiaryTextColor};
}
.label div .edgeLabel {
  color: ${t.transitionLabelColor || t.tertiaryTextColor};
}

.stateLabel text {
  fill: ${t.stateLabelColor};
  font-size: 10px;
  font-weight: bold;
}

.node circle.state-start {
  fill: ${t.specialStateColor};
  stroke: ${t.specialStateColor};
}

.node .fork-join {
  fill: ${t.specialStateColor};
  stroke: ${t.specialStateColor};
}

.node circle.state-end {
  fill: ${t.innerEndBackground};
  stroke: ${t.background};
  stroke-width: 1.5
}
.end-state-inner {
  fill: ${t.compositeBackground || t.background};
  // stroke: ${t.background};
  stroke-width: 1.5
}

.node rect {
  fill: ${t.stateBkg || t.mainBkg};
  stroke: ${t.stateBorder || t.nodeBorder};
  stroke-width: 1px;
}
.node polygon {
  fill: ${t.mainBkg};
  stroke: ${t.stateBorder || t.nodeBorder};;
  stroke-width: 1px;
}
#statediagram-barbEnd {
  fill: ${t.lineColor};
}

.statediagram-cluster rect {
  fill: ${t.compositeTitleBackground};
  stroke: ${t.stateBorder || t.nodeBorder};
  stroke-width: 1px;
}

.cluster-label, .nodeLabel {
  color: ${t.stateLabelColor};
  // line-height: 1;
}

.statediagram-cluster rect.outer {
  rx: 5px;
  ry: 5px;
}
.statediagram-state .divider {
  stroke: ${t.stateBorder || t.nodeBorder};
}

.statediagram-state .title-state {
  rx: 5px;
  ry: 5px;
}
.statediagram-cluster.statediagram-cluster .inner {
  fill: ${t.compositeBackground || t.background};
}
.statediagram-cluster.statediagram-cluster-alt .inner {
  fill: ${t.altBackground ? t.altBackground : "#efefef"};
}

.statediagram-cluster .inner {
  rx:0;
  ry:0;
}

.statediagram-state rect.basic {
  rx: 5px;
  ry: 5px;
}
.statediagram-state rect.divider {
  stroke-dasharray: 10,10;
  fill: ${t.altBackground ? t.altBackground : "#efefef"};
}

.note-edge {
  stroke-dasharray: 5;
}

.statediagram-note rect {
  fill: ${t.noteBkgColor};
  stroke: ${t.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}
.statediagram-note rect {
  fill: ${t.noteBkgColor};
  stroke: ${t.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}

.statediagram-note text {
  fill: ${t.noteTextColor};
}

.statediagram-note .nodeLabel {
  color: ${t.noteTextColor};
}
.statediagram .edgeLabel {
  color: red; // ${t.noteTextColor};
}

#dependencyStart, #dependencyEnd {
  fill: ${t.lineColor};
  stroke: ${t.lineColor};
  stroke-width: 1;
}

.statediagramTitleText {
  text-anchor: middle;
  font-size: 18px;
  fill: ${t.textColor};
}
`, "getStyles"), mX = bDe, wDe = /* @__PURE__ */ x((t) => t.append("circle").attr("class", "start-state").attr("r", we().state.sizeUnit).attr("cx", we().state.padding + we().state.sizeUnit).attr("cy", we().state.padding + we().state.sizeUnit), "drawStartState"), TDe = /* @__PURE__ */ x((t) => t.append("line").style("stroke", "grey").style("stroke-dasharray", "3").attr("x1", we().state.textHeight).attr("class", "divider").attr("x2", we().state.textHeight * 2).attr("y1", 0).attr("y2", 0), "drawDivider"), EDe = /* @__PURE__ */ x((t, e) => {
  const r = t.append("text").attr("x", 2 * we().state.padding).attr("y", we().state.textHeight + 2 * we().state.padding).attr("font-size", we().state.fontSize).attr("class", "state-title").text(e.id), n = r.node().getBBox();
  return t.insert("rect", ":first-child").attr("x", we().state.padding).attr("y", we().state.padding).attr("width", n.width + 2 * we().state.padding).attr("height", n.height + 2 * we().state.padding).attr("rx", we().state.radius), r;
}, "drawSimpleState"), kDe = /* @__PURE__ */ x((t, e) => {
  const r = /* @__PURE__ */ x(function(f, p, g) {
    const m = f.append("tspan").attr("x", 2 * we().state.padding).text(p);
    g || m.attr("dy", we().state.textHeight);
  }, "addTspan"), i = t.append("text").attr("x", 2 * we().state.padding).attr("y", we().state.textHeight + 1.3 * we().state.padding).attr("font-size", we().state.fontSize).attr("class", "state-title").text(e.descriptions[0]).node().getBBox(), a = i.height, s = t.append("text").attr("x", we().state.padding).attr(
    "y",
    a + we().state.padding * 0.4 + we().state.dividerMargin + we().state.textHeight
  ).attr("class", "state-description");
  let o = !0, l = !0;
  e.descriptions.forEach(function(f) {
    o || (r(s, f, l), l = !1), o = !1;
  });
  const u = t.append("line").attr("x1", we().state.padding).attr("y1", we().state.padding + a + we().state.dividerMargin / 2).attr("y2", we().state.padding + a + we().state.dividerMargin / 2).attr("class", "descr-divider"), h = s.node().getBBox(), d = Math.max(h.width, i.width);
  return u.attr("x2", d + 3 * we().state.padding), t.insert("rect", ":first-child").attr("x", we().state.padding).attr("y", we().state.padding).attr("width", d + 2 * we().state.padding).attr("height", h.height + a + 2 * we().state.padding).attr("rx", we().state.radius), t;
}, "drawDescrState"), SDe = /* @__PURE__ */ x((t, e, r) => {
  const n = we().state.padding, i = 2 * we().state.padding, a = t.node().getBBox(), s = a.width, o = a.x, l = t.append("text").attr("x", 0).attr("y", we().state.titleShift).attr("font-size", we().state.fontSize).attr("class", "state-title").text(e.id), h = l.node().getBBox().width + i;
  let d = Math.max(h, s);
  d === s && (d = d + i);
  let f;
  const p = t.node().getBBox();
  e.doc, f = o - n, h > s && (f = (s - d) / 2 + n), Math.abs(o - p.x) < n && h > s && (f = o - (h - s) / 2);
  const g = 1 - we().state.textHeight;
  return t.insert("rect", ":first-child").attr("x", f).attr("y", g).attr("class", r ? "alt-composit" : "composit").attr("width", d).attr(
    "height",
    p.height + we().state.textHeight + we().state.titleShift + 1
  ).attr("rx", "0"), l.attr("x", f + n), h <= s && l.attr("x", o + (d - i) / 2 - h / 2 + n), t.insert("rect", ":first-child").attr("x", f).attr(
    "y",
    we().state.titleShift - we().state.textHeight - we().state.padding
  ).attr("width", d).attr("height", we().state.textHeight * 3).attr("rx", we().state.radius), t.insert("rect", ":first-child").attr("x", f).attr(
    "y",
    we().state.titleShift - we().state.textHeight - we().state.padding
  ).attr("width", d).attr("height", p.height + 3 + 2 * we().state.textHeight).attr("rx", we().state.radius), t;
}, "addTitleAndBox"), CDe = /* @__PURE__ */ x((t) => (t.append("circle").attr("class", "end-state-outer").attr("r", we().state.sizeUnit + we().state.miniPadding).attr(
  "cx",
  we().state.padding + we().state.sizeUnit + we().state.miniPadding
).attr(
  "cy",
  we().state.padding + we().state.sizeUnit + we().state.miniPadding
), t.append("circle").attr("class", "end-state-inner").attr("r", we().state.sizeUnit).attr("cx", we().state.padding + we().state.sizeUnit + 2).attr("cy", we().state.padding + we().state.sizeUnit + 2)), "drawEndState"), ADe = /* @__PURE__ */ x((t, e) => {
  let r = we().state.forkWidth, n = we().state.forkHeight;
  if (e.parentId) {
    let i = r;
    r = n, n = i;
  }
  return t.append("rect").style("stroke", "black").style("fill", "black").attr("width", r).attr("height", n).attr("x", we().state.padding).attr("y", we().state.padding);
}, "drawForkJoinState"), _De = /* @__PURE__ */ x((t, e, r, n) => {
  let i = 0;
  const a = n.append("text");
  a.style("text-anchor", "start"), a.attr("class", "noteText");
  let s = t.replace(/\r\n/g, "<br/>");
  s = s.replace(/\n/g, "<br/>");
  const o = s.split(at.lineBreakRegex);
  let l = 1.25 * we().state.noteMargin;
  for (const u of o) {
    const h = u.trim();
    if (h.length > 0) {
      const d = a.append("tspan");
      if (d.text(h), l === 0) {
        const f = d.node().getBBox();
        l += f.height;
      }
      i += l, d.attr("x", e + we().state.noteMargin), d.attr("y", r + i + 1.25 * we().state.noteMargin);
    }
  }
  return { textWidth: a.node().getBBox().width, textHeight: i };
}, "_drawLongText"), LDe = /* @__PURE__ */ x((t, e) => {
  e.attr("class", "state-note");
  const r = e.append("rect").attr("x", 0).attr("y", we().state.padding), n = e.append("g"), { textWidth: i, textHeight: a } = _De(t, 0, 0, n);
  return r.attr("height", a + 2 * we().state.noteMargin), r.attr("width", i + we().state.noteMargin * 2), r;
}, "drawNote"), $N = /* @__PURE__ */ x(function(t, e) {
  const r = e.id, n = {
    id: r,
    label: e.id,
    width: 0,
    height: 0
  }, i = t.append("g").attr("id", r).attr("class", "stateGroup");
  e.type === "start" && wDe(i), e.type === "end" && CDe(i), (e.type === "fork" || e.type === "join") && ADe(i, e), e.type === "note" && LDe(e.note.text, i), e.type === "divider" && TDe(i), e.type === "default" && e.descriptions.length === 0 && EDe(i, e), e.type === "default" && e.descriptions.length > 0 && kDe(i, e);
  const a = i.node().getBBox();
  return n.width = a.width + 2 * we().state.padding, n.height = a.height + 2 * we().state.padding, n;
}, "drawState"), zN = 0, RDe = /* @__PURE__ */ x(function(t, e, r) {
  const n = /* @__PURE__ */ x(function(l) {
    switch (l) {
      case Jc.relationType.AGGREGATION:
        return "aggregation";
      case Jc.relationType.EXTENSION:
        return "extension";
      case Jc.relationType.COMPOSITION:
        return "composition";
      case Jc.relationType.DEPENDENCY:
        return "dependency";
    }
  }, "getRelationType");
  e.points = e.points.filter((l) => !Number.isNaN(l.y));
  const i = e.points, a = gp().x(function(l) {
    return l.x;
  }).y(function(l) {
    return l.y;
  }).curve(jh), s = t.append("path").attr("d", a(i)).attr("id", "edge" + zN).attr("class", "transition");
  let o = "";
  if (we().state.arrowMarkerAbsolute && (o = I2(!0)), s.attr(
    "marker-end",
    "url(" + o + "#" + n(Jc.relationType.DEPENDENCY) + "End)"
  ), r.title !== void 0) {
    const l = t.append("g").attr("class", "stateLabel"), { x: u, y: h } = Zt.calcLabelPosition(e.points), d = at.getRows(r.title);
    let f = 0;
    const p = [];
    let g = 0, m = 0;
    for (let b = 0; b <= d.length; b++) {
      const w = l.append("text").attr("text-anchor", "middle").text(d[b]).attr("x", u).attr("y", h + f), T = w.node().getBBox();
      g = Math.max(g, T.width), m = Math.min(m, T.x), ie.info(T.x, u, h + f), f === 0 && (f = w.node().getBBox().height, ie.info("Title height", f, h)), p.push(w);
    }
    let v = f * d.length;
    if (d.length > 1) {
      const b = (d.length - 1) * f * 0.5;
      p.forEach((w, T) => w.attr("y", h + T * f - b)), v = f * d.length;
    }
    const y = l.node().getBBox();
    l.insert("rect", ":first-child").attr("class", "box").attr("x", u - g / 2 - we().state.padding / 2).attr("y", h - v / 2 - we().state.padding / 2 - 3.5).attr("width", g + we().state.padding).attr("height", v + we().state.padding), ie.info(y);
  }
  zN++;
}, "drawEdge"), xa, U5 = {}, MDe = /* @__PURE__ */ x(function() {
}, "setConf"), NDe = /* @__PURE__ */ x(function(t) {
  t.append("defs").append("marker").attr("id", "dependencyEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
}, "insertMarkers"), IDe = /* @__PURE__ */ x(function(t, e, r, n) {
  xa = we().state;
  const i = we().securityLevel;
  let a;
  i === "sandbox" && (a = Qe("#i" + e));
  const s = Qe(i === "sandbox" ? a.nodes()[0].contentDocument.body : "body"), o = i === "sandbox" ? a.nodes()[0].contentDocument : document;
  ie.debug("Rendering diagram " + t);
  const l = s.select(`[id='${e}']`);
  NDe(l);
  const u = n.db.getRootDoc();
  vX(u, l, void 0, !1, s, o, n);
  const h = xa.padding, d = l.node().getBBox(), f = d.width + h * 2, p = d.height + h * 2, g = f * 1.75;
  Xi(l, p, g, xa.useMaxWidth), l.attr(
    "viewBox",
    `${d.x - xa.padding}  ${d.y - xa.padding} ` + f + " " + p
  );
}, "draw"), DDe = /* @__PURE__ */ x((t) => t ? t.length * xa.fontSizeFactor : 1, "getLabelWidth"), vX = /* @__PURE__ */ x((t, e, r, n, i, a, s) => {
  const o = new fa({
    compound: !0,
    multigraph: !0
  });
  let l, u = !0;
  for (l = 0; l < t.length; l++)
    if (t[l].stmt === "relation") {
      u = !1;
      break;
    }
  r ? o.setGraph({
    rankdir: "LR",
    multigraph: !0,
    compound: !0,
    // acyclicer: 'greedy',
    ranker: "tight-tree",
    ranksep: u ? 1 : xa.edgeLengthFactor,
    nodeSep: u ? 1 : 50,
    isMultiGraph: !0
    // ranksep: 5,
    // nodesep: 1
  }) : o.setGraph({
    rankdir: "TB",
    multigraph: !0,
    compound: !0,
    // isCompound: true,
    // acyclicer: 'greedy',
    // ranker: 'longest-path'
    ranksep: u ? 1 : xa.edgeLengthFactor,
    nodeSep: u ? 1 : 50,
    ranker: "tight-tree",
    // ranker: 'network-simplex'
    isMultiGraph: !0
  }), o.setDefaultEdgeLabel(function() {
    return {};
  });
  const h = s.db.getStates(), d = s.db.getRelations(), f = Object.keys(h);
  for (const y of f) {
    const b = h[y];
    r && (b.parentId = r);
    let w;
    if (b.doc) {
      let T = e.append("g").attr("id", b.id).attr("class", "stateGroup");
      w = vX(b.doc, T, b.id, !n, i, a, s);
      {
        T = SDe(T, b, n);
        let E = T.node().getBBox();
        w.width = E.width, w.height = E.height + xa.padding / 2, U5[b.id] = { y: xa.compositTitleSize };
      }
    } else
      w = $N(e, b, o);
    if (b.note) {
      const T = {
        descriptions: [],
        id: b.id + "-note",
        note: b.note,
        type: "note"
      }, E = $N(e, T, o);
      b.note.position === "left of" ? (o.setNode(w.id + "-note", E), o.setNode(w.id, w)) : (o.setNode(w.id, w), o.setNode(w.id + "-note", E)), o.setParent(w.id, w.id + "-group"), o.setParent(w.id + "-note", w.id + "-group");
    } else
      o.setNode(w.id, w);
  }
  ie.debug("Count=", o.nodeCount(), o);
  let p = 0;
  d.forEach(function(y) {
    p++, ie.debug("Setting edge", y), o.setEdge(
      y.id1,
      y.id2,
      {
        relation: y,
        width: DDe(y.title),
        height: xa.labelHeight * at.getRows(y.title).length,
        labelpos: "c"
      },
      "id" + p
    );
  }), nV(o), ie.debug("Graph after layout", o.nodes());
  const g = e.node();
  o.nodes().forEach(function(y) {
    y !== void 0 && o.node(y) !== void 0 ? (ie.warn("Node " + y + ": " + JSON.stringify(o.node(y))), i.select("#" + g.id + " #" + y).attr(
      "transform",
      "translate(" + (o.node(y).x - o.node(y).width / 2) + "," + (o.node(y).y + (U5[y] ? U5[y].y : 0) - o.node(y).height / 2) + " )"
    ), i.select("#" + g.id + " #" + y).attr("data-x-shift", o.node(y).x - o.node(y).width / 2), a.querySelectorAll("#" + g.id + " #" + y + " .divider").forEach((w) => {
      const T = w.parentElement;
      let E = 0, L = 0;
      T && (T.parentElement && (E = T.parentElement.getBBox().width), L = parseInt(T.getAttribute("data-x-shift"), 10), Number.isNaN(L) && (L = 0)), w.setAttribute("x1", 0 - L + 8), w.setAttribute("x2", E - L - 8);
    })) : ie.debug("No Node " + y + ": " + JSON.stringify(o.node(y)));
  });
  let m = g.getBBox();
  o.edges().forEach(function(y) {
    y !== void 0 && o.edge(y) !== void 0 && (ie.debug("Edge " + y.v + " -> " + y.w + ": " + JSON.stringify(o.edge(y))), RDe(e, o.edge(y), o.edge(y).relation));
  }), m = g.getBBox();
  const v = {
    id: r || "root",
    label: r || "root",
    width: 0,
    height: 0
  };
  return v.width = m.width + 2 * xa.padding, v.height = m.height + 2 * xa.padding, ie.debug("Doc rendered", v, o), v;
}, "renderDoc"), ODe = {
  setConf: MDe,
  draw: IDe
}, PDe = {
  parser: rX,
  get db() {
    return new Jc(1);
  },
  renderer: ODe,
  styles: mX,
  init: /* @__PURE__ */ x((t) => {
    t.state || (t.state = {}), t.state.arrowMarkerAbsolute = t.arrowMarkerAbsolute;
  }, "init")
};
const BDe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: PDe
}, Symbol.toStringTag, { value: "Module" }));
var FDe = {
  parser: rX,
  get db() {
    return new Jc(2);
  },
  renderer: vDe,
  styles: mX,
  init: /* @__PURE__ */ x((t) => {
    t.state || (t.state = {}), t.state.arrowMarkerAbsolute = t.arrowMarkerAbsolute;
  }, "init")
};
const $De = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: FDe
}, Symbol.toStringTag, { value: "Module" }));
var G6 = (function() {
  var t = /* @__PURE__ */ x(function(d, f, p, g) {
    for (p = p || {}, g = d.length; g--; p[d[g]] = f) ;
    return p;
  }, "o"), e = [6, 8, 10, 11, 12, 14, 16, 17, 18], r = [1, 9], n = [1, 10], i = [1, 11], a = [1, 12], s = [1, 13], o = [1, 14], l = {
    trace: /* @__PURE__ */ x(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, journey: 4, document: 5, EOF: 6, line: 7, SPACE: 8, statement: 9, NEWLINE: 10, title: 11, acc_title: 12, acc_title_value: 13, acc_descr: 14, acc_descr_value: 15, acc_descr_multiline_value: 16, section: 17, taskName: 18, taskData: 19, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "journey", 6: "EOF", 8: "SPACE", 10: "NEWLINE", 11: "title", 12: "acc_title", 13: "acc_title_value", 14: "acc_descr", 15: "acc_descr_value", 16: "acc_descr_multiline_value", 17: "section", 18: "taskName", 19: "taskData" },
    productions_: [0, [3, 3], [5, 0], [5, 2], [7, 2], [7, 1], [7, 1], [7, 1], [9, 1], [9, 2], [9, 2], [9, 1], [9, 1], [9, 2]],
    performAction: /* @__PURE__ */ x(function(f, p, g, m, v, y, b) {
      var w = y.length - 1;
      switch (v) {
        case 1:
          return y[w - 1];
        case 2:
          this.$ = [];
          break;
        case 3:
          y[w - 1].push(y[w]), this.$ = y[w - 1];
          break;
        case 4:
        case 5:
          this.$ = y[w];
          break;
        case 6:
        case 7:
          this.$ = [];
          break;
        case 8:
          m.setDiagramTitle(y[w].substr(6)), this.$ = y[w].substr(6);
          break;
        case 9:
          this.$ = y[w].trim(), m.setAccTitle(this.$);
          break;
        case 10:
        case 11:
          this.$ = y[w].trim(), m.setAccDescription(this.$);
          break;
        case 12:
          m.addSection(y[w].substr(8)), this.$ = y[w].substr(8);
          break;
        case 13:
          m.addTask(y[w - 1], y[w]), this.$ = "task";
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, t(e, [2, 2], { 5: 3 }), { 6: [1, 4], 7: 5, 8: [1, 6], 9: 7, 10: [1, 8], 11: r, 12: n, 14: i, 16: a, 17: s, 18: o }, t(e, [2, 7], { 1: [2, 1] }), t(e, [2, 3]), { 9: 15, 11: r, 12: n, 14: i, 16: a, 17: s, 18: o }, t(e, [2, 5]), t(e, [2, 6]), t(e, [2, 8]), { 13: [1, 16] }, { 15: [1, 17] }, t(e, [2, 11]), t(e, [2, 12]), { 19: [1, 18] }, t(e, [2, 4]), t(e, [2, 9]), t(e, [2, 10]), t(e, [2, 13])],
    defaultActions: {},
    parseError: /* @__PURE__ */ x(function(f, p) {
      if (p.recoverable)
        this.trace(f);
      else {
        var g = new Error(f);
        throw g.hash = p, g;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ x(function(f) {
      var p = this, g = [0], m = [], v = [null], y = [], b = this.table, w = "", T = 0, E = 0, L = 2, k = 1, C = y.slice.call(arguments, 1), A = Object.create(this.lexer), R = { yy: {} };
      for (var _ in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, _) && (R.yy[_] = this.yy[_]);
      A.setInput(f, R.yy), R.yy.lexer = A, R.yy.parser = this, typeof A.yylloc > "u" && (A.yylloc = {});
      var O = A.yylloc;
      y.push(O);
      var P = A.options && A.options.ranges;
      typeof R.yy.parseError == "function" ? this.parseError = R.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function S(ae) {
        g.length = g.length - 2 * ae, v.length = v.length - ae, y.length = y.length - ae;
      }
      x(S, "popStack");
      function M() {
        var ae;
        return ae = m.pop() || A.lex() || k, typeof ae != "number" && (ae instanceof Array && (m = ae, ae = m.pop()), ae = p.symbols_[ae] || ae), ae;
      }
      x(M, "lex");
      for (var N, D, I, B, z = {}, F, V, H, J; ; ) {
        if (D = g[g.length - 1], this.defaultActions[D] ? I = this.defaultActions[D] : ((N === null || typeof N > "u") && (N = M()), I = b[D] && b[D][N]), typeof I > "u" || !I.length || !I[0]) {
          var q = "";
          J = [];
          for (F in b[D])
            this.terminals_[F] && F > L && J.push("'" + this.terminals_[F] + "'");
          A.showPosition ? q = "Parse error on line " + (T + 1) + `:
` + A.showPosition() + `
Expecting ` + J.join(", ") + ", got '" + (this.terminals_[N] || N) + "'" : q = "Parse error on line " + (T + 1) + ": Unexpected " + (N == k ? "end of input" : "'" + (this.terminals_[N] || N) + "'"), this.parseError(q, {
            text: A.match,
            token: this.terminals_[N] || N,
            line: A.yylineno,
            loc: O,
            expected: J
          });
        }
        if (I[0] instanceof Array && I.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + D + ", token: " + N);
        switch (I[0]) {
          case 1:
            g.push(N), v.push(A.yytext), y.push(A.yylloc), g.push(I[1]), N = null, E = A.yyleng, w = A.yytext, T = A.yylineno, O = A.yylloc;
            break;
          case 2:
            if (V = this.productions_[I[1]][1], z.$ = v[v.length - V], z._$ = {
              first_line: y[y.length - (V || 1)].first_line,
              last_line: y[y.length - 1].last_line,
              first_column: y[y.length - (V || 1)].first_column,
              last_column: y[y.length - 1].last_column
            }, P && (z._$.range = [
              y[y.length - (V || 1)].range[0],
              y[y.length - 1].range[1]
            ]), B = this.performAction.apply(z, [
              w,
              E,
              T,
              R.yy,
              I[1],
              v,
              y
            ].concat(C)), typeof B < "u")
              return B;
            V && (g = g.slice(0, -1 * V * 2), v = v.slice(0, -1 * V), y = y.slice(0, -1 * V)), g.push(this.productions_[I[1]][0]), v.push(z.$), y.push(z._$), H = b[g[g.length - 2]][g[g.length - 1]], g.push(H);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, u = /* @__PURE__ */ (function() {
    var d = {
      EOF: 1,
      parseError: /* @__PURE__ */ x(function(p, g) {
        if (this.yy.parser)
          this.yy.parser.parseError(p, g);
        else
          throw new Error(p);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ x(function(f, p) {
        return this.yy = p || this.yy || {}, this._input = f, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ x(function() {
        var f = this._input[0];
        this.yytext += f, this.yyleng++, this.offset++, this.match += f, this.matched += f;
        var p = f.match(/(?:\r\n?|\n).*/g);
        return p ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), f;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ x(function(f) {
        var p = f.length, g = f.split(/(?:\r\n?|\n)/g);
        this._input = f + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - p), this.offset -= p;
        var m = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), g.length - 1 && (this.yylineno -= g.length - 1);
        var v = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: g ? (g.length === m.length ? this.yylloc.first_column : 0) + m[m.length - g.length].length - g[0].length : this.yylloc.first_column - p
        }, this.options.ranges && (this.yylloc.range = [v[0], v[0] + this.yyleng - p]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ x(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ x(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ x(function(f) {
        this.unput(this.match.slice(f));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ x(function() {
        var f = this.matched.substr(0, this.matched.length - this.match.length);
        return (f.length > 20 ? "..." : "") + f.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ x(function() {
        var f = this.match;
        return f.length < 20 && (f += this._input.substr(0, 20 - f.length)), (f.substr(0, 20) + (f.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ x(function() {
        var f = this.pastInput(), p = new Array(f.length + 1).join("-");
        return f + this.upcomingInput() + `
` + p + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ x(function(f, p) {
        var g, m, v;
        if (this.options.backtrack_lexer && (v = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (v.yylloc.range = this.yylloc.range.slice(0))), m = f[0].match(/(?:\r\n?|\n).*/g), m && (this.yylineno += m.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: m ? m[m.length - 1].length - m[m.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + f[0].length
        }, this.yytext += f[0], this.match += f[0], this.matches = f, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(f[0].length), this.matched += f[0], g = this.performAction.call(this, this.yy, this, p, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), g)
          return g;
        if (this._backtrack) {
          for (var y in v)
            this[y] = v[y];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ x(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var f, p, g, m;
        this._more || (this.yytext = "", this.match = "");
        for (var v = this._currentRules(), y = 0; y < v.length; y++)
          if (g = this._input.match(this.rules[v[y]]), g && (!p || g[0].length > p[0].length)) {
            if (p = g, m = y, this.options.backtrack_lexer) {
              if (f = this.test_match(g, v[y]), f !== !1)
                return f;
              if (this._backtrack) {
                p = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return p ? (f = this.test_match(p, v[m]), f !== !1 ? f : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ x(function() {
        var p = this.next();
        return p || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ x(function(p) {
        this.conditionStack.push(p);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ x(function() {
        var p = this.conditionStack.length - 1;
        return p > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ x(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ x(function(p) {
        return p = this.conditionStack.length - 1 - Math.abs(p || 0), p >= 0 ? this.conditionStack[p] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ x(function(p) {
        this.begin(p);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ x(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ x(function(p, g, m, v) {
        switch (m) {
          case 0:
            break;
          case 1:
            break;
          case 2:
            return 10;
          case 3:
            break;
          case 4:
            break;
          case 5:
            return 4;
          case 6:
            return 11;
          case 7:
            return this.begin("acc_title"), 12;
          case 8:
            return this.popState(), "acc_title_value";
          case 9:
            return this.begin("acc_descr"), 14;
          case 10:
            return this.popState(), "acc_descr_value";
          case 11:
            this.begin("acc_descr_multiline");
            break;
          case 12:
            this.popState();
            break;
          case 13:
            return "acc_descr_multiline_value";
          case 14:
            return 17;
          case 15:
            return 18;
          case 16:
            return 19;
          case 17:
            return ":";
          case 18:
            return 6;
          case 19:
            return "INVALID";
        }
      }, "anonymous"),
      rules: [/^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:journey\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:section\s[^#:\n;]+)/i, /^(?:[^#:\n;]+)/i, /^(?::[^#\n;]+)/i, /^(?::)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { acc_descr_multiline: { rules: [12, 13], inclusive: !1 }, acc_descr: { rules: [10], inclusive: !1 }, acc_title: { rules: [8], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 19], inclusive: !0 } }
    };
    return d;
  })();
  l.lexer = u;
  function h() {
    this.yy = {};
  }
  return x(h, "Parser"), h.prototype = l, l.Parser = h, new h();
})();
G6.parser = G6;
var zDe = G6, Vd = "", D7 = [], tg = [], rg = [], GDe = /* @__PURE__ */ x(function() {
  D7.length = 0, tg.length = 0, Vd = "", rg.length = 0, _n();
}, "clear"), VDe = /* @__PURE__ */ x(function(t) {
  Vd = t, D7.push(t);
}, "addSection"), UDe = /* @__PURE__ */ x(function() {
  return D7;
}, "getSections"), HDe = /* @__PURE__ */ x(function() {
  let t = GN();
  const e = 100;
  let r = 0;
  for (; !t && r < e; )
    t = GN(), r++;
  return tg.push(...rg), tg;
}, "getTasks"), qDe = /* @__PURE__ */ x(function() {
  const t = [];
  return tg.forEach((r) => {
    r.people && t.push(...r.people);
  }), [...new Set(t)].sort();
}, "updateActors"), WDe = /* @__PURE__ */ x(function(t, e) {
  const r = e.substr(1).split(":");
  let n = 0, i = [];
  r.length === 1 ? (n = Number(r[0]), i = []) : (n = Number(r[0]), i = r[1].split(","));
  const a = i.map((o) => o.trim()), s = {
    section: Vd,
    type: Vd,
    people: a,
    task: t,
    score: n
  };
  rg.push(s);
}, "addTask"), YDe = /* @__PURE__ */ x(function(t) {
  const e = {
    section: Vd,
    type: Vd,
    description: t,
    task: t,
    classes: []
  };
  tg.push(e);
}, "addTaskOrg"), GN = /* @__PURE__ */ x(function() {
  const t = /* @__PURE__ */ x(function(r) {
    return rg[r].processed;
  }, "compileTask");
  let e = !0;
  for (const [r, n] of rg.entries())
    t(r), e = e && n.processed;
  return e;
}, "compileTasks"), XDe = /* @__PURE__ */ x(function() {
  return qDe();
}, "getActors"), VN = {
  getConfig: /* @__PURE__ */ x(() => we().journey, "getConfig"),
  clear: GDe,
  setDiagramTitle: Zn,
  getDiagramTitle: Ln,
  setAccTitle: Cn,
  getAccTitle: Gn,
  setAccDescription: Vn,
  getAccDescription: Un,
  addSection: VDe,
  getSections: UDe,
  getTasks: HDe,
  addTask: WDe,
  addTaskOrg: YDe,
  getActors: XDe
}, jDe = /* @__PURE__ */ x((t) => `.label {
    font-family: ${t.fontFamily};
    color: ${t.textColor};
  }
  .mouth {
    stroke: #666;
  }

  line {
    stroke: ${t.textColor}
  }

  .legend {
    fill: ${t.textColor};
    font-family: ${t.fontFamily};
  }

  .label text {
    fill: #333;
  }
  .label {
    color: ${t.textColor}
  }

  .face {
    ${t.faceColor ? `fill: ${t.faceColor}` : "fill: #FFF8DC"};
    stroke: #999;
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${t.mainBkg};
    stroke: ${t.nodeBorder};
    stroke-width: 1px;
  }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${t.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${t.lineColor};
    stroke-width: 1.5px;
  }

  .flowchart-link {
    stroke: ${t.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${t.edgeLabelBackground};
    rect {
      opacity: 0.5;
    }
    text-align: center;
  }

  .cluster rect {
  }

  .cluster text {
    fill: ${t.titleColor};
  }

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${t.fontFamily};
    font-size: 12px;
    background: ${t.tertiaryColor};
    border: 1px solid ${t.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .task-type-0, .section-type-0  {
    ${t.fillType0 ? `fill: ${t.fillType0}` : ""};
  }
  .task-type-1, .section-type-1  {
    ${t.fillType0 ? `fill: ${t.fillType1}` : ""};
  }
  .task-type-2, .section-type-2  {
    ${t.fillType0 ? `fill: ${t.fillType2}` : ""};
  }
  .task-type-3, .section-type-3  {
    ${t.fillType0 ? `fill: ${t.fillType3}` : ""};
  }
  .task-type-4, .section-type-4  {
    ${t.fillType0 ? `fill: ${t.fillType4}` : ""};
  }
  .task-type-5, .section-type-5  {
    ${t.fillType0 ? `fill: ${t.fillType5}` : ""};
  }
  .task-type-6, .section-type-6  {
    ${t.fillType0 ? `fill: ${t.fillType6}` : ""};
  }
  .task-type-7, .section-type-7  {
    ${t.fillType0 ? `fill: ${t.fillType7}` : ""};
  }

  .actor-0 {
    ${t.actor0 ? `fill: ${t.actor0}` : ""};
  }
  .actor-1 {
    ${t.actor1 ? `fill: ${t.actor1}` : ""};
  }
  .actor-2 {
    ${t.actor2 ? `fill: ${t.actor2}` : ""};
  }
  .actor-3 {
    ${t.actor3 ? `fill: ${t.actor3}` : ""};
  }
  .actor-4 {
    ${t.actor4 ? `fill: ${t.actor4}` : ""};
  }
  .actor-5 {
    ${t.actor5 ? `fill: ${t.actor5}` : ""};
  }
  ${Dg()}
`, "getStyles"), KDe = jDe, O7 = /* @__PURE__ */ x(function(t, e) {
  return Ux(t, e);
}, "drawRect"), ZDe = /* @__PURE__ */ x(function(t, e) {
  const n = t.append("circle").attr("cx", e.cx).attr("cy", e.cy).attr("class", "face").attr("r", 15).attr("stroke-width", 2).attr("overflow", "visible"), i = t.append("g");
  i.append("circle").attr("cx", e.cx - 15 / 3).attr("cy", e.cy - 15 / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666"), i.append("circle").attr("cx", e.cx + 15 / 3).attr("cy", e.cy - 15 / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666");
  function a(l) {
    const u = yd().startAngle(Math.PI / 2).endAngle(3 * (Math.PI / 2)).innerRadius(7.5).outerRadius(6.8181818181818175);
    l.append("path").attr("class", "mouth").attr("d", u).attr("transform", "translate(" + e.cx + "," + (e.cy + 2) + ")");
  }
  x(a, "smile");
  function s(l) {
    const u = yd().startAngle(3 * Math.PI / 2).endAngle(5 * (Math.PI / 2)).innerRadius(7.5).outerRadius(6.8181818181818175);
    l.append("path").attr("class", "mouth").attr("d", u).attr("transform", "translate(" + e.cx + "," + (e.cy + 7) + ")");
  }
  x(s, "sad");
  function o(l) {
    l.append("line").attr("class", "mouth").attr("stroke", 2).attr("x1", e.cx - 5).attr("y1", e.cy + 7).attr("x2", e.cx + 5).attr("y2", e.cy + 7).attr("class", "mouth").attr("stroke-width", "1px").attr("stroke", "#666");
  }
  return x(o, "ambivalent"), e.score > 3 ? a(i) : e.score < 3 ? s(i) : o(i), n;
}, "drawFace"), yX = /* @__PURE__ */ x(function(t, e) {
  const r = t.append("circle");
  return r.attr("cx", e.cx), r.attr("cy", e.cy), r.attr("class", "actor-" + e.pos), r.attr("fill", e.fill), r.attr("stroke", e.stroke), r.attr("r", e.r), r.class !== void 0 && r.attr("class", r.class), e.title !== void 0 && r.append("title").text(e.title), r;
}, "drawCircle"), xX = /* @__PURE__ */ x(function(t, e) {
  return U5e(t, e);
}, "drawText"), QDe = /* @__PURE__ */ x(function(t, e) {
  function r(i, a, s, o, l) {
    return i + "," + a + " " + (i + s) + "," + a + " " + (i + s) + "," + (a + o - l) + " " + (i + s - l * 1.2) + "," + (a + o) + " " + i + "," + (a + o);
  }
  x(r, "genPoints");
  const n = t.append("polygon");
  n.attr("points", r(e.x, e.y, 50, 20, 7)), n.attr("class", "labelBox"), e.y = e.y + e.labelMargin, e.x = e.x + 0.5 * e.labelMargin, xX(t, e);
}, "drawLabel"), JDe = /* @__PURE__ */ x(function(t, e, r) {
  const n = t.append("g"), i = Ma();
  i.x = e.x, i.y = e.y, i.fill = e.fill, i.width = r.width * e.taskCount + // width of the tasks
  r.diagramMarginX * (e.taskCount - 1), i.height = r.height, i.class = "journey-section section-type-" + e.num, i.rx = 3, i.ry = 3, O7(n, i), bX(r)(
    e.text,
    n,
    i.x,
    i.y,
    i.width,
    i.height,
    { class: "journey-section section-type-" + e.num },
    r,
    e.colour
  );
}, "drawSection"), UN = -1, eOe = /* @__PURE__ */ x(function(t, e, r) {
  const n = e.x + r.width / 2, i = t.append("g");
  UN++, i.append("line").attr("id", "task" + UN).attr("x1", n).attr("y1", e.y).attr("x2", n).attr("y2", 450).attr("class", "task-line").attr("stroke-width", "1px").attr("stroke-dasharray", "4 2").attr("stroke", "#666"), ZDe(i, {
    cx: n,
    cy: 300 + (5 - e.score) * 30,
    score: e.score
  });
  const s = Ma();
  s.x = e.x, s.y = e.y, s.fill = e.fill, s.width = r.width, s.height = r.height, s.class = "task task-type-" + e.num, s.rx = 3, s.ry = 3, O7(i, s);
  let o = e.x + 14;
  e.people.forEach((l) => {
    const u = e.actors[l].color, h = {
      cx: o,
      cy: e.y,
      r: 7,
      fill: u,
      stroke: "#000",
      title: l,
      pos: e.actors[l].position
    };
    yX(i, h), o += 10;
  }), bX(r)(
    e.task,
    i,
    s.x,
    s.y,
    s.width,
    s.height,
    { class: "task" },
    r,
    e.colour
  );
}, "drawTask"), tOe = /* @__PURE__ */ x(function(t, e) {
  lH(t, e);
}, "drawBackgroundRect"), bX = /* @__PURE__ */ (function() {
  function t(i, a, s, o, l, u, h, d) {
    const f = a.append("text").attr("x", s + l / 2).attr("y", o + u / 2 + 5).style("font-color", d).style("text-anchor", "middle").text(i);
    n(f, h);
  }
  x(t, "byText");
  function e(i, a, s, o, l, u, h, d, f) {
    const { taskFontSize: p, taskFontFamily: g } = d, m = i.split(/<br\s*\/?>/gi);
    for (let v = 0; v < m.length; v++) {
      const y = v * p - p * (m.length - 1) / 2, b = a.append("text").attr("x", s + l / 2).attr("y", o).attr("fill", f).style("text-anchor", "middle").style("font-size", p).style("font-family", g);
      b.append("tspan").attr("x", s + l / 2).attr("dy", y).text(m[v]), b.attr("y", o + u / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), n(b, h);
    }
  }
  x(e, "byTspan");
  function r(i, a, s, o, l, u, h, d) {
    const f = a.append("switch"), g = f.append("foreignObject").attr("x", s).attr("y", o).attr("width", l).attr("height", u).attr("position", "fixed").append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    g.append("div").attr("class", "label").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(i), e(i, f, s, o, l, u, h, d), n(g, h);
  }
  x(r, "byFo");
  function n(i, a) {
    for (const s in a)
      s in a && i.attr(s, a[s]);
  }
  return x(n, "_setTextAttrs"), function(i) {
    return i.textPlacement === "fo" ? r : i.textPlacement === "old" ? t : e;
  };
})(), rOe = /* @__PURE__ */ x(function(t) {
  t.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 5).attr("refY", 2).attr("markerWidth", 6).attr("markerHeight", 4).attr("orient", "auto").append("path").attr("d", "M 0,0 V 4 L6,2 Z");
}, "initGraphics"), ng = {
  drawRect: O7,
  drawCircle: yX,
  drawSection: JDe,
  drawText: xX,
  drawLabel: QDe,
  drawTask: eOe,
  drawBackgroundRect: tOe,
  initGraphics: rOe
}, nOe = /* @__PURE__ */ x(function(t) {
  Object.keys(t).forEach(function(r) {
    cs[r] = t[r];
  });
}, "setConf"), Uo = {}, xv = 0;
function wX(t) {
  const e = we().journey, r = e.maxLabelWidth;
  xv = 0;
  let n = 60;
  Object.keys(Uo).forEach((i) => {
    const a = Uo[i].color, s = {
      cx: 20,
      cy: n,
      r: 7,
      fill: a,
      stroke: "#000",
      pos: Uo[i].position
    };
    ng.drawCircle(t, s);
    let o = t.append("text").attr("visibility", "hidden").text(i);
    const l = o.node().getBoundingClientRect().width;
    o.remove();
    let u = [];
    if (l <= r)
      u = [i];
    else {
      const h = i.split(" ");
      let d = "";
      o = t.append("text").attr("visibility", "hidden"), h.forEach((f) => {
        const p = d ? `${d} ${f}` : f;
        if (o.text(p), o.node().getBoundingClientRect().width > r) {
          if (d && u.push(d), d = f, o.text(f), o.node().getBoundingClientRect().width > r) {
            let m = "";
            for (const v of f)
              m += v, o.text(m + "-"), o.node().getBoundingClientRect().width > r && (u.push(m.slice(0, -1) + "-"), m = v);
            d = m;
          }
        } else
          d = p;
      }), d && u.push(d), o.remove();
    }
    u.forEach((h, d) => {
      const f = {
        x: 40,
        y: n + 7 + d * 20,
        fill: "#666",
        text: h,
        textMargin: e.boxTextMargin ?? 5
      }, g = ng.drawText(t, f).node().getBoundingClientRect().width;
      g > xv && g > e.leftMargin - g && (xv = g);
    }), n += Math.max(20, u.length * 20);
  });
}
x(wX, "drawActorLegend");
var cs = we().journey, Al = 0, iOe = /* @__PURE__ */ x(function(t, e, r, n) {
  const i = we(), a = i.journey.titleColor, s = i.journey.titleFontSize, o = i.journey.titleFontFamily, l = i.securityLevel;
  let u;
  l === "sandbox" && (u = Qe("#i" + e));
  const h = Qe(l === "sandbox" ? u.nodes()[0].contentDocument.body : "body");
  $a.init();
  const d = h.select("#" + e);
  ng.initGraphics(d);
  const f = n.db.getTasks(), p = n.db.getDiagramTitle(), g = n.db.getActors();
  for (const T in Uo)
    delete Uo[T];
  let m = 0;
  g.forEach((T) => {
    Uo[T] = {
      color: cs.actorColours[m % cs.actorColours.length],
      position: m
    }, m++;
  }), wX(d), Al = cs.leftMargin + xv, $a.insert(0, 0, Al, Object.keys(Uo).length * 50), aOe(d, f, 0);
  const v = $a.getBounds();
  p && d.append("text").text(p).attr("x", Al).attr("font-size", s).attr("font-weight", "bold").attr("y", 25).attr("fill", a).attr("font-family", o);
  const y = v.stopy - v.starty + 2 * cs.diagramMarginY, b = Al + v.stopx + 2 * cs.diagramMarginX;
  Xi(d, y, b, cs.useMaxWidth), d.append("line").attr("x1", Al).attr("y1", cs.height * 4).attr("x2", b - Al - 4).attr("y2", cs.height * 4).attr("stroke-width", 4).attr("stroke", "black").attr("marker-end", "url(#arrowhead)");
  const w = p ? 70 : 0;
  d.attr("viewBox", `${v.startx} -25 ${b} ${y + w}`), d.attr("preserveAspectRatio", "xMinYMin meet"), d.attr("height", y + w + 25);
}, "draw"), $a = {
  data: {
    startx: void 0,
    stopx: void 0,
    starty: void 0,
    stopy: void 0
  },
  verticalPos: 0,
  sequenceItems: [],
  init: /* @__PURE__ */ x(function() {
    this.sequenceItems = [], this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0
    }, this.verticalPos = 0;
  }, "init"),
  updateVal: /* @__PURE__ */ x(function(t, e, r, n) {
    t[e] === void 0 ? t[e] = r : t[e] = n(r, t[e]);
  }, "updateVal"),
  updateBounds: /* @__PURE__ */ x(function(t, e, r, n) {
    const i = we().journey, a = this;
    let s = 0;
    function o(l) {
      return /* @__PURE__ */ x(function(h) {
        s++;
        const d = a.sequenceItems.length - s + 1;
        a.updateVal(h, "starty", e - d * i.boxMargin, Math.min), a.updateVal(h, "stopy", n + d * i.boxMargin, Math.max), a.updateVal($a.data, "startx", t - d * i.boxMargin, Math.min), a.updateVal($a.data, "stopx", r + d * i.boxMargin, Math.max), l !== "activation" && (a.updateVal(h, "startx", t - d * i.boxMargin, Math.min), a.updateVal(h, "stopx", r + d * i.boxMargin, Math.max), a.updateVal($a.data, "starty", e - d * i.boxMargin, Math.min), a.updateVal($a.data, "stopy", n + d * i.boxMargin, Math.max));
      }, "updateItemBounds");
    }
    x(o, "updateFn"), this.sequenceItems.forEach(o());
  }, "updateBounds"),
  insert: /* @__PURE__ */ x(function(t, e, r, n) {
    const i = Math.min(t, r), a = Math.max(t, r), s = Math.min(e, n), o = Math.max(e, n);
    this.updateVal($a.data, "startx", i, Math.min), this.updateVal($a.data, "starty", s, Math.min), this.updateVal($a.data, "stopx", a, Math.max), this.updateVal($a.data, "stopy", o, Math.max), this.updateBounds(i, s, a, o);
  }, "insert"),
  bumpVerticalPos: /* @__PURE__ */ x(function(t) {
    this.verticalPos = this.verticalPos + t, this.data.stopy = this.verticalPos;
  }, "bumpVerticalPos"),
  getVerticalPos: /* @__PURE__ */ x(function() {
    return this.verticalPos;
  }, "getVerticalPos"),
  getBounds: /* @__PURE__ */ x(function() {
    return this.data;
  }, "getBounds")
}, H5 = cs.sectionFills, HN = cs.sectionColours, aOe = /* @__PURE__ */ x(function(t, e, r) {
  const n = we().journey;
  let i = "";
  const a = n.height * 2 + n.diagramMarginY, s = r + a;
  let o = 0, l = "#CCC", u = "black", h = 0;
  for (const [d, f] of e.entries()) {
    if (i !== f.section) {
      l = H5[o % H5.length], h = o % H5.length, u = HN[o % HN.length];
      let g = 0;
      const m = f.section;
      for (let y = d; y < e.length && e[y].section == m; y++)
        g = g + 1;
      const v = {
        x: d * n.taskMargin + d * n.width + Al,
        y: 50,
        text: f.section,
        fill: l,
        num: h,
        colour: u,
        taskCount: g
      };
      ng.drawSection(t, v, n), i = f.section, o++;
    }
    const p = f.people.reduce((g, m) => (Uo[m] && (g[m] = Uo[m]), g), {});
    f.x = d * n.taskMargin + d * n.width + Al, f.y = s, f.width = n.diagramMarginX, f.height = n.diagramMarginY, f.colour = u, f.fill = l, f.num = h, f.actors = p, ng.drawTask(t, f, n), $a.insert(f.x, f.y, f.x + f.width + n.taskMargin, 450);
  }
}, "drawTasks"), qN = {
  setConf: nOe,
  draw: iOe
}, sOe = {
  parser: zDe,
  db: VN,
  renderer: qN,
  styles: KDe,
  init: /* @__PURE__ */ x((t) => {
    qN.setConf(t.journey), VN.clear();
  }, "init")
};
const oOe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: sOe
}, Symbol.toStringTag, { value: "Module" }));
var V6 = (function() {
  var t = /* @__PURE__ */ x(function(f, p, g, m) {
    for (g = g || {}, m = f.length; m--; g[f[m]] = p) ;
    return g;
  }, "o"), e = [6, 8, 10, 11, 12, 14, 16, 17, 20, 21], r = [1, 9], n = [1, 10], i = [1, 11], a = [1, 12], s = [1, 13], o = [1, 16], l = [1, 17], u = {
    trace: /* @__PURE__ */ x(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, timeline: 4, document: 5, EOF: 6, line: 7, SPACE: 8, statement: 9, NEWLINE: 10, title: 11, acc_title: 12, acc_title_value: 13, acc_descr: 14, acc_descr_value: 15, acc_descr_multiline_value: 16, section: 17, period_statement: 18, event_statement: 19, period: 20, event: 21, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "timeline", 6: "EOF", 8: "SPACE", 10: "NEWLINE", 11: "title", 12: "acc_title", 13: "acc_title_value", 14: "acc_descr", 15: "acc_descr_value", 16: "acc_descr_multiline_value", 17: "section", 20: "period", 21: "event" },
    productions_: [0, [3, 3], [5, 0], [5, 2], [7, 2], [7, 1], [7, 1], [7, 1], [9, 1], [9, 2], [9, 2], [9, 1], [9, 1], [9, 1], [9, 1], [18, 1], [19, 1]],
    performAction: /* @__PURE__ */ x(function(p, g, m, v, y, b, w) {
      var T = b.length - 1;
      switch (y) {
        case 1:
          return b[T - 1];
        case 2:
          this.$ = [];
          break;
        case 3:
          b[T - 1].push(b[T]), this.$ = b[T - 1];
          break;
        case 4:
        case 5:
          this.$ = b[T];
          break;
        case 6:
        case 7:
          this.$ = [];
          break;
        case 8:
          v.getCommonDb().setDiagramTitle(b[T].substr(6)), this.$ = b[T].substr(6);
          break;
        case 9:
          this.$ = b[T].trim(), v.getCommonDb().setAccTitle(this.$);
          break;
        case 10:
        case 11:
          this.$ = b[T].trim(), v.getCommonDb().setAccDescription(this.$);
          break;
        case 12:
          v.addSection(b[T].substr(8)), this.$ = b[T].substr(8);
          break;
        case 15:
          v.addTask(b[T], 0, ""), this.$ = b[T];
          break;
        case 16:
          v.addEvent(b[T].substr(2)), this.$ = b[T];
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, t(e, [2, 2], { 5: 3 }), { 6: [1, 4], 7: 5, 8: [1, 6], 9: 7, 10: [1, 8], 11: r, 12: n, 14: i, 16: a, 17: s, 18: 14, 19: 15, 20: o, 21: l }, t(e, [2, 7], { 1: [2, 1] }), t(e, [2, 3]), { 9: 18, 11: r, 12: n, 14: i, 16: a, 17: s, 18: 14, 19: 15, 20: o, 21: l }, t(e, [2, 5]), t(e, [2, 6]), t(e, [2, 8]), { 13: [1, 19] }, { 15: [1, 20] }, t(e, [2, 11]), t(e, [2, 12]), t(e, [2, 13]), t(e, [2, 14]), t(e, [2, 15]), t(e, [2, 16]), t(e, [2, 4]), t(e, [2, 9]), t(e, [2, 10])],
    defaultActions: {},
    parseError: /* @__PURE__ */ x(function(p, g) {
      if (g.recoverable)
        this.trace(p);
      else {
        var m = new Error(p);
        throw m.hash = g, m;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ x(function(p) {
      var g = this, m = [0], v = [], y = [null], b = [], w = this.table, T = "", E = 0, L = 0, k = 2, C = 1, A = b.slice.call(arguments, 1), R = Object.create(this.lexer), _ = { yy: {} };
      for (var O in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, O) && (_.yy[O] = this.yy[O]);
      R.setInput(p, _.yy), _.yy.lexer = R, _.yy.parser = this, typeof R.yylloc > "u" && (R.yylloc = {});
      var P = R.yylloc;
      b.push(P);
      var S = R.options && R.options.ranges;
      typeof _.yy.parseError == "function" ? this.parseError = _.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function M(re) {
        m.length = m.length - 2 * re, y.length = y.length - re, b.length = b.length - re;
      }
      x(M, "popStack");
      function N() {
        var re;
        return re = v.pop() || R.lex() || C, typeof re != "number" && (re instanceof Array && (v = re, re = v.pop()), re = g.symbols_[re] || re), re;
      }
      x(N, "lex");
      for (var D, I, B, z, F = {}, V, H, J, q; ; ) {
        if (I = m[m.length - 1], this.defaultActions[I] ? B = this.defaultActions[I] : ((D === null || typeof D > "u") && (D = N()), B = w[I] && w[I][D]), typeof B > "u" || !B.length || !B[0]) {
          var ae = "";
          q = [];
          for (V in w[I])
            this.terminals_[V] && V > k && q.push("'" + this.terminals_[V] + "'");
          R.showPosition ? ae = "Parse error on line " + (E + 1) + `:
` + R.showPosition() + `
Expecting ` + q.join(", ") + ", got '" + (this.terminals_[D] || D) + "'" : ae = "Parse error on line " + (E + 1) + ": Unexpected " + (D == C ? "end of input" : "'" + (this.terminals_[D] || D) + "'"), this.parseError(ae, {
            text: R.match,
            token: this.terminals_[D] || D,
            line: R.yylineno,
            loc: P,
            expected: q
          });
        }
        if (B[0] instanceof Array && B.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + I + ", token: " + D);
        switch (B[0]) {
          case 1:
            m.push(D), y.push(R.yytext), b.push(R.yylloc), m.push(B[1]), D = null, L = R.yyleng, T = R.yytext, E = R.yylineno, P = R.yylloc;
            break;
          case 2:
            if (H = this.productions_[B[1]][1], F.$ = y[y.length - H], F._$ = {
              first_line: b[b.length - (H || 1)].first_line,
              last_line: b[b.length - 1].last_line,
              first_column: b[b.length - (H || 1)].first_column,
              last_column: b[b.length - 1].last_column
            }, S && (F._$.range = [
              b[b.length - (H || 1)].range[0],
              b[b.length - 1].range[1]
            ]), z = this.performAction.apply(F, [
              T,
              L,
              E,
              _.yy,
              B[1],
              y,
              b
            ].concat(A)), typeof z < "u")
              return z;
            H && (m = m.slice(0, -1 * H * 2), y = y.slice(0, -1 * H), b = b.slice(0, -1 * H)), m.push(this.productions_[B[1]][0]), y.push(F.$), b.push(F._$), J = w[m[m.length - 2]][m[m.length - 1]], m.push(J);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, h = /* @__PURE__ */ (function() {
    var f = {
      EOF: 1,
      parseError: /* @__PURE__ */ x(function(g, m) {
        if (this.yy.parser)
          this.yy.parser.parseError(g, m);
        else
          throw new Error(g);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ x(function(p, g) {
        return this.yy = g || this.yy || {}, this._input = p, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ x(function() {
        var p = this._input[0];
        this.yytext += p, this.yyleng++, this.offset++, this.match += p, this.matched += p;
        var g = p.match(/(?:\r\n?|\n).*/g);
        return g ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), p;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ x(function(p) {
        var g = p.length, m = p.split(/(?:\r\n?|\n)/g);
        this._input = p + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - g), this.offset -= g;
        var v = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), m.length - 1 && (this.yylineno -= m.length - 1);
        var y = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: m ? (m.length === v.length ? this.yylloc.first_column : 0) + v[v.length - m.length].length - m[0].length : this.yylloc.first_column - g
        }, this.options.ranges && (this.yylloc.range = [y[0], y[0] + this.yyleng - g]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ x(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ x(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ x(function(p) {
        this.unput(this.match.slice(p));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ x(function() {
        var p = this.matched.substr(0, this.matched.length - this.match.length);
        return (p.length > 20 ? "..." : "") + p.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ x(function() {
        var p = this.match;
        return p.length < 20 && (p += this._input.substr(0, 20 - p.length)), (p.substr(0, 20) + (p.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ x(function() {
        var p = this.pastInput(), g = new Array(p.length + 1).join("-");
        return p + this.upcomingInput() + `
` + g + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ x(function(p, g) {
        var m, v, y;
        if (this.options.backtrack_lexer && (y = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (y.yylloc.range = this.yylloc.range.slice(0))), v = p[0].match(/(?:\r\n?|\n).*/g), v && (this.yylineno += v.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: v ? v[v.length - 1].length - v[v.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + p[0].length
        }, this.yytext += p[0], this.match += p[0], this.matches = p, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(p[0].length), this.matched += p[0], m = this.performAction.call(this, this.yy, this, g, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), m)
          return m;
        if (this._backtrack) {
          for (var b in y)
            this[b] = y[b];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ x(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var p, g, m, v;
        this._more || (this.yytext = "", this.match = "");
        for (var y = this._currentRules(), b = 0; b < y.length; b++)
          if (m = this._input.match(this.rules[y[b]]), m && (!g || m[0].length > g[0].length)) {
            if (g = m, v = b, this.options.backtrack_lexer) {
              if (p = this.test_match(m, y[b]), p !== !1)
                return p;
              if (this._backtrack) {
                g = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return g ? (p = this.test_match(g, y[v]), p !== !1 ? p : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ x(function() {
        var g = this.next();
        return g || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ x(function(g) {
        this.conditionStack.push(g);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ x(function() {
        var g = this.conditionStack.length - 1;
        return g > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ x(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ x(function(g) {
        return g = this.conditionStack.length - 1 - Math.abs(g || 0), g >= 0 ? this.conditionStack[g] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ x(function(g) {
        this.begin(g);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ x(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ x(function(g, m, v, y) {
        switch (v) {
          case 0:
            break;
          case 1:
            break;
          case 2:
            return 10;
          case 3:
            break;
          case 4:
            break;
          case 5:
            return 4;
          case 6:
            return 11;
          case 7:
            return this.begin("acc_title"), 12;
          case 8:
            return this.popState(), "acc_title_value";
          case 9:
            return this.begin("acc_descr"), 14;
          case 10:
            return this.popState(), "acc_descr_value";
          case 11:
            this.begin("acc_descr_multiline");
            break;
          case 12:
            this.popState();
            break;
          case 13:
            return "acc_descr_multiline_value";
          case 14:
            return 17;
          case 15:
            return 21;
          case 16:
            return 20;
          case 17:
            return 6;
          case 18:
            return "INVALID";
        }
      }, "anonymous"),
      rules: [/^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:timeline\b)/i, /^(?:title\s[^\n]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:section\s[^:\n]+)/i, /^(?::\s(?:[^:\n]|:(?!\s))+)/i, /^(?:[^#:\n]+)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { acc_descr_multiline: { rules: [12, 13], inclusive: !1 }, acc_descr: { rules: [10], inclusive: !1 }, acc_title: { rules: [8], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18], inclusive: !0 } }
    };
    return f;
  })();
  u.lexer = h;
  function d() {
    this.yy = {};
  }
  return x(d, "Parser"), d.prototype = u, u.Parser = d, new d();
})();
V6.parser = V6;
var lOe = V6, TX = {};
A2(TX, {
  addEvent: () => RX,
  addSection: () => CX,
  addTask: () => LX,
  addTaskOrg: () => MX,
  clear: () => SX,
  default: () => cOe,
  getCommonDb: () => kX,
  getSections: () => AX,
  getTasks: () => _X
});
var Ud = "", EX = 0, P7 = [], x2 = [], Hd = [], kX = /* @__PURE__ */ x(() => sE, "getCommonDb"), SX = /* @__PURE__ */ x(function() {
  P7.length = 0, x2.length = 0, Ud = "", Hd.length = 0, _n();
}, "clear"), CX = /* @__PURE__ */ x(function(t) {
  Ud = t, P7.push(t);
}, "addSection"), AX = /* @__PURE__ */ x(function() {
  return P7;
}, "getSections"), _X = /* @__PURE__ */ x(function() {
  let t = WN();
  const e = 100;
  let r = 0;
  for (; !t && r < e; )
    t = WN(), r++;
  return x2.push(...Hd), x2;
}, "getTasks"), LX = /* @__PURE__ */ x(function(t, e, r) {
  const n = {
    id: EX++,
    section: Ud,
    type: Ud,
    task: t,
    score: e || 0,
    //if event is defined, then add it the events array
    events: r ? [r] : []
  };
  Hd.push(n);
}, "addTask"), RX = /* @__PURE__ */ x(function(t) {
  Hd.find((r) => r.id === EX - 1).events.push(t);
}, "addEvent"), MX = /* @__PURE__ */ x(function(t) {
  const e = {
    section: Ud,
    type: Ud,
    description: t,
    task: t,
    classes: []
  };
  x2.push(e);
}, "addTaskOrg"), WN = /* @__PURE__ */ x(function() {
  const t = /* @__PURE__ */ x(function(r) {
    return Hd[r].processed;
  }, "compileTask");
  let e = !0;
  for (const [r, n] of Hd.entries())
    t(r), e = e && n.processed;
  return e;
}, "compileTasks"), cOe = {
  clear: SX,
  getCommonDb: kX,
  addSection: CX,
  getSections: AX,
  getTasks: _X,
  addTask: LX,
  addTaskOrg: MX,
  addEvent: RX
}, uOe = 12, Eb = /* @__PURE__ */ x(function(t, e) {
  const r = t.append("rect");
  return r.attr("x", e.x), r.attr("y", e.y), r.attr("fill", e.fill), r.attr("stroke", e.stroke), r.attr("width", e.width), r.attr("height", e.height), r.attr("rx", e.rx), r.attr("ry", e.ry), e.class !== void 0 && r.attr("class", e.class), r;
}, "drawRect"), hOe = /* @__PURE__ */ x(function(t, e) {
  const n = t.append("circle").attr("cx", e.cx).attr("cy", e.cy).attr("class", "face").attr("r", 15).attr("stroke-width", 2).attr("overflow", "visible"), i = t.append("g");
  i.append("circle").attr("cx", e.cx - 15 / 3).attr("cy", e.cy - 15 / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666"), i.append("circle").attr("cx", e.cx + 15 / 3).attr("cy", e.cy - 15 / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666");
  function a(l) {
    const u = yd().startAngle(Math.PI / 2).endAngle(3 * (Math.PI / 2)).innerRadius(7.5).outerRadius(6.8181818181818175);
    l.append("path").attr("class", "mouth").attr("d", u).attr("transform", "translate(" + e.cx + "," + (e.cy + 2) + ")");
  }
  x(a, "smile");
  function s(l) {
    const u = yd().startAngle(3 * Math.PI / 2).endAngle(5 * (Math.PI / 2)).innerRadius(7.5).outerRadius(6.8181818181818175);
    l.append("path").attr("class", "mouth").attr("d", u).attr("transform", "translate(" + e.cx + "," + (e.cy + 7) + ")");
  }
  x(s, "sad");
  function o(l) {
    l.append("line").attr("class", "mouth").attr("stroke", 2).attr("x1", e.cx - 5).attr("y1", e.cy + 7).attr("x2", e.cx + 5).attr("y2", e.cy + 7).attr("class", "mouth").attr("stroke-width", "1px").attr("stroke", "#666");
  }
  return x(o, "ambivalent"), e.score > 3 ? a(i) : e.score < 3 ? s(i) : o(i), n;
}, "drawFace"), dOe = /* @__PURE__ */ x(function(t, e) {
  const r = t.append("circle");
  return r.attr("cx", e.cx), r.attr("cy", e.cy), r.attr("class", "actor-" + e.pos), r.attr("fill", e.fill), r.attr("stroke", e.stroke), r.attr("r", e.r), r.class !== void 0 && r.attr("class", r.class), e.title !== void 0 && r.append("title").text(e.title), r;
}, "drawCircle"), NX = /* @__PURE__ */ x(function(t, e) {
  const r = e.text.replace(/<br\s*\/?>/gi, " "), n = t.append("text");
  n.attr("x", e.x), n.attr("y", e.y), n.attr("class", "legend"), n.style("text-anchor", e.anchor), e.class !== void 0 && n.attr("class", e.class);
  const i = n.append("tspan");
  return i.attr("x", e.x + e.textMargin * 2), i.text(r), n;
}, "drawText"), fOe = /* @__PURE__ */ x(function(t, e) {
  function r(i, a, s, o, l) {
    return i + "," + a + " " + (i + s) + "," + a + " " + (i + s) + "," + (a + o - l) + " " + (i + s - l * 1.2) + "," + (a + o) + " " + i + "," + (a + o);
  }
  x(r, "genPoints");
  const n = t.append("polygon");
  n.attr("points", r(e.x, e.y, 50, 20, 7)), n.attr("class", "labelBox"), e.y = e.y + e.labelMargin, e.x = e.x + 0.5 * e.labelMargin, NX(t, e);
}, "drawLabel"), pOe = /* @__PURE__ */ x(function(t, e, r) {
  const n = t.append("g"), i = B7();
  i.x = e.x, i.y = e.y, i.fill = e.fill, i.width = r.width, i.height = r.height, i.class = "journey-section section-type-" + e.num, i.rx = 3, i.ry = 3, Eb(n, i), IX(r)(
    e.text,
    n,
    i.x,
    i.y,
    i.width,
    i.height,
    { class: "journey-section section-type-" + e.num },
    r,
    e.colour
  );
}, "drawSection"), YN = -1, gOe = /* @__PURE__ */ x(function(t, e, r) {
  const n = e.x + r.width / 2, i = t.append("g");
  YN++, i.append("line").attr("id", "task" + YN).attr("x1", n).attr("y1", e.y).attr("x2", n).attr("y2", 450).attr("class", "task-line").attr("stroke-width", "1px").attr("stroke-dasharray", "4 2").attr("stroke", "#666"), hOe(i, {
    cx: n,
    cy: 300 + (5 - e.score) * 30,
    score: e.score
  });
  const s = B7();
  s.x = e.x, s.y = e.y, s.fill = e.fill, s.width = r.width, s.height = r.height, s.class = "task task-type-" + e.num, s.rx = 3, s.ry = 3, Eb(i, s), IX(r)(
    e.task,
    i,
    s.x,
    s.y,
    s.width,
    s.height,
    { class: "task" },
    r,
    e.colour
  );
}, "drawTask"), mOe = /* @__PURE__ */ x(function(t, e) {
  Eb(t, {
    x: e.startx,
    y: e.starty,
    width: e.stopx - e.startx,
    height: e.stopy - e.starty,
    fill: e.fill,
    class: "rect"
  }).lower();
}, "drawBackgroundRect"), vOe = /* @__PURE__ */ x(function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    "text-anchor": "start",
    width: 100,
    height: 100,
    textMargin: 0,
    rx: 0,
    ry: 0
  };
}, "getTextObj"), B7 = /* @__PURE__ */ x(function() {
  return {
    x: 0,
    y: 0,
    width: 100,
    anchor: "start",
    height: 100,
    rx: 0,
    ry: 0
  };
}, "getNoteRect"), IX = /* @__PURE__ */ (function() {
  function t(i, a, s, o, l, u, h, d) {
    const f = a.append("text").attr("x", s + l / 2).attr("y", o + u / 2 + 5).style("font-color", d).style("text-anchor", "middle").text(i);
    n(f, h);
  }
  x(t, "byText");
  function e(i, a, s, o, l, u, h, d, f) {
    const { taskFontSize: p, taskFontFamily: g } = d, m = i.split(/<br\s*\/?>/gi);
    for (let v = 0; v < m.length; v++) {
      const y = v * p - p * (m.length - 1) / 2, b = a.append("text").attr("x", s + l / 2).attr("y", o).attr("fill", f).style("text-anchor", "middle").style("font-size", p).style("font-family", g);
      b.append("tspan").attr("x", s + l / 2).attr("dy", y).text(m[v]), b.attr("y", o + u / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), n(b, h);
    }
  }
  x(e, "byTspan");
  function r(i, a, s, o, l, u, h, d) {
    const f = a.append("switch"), g = f.append("foreignObject").attr("x", s).attr("y", o).attr("width", l).attr("height", u).attr("position", "fixed").append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    g.append("div").attr("class", "label").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(i), e(i, f, s, o, l, u, h, d), n(g, h);
  }
  x(r, "byFo");
  function n(i, a) {
    for (const s in a)
      s in a && i.attr(s, a[s]);
  }
  return x(n, "_setTextAttrs"), function(i) {
    return i.textPlacement === "fo" ? r : i.textPlacement === "old" ? t : e;
  };
})(), yOe = /* @__PURE__ */ x(function(t) {
  t.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 5).attr("refY", 2).attr("markerWidth", 6).attr("markerHeight", 4).attr("orient", "auto").append("path").attr("d", "M 0,0 V 4 L6,2 Z");
}, "initGraphics");
function F7(t, e) {
  t.each(function() {
    var r = Qe(this), n = r.text().split(/(\s+|<br>)/).reverse(), i, a = [], s = 1.1, o = r.attr("y"), l = parseFloat(r.attr("dy")), u = r.text(null).append("tspan").attr("x", 0).attr("y", o).attr("dy", l + "em");
    for (let h = 0; h < n.length; h++)
      i = n[n.length - 1 - h], a.push(i), u.text(a.join(" ").trim()), (u.node().getComputedTextLength() > e || i === "<br>") && (a.pop(), u.text(a.join(" ").trim()), i === "<br>" ? a = [""] : a = [i], u = r.append("tspan").attr("x", 0).attr("y", o).attr("dy", s + "em").text(i));
  });
}
x(F7, "wrap");
var xOe = /* @__PURE__ */ x(function(t, e, r, n) {
  const i = r % uOe - 1, a = t.append("g");
  e.section = i, a.attr(
    "class",
    (e.class ? e.class + " " : "") + "timeline-node " + ("section-" + i)
  );
  const s = a.append("g"), o = a.append("g"), u = o.append("text").text(e.descr).attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle").call(F7, e.width).node().getBBox(), h = n.fontSize?.replace ? n.fontSize.replace("px", "") : n.fontSize;
  return e.height = u.height + h * 1.1 * 0.5 + e.padding, e.height = Math.max(e.height, e.maxHeight), e.width = e.width + 2 * e.padding, o.attr("transform", "translate(" + e.width / 2 + ", " + e.padding / 2 + ")"), wOe(s, e, i, n), e;
}, "drawNode"), bOe = /* @__PURE__ */ x(function(t, e, r) {
  const n = t.append("g"), a = n.append("text").text(e.descr).attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle").call(F7, e.width).node().getBBox(), s = r.fontSize?.replace ? r.fontSize.replace("px", "") : r.fontSize;
  return n.remove(), a.height + s * 1.1 * 0.5 + e.padding;
}, "getVirtualNodeHeight"), wOe = /* @__PURE__ */ x(function(t, e, r) {
  t.append("path").attr("id", "node-" + e.id).attr("class", "node-bkg node-" + e.type).attr(
    "d",
    `M0 ${e.height - 5} v${-e.height + 10} q0,-5 5,-5 h${e.width - 10} q5,0 5,5 v${e.height - 5} H0 Z`
  ), t.append("line").attr("class", "node-line-" + r).attr("x1", 0).attr("y1", e.height).attr("x2", e.width).attr("y2", e.height);
}, "defaultBkg"), eu = {
  drawRect: Eb,
  drawCircle: dOe,
  drawSection: pOe,
  drawText: NX,
  drawLabel: fOe,
  drawTask: gOe,
  drawBackgroundRect: mOe,
  getTextObj: vOe,
  getNoteRect: B7,
  initGraphics: yOe,
  drawNode: xOe,
  getVirtualNodeHeight: bOe
}, TOe = /* @__PURE__ */ x(function(t, e, r, n) {
  const i = we(), a = i.timeline?.leftMargin ?? 50;
  ie.debug("timeline", n.db);
  const s = i.securityLevel;
  let o;
  s === "sandbox" && (o = Qe("#i" + e));
  const u = Qe(s === "sandbox" ? o.nodes()[0].contentDocument.body : "body").select("#" + e);
  u.append("g");
  const h = n.db.getTasks(), d = n.db.getCommonDb().getDiagramTitle();
  ie.debug("task", h), eu.initGraphics(u);
  const f = n.db.getSections();
  ie.debug("sections", f);
  let p = 0, g = 0, m = 0, v = 0, y = 50 + a, b = 50;
  v = 50;
  let w = 0, T = !0;
  f.forEach(function(A) {
    const R = {
      number: w,
      descr: A,
      section: w,
      width: 150,
      padding: 20,
      maxHeight: p
    }, _ = eu.getVirtualNodeHeight(u, R, i);
    ie.debug("sectionHeight before draw", _), p = Math.max(p, _ + 20);
  });
  let E = 0, L = 0;
  ie.debug("tasks.length", h.length);
  for (const [A, R] of h.entries()) {
    const _ = {
      number: A,
      descr: R,
      section: R.section,
      width: 150,
      padding: 20,
      maxHeight: g
    }, O = eu.getVirtualNodeHeight(u, _, i);
    ie.debug("taskHeight before draw", O), g = Math.max(g, O + 20), E = Math.max(E, R.events.length);
    let P = 0;
    for (const S of R.events) {
      const M = {
        descr: S,
        section: R.section,
        number: R.section,
        width: 150,
        padding: 20,
        maxHeight: 50
      };
      P += eu.getVirtualNodeHeight(u, M, i);
    }
    R.events.length > 0 && (P += (R.events.length - 1) * 10), L = Math.max(L, P);
  }
  ie.debug("maxSectionHeight before draw", p), ie.debug("maxTaskHeight before draw", g), f && f.length > 0 ? f.forEach((A) => {
    const R = h.filter((S) => S.section === A), _ = {
      number: w,
      descr: A,
      section: w,
      width: 200 * Math.max(R.length, 1) - 50,
      padding: 20,
      maxHeight: p
    };
    ie.debug("sectionNode", _);
    const O = u.append("g"), P = eu.drawNode(O, _, w, i);
    ie.debug("sectionNode output", P), O.attr("transform", `translate(${y}, ${v})`), b += p + 50, R.length > 0 && XN(
      u,
      R,
      w,
      y,
      b,
      g,
      i,
      E,
      L,
      p,
      !1
    ), y += 200 * Math.max(R.length, 1), b = v, w++;
  }) : (T = !1, XN(
    u,
    h,
    w,
    y,
    b,
    g,
    i,
    E,
    L,
    p,
    !0
  ));
  const k = u.node().getBBox();
  ie.debug("bounds", k), d && u.append("text").text(d).attr("x", k.width / 2 - a).attr("font-size", "4ex").attr("font-weight", "bold").attr("y", 20), m = T ? p + g + 150 : g + 100, u.append("g").attr("class", "lineWrapper").append("line").attr("x1", a).attr("y1", m).attr("x2", k.width + 3 * a).attr("y2", m).attr("stroke-width", 4).attr("stroke", "black").attr("marker-end", "url(#arrowhead)"), og(
    void 0,
    u,
    i.timeline?.padding ?? 50,
    i.timeline?.useMaxWidth ?? !1
  );
}, "draw"), XN = /* @__PURE__ */ x(function(t, e, r, n, i, a, s, o, l, u, h) {
  for (const d of e) {
    const f = {
      descr: d.task,
      section: r,
      number: r,
      width: 150,
      padding: 20,
      maxHeight: a
    };
    ie.debug("taskNode", f);
    const p = t.append("g").attr("class", "taskWrapper"), m = eu.drawNode(p, f, r, s).height;
    if (ie.debug("taskHeight after draw", m), p.attr("transform", `translate(${n}, ${i})`), a = Math.max(a, m), d.events) {
      const v = t.append("g").attr("class", "lineWrapper");
      let y = a;
      i += 100, y = y + EOe(t, d.events, r, n, i, s), i -= 100, v.append("line").attr("x1", n + 190 / 2).attr("y1", i + a).attr("x2", n + 190 / 2).attr("y2", i + a + 100 + l + 100).attr("stroke-width", 2).attr("stroke", "black").attr("marker-end", "url(#arrowhead)").attr("stroke-dasharray", "5,5");
    }
    n = n + 200, h && !s.timeline?.disableMulticolor && r++;
  }
  i = i - 10;
}, "drawTasks"), EOe = /* @__PURE__ */ x(function(t, e, r, n, i, a) {
  let s = 0;
  const o = i;
  i = i + 100;
  for (const l of e) {
    const u = {
      descr: l,
      section: r,
      number: r,
      width: 150,
      padding: 20,
      maxHeight: 50
    };
    ie.debug("eventNode", u);
    const h = t.append("g").attr("class", "eventWrapper"), f = eu.drawNode(h, u, r, a).height;
    s = s + f, h.attr("transform", `translate(${n}, ${i})`), i = i + 10 + f;
  }
  return i = o, s;
}, "drawEvents"), kOe = {
  setConf: /* @__PURE__ */ x(() => {
  }, "setConf"),
  draw: TOe
}, SOe = /* @__PURE__ */ x((t) => {
  let e = "";
  for (let r = 0; r < t.THEME_COLOR_LIMIT; r++)
    t["lineColor" + r] = t["lineColor" + r] || t["cScaleInv" + r], hc(t["lineColor" + r]) ? t["lineColor" + r] = At(t["lineColor" + r], 20) : t["lineColor" + r] = It(t["lineColor" + r], 20);
  for (let r = 0; r < t.THEME_COLOR_LIMIT; r++) {
    const n = "" + (17 - 3 * r);
    e += `
    .section-${r - 1} rect, .section-${r - 1} path, .section-${r - 1} circle, .section-${r - 1} path  {
      fill: ${t["cScale" + r]};
    }
    .section-${r - 1} text {
     fill: ${t["cScaleLabel" + r]};
    }
    .node-icon-${r - 1} {
      font-size: 40px;
      color: ${t["cScaleLabel" + r]};
    }
    .section-edge-${r - 1}{
      stroke: ${t["cScale" + r]};
    }
    .edge-depth-${r - 1}{
      stroke-width: ${n};
    }
    .section-${r - 1} line {
      stroke: ${t["cScaleInv" + r]} ;
      stroke-width: 3;
    }

    .lineWrapper line{
      stroke: ${t["cScaleLabel" + r]} ;
    }

    .disabled, .disabled circle, .disabled text {
      fill: lightgray;
    }
    .disabled text {
      fill: #efefef;
    }
    `;
  }
  return e;
}, "genSections"), COe = /* @__PURE__ */ x((t) => `
  .edge {
    stroke-width: 3;
  }
  ${SOe(t)}
  .section-root rect, .section-root path, .section-root circle  {
    fill: ${t.git0};
  }
  .section-root text {
    fill: ${t.gitBranchLabel0};
  }
  .icon-container {
    height:100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .edge {
    fill: none;
  }
  .eventWrapper  {
   filter: brightness(120%);
  }
`, "getStyles"), AOe = COe, _Oe = {
  db: TX,
  renderer: kOe,
  parser: lOe,
  styles: AOe
};
const LOe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: _Oe
}, Symbol.toStringTag, { value: "Module" })), ni = [];
for (let t = 0; t < 256; ++t)
  ni.push((t + 256).toString(16).slice(1));
function ROe(t, e = 0) {
  return (ni[t[e + 0]] + ni[t[e + 1]] + ni[t[e + 2]] + ni[t[e + 3]] + "-" + ni[t[e + 4]] + ni[t[e + 5]] + "-" + ni[t[e + 6]] + ni[t[e + 7]] + "-" + ni[t[e + 8]] + ni[t[e + 9]] + "-" + ni[t[e + 10]] + ni[t[e + 11]] + ni[t[e + 12]] + ni[t[e + 13]] + ni[t[e + 14]] + ni[t[e + 15]]).toLowerCase();
}
let q5;
const MOe = new Uint8Array(16);
function NOe() {
  if (!q5) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    q5 = crypto.getRandomValues.bind(crypto);
  }
  return q5(MOe);
}
const IOe = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), jN = { randomUUID: IOe };
function DOe(t, e, r) {
  if (jN.randomUUID && !t)
    return jN.randomUUID();
  t = t || {};
  const n = t.random ?? t.rng?.() ?? NOe();
  if (n.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, ROe(n);
}
var U6 = (function() {
  var t = /* @__PURE__ */ x(function(T, E, L, k) {
    for (L = L || {}, k = T.length; k--; L[T[k]] = E) ;
    return L;
  }, "o"), e = [1, 4], r = [1, 13], n = [1, 12], i = [1, 15], a = [1, 16], s = [1, 20], o = [1, 19], l = [6, 7, 8], u = [1, 26], h = [1, 24], d = [1, 25], f = [6, 7, 11], p = [1, 6, 13, 15, 16, 19, 22], g = [1, 33], m = [1, 34], v = [1, 6, 7, 11, 13, 15, 16, 19, 22], y = {
    trace: /* @__PURE__ */ x(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, mindMap: 4, spaceLines: 5, SPACELINE: 6, NL: 7, MINDMAP: 8, document: 9, stop: 10, EOF: 11, statement: 12, SPACELIST: 13, node: 14, ICON: 15, CLASS: 16, nodeWithId: 17, nodeWithoutId: 18, NODE_DSTART: 19, NODE_DESCR: 20, NODE_DEND: 21, NODE_ID: 22, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 6: "SPACELINE", 7: "NL", 8: "MINDMAP", 11: "EOF", 13: "SPACELIST", 15: "ICON", 16: "CLASS", 19: "NODE_DSTART", 20: "NODE_DESCR", 21: "NODE_DEND", 22: "NODE_ID" },
    productions_: [0, [3, 1], [3, 2], [5, 1], [5, 2], [5, 2], [4, 2], [4, 3], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [9, 3], [9, 2], [12, 2], [12, 2], [12, 2], [12, 1], [12, 1], [12, 1], [12, 1], [12, 1], [14, 1], [14, 1], [18, 3], [17, 1], [17, 4]],
    performAction: /* @__PURE__ */ x(function(E, L, k, C, A, R, _) {
      var O = R.length - 1;
      switch (A) {
        case 6:
        case 7:
          return C;
        case 8:
          C.getLogger().trace("Stop NL ");
          break;
        case 9:
          C.getLogger().trace("Stop EOF ");
          break;
        case 11:
          C.getLogger().trace("Stop NL2 ");
          break;
        case 12:
          C.getLogger().trace("Stop EOF2 ");
          break;
        case 15:
          C.getLogger().info("Node: ", R[O].id), C.addNode(R[O - 1].length, R[O].id, R[O].descr, R[O].type);
          break;
        case 16:
          C.getLogger().trace("Icon: ", R[O]), C.decorateNode({ icon: R[O] });
          break;
        case 17:
        case 21:
          C.decorateNode({ class: R[O] });
          break;
        case 18:
          C.getLogger().trace("SPACELIST");
          break;
        case 19:
          C.getLogger().trace("Node: ", R[O].id), C.addNode(0, R[O].id, R[O].descr, R[O].type);
          break;
        case 20:
          C.decorateNode({ icon: R[O] });
          break;
        case 25:
          C.getLogger().trace("node found ..", R[O - 2]), this.$ = { id: R[O - 1], descr: R[O - 1], type: C.getType(R[O - 2], R[O]) };
          break;
        case 26:
          this.$ = { id: R[O], descr: R[O], type: C.nodeType.DEFAULT };
          break;
        case 27:
          C.getLogger().trace("node found ..", R[O - 3]), this.$ = { id: R[O - 3], descr: R[O - 1], type: C.getType(R[O - 2], R[O]) };
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: 2, 5: 3, 6: [1, 5], 8: e }, { 1: [3] }, { 1: [2, 1] }, { 4: 6, 6: [1, 7], 7: [1, 8], 8: e }, { 6: r, 7: [1, 10], 9: 9, 12: 11, 13: n, 14: 14, 15: i, 16: a, 17: 17, 18: 18, 19: s, 22: o }, t(l, [2, 3]), { 1: [2, 2] }, t(l, [2, 4]), t(l, [2, 5]), { 1: [2, 6], 6: r, 12: 21, 13: n, 14: 14, 15: i, 16: a, 17: 17, 18: 18, 19: s, 22: o }, { 6: r, 9: 22, 12: 11, 13: n, 14: 14, 15: i, 16: a, 17: 17, 18: 18, 19: s, 22: o }, { 6: u, 7: h, 10: 23, 11: d }, t(f, [2, 22], { 17: 17, 18: 18, 14: 27, 15: [1, 28], 16: [1, 29], 19: s, 22: o }), t(f, [2, 18]), t(f, [2, 19]), t(f, [2, 20]), t(f, [2, 21]), t(f, [2, 23]), t(f, [2, 24]), t(f, [2, 26], { 19: [1, 30] }), { 20: [1, 31] }, { 6: u, 7: h, 10: 32, 11: d }, { 1: [2, 7], 6: r, 12: 21, 13: n, 14: 14, 15: i, 16: a, 17: 17, 18: 18, 19: s, 22: o }, t(p, [2, 14], { 7: g, 11: m }), t(v, [2, 8]), t(v, [2, 9]), t(v, [2, 10]), t(f, [2, 15]), t(f, [2, 16]), t(f, [2, 17]), { 20: [1, 35] }, { 21: [1, 36] }, t(p, [2, 13], { 7: g, 11: m }), t(v, [2, 11]), t(v, [2, 12]), { 21: [1, 37] }, t(f, [2, 25]), t(f, [2, 27])],
    defaultActions: { 2: [2, 1], 6: [2, 2] },
    parseError: /* @__PURE__ */ x(function(E, L) {
      if (L.recoverable)
        this.trace(E);
      else {
        var k = new Error(E);
        throw k.hash = L, k;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ x(function(E) {
      var L = this, k = [0], C = [], A = [null], R = [], _ = this.table, O = "", P = 0, S = 0, M = 2, N = 1, D = R.slice.call(arguments, 1), I = Object.create(this.lexer), B = { yy: {} };
      for (var z in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, z) && (B.yy[z] = this.yy[z]);
      I.setInput(E, B.yy), B.yy.lexer = I, B.yy.parser = this, typeof I.yylloc > "u" && (I.yylloc = {});
      var F = I.yylloc;
      R.push(F);
      var V = I.options && I.options.ranges;
      typeof B.yy.parseError == "function" ? this.parseError = B.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function H(fe) {
        k.length = k.length - 2 * fe, A.length = A.length - fe, R.length = R.length - fe;
      }
      x(H, "popStack");
      function J() {
        var fe;
        return fe = C.pop() || I.lex() || N, typeof fe != "number" && (fe instanceof Array && (C = fe, fe = C.pop()), fe = L.symbols_[fe] || fe), fe;
      }
      x(J, "lex");
      for (var q, ae, re, pe, K = {}, Z, X, Y, ee; ; ) {
        if (ae = k[k.length - 1], this.defaultActions[ae] ? re = this.defaultActions[ae] : ((q === null || typeof q > "u") && (q = J()), re = _[ae] && _[ae][q]), typeof re > "u" || !re.length || !re[0]) {
          var j = "";
          ee = [];
          for (Z in _[ae])
            this.terminals_[Z] && Z > M && ee.push("'" + this.terminals_[Z] + "'");
          I.showPosition ? j = "Parse error on line " + (P + 1) + `:
` + I.showPosition() + `
Expecting ` + ee.join(", ") + ", got '" + (this.terminals_[q] || q) + "'" : j = "Parse error on line " + (P + 1) + ": Unexpected " + (q == N ? "end of input" : "'" + (this.terminals_[q] || q) + "'"), this.parseError(j, {
            text: I.match,
            token: this.terminals_[q] || q,
            line: I.yylineno,
            loc: F,
            expected: ee
          });
        }
        if (re[0] instanceof Array && re.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + ae + ", token: " + q);
        switch (re[0]) {
          case 1:
            k.push(q), A.push(I.yytext), R.push(I.yylloc), k.push(re[1]), q = null, S = I.yyleng, O = I.yytext, P = I.yylineno, F = I.yylloc;
            break;
          case 2:
            if (X = this.productions_[re[1]][1], K.$ = A[A.length - X], K._$ = {
              first_line: R[R.length - (X || 1)].first_line,
              last_line: R[R.length - 1].last_line,
              first_column: R[R.length - (X || 1)].first_column,
              last_column: R[R.length - 1].last_column
            }, V && (K._$.range = [
              R[R.length - (X || 1)].range[0],
              R[R.length - 1].range[1]
            ]), pe = this.performAction.apply(K, [
              O,
              S,
              P,
              B.yy,
              re[1],
              A,
              R
            ].concat(D)), typeof pe < "u")
              return pe;
            X && (k = k.slice(0, -1 * X * 2), A = A.slice(0, -1 * X), R = R.slice(0, -1 * X)), k.push(this.productions_[re[1]][0]), A.push(K.$), R.push(K._$), Y = _[k[k.length - 2]][k[k.length - 1]], k.push(Y);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, b = /* @__PURE__ */ (function() {
    var T = {
      EOF: 1,
      parseError: /* @__PURE__ */ x(function(L, k) {
        if (this.yy.parser)
          this.yy.parser.parseError(L, k);
        else
          throw new Error(L);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ x(function(E, L) {
        return this.yy = L || this.yy || {}, this._input = E, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ x(function() {
        var E = this._input[0];
        this.yytext += E, this.yyleng++, this.offset++, this.match += E, this.matched += E;
        var L = E.match(/(?:\r\n?|\n).*/g);
        return L ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), E;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ x(function(E) {
        var L = E.length, k = E.split(/(?:\r\n?|\n)/g);
        this._input = E + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - L), this.offset -= L;
        var C = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), k.length - 1 && (this.yylineno -= k.length - 1);
        var A = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: k ? (k.length === C.length ? this.yylloc.first_column : 0) + C[C.length - k.length].length - k[0].length : this.yylloc.first_column - L
        }, this.options.ranges && (this.yylloc.range = [A[0], A[0] + this.yyleng - L]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ x(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ x(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ x(function(E) {
        this.unput(this.match.slice(E));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ x(function() {
        var E = this.matched.substr(0, this.matched.length - this.match.length);
        return (E.length > 20 ? "..." : "") + E.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ x(function() {
        var E = this.match;
        return E.length < 20 && (E += this._input.substr(0, 20 - E.length)), (E.substr(0, 20) + (E.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ x(function() {
        var E = this.pastInput(), L = new Array(E.length + 1).join("-");
        return E + this.upcomingInput() + `
` + L + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ x(function(E, L) {
        var k, C, A;
        if (this.options.backtrack_lexer && (A = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (A.yylloc.range = this.yylloc.range.slice(0))), C = E[0].match(/(?:\r\n?|\n).*/g), C && (this.yylineno += C.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: C ? C[C.length - 1].length - C[C.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + E[0].length
        }, this.yytext += E[0], this.match += E[0], this.matches = E, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(E[0].length), this.matched += E[0], k = this.performAction.call(this, this.yy, this, L, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), k)
          return k;
        if (this._backtrack) {
          for (var R in A)
            this[R] = A[R];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ x(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var E, L, k, C;
        this._more || (this.yytext = "", this.match = "");
        for (var A = this._currentRules(), R = 0; R < A.length; R++)
          if (k = this._input.match(this.rules[A[R]]), k && (!L || k[0].length > L[0].length)) {
            if (L = k, C = R, this.options.backtrack_lexer) {
              if (E = this.test_match(k, A[R]), E !== !1)
                return E;
              if (this._backtrack) {
                L = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return L ? (E = this.test_match(L, A[C]), E !== !1 ? E : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ x(function() {
        var L = this.next();
        return L || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ x(function(L) {
        this.conditionStack.push(L);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ x(function() {
        var L = this.conditionStack.length - 1;
        return L > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ x(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ x(function(L) {
        return L = this.conditionStack.length - 1 - Math.abs(L || 0), L >= 0 ? this.conditionStack[L] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ x(function(L) {
        this.begin(L);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ x(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ x(function(L, k, C, A) {
        switch (C) {
          case 0:
            return L.getLogger().trace("Found comment", k.yytext), 6;
          case 1:
            return 8;
          case 2:
            this.begin("CLASS");
            break;
          case 3:
            return this.popState(), 16;
          case 4:
            this.popState();
            break;
          case 5:
            L.getLogger().trace("Begin icon"), this.begin("ICON");
            break;
          case 6:
            return L.getLogger().trace("SPACELINE"), 6;
          case 7:
            return 7;
          case 8:
            return 15;
          case 9:
            L.getLogger().trace("end icon"), this.popState();
            break;
          case 10:
            return L.getLogger().trace("Exploding node"), this.begin("NODE"), 19;
          case 11:
            return L.getLogger().trace("Cloud"), this.begin("NODE"), 19;
          case 12:
            return L.getLogger().trace("Explosion Bang"), this.begin("NODE"), 19;
          case 13:
            return L.getLogger().trace("Cloud Bang"), this.begin("NODE"), 19;
          case 14:
            return this.begin("NODE"), 19;
          case 15:
            return this.begin("NODE"), 19;
          case 16:
            return this.begin("NODE"), 19;
          case 17:
            return this.begin("NODE"), 19;
          case 18:
            return 13;
          case 19:
            return 22;
          case 20:
            return 11;
          case 21:
            this.begin("NSTR2");
            break;
          case 22:
            return "NODE_DESCR";
          case 23:
            this.popState();
            break;
          case 24:
            L.getLogger().trace("Starting NSTR"), this.begin("NSTR");
            break;
          case 25:
            return L.getLogger().trace("description:", k.yytext), "NODE_DESCR";
          case 26:
            this.popState();
            break;
          case 27:
            return this.popState(), L.getLogger().trace("node end ))"), "NODE_DEND";
          case 28:
            return this.popState(), L.getLogger().trace("node end )"), "NODE_DEND";
          case 29:
            return this.popState(), L.getLogger().trace("node end ...", k.yytext), "NODE_DEND";
          case 30:
            return this.popState(), L.getLogger().trace("node end (("), "NODE_DEND";
          case 31:
            return this.popState(), L.getLogger().trace("node end (-"), "NODE_DEND";
          case 32:
            return this.popState(), L.getLogger().trace("node end (-"), "NODE_DEND";
          case 33:
            return this.popState(), L.getLogger().trace("node end (("), "NODE_DEND";
          case 34:
            return this.popState(), L.getLogger().trace("node end (("), "NODE_DEND";
          case 35:
            return L.getLogger().trace("Long description:", k.yytext), 20;
          case 36:
            return L.getLogger().trace("Long description:", k.yytext), 20;
        }
      }, "anonymous"),
      rules: [/^(?:\s*%%.*)/i, /^(?:mindmap\b)/i, /^(?::::)/i, /^(?:.+)/i, /^(?:\n)/i, /^(?:::icon\()/i, /^(?:[\s]+[\n])/i, /^(?:[\n]+)/i, /^(?:[^\)]+)/i, /^(?:\))/i, /^(?:-\))/i, /^(?:\(-)/i, /^(?:\)\))/i, /^(?:\))/i, /^(?:\(\()/i, /^(?:\{\{)/i, /^(?:\()/i, /^(?:\[)/i, /^(?:[\s]+)/i, /^(?:[^\(\[\n\)\{\}]+)/i, /^(?:$)/i, /^(?:["][`])/i, /^(?:[^`"]+)/i, /^(?:[`]["])/i, /^(?:["])/i, /^(?:[^"]+)/i, /^(?:["])/i, /^(?:[\)]\))/i, /^(?:[\)])/i, /^(?:[\]])/i, /^(?:\}\})/i, /^(?:\(-)/i, /^(?:-\))/i, /^(?:\(\()/i, /^(?:\()/i, /^(?:[^\)\]\(\}]+)/i, /^(?:.+(?!\(\())/i],
      conditions: { CLASS: { rules: [3, 4], inclusive: !1 }, ICON: { rules: [8, 9], inclusive: !1 }, NSTR2: { rules: [22, 23], inclusive: !1 }, NSTR: { rules: [25, 26], inclusive: !1 }, NODE: { rules: [21, 24, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], inclusive: !0 } }
    };
    return T;
  })();
  y.lexer = b;
  function w() {
    this.yy = {};
  }
  return x(w, "Parser"), w.prototype = y, y.Parser = w, new w();
})();
U6.parser = U6;
var OOe = U6, _o = {
  DEFAULT: 0,
  NO_BORDER: 0,
  ROUNDED_RECT: 1,
  RECT: 2,
  CIRCLE: 3,
  CLOUD: 4,
  BANG: 5,
  HEXAGON: 6
}, POe = class {
  constructor() {
    this.nodes = [], this.count = 0, this.elements = {}, this.getLogger = this.getLogger.bind(this), this.nodeType = _o, this.clear(), this.getType = this.getType.bind(this), this.getElementById = this.getElementById.bind(this), this.getParent = this.getParent.bind(this), this.getMindmap = this.getMindmap.bind(this), this.addNode = this.addNode.bind(this), this.decorateNode = this.decorateNode.bind(this);
  }
  static {
    x(this, "MindmapDB");
  }
  clear() {
    this.nodes = [], this.count = 0, this.elements = {}, this.baseLevel = void 0;
  }
  getParent(t) {
    for (let e = this.nodes.length - 1; e >= 0; e--)
      if (this.nodes[e].level < t)
        return this.nodes[e];
    return null;
  }
  getMindmap() {
    return this.nodes.length > 0 ? this.nodes[0] : null;
  }
  addNode(t, e, r, n) {
    ie.info("addNode", t, e, r, n);
    let i = !1;
    this.nodes.length === 0 ? (this.baseLevel = t, t = 0, i = !0) : this.baseLevel !== void 0 && (t = t - this.baseLevel, i = !1);
    const a = we();
    let s = a.mindmap?.padding ?? ur.mindmap.padding;
    switch (n) {
      case this.nodeType.ROUNDED_RECT:
      case this.nodeType.RECT:
      case this.nodeType.HEXAGON:
        s *= 2;
        break;
    }
    const o = {
      id: this.count++,
      nodeId: dr(e, a),
      level: t,
      descr: dr(r, a),
      type: n,
      children: [],
      width: a.mindmap?.maxNodeWidth ?? ur.mindmap.maxNodeWidth,
      padding: s,
      isRoot: i
    }, l = this.getParent(t);
    if (l)
      l.children.push(o), this.nodes.push(o);
    else if (i)
      this.nodes.push(o);
    else
      throw new Error(
        `There can be only one root. No parent could be found for ("${o.descr}")`
      );
  }
  getType(t, e) {
    switch (ie.debug("In get type", t, e), t) {
      case "[":
        return this.nodeType.RECT;
      case "(":
        return e === ")" ? this.nodeType.ROUNDED_RECT : this.nodeType.CLOUD;
      case "((":
        return this.nodeType.CIRCLE;
      case ")":
        return this.nodeType.CLOUD;
      case "))":
        return this.nodeType.BANG;
      case "{{":
        return this.nodeType.HEXAGON;
      default:
        return this.nodeType.DEFAULT;
    }
  }
  setElementForId(t, e) {
    this.elements[t] = e;
  }
  getElementById(t) {
    return this.elements[t];
  }
  decorateNode(t) {
    if (!t)
      return;
    const e = we(), r = this.nodes[this.nodes.length - 1];
    t.icon && (r.icon = dr(t.icon, e)), t.class && (r.class = dr(t.class, e));
  }
  type2Str(t) {
    switch (t) {
      case this.nodeType.DEFAULT:
        return "no-border";
      case this.nodeType.RECT:
        return "rect";
      case this.nodeType.ROUNDED_RECT:
        return "rounded-rect";
      case this.nodeType.CIRCLE:
        return "circle";
      case this.nodeType.CLOUD:
        return "cloud";
      case this.nodeType.BANG:
        return "bang";
      case this.nodeType.HEXAGON:
        return "hexgon";
      // cspell: disable-line
      default:
        return "no-border";
    }
  }
  /**
   * Assign section numbers to nodes based on their position relative to root
   * @param node - The mindmap node to process
   * @param sectionNumber - The section number to assign (undefined for root)
   */
  assignSections(t, e) {
    if (t.level === 0 ? t.section = void 0 : t.section = e, t.children)
      for (const [r, n] of t.children.entries()) {
        const i = t.level === 0 ? r : e;
        this.assignSections(n, i);
      }
  }
  /**
   * Convert mindmap tree structure to flat array of nodes
   * @param node - The mindmap node to process
   * @param processedNodes - Array to collect processed nodes
   */
  flattenNodes(t, e) {
    const r = ["mindmap-node"];
    t.isRoot === !0 ? r.push("section-root", "section--1") : t.section !== void 0 && r.push(`section-${t.section}`), t.class && r.push(t.class);
    const n = r.join(" "), i = /* @__PURE__ */ x((s) => {
      switch (s) {
        case _o.CIRCLE:
          return "mindmapCircle";
        case _o.RECT:
          return "rect";
        case _o.ROUNDED_RECT:
          return "rounded";
        case _o.CLOUD:
          return "cloud";
        case _o.BANG:
          return "bang";
        case _o.HEXAGON:
          return "hexagon";
        case _o.DEFAULT:
          return "defaultMindmapNode";
        case _o.NO_BORDER:
        default:
          return "rect";
      }
    }, "getShapeFromType"), a = {
      id: t.id.toString(),
      domId: "node_" + t.id.toString(),
      label: t.descr,
      isGroup: !1,
      shape: i(t.type),
      width: t.width,
      height: t.height ?? 0,
      padding: t.padding,
      cssClasses: n,
      cssStyles: [],
      look: "default",
      icon: t.icon,
      x: t.x,
      y: t.y,
      // Mindmap-specific properties
      level: t.level,
      nodeId: t.nodeId,
      type: t.type,
      section: t.section
    };
    if (e.push(a), t.children)
      for (const s of t.children)
        this.flattenNodes(s, e);
  }
  /**
   * Generate edges from parent-child relationships in mindmap tree
   * @param node - The mindmap node to process
   * @param edges - Array to collect edges
   */
  generateEdges(t, e) {
    if (t.children)
      for (const r of t.children) {
        let n = "edge";
        r.section !== void 0 && (n += ` section-edge-${r.section}`);
        const i = t.level + 1;
        n += ` edge-depth-${i}`;
        const a = {
          id: `edge_${t.id}_${r.id}`,
          start: t.id.toString(),
          end: r.id.toString(),
          type: "normal",
          curve: "basis",
          thickness: "normal",
          look: "default",
          classes: n,
          // Store mindmap-specific data
          depth: t.level,
          section: r.section
        };
        e.push(a), this.generateEdges(r, e);
      }
  }
  /**
   * Get structured data for layout algorithms
   * Following the pattern established by ER diagrams
   * @returns Structured data containing nodes, edges, and config
   */
  getData() {
    const t = this.getMindmap(), e = we(), n = _K().layout !== void 0, i = e;
    if (n || (i.layout = "cose-bilkent"), !t)
      return {
        nodes: [],
        edges: [],
        config: i
      };
    ie.debug("getData: mindmapRoot", t, e), this.assignSections(t);
    const a = [], s = [];
    this.flattenNodes(t, a), this.generateEdges(t, s), ie.debug(
      `getData: processed ${a.length} nodes and ${s.length} edges`
    );
    const o = /* @__PURE__ */ new Map();
    for (const l of a)
      o.set(l.id, {
        shape: l.shape,
        width: l.width,
        height: l.height,
        padding: l.padding
      });
    return {
      nodes: a,
      edges: s,
      config: i,
      // Store the root node for mindmap-specific layout algorithms
      rootNode: t,
      // Properties required by dagre layout algorithm
      markers: ["point"],
      // Mindmaps don't use markers
      direction: "TB",
      // Top-to-bottom direction for mindmaps
      nodeSpacing: 50,
      // Default spacing between nodes
      rankSpacing: 50,
      // Default spacing between ranks
      // Add shapes for ELK compatibility
      shapes: Object.fromEntries(o),
      // Additional properties that layout algorithms might expect
      type: "mindmap",
      diagramId: "mindmap-" + DOe()
    };
  }
  // Expose logger to grammar
  getLogger() {
    return ie;
  }
}, BOe = /* @__PURE__ */ x(async (t, e, r, n) => {
  ie.debug(`Rendering mindmap diagram
` + t);
  const i = n.db, a = i.getData(), s = lf(e, a.config.securityLevel);
  a.type = n.type, a.layoutAlgorithm = mg(a.config.layout, {
    fallback: "cose-bilkent"
  }), a.diagramId = e, i.getMindmap() && (a.nodes.forEach((l) => {
    l.shape === "rounded" ? (l.radius = 15, l.taper = 15, l.stroke = "none", l.width = 0, l.padding = 15) : l.shape === "circle" ? l.padding = 10 : l.shape === "rect" && (l.width = 0, l.padding = 10);
  }), await Kd(a, s), rh(
    s,
    a.config.mindmap?.padding ?? ur.mindmap.padding,
    "mindmapDiagram",
    a.config.mindmap?.useMaxWidth ?? ur.mindmap.useMaxWidth
  ));
}, "draw"), FOe = {
  draw: BOe
}, $Oe = /* @__PURE__ */ x((t) => {
  let e = "";
  for (let r = 0; r < t.THEME_COLOR_LIMIT; r++)
    t["lineColor" + r] = t["lineColor" + r] || t["cScaleInv" + r], hc(t["lineColor" + r]) ? t["lineColor" + r] = At(t["lineColor" + r], 20) : t["lineColor" + r] = It(t["lineColor" + r], 20);
  for (let r = 0; r < t.THEME_COLOR_LIMIT; r++) {
    const n = "" + (17 - 3 * r);
    e += `
    .section-${r - 1} rect, .section-${r - 1} path, .section-${r - 1} circle, .section-${r - 1} polygon, .section-${r - 1} path  {
      fill: ${t["cScale" + r]};
    }
    .section-${r - 1} text {
     fill: ${t["cScaleLabel" + r]};
    }
    .node-icon-${r - 1} {
      font-size: 40px;
      color: ${t["cScaleLabel" + r]};
    }
    .section-edge-${r - 1}{
      stroke: ${t["cScale" + r]};
    }
    .edge-depth-${r - 1}{
      stroke-width: ${n};
    }
    .section-${r - 1} line {
      stroke: ${t["cScaleInv" + r]} ;
      stroke-width: 3;
    }

    .disabled, .disabled circle, .disabled text {
      fill: lightgray;
    }
    .disabled text {
      fill: #efefef;
    }
    `;
  }
  return e;
}, "genSections"), zOe = /* @__PURE__ */ x((t) => `
  .edge {
    stroke-width: 3;
  }
  ${$Oe(t)}
  .section-root rect, .section-root path, .section-root circle, .section-root polygon  {
    fill: ${t.git0};
  }
  .section-root text {
    fill: ${t.gitBranchLabel0};
  }
  .section-root span {
    color: ${t.gitBranchLabel0};
  }
  .section-2 span {
    color: ${t.gitBranchLabel0};
  }
  .icon-container {
    height:100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .edge {
    fill: none;
  }
  .mindmap-node-label {
    dy: 1em;
    alignment-baseline: middle;
    text-anchor: middle;
    dominant-baseline: middle;
    text-align: center;
  }
`, "getStyles"), GOe = zOe, VOe = {
  get db() {
    return new POe();
  },
  renderer: FOe,
  parser: OOe,
  styles: GOe
};
const UOe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: VOe
}, Symbol.toStringTag, { value: "Module" }));
var H6 = (function() {
  var t = /* @__PURE__ */ x(function(k, C, A, R) {
    for (A = A || {}, R = k.length; R--; A[k[R]] = C) ;
    return A;
  }, "o"), e = [1, 4], r = [1, 13], n = [1, 12], i = [1, 15], a = [1, 16], s = [1, 20], o = [1, 19], l = [6, 7, 8], u = [1, 26], h = [1, 24], d = [1, 25], f = [6, 7, 11], p = [1, 31], g = [6, 7, 11, 24], m = [1, 6, 13, 16, 17, 20, 23], v = [1, 35], y = [1, 36], b = [1, 6, 7, 11, 13, 16, 17, 20, 23], w = [1, 38], T = {
    trace: /* @__PURE__ */ x(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, mindMap: 4, spaceLines: 5, SPACELINE: 6, NL: 7, KANBAN: 8, document: 9, stop: 10, EOF: 11, statement: 12, SPACELIST: 13, node: 14, shapeData: 15, ICON: 16, CLASS: 17, nodeWithId: 18, nodeWithoutId: 19, NODE_DSTART: 20, NODE_DESCR: 21, NODE_DEND: 22, NODE_ID: 23, SHAPE_DATA: 24, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 6: "SPACELINE", 7: "NL", 8: "KANBAN", 11: "EOF", 13: "SPACELIST", 16: "ICON", 17: "CLASS", 20: "NODE_DSTART", 21: "NODE_DESCR", 22: "NODE_DEND", 23: "NODE_ID", 24: "SHAPE_DATA" },
    productions_: [0, [3, 1], [3, 2], [5, 1], [5, 2], [5, 2], [4, 2], [4, 3], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [9, 3], [9, 2], [12, 3], [12, 2], [12, 2], [12, 2], [12, 1], [12, 2], [12, 1], [12, 1], [12, 1], [12, 1], [14, 1], [14, 1], [19, 3], [18, 1], [18, 4], [15, 2], [15, 1]],
    performAction: /* @__PURE__ */ x(function(C, A, R, _, O, P, S) {
      var M = P.length - 1;
      switch (O) {
        case 6:
        case 7:
          return _;
        case 8:
          _.getLogger().trace("Stop NL ");
          break;
        case 9:
          _.getLogger().trace("Stop EOF ");
          break;
        case 11:
          _.getLogger().trace("Stop NL2 ");
          break;
        case 12:
          _.getLogger().trace("Stop EOF2 ");
          break;
        case 15:
          _.getLogger().info("Node: ", P[M - 1].id), _.addNode(P[M - 2].length, P[M - 1].id, P[M - 1].descr, P[M - 1].type, P[M]);
          break;
        case 16:
          _.getLogger().info("Node: ", P[M].id), _.addNode(P[M - 1].length, P[M].id, P[M].descr, P[M].type);
          break;
        case 17:
          _.getLogger().trace("Icon: ", P[M]), _.decorateNode({ icon: P[M] });
          break;
        case 18:
        case 23:
          _.decorateNode({ class: P[M] });
          break;
        case 19:
          _.getLogger().trace("SPACELIST");
          break;
        case 20:
          _.getLogger().trace("Node: ", P[M - 1].id), _.addNode(0, P[M - 1].id, P[M - 1].descr, P[M - 1].type, P[M]);
          break;
        case 21:
          _.getLogger().trace("Node: ", P[M].id), _.addNode(0, P[M].id, P[M].descr, P[M].type);
          break;
        case 22:
          _.decorateNode({ icon: P[M] });
          break;
        case 27:
          _.getLogger().trace("node found ..", P[M - 2]), this.$ = { id: P[M - 1], descr: P[M - 1], type: _.getType(P[M - 2], P[M]) };
          break;
        case 28:
          this.$ = { id: P[M], descr: P[M], type: 0 };
          break;
        case 29:
          _.getLogger().trace("node found ..", P[M - 3]), this.$ = { id: P[M - 3], descr: P[M - 1], type: _.getType(P[M - 2], P[M]) };
          break;
        case 30:
          this.$ = P[M - 1] + P[M];
          break;
        case 31:
          this.$ = P[M];
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: 2, 5: 3, 6: [1, 5], 8: e }, { 1: [3] }, { 1: [2, 1] }, { 4: 6, 6: [1, 7], 7: [1, 8], 8: e }, { 6: r, 7: [1, 10], 9: 9, 12: 11, 13: n, 14: 14, 16: i, 17: a, 18: 17, 19: 18, 20: s, 23: o }, t(l, [2, 3]), { 1: [2, 2] }, t(l, [2, 4]), t(l, [2, 5]), { 1: [2, 6], 6: r, 12: 21, 13: n, 14: 14, 16: i, 17: a, 18: 17, 19: 18, 20: s, 23: o }, { 6: r, 9: 22, 12: 11, 13: n, 14: 14, 16: i, 17: a, 18: 17, 19: 18, 20: s, 23: o }, { 6: u, 7: h, 10: 23, 11: d }, t(f, [2, 24], { 18: 17, 19: 18, 14: 27, 16: [1, 28], 17: [1, 29], 20: s, 23: o }), t(f, [2, 19]), t(f, [2, 21], { 15: 30, 24: p }), t(f, [2, 22]), t(f, [2, 23]), t(g, [2, 25]), t(g, [2, 26]), t(g, [2, 28], { 20: [1, 32] }), { 21: [1, 33] }, { 6: u, 7: h, 10: 34, 11: d }, { 1: [2, 7], 6: r, 12: 21, 13: n, 14: 14, 16: i, 17: a, 18: 17, 19: 18, 20: s, 23: o }, t(m, [2, 14], { 7: v, 11: y }), t(b, [2, 8]), t(b, [2, 9]), t(b, [2, 10]), t(f, [2, 16], { 15: 37, 24: p }), t(f, [2, 17]), t(f, [2, 18]), t(f, [2, 20], { 24: w }), t(g, [2, 31]), { 21: [1, 39] }, { 22: [1, 40] }, t(m, [2, 13], { 7: v, 11: y }), t(b, [2, 11]), t(b, [2, 12]), t(f, [2, 15], { 24: w }), t(g, [2, 30]), { 22: [1, 41] }, t(g, [2, 27]), t(g, [2, 29])],
    defaultActions: { 2: [2, 1], 6: [2, 2] },
    parseError: /* @__PURE__ */ x(function(C, A) {
      if (A.recoverable)
        this.trace(C);
      else {
        var R = new Error(C);
        throw R.hash = A, R;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ x(function(C) {
      var A = this, R = [0], _ = [], O = [null], P = [], S = this.table, M = "", N = 0, D = 0, I = 2, B = 1, z = P.slice.call(arguments, 1), F = Object.create(this.lexer), V = { yy: {} };
      for (var H in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, H) && (V.yy[H] = this.yy[H]);
      F.setInput(C, V.yy), V.yy.lexer = F, V.yy.parser = this, typeof F.yylloc > "u" && (F.yylloc = {});
      var J = F.yylloc;
      P.push(J);
      var q = F.options && F.options.ranges;
      typeof V.yy.parseError == "function" ? this.parseError = V.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function ae(W) {
        R.length = R.length - 2 * W, O.length = O.length - W, P.length = P.length - W;
      }
      x(ae, "popStack");
      function re() {
        var W;
        return W = _.pop() || F.lex() || B, typeof W != "number" && (W instanceof Array && (_ = W, W = _.pop()), W = A.symbols_[W] || W), W;
      }
      x(re, "lex");
      for (var pe, K, Z, X, Y = {}, ee, j, fe, te; ; ) {
        if (K = R[R.length - 1], this.defaultActions[K] ? Z = this.defaultActions[K] : ((pe === null || typeof pe > "u") && (pe = re()), Z = S[K] && S[K][pe]), typeof Z > "u" || !Z.length || !Z[0]) {
          var Ae = "";
          te = [];
          for (ee in S[K])
            this.terminals_[ee] && ee > I && te.push("'" + this.terminals_[ee] + "'");
          F.showPosition ? Ae = "Parse error on line " + (N + 1) + `:
` + F.showPosition() + `
Expecting ` + te.join(", ") + ", got '" + (this.terminals_[pe] || pe) + "'" : Ae = "Parse error on line " + (N + 1) + ": Unexpected " + (pe == B ? "end of input" : "'" + (this.terminals_[pe] || pe) + "'"), this.parseError(Ae, {
            text: F.match,
            token: this.terminals_[pe] || pe,
            line: F.yylineno,
            loc: J,
            expected: te
          });
        }
        if (Z[0] instanceof Array && Z.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + K + ", token: " + pe);
        switch (Z[0]) {
          case 1:
            R.push(pe), O.push(F.yytext), P.push(F.yylloc), R.push(Z[1]), pe = null, D = F.yyleng, M = F.yytext, N = F.yylineno, J = F.yylloc;
            break;
          case 2:
            if (j = this.productions_[Z[1]][1], Y.$ = O[O.length - j], Y._$ = {
              first_line: P[P.length - (j || 1)].first_line,
              last_line: P[P.length - 1].last_line,
              first_column: P[P.length - (j || 1)].first_column,
              last_column: P[P.length - 1].last_column
            }, q && (Y._$.range = [
              P[P.length - (j || 1)].range[0],
              P[P.length - 1].range[1]
            ]), X = this.performAction.apply(Y, [
              M,
              D,
              N,
              V.yy,
              Z[1],
              O,
              P
            ].concat(z)), typeof X < "u")
              return X;
            j && (R = R.slice(0, -1 * j * 2), O = O.slice(0, -1 * j), P = P.slice(0, -1 * j)), R.push(this.productions_[Z[1]][0]), O.push(Y.$), P.push(Y._$), fe = S[R[R.length - 2]][R[R.length - 1]], R.push(fe);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, E = /* @__PURE__ */ (function() {
    var k = {
      EOF: 1,
      parseError: /* @__PURE__ */ x(function(A, R) {
        if (this.yy.parser)
          this.yy.parser.parseError(A, R);
        else
          throw new Error(A);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ x(function(C, A) {
        return this.yy = A || this.yy || {}, this._input = C, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ x(function() {
        var C = this._input[0];
        this.yytext += C, this.yyleng++, this.offset++, this.match += C, this.matched += C;
        var A = C.match(/(?:\r\n?|\n).*/g);
        return A ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), C;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ x(function(C) {
        var A = C.length, R = C.split(/(?:\r\n?|\n)/g);
        this._input = C + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - A), this.offset -= A;
        var _ = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), R.length - 1 && (this.yylineno -= R.length - 1);
        var O = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: R ? (R.length === _.length ? this.yylloc.first_column : 0) + _[_.length - R.length].length - R[0].length : this.yylloc.first_column - A
        }, this.options.ranges && (this.yylloc.range = [O[0], O[0] + this.yyleng - A]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ x(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ x(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ x(function(C) {
        this.unput(this.match.slice(C));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ x(function() {
        var C = this.matched.substr(0, this.matched.length - this.match.length);
        return (C.length > 20 ? "..." : "") + C.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ x(function() {
        var C = this.match;
        return C.length < 20 && (C += this._input.substr(0, 20 - C.length)), (C.substr(0, 20) + (C.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ x(function() {
        var C = this.pastInput(), A = new Array(C.length + 1).join("-");
        return C + this.upcomingInput() + `
` + A + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ x(function(C, A) {
        var R, _, O;
        if (this.options.backtrack_lexer && (O = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (O.yylloc.range = this.yylloc.range.slice(0))), _ = C[0].match(/(?:\r\n?|\n).*/g), _ && (this.yylineno += _.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: _ ? _[_.length - 1].length - _[_.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + C[0].length
        }, this.yytext += C[0], this.match += C[0], this.matches = C, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(C[0].length), this.matched += C[0], R = this.performAction.call(this, this.yy, this, A, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), R)
          return R;
        if (this._backtrack) {
          for (var P in O)
            this[P] = O[P];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ x(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var C, A, R, _;
        this._more || (this.yytext = "", this.match = "");
        for (var O = this._currentRules(), P = 0; P < O.length; P++)
          if (R = this._input.match(this.rules[O[P]]), R && (!A || R[0].length > A[0].length)) {
            if (A = R, _ = P, this.options.backtrack_lexer) {
              if (C = this.test_match(R, O[P]), C !== !1)
                return C;
              if (this._backtrack) {
                A = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return A ? (C = this.test_match(A, O[_]), C !== !1 ? C : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ x(function() {
        var A = this.next();
        return A || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ x(function(A) {
        this.conditionStack.push(A);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ x(function() {
        var A = this.conditionStack.length - 1;
        return A > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ x(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ x(function(A) {
        return A = this.conditionStack.length - 1 - Math.abs(A || 0), A >= 0 ? this.conditionStack[A] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ x(function(A) {
        this.begin(A);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ x(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ x(function(A, R, _, O) {
        switch (_) {
          case 0:
            return this.pushState("shapeData"), R.yytext = "", 24;
          case 1:
            return this.pushState("shapeDataStr"), 24;
          case 2:
            return this.popState(), 24;
          case 3:
            const P = /\n\s*/g;
            return R.yytext = R.yytext.replace(P, "<br/>"), 24;
          case 4:
            return 24;
          case 5:
            this.popState();
            break;
          case 6:
            return A.getLogger().trace("Found comment", R.yytext), 6;
          case 7:
            return 8;
          case 8:
            this.begin("CLASS");
            break;
          case 9:
            return this.popState(), 17;
          case 10:
            this.popState();
            break;
          case 11:
            A.getLogger().trace("Begin icon"), this.begin("ICON");
            break;
          case 12:
            return A.getLogger().trace("SPACELINE"), 6;
          case 13:
            return 7;
          case 14:
            return 16;
          case 15:
            A.getLogger().trace("end icon"), this.popState();
            break;
          case 16:
            return A.getLogger().trace("Exploding node"), this.begin("NODE"), 20;
          case 17:
            return A.getLogger().trace("Cloud"), this.begin("NODE"), 20;
          case 18:
            return A.getLogger().trace("Explosion Bang"), this.begin("NODE"), 20;
          case 19:
            return A.getLogger().trace("Cloud Bang"), this.begin("NODE"), 20;
          case 20:
            return this.begin("NODE"), 20;
          case 21:
            return this.begin("NODE"), 20;
          case 22:
            return this.begin("NODE"), 20;
          case 23:
            return this.begin("NODE"), 20;
          case 24:
            return 13;
          case 25:
            return 23;
          case 26:
            return 11;
          case 27:
            this.begin("NSTR2");
            break;
          case 28:
            return "NODE_DESCR";
          case 29:
            this.popState();
            break;
          case 30:
            A.getLogger().trace("Starting NSTR"), this.begin("NSTR");
            break;
          case 31:
            return A.getLogger().trace("description:", R.yytext), "NODE_DESCR";
          case 32:
            this.popState();
            break;
          case 33:
            return this.popState(), A.getLogger().trace("node end ))"), "NODE_DEND";
          case 34:
            return this.popState(), A.getLogger().trace("node end )"), "NODE_DEND";
          case 35:
            return this.popState(), A.getLogger().trace("node end ...", R.yytext), "NODE_DEND";
          case 36:
            return this.popState(), A.getLogger().trace("node end (("), "NODE_DEND";
          case 37:
            return this.popState(), A.getLogger().trace("node end (-"), "NODE_DEND";
          case 38:
            return this.popState(), A.getLogger().trace("node end (-"), "NODE_DEND";
          case 39:
            return this.popState(), A.getLogger().trace("node end (("), "NODE_DEND";
          case 40:
            return this.popState(), A.getLogger().trace("node end (("), "NODE_DEND";
          case 41:
            return A.getLogger().trace("Long description:", R.yytext), 21;
          case 42:
            return A.getLogger().trace("Long description:", R.yytext), 21;
        }
      }, "anonymous"),
      rules: [/^(?:@\{)/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^\"]+)/i, /^(?:[^}^"]+)/i, /^(?:\})/i, /^(?:\s*%%.*)/i, /^(?:kanban\b)/i, /^(?::::)/i, /^(?:.+)/i, /^(?:\n)/i, /^(?:::icon\()/i, /^(?:[\s]+[\n])/i, /^(?:[\n]+)/i, /^(?:[^\)]+)/i, /^(?:\))/i, /^(?:-\))/i, /^(?:\(-)/i, /^(?:\)\))/i, /^(?:\))/i, /^(?:\(\()/i, /^(?:\{\{)/i, /^(?:\()/i, /^(?:\[)/i, /^(?:[\s]+)/i, /^(?:[^\(\[\n\)\{\}@]+)/i, /^(?:$)/i, /^(?:["][`])/i, /^(?:[^`"]+)/i, /^(?:[`]["])/i, /^(?:["])/i, /^(?:[^"]+)/i, /^(?:["])/i, /^(?:[\)]\))/i, /^(?:[\)])/i, /^(?:[\]])/i, /^(?:\}\})/i, /^(?:\(-)/i, /^(?:-\))/i, /^(?:\(\()/i, /^(?:\()/i, /^(?:[^\)\]\(\}]+)/i, /^(?:.+(?!\(\())/i],
      conditions: { shapeDataEndBracket: { rules: [], inclusive: !1 }, shapeDataStr: { rules: [2, 3], inclusive: !1 }, shapeData: { rules: [1, 4, 5], inclusive: !1 }, CLASS: { rules: [9, 10], inclusive: !1 }, ICON: { rules: [14, 15], inclusive: !1 }, NSTR2: { rules: [28, 29], inclusive: !1 }, NSTR: { rules: [31, 32], inclusive: !1 }, NODE: { rules: [27, 30, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42], inclusive: !1 }, INITIAL: { rules: [0, 6, 7, 8, 11, 12, 13, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26], inclusive: !0 } }
    };
    return k;
  })();
  T.lexer = E;
  function L() {
    this.yy = {};
  }
  return x(L, "Parser"), L.prototype = T, T.Parser = L, new L();
})();
H6.parser = H6;
var HOe = H6, za = [], $7 = [], q6 = 0, z7 = {}, qOe = /* @__PURE__ */ x(() => {
  za = [], $7 = [], q6 = 0, z7 = {};
}, "clear"), WOe = /* @__PURE__ */ x((t) => {
  if (za.length === 0)
    return null;
  const e = za[0].level;
  let r = null;
  for (let n = za.length - 1; n >= 0; n--)
    if (za[n].level === e && !r && (r = za[n]), za[n].level < e)
      throw new Error('Items without section detected, found section ("' + za[n].label + '")');
  return t === r?.level ? null : r;
}, "getSection"), DX = /* @__PURE__ */ x(function() {
  return $7;
}, "getSections"), YOe = /* @__PURE__ */ x(function() {
  const t = [], e = [], r = DX(), n = we();
  for (const i of r) {
    const a = {
      id: i.id,
      label: dr(i.label ?? "", n),
      isGroup: !0,
      ticket: i.ticket,
      shape: "kanbanSection",
      level: i.level,
      look: n.look
    };
    e.push(a);
    const s = za.filter((o) => o.parentId === i.id);
    for (const o of s) {
      const l = {
        id: o.id,
        parentId: i.id,
        label: dr(o.label ?? "", n),
        isGroup: !1,
        ticket: o?.ticket,
        priority: o?.priority,
        assigned: o?.assigned,
        icon: o?.icon,
        shape: "kanbanItem",
        level: o.level,
        rx: 5,
        ry: 5,
        cssStyles: ["text-align: left"]
      };
      e.push(l);
    }
  }
  return { nodes: e, edges: t, other: {}, config: we() };
}, "getData"), XOe = /* @__PURE__ */ x((t, e, r, n, i) => {
  const a = we();
  let s = a.mindmap?.padding ?? ur.mindmap.padding;
  switch (n) {
    case Pn.ROUNDED_RECT:
    case Pn.RECT:
    case Pn.HEXAGON:
      s *= 2;
  }
  const o = {
    id: dr(e, a) || "kbn" + q6++,
    level: t,
    label: dr(r, a),
    width: a.mindmap?.maxNodeWidth ?? ur.mindmap.maxNodeWidth,
    padding: s,
    isGroup: !1
  };
  if (i !== void 0) {
    let u;
    i.includes(`
`) ? u = i + `
` : u = `{
` + i + `
}`;
    const h = q2(u, { schema: H2 });
    if (h.shape && (h.shape !== h.shape.toLowerCase() || h.shape.includes("_")))
      throw new Error(`No such shape: ${h.shape}. Shape names should be lowercase.`);
    h?.shape && h.shape === "kanbanItem" && (o.shape = h?.shape), h?.label && (o.label = h?.label), h?.icon && (o.icon = h?.icon.toString()), h?.assigned && (o.assigned = h?.assigned.toString()), h?.ticket && (o.ticket = h?.ticket.toString()), h?.priority && (o.priority = h?.priority);
  }
  const l = WOe(t);
  l ? o.parentId = l.id || "kbn" + q6++ : $7.push(o), za.push(o);
}, "addNode"), Pn = {
  DEFAULT: 0,
  NO_BORDER: 0,
  ROUNDED_RECT: 1,
  RECT: 2,
  CIRCLE: 3,
  CLOUD: 4,
  BANG: 5,
  HEXAGON: 6
}, jOe = /* @__PURE__ */ x((t, e) => {
  switch (ie.debug("In get type", t, e), t) {
    case "[":
      return Pn.RECT;
    case "(":
      return e === ")" ? Pn.ROUNDED_RECT : Pn.CLOUD;
    case "((":
      return Pn.CIRCLE;
    case ")":
      return Pn.CLOUD;
    case "))":
      return Pn.BANG;
    case "{{":
      return Pn.HEXAGON;
    default:
      return Pn.DEFAULT;
  }
}, "getType"), KOe = /* @__PURE__ */ x((t, e) => {
  z7[t] = e;
}, "setElementForId"), ZOe = /* @__PURE__ */ x((t) => {
  if (!t)
    return;
  const e = we(), r = za[za.length - 1];
  t.icon && (r.icon = dr(t.icon, e)), t.class && (r.cssClasses = dr(t.class, e));
}, "decorateNode"), QOe = /* @__PURE__ */ x((t) => {
  switch (t) {
    case Pn.DEFAULT:
      return "no-border";
    case Pn.RECT:
      return "rect";
    case Pn.ROUNDED_RECT:
      return "rounded-rect";
    case Pn.CIRCLE:
      return "circle";
    case Pn.CLOUD:
      return "cloud";
    case Pn.BANG:
      return "bang";
    case Pn.HEXAGON:
      return "hexgon";
    // cspell: disable-line
    default:
      return "no-border";
  }
}, "type2Str"), JOe = /* @__PURE__ */ x(() => ie, "getLogger"), ePe = /* @__PURE__ */ x((t) => z7[t], "getElementById"), tPe = {
  clear: qOe,
  addNode: XOe,
  getSections: DX,
  getData: YOe,
  nodeType: Pn,
  getType: jOe,
  setElementForId: KOe,
  decorateNode: ZOe,
  type2Str: QOe,
  getLogger: JOe,
  getElementById: ePe
}, rPe = tPe, nPe = /* @__PURE__ */ x(async (t, e, r, n) => {
  ie.debug(`Rendering kanban diagram
` + t);
  const a = n.db.getData(), s = we();
  s.htmlLabels = !1;
  const o = ll(e), l = o.append("g");
  l.attr("class", "sections");
  const u = o.append("g");
  u.attr("class", "items");
  const h = a.nodes.filter(
    // TODO: TypeScript 5.5 will infer this predicate automatically
    (v) => v.isGroup
  );
  let d = 0;
  const f = 10, p = [];
  let g = 25;
  for (const v of h) {
    const y = s?.kanban?.sectionWidth || 200;
    d = d + 1, v.x = y * d + (d - 1) * f / 2, v.width = y, v.y = 0, v.height = y * 3, v.rx = 5, v.ry = 5, v.cssClasses = v.cssClasses + " section-" + d;
    const b = await ik(l, v);
    g = Math.max(g, b?.labelBBox?.height), p.push(b);
  }
  let m = 0;
  for (const v of h) {
    const y = p[m];
    m = m + 1;
    const b = s?.kanban?.sectionWidth || 200, w = -b * 3 / 2 + g;
    let T = w;
    const E = a.nodes.filter((C) => C.parentId === v.id);
    for (const C of E) {
      if (C.isGroup)
        throw new Error("Groups within groups are not allowed in Kanban diagrams");
      C.x = v.x, C.width = b - 1.5 * f;
      const R = (await lx(u, C, { config: s })).node().getBBox();
      C.y = T + R.height / 2, await Ww(C), T = C.y + R.height / 2 + f / 2;
    }
    const L = y.cluster.select("rect"), k = Math.max(T - w + 3 * f, 50) + (g - 25);
    L.attr("height", k);
  }
  og(
    void 0,
    o,
    s.mindmap?.padding ?? ur.kanban.padding,
    s.mindmap?.useMaxWidth ?? ur.kanban.useMaxWidth
  );
}, "draw"), iPe = {
  draw: nPe
}, aPe = /* @__PURE__ */ x((t) => {
  let e = "";
  for (let n = 0; n < t.THEME_COLOR_LIMIT; n++)
    t["lineColor" + n] = t["lineColor" + n] || t["cScaleInv" + n], hc(t["lineColor" + n]) ? t["lineColor" + n] = At(t["lineColor" + n], 20) : t["lineColor" + n] = It(t["lineColor" + n], 20);
  const r = /* @__PURE__ */ x((n, i) => t.darkMode ? It(n, i) : At(n, i), "adjuster");
  for (let n = 0; n < t.THEME_COLOR_LIMIT; n++) {
    const i = "" + (17 - 3 * n);
    e += `
    .section-${n - 1} rect, .section-${n - 1} path, .section-${n - 1} circle, .section-${n - 1} polygon, .section-${n - 1} path  {
      fill: ${r(t["cScale" + n], 10)};
      stroke: ${r(t["cScale" + n], 10)};

    }
    .section-${n - 1} text {
     fill: ${t["cScaleLabel" + n]};
    }
    .node-icon-${n - 1} {
      font-size: 40px;
      color: ${t["cScaleLabel" + n]};
    }
    .section-edge-${n - 1}{
      stroke: ${t["cScale" + n]};
    }
    .edge-depth-${n - 1}{
      stroke-width: ${i};
    }
    .section-${n - 1} line {
      stroke: ${t["cScaleInv" + n]} ;
      stroke-width: 3;
    }

    .disabled, .disabled circle, .disabled text {
      fill: lightgray;
    }
    .disabled text {
      fill: #efefef;
    }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${t.background};
    stroke: ${t.nodeBorder};
    stroke-width: 1px;
  }

  .kanban-ticket-link {
    fill: ${t.background};
    stroke: ${t.nodeBorder};
    text-decoration: underline;
  }
    `;
  }
  return e;
}, "genSections"), sPe = /* @__PURE__ */ x((t) => `
  .edge {
    stroke-width: 3;
  }
  ${aPe(t)}
  .section-root rect, .section-root path, .section-root circle, .section-root polygon  {
    fill: ${t.git0};
  }
  .section-root text {
    fill: ${t.gitBranchLabel0};
  }
  .icon-container {
    height:100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .edge {
    fill: none;
  }
  .cluster-label, .label {
    color: ${t.textColor};
    fill: ${t.textColor};
    }
  .kanban-label {
    dy: 1em;
    alignment-baseline: middle;
    text-anchor: middle;
    dominant-baseline: middle;
    text-align: center;
  }
    ${Dg()}
`, "getStyles"), oPe = sPe, lPe = {
  db: rPe,
  renderer: iPe,
  parser: HOe,
  styles: oPe
};
const cPe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: lPe
}, Symbol.toStringTag, { value: "Module" }));
function KN(t, e) {
  let r;
  if (e === void 0)
    for (const n of t)
      n != null && (r < n || r === void 0 && n >= n) && (r = n);
  else {
    let n = -1;
    for (let i of t)
      (i = e(i, ++n, t)) != null && (r < i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function OX(t, e) {
  let r;
  if (e === void 0)
    for (const n of t)
      n != null && (r > n || r === void 0 && n >= n) && (r = n);
  else {
    let n = -1;
    for (let i of t)
      (i = e(i, ++n, t)) != null && (r > i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function W5(t, e) {
  let r = 0;
  if (e === void 0)
    for (let n of t)
      (n = +n) && (r += n);
  else {
    let n = -1;
    for (let i of t)
      (i = +e(i, ++n, t)) && (r += i);
  }
  return r;
}
function uPe(t) {
  return t.target.depth;
}
function hPe(t) {
  return t.depth;
}
function dPe(t, e) {
  return e - 1 - t.height;
}
function PX(t, e) {
  return t.sourceLinks.length ? t.depth : e - 1;
}
function fPe(t) {
  return t.targetLinks.length ? t.depth : t.sourceLinks.length ? OX(t.sourceLinks, uPe) - 1 : 0;
}
function dm(t) {
  return function() {
    return t;
  };
}
function ZN(t, e) {
  return b2(t.source, e.source) || t.index - e.index;
}
function QN(t, e) {
  return b2(t.target, e.target) || t.index - e.index;
}
function b2(t, e) {
  return t.y0 - e.y0;
}
function Y5(t) {
  return t.value;
}
function pPe(t) {
  return t.index;
}
function gPe(t) {
  return t.nodes;
}
function mPe(t) {
  return t.links;
}
function JN(t, e) {
  const r = t.get(e);
  if (!r) throw new Error("missing: " + e);
  return r;
}
function eI({ nodes: t }) {
  for (const e of t) {
    let r = e.y0, n = r;
    for (const i of e.sourceLinks)
      i.y0 = r + i.width / 2, r += i.width;
    for (const i of e.targetLinks)
      i.y1 = n + i.width / 2, n += i.width;
  }
}
function vPe() {
  let t = 0, e = 0, r = 1, n = 1, i = 24, a = 8, s, o = pPe, l = PX, u, h, d = gPe, f = mPe, p = 6;
  function g() {
    const M = { nodes: d.apply(null, arguments), links: f.apply(null, arguments) };
    return m(M), v(M), y(M), b(M), E(M), eI(M), M;
  }
  g.update = function(M) {
    return eI(M), M;
  }, g.nodeId = function(M) {
    return arguments.length ? (o = typeof M == "function" ? M : dm(M), g) : o;
  }, g.nodeAlign = function(M) {
    return arguments.length ? (l = typeof M == "function" ? M : dm(M), g) : l;
  }, g.nodeSort = function(M) {
    return arguments.length ? (u = M, g) : u;
  }, g.nodeWidth = function(M) {
    return arguments.length ? (i = +M, g) : i;
  }, g.nodePadding = function(M) {
    return arguments.length ? (a = s = +M, g) : a;
  }, g.nodes = function(M) {
    return arguments.length ? (d = typeof M == "function" ? M : dm(M), g) : d;
  }, g.links = function(M) {
    return arguments.length ? (f = typeof M == "function" ? M : dm(M), g) : f;
  }, g.linkSort = function(M) {
    return arguments.length ? (h = M, g) : h;
  }, g.size = function(M) {
    return arguments.length ? (t = e = 0, r = +M[0], n = +M[1], g) : [r - t, n - e];
  }, g.extent = function(M) {
    return arguments.length ? (t = +M[0][0], r = +M[1][0], e = +M[0][1], n = +M[1][1], g) : [[t, e], [r, n]];
  }, g.iterations = function(M) {
    return arguments.length ? (p = +M, g) : p;
  };
  function m({ nodes: M, links: N }) {
    for (const [I, B] of M.entries())
      B.index = I, B.sourceLinks = [], B.targetLinks = [];
    const D = new Map(M.map((I, B) => [o(I, B, M), I]));
    for (const [I, B] of N.entries()) {
      B.index = I;
      let { source: z, target: F } = B;
      typeof z != "object" && (z = B.source = JN(D, z)), typeof F != "object" && (F = B.target = JN(D, F)), z.sourceLinks.push(B), F.targetLinks.push(B);
    }
    if (h != null)
      for (const { sourceLinks: I, targetLinks: B } of M)
        I.sort(h), B.sort(h);
  }
  function v({ nodes: M }) {
    for (const N of M)
      N.value = N.fixedValue === void 0 ? Math.max(W5(N.sourceLinks, Y5), W5(N.targetLinks, Y5)) : N.fixedValue;
  }
  function y({ nodes: M }) {
    const N = M.length;
    let D = new Set(M), I = /* @__PURE__ */ new Set(), B = 0;
    for (; D.size; ) {
      for (const z of D) {
        z.depth = B;
        for (const { target: F } of z.sourceLinks)
          I.add(F);
      }
      if (++B > N) throw new Error("circular link");
      D = I, I = /* @__PURE__ */ new Set();
    }
  }
  function b({ nodes: M }) {
    const N = M.length;
    let D = new Set(M), I = /* @__PURE__ */ new Set(), B = 0;
    for (; D.size; ) {
      for (const z of D) {
        z.height = B;
        for (const { source: F } of z.targetLinks)
          I.add(F);
      }
      if (++B > N) throw new Error("circular link");
      D = I, I = /* @__PURE__ */ new Set();
    }
  }
  function w({ nodes: M }) {
    const N = KN(M, (B) => B.depth) + 1, D = (r - t - i) / (N - 1), I = new Array(N);
    for (const B of M) {
      const z = Math.max(0, Math.min(N - 1, Math.floor(l.call(null, B, N))));
      B.layer = z, B.x0 = t + z * D, B.x1 = B.x0 + i, I[z] ? I[z].push(B) : I[z] = [B];
    }
    if (u) for (const B of I)
      B.sort(u);
    return I;
  }
  function T(M) {
    const N = OX(M, (D) => (n - e - (D.length - 1) * s) / W5(D, Y5));
    for (const D of M) {
      let I = e;
      for (const B of D) {
        B.y0 = I, B.y1 = I + B.value * N, I = B.y1 + s;
        for (const z of B.sourceLinks)
          z.width = z.value * N;
      }
      I = (n - I + s) / (D.length + 1);
      for (let B = 0; B < D.length; ++B) {
        const z = D[B];
        z.y0 += I * (B + 1), z.y1 += I * (B + 1);
      }
      O(D);
    }
  }
  function E(M) {
    const N = w(M);
    s = Math.min(a, (n - e) / (KN(N, (D) => D.length) - 1)), T(N);
    for (let D = 0; D < p; ++D) {
      const I = Math.pow(0.99, D), B = Math.max(1 - I, (D + 1) / p);
      k(N, I, B), L(N, I, B);
    }
  }
  function L(M, N, D) {
    for (let I = 1, B = M.length; I < B; ++I) {
      const z = M[I];
      for (const F of z) {
        let V = 0, H = 0;
        for (const { source: q, value: ae } of F.targetLinks) {
          let re = ae * (F.layer - q.layer);
          V += P(q, F) * re, H += re;
        }
        if (!(H > 0)) continue;
        let J = (V / H - F.y0) * N;
        F.y0 += J, F.y1 += J, _(F);
      }
      u === void 0 && z.sort(b2), C(z, D);
    }
  }
  function k(M, N, D) {
    for (let I = M.length, B = I - 2; B >= 0; --B) {
      const z = M[B];
      for (const F of z) {
        let V = 0, H = 0;
        for (const { target: q, value: ae } of F.sourceLinks) {
          let re = ae * (q.layer - F.layer);
          V += S(F, q) * re, H += re;
        }
        if (!(H > 0)) continue;
        let J = (V / H - F.y0) * N;
        F.y0 += J, F.y1 += J, _(F);
      }
      u === void 0 && z.sort(b2), C(z, D);
    }
  }
  function C(M, N) {
    const D = M.length >> 1, I = M[D];
    R(M, I.y0 - s, D - 1, N), A(M, I.y1 + s, D + 1, N), R(M, n, M.length - 1, N), A(M, e, 0, N);
  }
  function A(M, N, D, I) {
    for (; D < M.length; ++D) {
      const B = M[D], z = (N - B.y0) * I;
      z > 1e-6 && (B.y0 += z, B.y1 += z), N = B.y1 + s;
    }
  }
  function R(M, N, D, I) {
    for (; D >= 0; --D) {
      const B = M[D], z = (B.y1 - N) * I;
      z > 1e-6 && (B.y0 -= z, B.y1 -= z), N = B.y0 - s;
    }
  }
  function _({ sourceLinks: M, targetLinks: N }) {
    if (h === void 0) {
      for (const { source: { sourceLinks: D } } of N)
        D.sort(QN);
      for (const { target: { targetLinks: D } } of M)
        D.sort(ZN);
    }
  }
  function O(M) {
    if (h === void 0)
      for (const { sourceLinks: N, targetLinks: D } of M)
        N.sort(QN), D.sort(ZN);
  }
  function P(M, N) {
    let D = M.y0 - (M.sourceLinks.length - 1) * s / 2;
    for (const { target: I, width: B } of M.sourceLinks) {
      if (I === N) break;
      D += B + s;
    }
    for (const { source: I, width: B } of N.targetLinks) {
      if (I === M) break;
      D -= B;
    }
    return D;
  }
  function S(M, N) {
    let D = N.y0 - (N.targetLinks.length - 1) * s / 2;
    for (const { source: I, width: B } of N.targetLinks) {
      if (I === M) break;
      D += B + s;
    }
    for (const { target: I, width: B } of M.sourceLinks) {
      if (I === N) break;
      D -= B;
    }
    return D;
  }
  return g;
}
var W6 = Math.PI, Y6 = 2 * W6, Xc = 1e-6, yPe = Y6 - Xc;
function X6() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null, this._ = "";
}
function BX() {
  return new X6();
}
X6.prototype = BX.prototype = {
  constructor: X6,
  moveTo: function(t, e) {
    this._ += "M" + (this._x0 = this._x1 = +t) + "," + (this._y0 = this._y1 = +e);
  },
  closePath: function() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  },
  lineTo: function(t, e) {
    this._ += "L" + (this._x1 = +t) + "," + (this._y1 = +e);
  },
  quadraticCurveTo: function(t, e, r, n) {
    this._ += "Q" + +t + "," + +e + "," + (this._x1 = +r) + "," + (this._y1 = +n);
  },
  bezierCurveTo: function(t, e, r, n, i, a) {
    this._ += "C" + +t + "," + +e + "," + +r + "," + +n + "," + (this._x1 = +i) + "," + (this._y1 = +a);
  },
  arcTo: function(t, e, r, n, i) {
    t = +t, e = +e, r = +r, n = +n, i = +i;
    var a = this._x1, s = this._y1, o = r - t, l = n - e, u = a - t, h = s - e, d = u * u + h * h;
    if (i < 0) throw new Error("negative radius: " + i);
    if (this._x1 === null)
      this._ += "M" + (this._x1 = t) + "," + (this._y1 = e);
    else if (d > Xc) if (!(Math.abs(h * o - l * u) > Xc) || !i)
      this._ += "L" + (this._x1 = t) + "," + (this._y1 = e);
    else {
      var f = r - a, p = n - s, g = o * o + l * l, m = f * f + p * p, v = Math.sqrt(g), y = Math.sqrt(d), b = i * Math.tan((W6 - Math.acos((g + d - m) / (2 * v * y))) / 2), w = b / y, T = b / v;
      Math.abs(w - 1) > Xc && (this._ += "L" + (t + w * u) + "," + (e + w * h)), this._ += "A" + i + "," + i + ",0,0," + +(h * f > u * p) + "," + (this._x1 = t + T * o) + "," + (this._y1 = e + T * l);
    }
  },
  arc: function(t, e, r, n, i, a) {
    t = +t, e = +e, r = +r, a = !!a;
    var s = r * Math.cos(n), o = r * Math.sin(n), l = t + s, u = e + o, h = 1 ^ a, d = a ? n - i : i - n;
    if (r < 0) throw new Error("negative radius: " + r);
    this._x1 === null ? this._ += "M" + l + "," + u : (Math.abs(this._x1 - l) > Xc || Math.abs(this._y1 - u) > Xc) && (this._ += "L" + l + "," + u), r && (d < 0 && (d = d % Y6 + Y6), d > yPe ? this._ += "A" + r + "," + r + ",0,1," + h + "," + (t - s) + "," + (e - o) + "A" + r + "," + r + ",0,1," + h + "," + (this._x1 = l) + "," + (this._y1 = u) : d > Xc && (this._ += "A" + r + "," + r + ",0," + +(d >= W6) + "," + h + "," + (this._x1 = t + r * Math.cos(i)) + "," + (this._y1 = e + r * Math.sin(i))));
  },
  rect: function(t, e, r, n) {
    this._ += "M" + (this._x0 = this._x1 = +t) + "," + (this._y0 = this._y1 = +e) + "h" + +r + "v" + +n + "h" + -r + "Z";
  },
  toString: function() {
    return this._;
  }
};
function tI(t) {
  return function() {
    return t;
  };
}
function xPe(t) {
  return t[0];
}
function bPe(t) {
  return t[1];
}
var wPe = Array.prototype.slice;
function TPe(t) {
  return t.source;
}
function EPe(t) {
  return t.target;
}
function kPe(t) {
  var e = TPe, r = EPe, n = xPe, i = bPe, a = null;
  function s() {
    var o, l = wPe.call(arguments), u = e.apply(this, l), h = r.apply(this, l);
    if (a || (a = o = BX()), t(a, +n.apply(this, (l[0] = u, l)), +i.apply(this, l), +n.apply(this, (l[0] = h, l)), +i.apply(this, l)), o) return a = null, o + "" || null;
  }
  return s.source = function(o) {
    return arguments.length ? (e = o, s) : e;
  }, s.target = function(o) {
    return arguments.length ? (r = o, s) : r;
  }, s.x = function(o) {
    return arguments.length ? (n = typeof o == "function" ? o : tI(+o), s) : n;
  }, s.y = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : tI(+o), s) : i;
  }, s.context = function(o) {
    return arguments.length ? (a = o ?? null, s) : a;
  }, s;
}
function SPe(t, e, r, n, i) {
  t.moveTo(e, r), t.bezierCurveTo(e = (e + n) / 2, r, e, i, n, i);
}
function CPe() {
  return kPe(SPe);
}
function APe(t) {
  return [t.source.x1, t.y0];
}
function _Pe(t) {
  return [t.target.x0, t.y1];
}
function LPe() {
  return CPe().source(APe).target(_Pe);
}
var j6 = (function() {
  var t = /* @__PURE__ */ x(function(o, l, u, h) {
    for (u = u || {}, h = o.length; h--; u[o[h]] = l) ;
    return u;
  }, "o"), e = [1, 9], r = [1, 10], n = [1, 5, 10, 12], i = {
    trace: /* @__PURE__ */ x(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, SANKEY: 4, NEWLINE: 5, csv: 6, opt_eof: 7, record: 8, csv_tail: 9, EOF: 10, "field[source]": 11, COMMA: 12, "field[target]": 13, "field[value]": 14, field: 15, escaped: 16, non_escaped: 17, DQUOTE: 18, ESCAPED_TEXT: 19, NON_ESCAPED_TEXT: 20, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "SANKEY", 5: "NEWLINE", 10: "EOF", 11: "field[source]", 12: "COMMA", 13: "field[target]", 14: "field[value]", 18: "DQUOTE", 19: "ESCAPED_TEXT", 20: "NON_ESCAPED_TEXT" },
    productions_: [0, [3, 4], [6, 2], [9, 2], [9, 0], [7, 1], [7, 0], [8, 5], [15, 1], [15, 1], [16, 3], [17, 1]],
    performAction: /* @__PURE__ */ x(function(l, u, h, d, f, p, g) {
      var m = p.length - 1;
      switch (f) {
        case 7:
          const v = d.findOrCreateNode(p[m - 4].trim().replaceAll('""', '"')), y = d.findOrCreateNode(p[m - 2].trim().replaceAll('""', '"')), b = parseFloat(p[m].trim());
          d.addLink(v, y, b);
          break;
        case 8:
        case 9:
        case 11:
          this.$ = p[m];
          break;
        case 10:
          this.$ = p[m - 1];
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, { 5: [1, 3] }, { 6: 4, 8: 5, 15: 6, 16: 7, 17: 8, 18: e, 20: r }, { 1: [2, 6], 7: 11, 10: [1, 12] }, t(r, [2, 4], { 9: 13, 5: [1, 14] }), { 12: [1, 15] }, t(n, [2, 8]), t(n, [2, 9]), { 19: [1, 16] }, t(n, [2, 11]), { 1: [2, 1] }, { 1: [2, 5] }, t(r, [2, 2]), { 6: 17, 8: 5, 15: 6, 16: 7, 17: 8, 18: e, 20: r }, { 15: 18, 16: 7, 17: 8, 18: e, 20: r }, { 18: [1, 19] }, t(r, [2, 3]), { 12: [1, 20] }, t(n, [2, 10]), { 15: 21, 16: 7, 17: 8, 18: e, 20: r }, t([1, 5, 10], [2, 7])],
    defaultActions: { 11: [2, 1], 12: [2, 5] },
    parseError: /* @__PURE__ */ x(function(l, u) {
      if (u.recoverable)
        this.trace(l);
      else {
        var h = new Error(l);
        throw h.hash = u, h;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ x(function(l) {
      var u = this, h = [0], d = [], f = [null], p = [], g = this.table, m = "", v = 0, y = 0, b = 2, w = 1, T = p.slice.call(arguments, 1), E = Object.create(this.lexer), L = { yy: {} };
      for (var k in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, k) && (L.yy[k] = this.yy[k]);
      E.setInput(l, L.yy), L.yy.lexer = E, L.yy.parser = this, typeof E.yylloc > "u" && (E.yylloc = {});
      var C = E.yylloc;
      p.push(C);
      var A = E.options && E.options.ranges;
      typeof L.yy.parseError == "function" ? this.parseError = L.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function R(V) {
        h.length = h.length - 2 * V, f.length = f.length - V, p.length = p.length - V;
      }
      x(R, "popStack");
      function _() {
        var V;
        return V = d.pop() || E.lex() || w, typeof V != "number" && (V instanceof Array && (d = V, V = d.pop()), V = u.symbols_[V] || V), V;
      }
      x(_, "lex");
      for (var O, P, S, M, N = {}, D, I, B, z; ; ) {
        if (P = h[h.length - 1], this.defaultActions[P] ? S = this.defaultActions[P] : ((O === null || typeof O > "u") && (O = _()), S = g[P] && g[P][O]), typeof S > "u" || !S.length || !S[0]) {
          var F = "";
          z = [];
          for (D in g[P])
            this.terminals_[D] && D > b && z.push("'" + this.terminals_[D] + "'");
          E.showPosition ? F = "Parse error on line " + (v + 1) + `:
` + E.showPosition() + `
Expecting ` + z.join(", ") + ", got '" + (this.terminals_[O] || O) + "'" : F = "Parse error on line " + (v + 1) + ": Unexpected " + (O == w ? "end of input" : "'" + (this.terminals_[O] || O) + "'"), this.parseError(F, {
            text: E.match,
            token: this.terminals_[O] || O,
            line: E.yylineno,
            loc: C,
            expected: z
          });
        }
        if (S[0] instanceof Array && S.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + P + ", token: " + O);
        switch (S[0]) {
          case 1:
            h.push(O), f.push(E.yytext), p.push(E.yylloc), h.push(S[1]), O = null, y = E.yyleng, m = E.yytext, v = E.yylineno, C = E.yylloc;
            break;
          case 2:
            if (I = this.productions_[S[1]][1], N.$ = f[f.length - I], N._$ = {
              first_line: p[p.length - (I || 1)].first_line,
              last_line: p[p.length - 1].last_line,
              first_column: p[p.length - (I || 1)].first_column,
              last_column: p[p.length - 1].last_column
            }, A && (N._$.range = [
              p[p.length - (I || 1)].range[0],
              p[p.length - 1].range[1]
            ]), M = this.performAction.apply(N, [
              m,
              y,
              v,
              L.yy,
              S[1],
              f,
              p
            ].concat(T)), typeof M < "u")
              return M;
            I && (h = h.slice(0, -1 * I * 2), f = f.slice(0, -1 * I), p = p.slice(0, -1 * I)), h.push(this.productions_[S[1]][0]), f.push(N.$), p.push(N._$), B = g[h[h.length - 2]][h[h.length - 1]], h.push(B);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, a = /* @__PURE__ */ (function() {
    var o = {
      EOF: 1,
      parseError: /* @__PURE__ */ x(function(u, h) {
        if (this.yy.parser)
          this.yy.parser.parseError(u, h);
        else
          throw new Error(u);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ x(function(l, u) {
        return this.yy = u || this.yy || {}, this._input = l, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ x(function() {
        var l = this._input[0];
        this.yytext += l, this.yyleng++, this.offset++, this.match += l, this.matched += l;
        var u = l.match(/(?:\r\n?|\n).*/g);
        return u ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), l;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ x(function(l) {
        var u = l.length, h = l.split(/(?:\r\n?|\n)/g);
        this._input = l + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - u), this.offset -= u;
        var d = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), h.length - 1 && (this.yylineno -= h.length - 1);
        var f = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: h ? (h.length === d.length ? this.yylloc.first_column : 0) + d[d.length - h.length].length - h[0].length : this.yylloc.first_column - u
        }, this.options.ranges && (this.yylloc.range = [f[0], f[0] + this.yyleng - u]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ x(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ x(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ x(function(l) {
        this.unput(this.match.slice(l));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ x(function() {
        var l = this.matched.substr(0, this.matched.length - this.match.length);
        return (l.length > 20 ? "..." : "") + l.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ x(function() {
        var l = this.match;
        return l.length < 20 && (l += this._input.substr(0, 20 - l.length)), (l.substr(0, 20) + (l.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ x(function() {
        var l = this.pastInput(), u = new Array(l.length + 1).join("-");
        return l + this.upcomingInput() + `
` + u + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ x(function(l, u) {
        var h, d, f;
        if (this.options.backtrack_lexer && (f = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (f.yylloc.range = this.yylloc.range.slice(0))), d = l[0].match(/(?:\r\n?|\n).*/g), d && (this.yylineno += d.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: d ? d[d.length - 1].length - d[d.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + l[0].length
        }, this.yytext += l[0], this.match += l[0], this.matches = l, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(l[0].length), this.matched += l[0], h = this.performAction.call(this, this.yy, this, u, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), h)
          return h;
        if (this._backtrack) {
          for (var p in f)
            this[p] = f[p];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ x(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var l, u, h, d;
        this._more || (this.yytext = "", this.match = "");
        for (var f = this._currentRules(), p = 0; p < f.length; p++)
          if (h = this._input.match(this.rules[f[p]]), h && (!u || h[0].length > u[0].length)) {
            if (u = h, d = p, this.options.backtrack_lexer) {
              if (l = this.test_match(h, f[p]), l !== !1)
                return l;
              if (this._backtrack) {
                u = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return u ? (l = this.test_match(u, f[d]), l !== !1 ? l : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ x(function() {
        var u = this.next();
        return u || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ x(function(u) {
        this.conditionStack.push(u);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ x(function() {
        var u = this.conditionStack.length - 1;
        return u > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ x(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ x(function(u) {
        return u = this.conditionStack.length - 1 - Math.abs(u || 0), u >= 0 ? this.conditionStack[u] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ x(function(u) {
        this.begin(u);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ x(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ x(function(u, h, d, f) {
        switch (d) {
          case 0:
            return this.pushState("csv"), 4;
          case 1:
            return this.pushState("csv"), 4;
          case 2:
            return 10;
          case 3:
            return 5;
          case 4:
            return 12;
          case 5:
            return this.pushState("escaped_text"), 18;
          case 6:
            return 20;
          case 7:
            return this.popState("escaped_text"), 18;
          case 8:
            return 19;
        }
      }, "anonymous"),
      rules: [/^(?:sankey-beta\b)/i, /^(?:sankey\b)/i, /^(?:$)/i, /^(?:((\u000D\u000A)|(\u000A)))/i, /^(?:(\u002C))/i, /^(?:(\u0022))/i, /^(?:([\u0020-\u0021\u0023-\u002B\u002D-\u007E])*)/i, /^(?:(\u0022)(?!(\u0022)))/i, /^(?:(([\u0020-\u0021\u0023-\u002B\u002D-\u007E])|(\u002C)|(\u000D)|(\u000A)|(\u0022)(\u0022))*)/i],
      conditions: { csv: { rules: [2, 3, 4, 5, 6, 7, 8], inclusive: !1 }, escaped_text: { rules: [7, 8], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8], inclusive: !0 } }
    };
    return o;
  })();
  i.lexer = a;
  function s() {
    this.yy = {};
  }
  return x(s, "Parser"), s.prototype = i, i.Parser = s, new s();
})();
j6.parser = j6;
var w2 = j6, kb = [], Sb = [], T2 = /* @__PURE__ */ new Map(), RPe = /* @__PURE__ */ x(() => {
  kb = [], Sb = [], T2 = /* @__PURE__ */ new Map(), _n();
}, "clear"), MPe = class {
  constructor(t, e, r = 0) {
    this.source = t, this.target = e, this.value = r;
  }
  static {
    x(this, "SankeyLink");
  }
}, NPe = /* @__PURE__ */ x((t, e, r) => {
  kb.push(new MPe(t, e, r));
}, "addLink"), IPe = class {
  constructor(t) {
    this.ID = t;
  }
  static {
    x(this, "SankeyNode");
  }
}, DPe = /* @__PURE__ */ x((t) => {
  t = at.sanitizeText(t, we());
  let e = T2.get(t);
  return e === void 0 && (e = new IPe(t), T2.set(t, e), Sb.push(e)), e;
}, "findOrCreateNode"), OPe = /* @__PURE__ */ x(() => Sb, "getNodes"), PPe = /* @__PURE__ */ x(() => kb, "getLinks"), BPe = /* @__PURE__ */ x(() => ({
  nodes: Sb.map((t) => ({ id: t.ID })),
  links: kb.map((t) => ({
    source: t.source.ID,
    target: t.target.ID,
    value: t.value
  }))
}), "getGraph"), FPe = {
  nodesMap: T2,
  getConfig: /* @__PURE__ */ x(() => we().sankey, "getConfig"),
  getNodes: OPe,
  getLinks: PPe,
  getGraph: BPe,
  addLink: NPe,
  findOrCreateNode: DPe,
  getAccTitle: Gn,
  setAccTitle: Cn,
  getAccDescription: Un,
  setAccDescription: Vn,
  getDiagramTitle: Ln,
  setDiagramTitle: Zn,
  clear: RPe
}, rI = class K6 {
  static {
    x(this, "Uid");
  }
  static {
    this.count = 0;
  }
  static next(e) {
    return new K6(e + ++K6.count);
  }
  constructor(e) {
    this.id = e, this.href = `#${e}`;
  }
  toString() {
    return "url(" + this.href + ")";
  }
}, $Pe = {
  left: hPe,
  right: dPe,
  center: fPe,
  justify: PX
}, zPe = /* @__PURE__ */ x(function(t, e, r, n) {
  const { securityLevel: i, sankey: a } = we(), s = BI.sankey;
  let o;
  i === "sandbox" && (o = Qe("#i" + e));
  const l = Qe(i === "sandbox" ? o.nodes()[0].contentDocument.body : "body"), u = i === "sandbox" ? l.select(`[id="${e}"]`) : Qe(`[id="${e}"]`), h = a?.width ?? s.width, d = a?.height ?? s.width, f = a?.useMaxWidth ?? s.useMaxWidth, p = a?.nodeAlignment ?? s.nodeAlignment, g = a?.prefix ?? s.prefix, m = a?.suffix ?? s.suffix, v = a?.showValues ?? s.showValues, y = n.db.getGraph(), b = $Pe[p];
  vPe().nodeId((R) => R.id).nodeWidth(10).nodePadding(10 + (v ? 15 : 0)).nodeAlign(b).extent([
    [0, 0],
    [h, d]
  ])(y);
  const E = hu(rne);
  u.append("g").attr("class", "nodes").selectAll(".node").data(y.nodes).join("g").attr("class", "node").attr("id", (R) => (R.uid = rI.next("node-")).id).attr("transform", function(R) {
    return "translate(" + R.x0 + "," + R.y0 + ")";
  }).attr("x", (R) => R.x0).attr("y", (R) => R.y0).append("rect").attr("height", (R) => R.y1 - R.y0).attr("width", (R) => R.x1 - R.x0).attr("fill", (R) => E(R.id));
  const L = /* @__PURE__ */ x(({ id: R, value: _ }) => v ? `${R}
${g}${Math.round(_ * 100) / 100}${m}` : R, "getText");
  u.append("g").attr("class", "node-labels").attr("font-size", 14).selectAll("text").data(y.nodes).join("text").attr("x", (R) => R.x0 < h / 2 ? R.x1 + 6 : R.x0 - 6).attr("y", (R) => (R.y1 + R.y0) / 2).attr("dy", `${v ? "0" : "0.35"}em`).attr("text-anchor", (R) => R.x0 < h / 2 ? "start" : "end").text(L);
  const k = u.append("g").attr("class", "links").attr("fill", "none").attr("stroke-opacity", 0.5).selectAll(".link").data(y.links).join("g").attr("class", "link").style("mix-blend-mode", "multiply"), C = a?.linkColor ?? "gradient";
  if (C === "gradient") {
    const R = k.append("linearGradient").attr("id", (_) => (_.uid = rI.next("linearGradient-")).id).attr("gradientUnits", "userSpaceOnUse").attr("x1", (_) => _.source.x1).attr("x2", (_) => _.target.x0);
    R.append("stop").attr("offset", "0%").attr("stop-color", (_) => E(_.source.id)), R.append("stop").attr("offset", "100%").attr("stop-color", (_) => E(_.target.id));
  }
  let A;
  switch (C) {
    case "gradient":
      A = /* @__PURE__ */ x((R) => R.uid, "coloring");
      break;
    case "source":
      A = /* @__PURE__ */ x((R) => E(R.source.id), "coloring");
      break;
    case "target":
      A = /* @__PURE__ */ x((R) => E(R.target.id), "coloring");
      break;
    default:
      A = C;
  }
  k.append("path").attr("d", LPe()).attr("stroke", A).attr("stroke-width", (R) => Math.max(1, R.width)), og(void 0, u, 0, f);
}, "draw"), GPe = {
  draw: zPe
}, VPe = /* @__PURE__ */ x((t) => t.replaceAll(/^[^\S\n\r]+|[^\S\n\r]+$/g, "").replaceAll(/([\n\r])+/g, `
`).trim(), "prepareTextForParsing"), UPe = /* @__PURE__ */ x((t) => `.label {
      font-family: ${t.fontFamily};
    }`, "getStyles"), HPe = UPe, qPe = w2.parse.bind(w2);
w2.parse = (t) => qPe(VPe(t));
var WPe = {
  styles: HPe,
  parser: w2,
  db: FPe,
  renderer: GPe
};
const YPe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: WPe
}, Symbol.toStringTag, { value: "Module" }));
var XPe = ur.packet, FX = class {
  constructor() {
    this.packet = [], this.setAccTitle = Cn, this.getAccTitle = Gn, this.setDiagramTitle = Zn, this.getDiagramTitle = Ln, this.getAccDescription = Un, this.setAccDescription = Vn;
  }
  static {
    x(this, "PacketDB");
  }
  getConfig() {
    const t = Hi({
      ...XPe,
      ...pr().packet
    });
    return t.showBits && (t.paddingY += 10), t;
  }
  getPacket() {
    return this.packet;
  }
  pushWord(t) {
    t.length > 0 && this.packet.push(t);
  }
  clear() {
    _n(), this.packet = [];
  }
}, jPe = 1e4, KPe = /* @__PURE__ */ x((t, e) => {
  nh(t, e);
  let r = -1, n = [], i = 1;
  const { bitsPerRow: a } = e.getConfig();
  for (let { start: s, end: o, bits: l, label: u } of t.blocks) {
    if (s !== void 0 && o !== void 0 && o < s)
      throw new Error(`Packet block ${s} - ${o} is invalid. End must be greater than start.`);
    if (s ??= r + 1, s !== r + 1)
      throw new Error(
        `Packet block ${s} - ${o ?? s} is not contiguous. It should start from ${r + 1}.`
      );
    if (l === 0)
      throw new Error(`Packet block ${s} is invalid. Cannot have a zero bit field.`);
    for (o ??= s + (l ?? 1) - 1, l ??= o - s + 1, r = o, ie.debug(`Packet block ${s} - ${r} with label ${u}`); n.length <= a + 1 && e.getPacket().length < jPe; ) {
      const [h, d] = ZPe({ start: s, end: o, bits: l, label: u }, i, a);
      if (n.push(h), h.end + 1 === i * a && (e.pushWord(n), n = [], i++), !d)
        break;
      ({ start: s, end: o, bits: l, label: u } = d);
    }
  }
  e.pushWord(n);
}, "populate"), ZPe = /* @__PURE__ */ x((t, e, r) => {
  if (t.start === void 0)
    throw new Error("start should have been set during first phase");
  if (t.end === void 0)
    throw new Error("end should have been set during first phase");
  if (t.start > t.end)
    throw new Error(`Block start ${t.start} is greater than block end ${t.end}.`);
  if (t.end + 1 <= e * r)
    return [t, void 0];
  const n = e * r - 1, i = e * r;
  return [
    {
      start: t.start,
      end: n,
      label: t.label,
      bits: n - t.start
    },
    {
      start: i,
      end: t.end,
      label: t.label,
      bits: t.end - i
    }
  ];
}, "getNextFittingBlock"), $X = {
  // @ts-expect-error - PacketDB is not assignable to DiagramDB
  parser: { yy: void 0 },
  parse: /* @__PURE__ */ x(async (t) => {
    const e = await Lc("packet", t), r = $X.parser?.yy;
    if (!(r instanceof FX))
      throw new Error(
        "parser.parser?.yy was not a PacketDB. This is due to a bug within Mermaid, please report this issue at https://github.com/mermaid-js/mermaid/issues."
      );
    ie.debug(e), KPe(e, r);
  }, "parse")
}, QPe = /* @__PURE__ */ x((t, e, r, n) => {
  const i = n.db, a = i.getConfig(), { rowHeight: s, paddingY: o, bitWidth: l, bitsPerRow: u } = a, h = i.getPacket(), d = i.getDiagramTitle(), f = s + o, p = f * (h.length + 1) - (d ? 0 : s), g = l * u + 2, m = ll(e);
  m.attr("viewbox", `0 0 ${g} ${p}`), Xi(m, p, g, a.useMaxWidth);
  for (const [v, y] of h.entries())
    JPe(m, y, v, a);
  m.append("text").text(d).attr("x", g / 2).attr("y", p - f / 2).attr("dominant-baseline", "middle").attr("text-anchor", "middle").attr("class", "packetTitle");
}, "draw"), JPe = /* @__PURE__ */ x((t, e, r, { rowHeight: n, paddingX: i, paddingY: a, bitWidth: s, bitsPerRow: o, showBits: l }) => {
  const u = t.append("g"), h = r * (n + a) + a;
  for (const d of e) {
    const f = d.start % o * s + 1, p = (d.end - d.start + 1) * s - i;
    if (u.append("rect").attr("x", f).attr("y", h).attr("width", p).attr("height", n).attr("class", "packetBlock"), u.append("text").attr("x", f + p / 2).attr("y", h + n / 2).attr("class", "packetLabel").attr("dominant-baseline", "middle").attr("text-anchor", "middle").text(d.label), !l)
      continue;
    const g = d.end === d.start, m = h - 2;
    u.append("text").attr("x", f + (g ? p / 2 : 0)).attr("y", m).attr("class", "packetByte start").attr("dominant-baseline", "auto").attr("text-anchor", g ? "middle" : "start").text(d.start), g || u.append("text").attr("x", f + p).attr("y", m).attr("class", "packetByte end").attr("dominant-baseline", "auto").attr("text-anchor", "end").text(d.end);
  }
}, "drawWord"), eBe = { draw: QPe }, tBe = {
  byteFontSize: "10px",
  startByteColor: "black",
  endByteColor: "black",
  labelColor: "black",
  labelFontSize: "12px",
  titleColor: "black",
  titleFontSize: "14px",
  blockStrokeColor: "black",
  blockStrokeWidth: "1",
  blockFillColor: "#efefef"
}, rBe = /* @__PURE__ */ x(({ packet: t } = {}) => {
  const e = Hi(tBe, t);
  return `
	.packetByte {
		font-size: ${e.byteFontSize};
	}
	.packetByte.start {
		fill: ${e.startByteColor};
	}
	.packetByte.end {
		fill: ${e.endByteColor};
	}
	.packetLabel {
		fill: ${e.labelColor};
		font-size: ${e.labelFontSize};
	}
	.packetTitle {
		fill: ${e.titleColor};
		font-size: ${e.titleFontSize};
	}
	.packetBlock {
		stroke: ${e.blockStrokeColor};
		stroke-width: ${e.blockStrokeWidth};
		fill: ${e.blockFillColor};
	}
	`;
}, "styles"), nBe = {
  parser: $X,
  get db() {
    return new FX();
  },
  renderer: eBe,
  styles: rBe
};
const iBe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: nBe
}, Symbol.toStringTag, { value: "Module" }));
var Ph = {
  showLegend: !0,
  ticks: 5,
  max: null,
  min: 0,
  graticule: "circle"
}, zX = {
  axes: [],
  curves: [],
  options: Ph
}, fh = structuredClone(zX), aBe = ur.radar, sBe = /* @__PURE__ */ x(() => Hi({
  ...aBe,
  ...pr().radar
}), "getConfig"), GX = /* @__PURE__ */ x(() => fh.axes, "getAxes"), oBe = /* @__PURE__ */ x(() => fh.curves, "getCurves"), lBe = /* @__PURE__ */ x(() => fh.options, "getOptions"), cBe = /* @__PURE__ */ x((t) => {
  fh.axes = t.map((e) => ({
    name: e.name,
    label: e.label ?? e.name
  }));
}, "setAxes"), uBe = /* @__PURE__ */ x((t) => {
  fh.curves = t.map((e) => ({
    name: e.name,
    label: e.label ?? e.name,
    entries: hBe(e.entries)
  }));
}, "setCurves"), hBe = /* @__PURE__ */ x((t) => {
  if (t[0].axis == null)
    return t.map((r) => r.value);
  const e = GX();
  if (e.length === 0)
    throw new Error("Axes must be populated before curves for reference entries");
  return e.map((r) => {
    const n = t.find((i) => i.axis?.$refText === r.name);
    if (n === void 0)
      throw new Error("Missing entry for axis " + r.label);
    return n.value;
  });
}, "computeCurveEntries"), dBe = /* @__PURE__ */ x((t) => {
  const e = t.reduce(
    (r, n) => (r[n.name] = n, r),
    {}
  );
  fh.options = {
    showLegend: e.showLegend?.value ?? Ph.showLegend,
    ticks: e.ticks?.value ?? Ph.ticks,
    max: e.max?.value ?? Ph.max,
    min: e.min?.value ?? Ph.min,
    graticule: e.graticule?.value ?? Ph.graticule
  };
}, "setOptions"), fBe = /* @__PURE__ */ x(() => {
  _n(), fh = structuredClone(zX);
}, "clear"), U0 = {
  getAxes: GX,
  getCurves: oBe,
  getOptions: lBe,
  setAxes: cBe,
  setCurves: uBe,
  setOptions: dBe,
  getConfig: sBe,
  clear: fBe,
  setAccTitle: Cn,
  getAccTitle: Gn,
  setDiagramTitle: Zn,
  getDiagramTitle: Ln,
  getAccDescription: Un,
  setAccDescription: Vn
}, pBe = /* @__PURE__ */ x((t) => {
  nh(t, U0);
  const { axes: e, curves: r, options: n } = t;
  U0.setAxes(e), U0.setCurves(r), U0.setOptions(n);
}, "populate"), gBe = {
  parse: /* @__PURE__ */ x(async (t) => {
    const e = await Lc("radar", t);
    ie.debug(e), pBe(e);
  }, "parse")
}, mBe = /* @__PURE__ */ x((t, e, r, n) => {
  const i = n.db, a = i.getAxes(), s = i.getCurves(), o = i.getOptions(), l = i.getConfig(), u = i.getDiagramTitle(), h = ll(e), d = vBe(h, l), f = o.max ?? Math.max(...s.map((m) => Math.max(...m.entries))), p = o.min, g = Math.min(l.width, l.height) / 2;
  yBe(d, a, g, o.ticks, o.graticule), xBe(d, a, g, l), VX(d, a, s, p, f, o.graticule, l), qX(d, s, o.showLegend, l), d.append("text").attr("class", "radarTitle").text(u).attr("x", 0).attr("y", -l.height / 2 - l.marginTop);
}, "draw"), vBe = /* @__PURE__ */ x((t, e) => {
  const r = e.width + e.marginLeft + e.marginRight, n = e.height + e.marginTop + e.marginBottom, i = {
    x: e.marginLeft + e.width / 2,
    y: e.marginTop + e.height / 2
  };
  return t.attr("viewbox", `0 0 ${r} ${n}`).attr("width", r).attr("height", n), t.append("g").attr("transform", `translate(${i.x}, ${i.y})`);
}, "drawFrame"), yBe = /* @__PURE__ */ x((t, e, r, n, i) => {
  if (i === "circle")
    for (let a = 0; a < n; a++) {
      const s = r * (a + 1) / n;
      t.append("circle").attr("r", s).attr("class", "radarGraticule");
    }
  else if (i === "polygon") {
    const a = e.length;
    for (let s = 0; s < n; s++) {
      const o = r * (s + 1) / n, l = e.map((u, h) => {
        const d = 2 * h * Math.PI / a - Math.PI / 2, f = o * Math.cos(d), p = o * Math.sin(d);
        return `${f},${p}`;
      }).join(" ");
      t.append("polygon").attr("points", l).attr("class", "radarGraticule");
    }
  }
}, "drawGraticule"), xBe = /* @__PURE__ */ x((t, e, r, n) => {
  const i = e.length;
  for (let a = 0; a < i; a++) {
    const s = e[a].label, o = 2 * a * Math.PI / i - Math.PI / 2;
    t.append("line").attr("x1", 0).attr("y1", 0).attr("x2", r * n.axisScaleFactor * Math.cos(o)).attr("y2", r * n.axisScaleFactor * Math.sin(o)).attr("class", "radarAxisLine"), t.append("text").text(s).attr("x", r * n.axisLabelFactor * Math.cos(o)).attr("y", r * n.axisLabelFactor * Math.sin(o)).attr("class", "radarAxisLabel");
  }
}, "drawAxes");
function VX(t, e, r, n, i, a, s) {
  const o = e.length, l = Math.min(s.width, s.height) / 2;
  r.forEach((u, h) => {
    if (u.entries.length !== o)
      return;
    const d = u.entries.map((f, p) => {
      const g = 2 * Math.PI * p / o - Math.PI / 2, m = UX(f, n, i, l), v = m * Math.cos(g), y = m * Math.sin(g);
      return { x: v, y };
    });
    a === "circle" ? t.append("path").attr("d", HX(d, s.curveTension)).attr("class", `radarCurve-${h}`) : a === "polygon" && t.append("polygon").attr("points", d.map((f) => `${f.x},${f.y}`).join(" ")).attr("class", `radarCurve-${h}`);
  });
}
x(VX, "drawCurves");
function UX(t, e, r, n) {
  const i = Math.min(Math.max(t, e), r);
  return n * (i - e) / (r - e);
}
x(UX, "relativeRadius");
function HX(t, e) {
  const r = t.length;
  let n = `M${t[0].x},${t[0].y}`;
  for (let i = 0; i < r; i++) {
    const a = t[(i - 1 + r) % r], s = t[i], o = t[(i + 1) % r], l = t[(i + 2) % r], u = {
      x: s.x + (o.x - a.x) * e,
      y: s.y + (o.y - a.y) * e
    }, h = {
      x: o.x - (l.x - s.x) * e,
      y: o.y - (l.y - s.y) * e
    };
    n += ` C${u.x},${u.y} ${h.x},${h.y} ${o.x},${o.y}`;
  }
  return `${n} Z`;
}
x(HX, "closedRoundCurve");
function qX(t, e, r, n) {
  if (!r)
    return;
  const i = (n.width / 2 + n.marginRight) * 3 / 4, a = -(n.height / 2 + n.marginTop) * 3 / 4, s = 20;
  e.forEach((o, l) => {
    const u = t.append("g").attr("transform", `translate(${i}, ${a + l * s})`);
    u.append("rect").attr("width", 12).attr("height", 12).attr("class", `radarLegendBox-${l}`), u.append("text").attr("x", 16).attr("y", 0).attr("class", "radarLegendText").text(o.label);
  });
}
x(qX, "drawLegend");
var bBe = { draw: mBe }, wBe = /* @__PURE__ */ x((t, e) => {
  let r = "";
  for (let n = 0; n < t.THEME_COLOR_LIMIT; n++) {
    const i = t[`cScale${n}`];
    r += `
		.radarCurve-${n} {
			color: ${i};
			fill: ${i};
			fill-opacity: ${e.curveOpacity};
			stroke: ${i};
			stroke-width: ${e.curveStrokeWidth};
		}
		.radarLegendBox-${n} {
			fill: ${i};
			fill-opacity: ${e.curveOpacity};
			stroke: ${i};
		}
		`;
  }
  return r;
}, "genIndexStyles"), TBe = /* @__PURE__ */ x((t) => {
  const e = M2(), r = pr(), n = Hi(e, r.themeVariables), i = Hi(n.radar, t);
  return { themeVariables: n, radarOptions: i };
}, "buildRadarStyleOptions"), EBe = /* @__PURE__ */ x(({ radar: t } = {}) => {
  const { themeVariables: e, radarOptions: r } = TBe(t);
  return `
	.radarTitle {
		font-size: ${e.fontSize};
		color: ${e.titleColor};
		dominant-baseline: hanging;
		text-anchor: middle;
	}
	.radarAxisLine {
		stroke: ${r.axisColor};
		stroke-width: ${r.axisStrokeWidth};
	}
	.radarAxisLabel {
		dominant-baseline: middle;
		text-anchor: middle;
		font-size: ${r.axisLabelFontSize}px;
		color: ${r.axisColor};
	}
	.radarGraticule {
		fill: ${r.graticuleColor};
		fill-opacity: ${r.graticuleOpacity};
		stroke: ${r.graticuleColor};
		stroke-width: ${r.graticuleStrokeWidth};
	}
	.radarLegendText {
		text-anchor: start;
		font-size: ${r.legendFontSize}px;
		dominant-baseline: hanging;
	}
	${wBe(e, r)}
	`;
}, "styles"), kBe = {
  parser: gBe,
  db: U0,
  renderer: bBe,
  styles: EBe
};
const SBe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: kBe
}, Symbol.toStringTag, { value: "Module" }));
var Z6 = (function() {
  var t = /* @__PURE__ */ x(function(w, T, E, L) {
    for (E = E || {}, L = w.length; L--; E[w[L]] = T) ;
    return E;
  }, "o"), e = [1, 15], r = [1, 7], n = [1, 13], i = [1, 14], a = [1, 19], s = [1, 16], o = [1, 17], l = [1, 18], u = [8, 30], h = [8, 10, 21, 28, 29, 30, 31, 39, 43, 46], d = [1, 23], f = [1, 24], p = [8, 10, 15, 16, 21, 28, 29, 30, 31, 39, 43, 46], g = [8, 10, 15, 16, 21, 27, 28, 29, 30, 31, 39, 43, 46], m = [1, 49], v = {
    trace: /* @__PURE__ */ x(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, spaceLines: 3, SPACELINE: 4, NL: 5, separator: 6, SPACE: 7, EOF: 8, start: 9, BLOCK_DIAGRAM_KEY: 10, document: 11, stop: 12, statement: 13, link: 14, LINK: 15, START_LINK: 16, LINK_LABEL: 17, STR: 18, nodeStatement: 19, columnsStatement: 20, SPACE_BLOCK: 21, blockStatement: 22, classDefStatement: 23, cssClassStatement: 24, styleStatement: 25, node: 26, SIZE: 27, COLUMNS: 28, "id-block": 29, end: 30, NODE_ID: 31, nodeShapeNLabel: 32, dirList: 33, DIR: 34, NODE_DSTART: 35, NODE_DEND: 36, BLOCK_ARROW_START: 37, BLOCK_ARROW_END: 38, classDef: 39, CLASSDEF_ID: 40, CLASSDEF_STYLEOPTS: 41, DEFAULT: 42, class: 43, CLASSENTITY_IDS: 44, STYLECLASS: 45, style: 46, STYLE_ENTITY_IDS: 47, STYLE_DEFINITION_DATA: 48, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "SPACELINE", 5: "NL", 7: "SPACE", 8: "EOF", 10: "BLOCK_DIAGRAM_KEY", 15: "LINK", 16: "START_LINK", 17: "LINK_LABEL", 18: "STR", 21: "SPACE_BLOCK", 27: "SIZE", 28: "COLUMNS", 29: "id-block", 30: "end", 31: "NODE_ID", 34: "DIR", 35: "NODE_DSTART", 36: "NODE_DEND", 37: "BLOCK_ARROW_START", 38: "BLOCK_ARROW_END", 39: "classDef", 40: "CLASSDEF_ID", 41: "CLASSDEF_STYLEOPTS", 42: "DEFAULT", 43: "class", 44: "CLASSENTITY_IDS", 45: "STYLECLASS", 46: "style", 47: "STYLE_ENTITY_IDS", 48: "STYLE_DEFINITION_DATA" },
    productions_: [0, [3, 1], [3, 2], [3, 2], [6, 1], [6, 1], [6, 1], [9, 3], [12, 1], [12, 1], [12, 2], [12, 2], [11, 1], [11, 2], [14, 1], [14, 4], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [19, 3], [19, 2], [19, 1], [20, 1], [22, 4], [22, 3], [26, 1], [26, 2], [33, 1], [33, 2], [32, 3], [32, 4], [23, 3], [23, 3], [24, 3], [25, 3]],
    performAction: /* @__PURE__ */ x(function(T, E, L, k, C, A, R) {
      var _ = A.length - 1;
      switch (C) {
        case 4:
          k.getLogger().debug("Rule: separator (NL) ");
          break;
        case 5:
          k.getLogger().debug("Rule: separator (Space) ");
          break;
        case 6:
          k.getLogger().debug("Rule: separator (EOF) ");
          break;
        case 7:
          k.getLogger().debug("Rule: hierarchy: ", A[_ - 1]), k.setHierarchy(A[_ - 1]);
          break;
        case 8:
          k.getLogger().debug("Stop NL ");
          break;
        case 9:
          k.getLogger().debug("Stop EOF ");
          break;
        case 10:
          k.getLogger().debug("Stop NL2 ");
          break;
        case 11:
          k.getLogger().debug("Stop EOF2 ");
          break;
        case 12:
          k.getLogger().debug("Rule: statement: ", A[_]), typeof A[_].length == "number" ? this.$ = A[_] : this.$ = [A[_]];
          break;
        case 13:
          k.getLogger().debug("Rule: statement #2: ", A[_ - 1]), this.$ = [A[_ - 1]].concat(A[_]);
          break;
        case 14:
          k.getLogger().debug("Rule: link: ", A[_], T), this.$ = { edgeTypeStr: A[_], label: "" };
          break;
        case 15:
          k.getLogger().debug("Rule: LABEL link: ", A[_ - 3], A[_ - 1], A[_]), this.$ = { edgeTypeStr: A[_], label: A[_ - 1] };
          break;
        case 18:
          const O = parseInt(A[_]), P = k.generateId();
          this.$ = { id: P, type: "space", label: "", width: O, children: [] };
          break;
        case 23:
          k.getLogger().debug("Rule: (nodeStatement link node) ", A[_ - 2], A[_ - 1], A[_], " typestr: ", A[_ - 1].edgeTypeStr);
          const S = k.edgeStrToEdgeData(A[_ - 1].edgeTypeStr);
          this.$ = [
            { id: A[_ - 2].id, label: A[_ - 2].label, type: A[_ - 2].type, directions: A[_ - 2].directions },
            { id: A[_ - 2].id + "-" + A[_].id, start: A[_ - 2].id, end: A[_].id, label: A[_ - 1].label, type: "edge", directions: A[_].directions, arrowTypeEnd: S, arrowTypeStart: "arrow_open" },
            { id: A[_].id, label: A[_].label, type: k.typeStr2Type(A[_].typeStr), directions: A[_].directions }
          ];
          break;
        case 24:
          k.getLogger().debug("Rule: nodeStatement (abc88 node size) ", A[_ - 1], A[_]), this.$ = { id: A[_ - 1].id, label: A[_ - 1].label, type: k.typeStr2Type(A[_ - 1].typeStr), directions: A[_ - 1].directions, widthInColumns: parseInt(A[_], 10) };
          break;
        case 25:
          k.getLogger().debug("Rule: nodeStatement (node) ", A[_]), this.$ = { id: A[_].id, label: A[_].label, type: k.typeStr2Type(A[_].typeStr), directions: A[_].directions, widthInColumns: 1 };
          break;
        case 26:
          k.getLogger().debug("APA123", this ? this : "na"), k.getLogger().debug("COLUMNS: ", A[_]), this.$ = { type: "column-setting", columns: A[_] === "auto" ? -1 : parseInt(A[_]) };
          break;
        case 27:
          k.getLogger().debug("Rule: id-block statement : ", A[_ - 2], A[_ - 1]), k.generateId(), this.$ = { ...A[_ - 2], type: "composite", children: A[_ - 1] };
          break;
        case 28:
          k.getLogger().debug("Rule: blockStatement : ", A[_ - 2], A[_ - 1], A[_]);
          const M = k.generateId();
          this.$ = { id: M, type: "composite", label: "", children: A[_ - 1] };
          break;
        case 29:
          k.getLogger().debug("Rule: node (NODE_ID separator): ", A[_]), this.$ = { id: A[_] };
          break;
        case 30:
          k.getLogger().debug("Rule: node (NODE_ID nodeShapeNLabel separator): ", A[_ - 1], A[_]), this.$ = { id: A[_ - 1], label: A[_].label, typeStr: A[_].typeStr, directions: A[_].directions };
          break;
        case 31:
          k.getLogger().debug("Rule: dirList: ", A[_]), this.$ = [A[_]];
          break;
        case 32:
          k.getLogger().debug("Rule: dirList: ", A[_ - 1], A[_]), this.$ = [A[_ - 1]].concat(A[_]);
          break;
        case 33:
          k.getLogger().debug("Rule: nodeShapeNLabel: ", A[_ - 2], A[_ - 1], A[_]), this.$ = { typeStr: A[_ - 2] + A[_], label: A[_ - 1] };
          break;
        case 34:
          k.getLogger().debug("Rule: BLOCK_ARROW nodeShapeNLabel: ", A[_ - 3], A[_ - 2], " #3:", A[_ - 1], A[_]), this.$ = { typeStr: A[_ - 3] + A[_], label: A[_ - 2], directions: A[_ - 1] };
          break;
        case 35:
        case 36:
          this.$ = { type: "classDef", id: A[_ - 1].trim(), css: A[_].trim() };
          break;
        case 37:
          this.$ = { type: "applyClass", id: A[_ - 1].trim(), styleClass: A[_].trim() };
          break;
        case 38:
          this.$ = { type: "applyStyles", id: A[_ - 1].trim(), stylesStr: A[_].trim() };
          break;
      }
    }, "anonymous"),
    table: [{ 9: 1, 10: [1, 2] }, { 1: [3] }, { 10: e, 11: 3, 13: 4, 19: 5, 20: 6, 21: r, 22: 8, 23: 9, 24: 10, 25: 11, 26: 12, 28: n, 29: i, 31: a, 39: s, 43: o, 46: l }, { 8: [1, 20] }, t(u, [2, 12], { 13: 4, 19: 5, 20: 6, 22: 8, 23: 9, 24: 10, 25: 11, 26: 12, 11: 21, 10: e, 21: r, 28: n, 29: i, 31: a, 39: s, 43: o, 46: l }), t(h, [2, 16], { 14: 22, 15: d, 16: f }), t(h, [2, 17]), t(h, [2, 18]), t(h, [2, 19]), t(h, [2, 20]), t(h, [2, 21]), t(h, [2, 22]), t(p, [2, 25], { 27: [1, 25] }), t(h, [2, 26]), { 19: 26, 26: 12, 31: a }, { 10: e, 11: 27, 13: 4, 19: 5, 20: 6, 21: r, 22: 8, 23: 9, 24: 10, 25: 11, 26: 12, 28: n, 29: i, 31: a, 39: s, 43: o, 46: l }, { 40: [1, 28], 42: [1, 29] }, { 44: [1, 30] }, { 47: [1, 31] }, t(g, [2, 29], { 32: 32, 35: [1, 33], 37: [1, 34] }), { 1: [2, 7] }, t(u, [2, 13]), { 26: 35, 31: a }, { 31: [2, 14] }, { 17: [1, 36] }, t(p, [2, 24]), { 10: e, 11: 37, 13: 4, 14: 22, 15: d, 16: f, 19: 5, 20: 6, 21: r, 22: 8, 23: 9, 24: 10, 25: 11, 26: 12, 28: n, 29: i, 31: a, 39: s, 43: o, 46: l }, { 30: [1, 38] }, { 41: [1, 39] }, { 41: [1, 40] }, { 45: [1, 41] }, { 48: [1, 42] }, t(g, [2, 30]), { 18: [1, 43] }, { 18: [1, 44] }, t(p, [2, 23]), { 18: [1, 45] }, { 30: [1, 46] }, t(h, [2, 28]), t(h, [2, 35]), t(h, [2, 36]), t(h, [2, 37]), t(h, [2, 38]), { 36: [1, 47] }, { 33: 48, 34: m }, { 15: [1, 50] }, t(h, [2, 27]), t(g, [2, 33]), { 38: [1, 51] }, { 33: 52, 34: m, 38: [2, 31] }, { 31: [2, 15] }, t(g, [2, 34]), { 38: [2, 32] }],
    defaultActions: { 20: [2, 7], 23: [2, 14], 50: [2, 15], 52: [2, 32] },
    parseError: /* @__PURE__ */ x(function(T, E) {
      if (E.recoverable)
        this.trace(T);
      else {
        var L = new Error(T);
        throw L.hash = E, L;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ x(function(T) {
      var E = this, L = [0], k = [], C = [null], A = [], R = this.table, _ = "", O = 0, P = 0, S = 2, M = 1, N = A.slice.call(arguments, 1), D = Object.create(this.lexer), I = { yy: {} };
      for (var B in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, B) && (I.yy[B] = this.yy[B]);
      D.setInput(T, I.yy), I.yy.lexer = D, I.yy.parser = this, typeof D.yylloc > "u" && (D.yylloc = {});
      var z = D.yylloc;
      A.push(z);
      var F = D.options && D.options.ranges;
      typeof I.yy.parseError == "function" ? this.parseError = I.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function V(j) {
        L.length = L.length - 2 * j, C.length = C.length - j, A.length = A.length - j;
      }
      x(V, "popStack");
      function H() {
        var j;
        return j = k.pop() || D.lex() || M, typeof j != "number" && (j instanceof Array && (k = j, j = k.pop()), j = E.symbols_[j] || j), j;
      }
      x(H, "lex");
      for (var J, q, ae, re, pe = {}, K, Z, X, Y; ; ) {
        if (q = L[L.length - 1], this.defaultActions[q] ? ae = this.defaultActions[q] : ((J === null || typeof J > "u") && (J = H()), ae = R[q] && R[q][J]), typeof ae > "u" || !ae.length || !ae[0]) {
          var ee = "";
          Y = [];
          for (K in R[q])
            this.terminals_[K] && K > S && Y.push("'" + this.terminals_[K] + "'");
          D.showPosition ? ee = "Parse error on line " + (O + 1) + `:
` + D.showPosition() + `
Expecting ` + Y.join(", ") + ", got '" + (this.terminals_[J] || J) + "'" : ee = "Parse error on line " + (O + 1) + ": Unexpected " + (J == M ? "end of input" : "'" + (this.terminals_[J] || J) + "'"), this.parseError(ee, {
            text: D.match,
            token: this.terminals_[J] || J,
            line: D.yylineno,
            loc: z,
            expected: Y
          });
        }
        if (ae[0] instanceof Array && ae.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + q + ", token: " + J);
        switch (ae[0]) {
          case 1:
            L.push(J), C.push(D.yytext), A.push(D.yylloc), L.push(ae[1]), J = null, P = D.yyleng, _ = D.yytext, O = D.yylineno, z = D.yylloc;
            break;
          case 2:
            if (Z = this.productions_[ae[1]][1], pe.$ = C[C.length - Z], pe._$ = {
              first_line: A[A.length - (Z || 1)].first_line,
              last_line: A[A.length - 1].last_line,
              first_column: A[A.length - (Z || 1)].first_column,
              last_column: A[A.length - 1].last_column
            }, F && (pe._$.range = [
              A[A.length - (Z || 1)].range[0],
              A[A.length - 1].range[1]
            ]), re = this.performAction.apply(pe, [
              _,
              P,
              O,
              I.yy,
              ae[1],
              C,
              A
            ].concat(N)), typeof re < "u")
              return re;
            Z && (L = L.slice(0, -1 * Z * 2), C = C.slice(0, -1 * Z), A = A.slice(0, -1 * Z)), L.push(this.productions_[ae[1]][0]), C.push(pe.$), A.push(pe._$), X = R[L[L.length - 2]][L[L.length - 1]], L.push(X);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, y = /* @__PURE__ */ (function() {
    var w = {
      EOF: 1,
      parseError: /* @__PURE__ */ x(function(E, L) {
        if (this.yy.parser)
          this.yy.parser.parseError(E, L);
        else
          throw new Error(E);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ x(function(T, E) {
        return this.yy = E || this.yy || {}, this._input = T, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ x(function() {
        var T = this._input[0];
        this.yytext += T, this.yyleng++, this.offset++, this.match += T, this.matched += T;
        var E = T.match(/(?:\r\n?|\n).*/g);
        return E ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), T;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ x(function(T) {
        var E = T.length, L = T.split(/(?:\r\n?|\n)/g);
        this._input = T + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - E), this.offset -= E;
        var k = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), L.length - 1 && (this.yylineno -= L.length - 1);
        var C = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: L ? (L.length === k.length ? this.yylloc.first_column : 0) + k[k.length - L.length].length - L[0].length : this.yylloc.first_column - E
        }, this.options.ranges && (this.yylloc.range = [C[0], C[0] + this.yyleng - E]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ x(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ x(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ x(function(T) {
        this.unput(this.match.slice(T));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ x(function() {
        var T = this.matched.substr(0, this.matched.length - this.match.length);
        return (T.length > 20 ? "..." : "") + T.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ x(function() {
        var T = this.match;
        return T.length < 20 && (T += this._input.substr(0, 20 - T.length)), (T.substr(0, 20) + (T.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ x(function() {
        var T = this.pastInput(), E = new Array(T.length + 1).join("-");
        return T + this.upcomingInput() + `
` + E + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ x(function(T, E) {
        var L, k, C;
        if (this.options.backtrack_lexer && (C = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (C.yylloc.range = this.yylloc.range.slice(0))), k = T[0].match(/(?:\r\n?|\n).*/g), k && (this.yylineno += k.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: k ? k[k.length - 1].length - k[k.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + T[0].length
        }, this.yytext += T[0], this.match += T[0], this.matches = T, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(T[0].length), this.matched += T[0], L = this.performAction.call(this, this.yy, this, E, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), L)
          return L;
        if (this._backtrack) {
          for (var A in C)
            this[A] = C[A];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ x(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var T, E, L, k;
        this._more || (this.yytext = "", this.match = "");
        for (var C = this._currentRules(), A = 0; A < C.length; A++)
          if (L = this._input.match(this.rules[C[A]]), L && (!E || L[0].length > E[0].length)) {
            if (E = L, k = A, this.options.backtrack_lexer) {
              if (T = this.test_match(L, C[A]), T !== !1)
                return T;
              if (this._backtrack) {
                E = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return E ? (T = this.test_match(E, C[k]), T !== !1 ? T : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ x(function() {
        var E = this.next();
        return E || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ x(function(E) {
        this.conditionStack.push(E);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ x(function() {
        var E = this.conditionStack.length - 1;
        return E > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ x(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ x(function(E) {
        return E = this.conditionStack.length - 1 - Math.abs(E || 0), E >= 0 ? this.conditionStack[E] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ x(function(E) {
        this.begin(E);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ x(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: {},
      performAction: /* @__PURE__ */ x(function(E, L, k, C) {
        switch (k) {
          case 0:
            return E.getLogger().debug("Found block-beta"), 10;
          case 1:
            return E.getLogger().debug("Found id-block"), 29;
          case 2:
            return E.getLogger().debug("Found block"), 10;
          case 3:
            E.getLogger().debug(".", L.yytext);
            break;
          case 4:
            E.getLogger().debug("_", L.yytext);
            break;
          case 5:
            return 5;
          case 6:
            return L.yytext = -1, 28;
          case 7:
            return L.yytext = L.yytext.replace(/columns\s+/, ""), E.getLogger().debug("COLUMNS (LEX)", L.yytext), 28;
          case 8:
            this.pushState("md_string");
            break;
          case 9:
            return "MD_STR";
          case 10:
            this.popState();
            break;
          case 11:
            this.pushState("string");
            break;
          case 12:
            E.getLogger().debug("LEX: POPPING STR:", L.yytext), this.popState();
            break;
          case 13:
            return E.getLogger().debug("LEX: STR end:", L.yytext), "STR";
          case 14:
            return L.yytext = L.yytext.replace(/space\:/, ""), E.getLogger().debug("SPACE NUM (LEX)", L.yytext), 21;
          case 15:
            return L.yytext = "1", E.getLogger().debug("COLUMNS (LEX)", L.yytext), 21;
          case 16:
            return 42;
          case 17:
            return "LINKSTYLE";
          case 18:
            return "INTERPOLATE";
          case 19:
            return this.pushState("CLASSDEF"), 39;
          case 20:
            return this.popState(), this.pushState("CLASSDEFID"), "DEFAULT_CLASSDEF_ID";
          case 21:
            return this.popState(), this.pushState("CLASSDEFID"), 40;
          case 22:
            return this.popState(), 41;
          case 23:
            return this.pushState("CLASS"), 43;
          case 24:
            return this.popState(), this.pushState("CLASS_STYLE"), 44;
          case 25:
            return this.popState(), 45;
          case 26:
            return this.pushState("STYLE_STMNT"), 46;
          case 27:
            return this.popState(), this.pushState("STYLE_DEFINITION"), 47;
          case 28:
            return this.popState(), 48;
          case 29:
            return this.pushState("acc_title"), "acc_title";
          case 30:
            return this.popState(), "acc_title_value";
          case 31:
            return this.pushState("acc_descr"), "acc_descr";
          case 32:
            return this.popState(), "acc_descr_value";
          case 33:
            this.pushState("acc_descr_multiline");
            break;
          case 34:
            this.popState();
            break;
          case 35:
            return "acc_descr_multiline_value";
          case 36:
            return 30;
          case 37:
            return this.popState(), E.getLogger().debug("Lex: (("), "NODE_DEND";
          case 38:
            return this.popState(), E.getLogger().debug("Lex: (("), "NODE_DEND";
          case 39:
            return this.popState(), E.getLogger().debug("Lex: ))"), "NODE_DEND";
          case 40:
            return this.popState(), E.getLogger().debug("Lex: (("), "NODE_DEND";
          case 41:
            return this.popState(), E.getLogger().debug("Lex: (("), "NODE_DEND";
          case 42:
            return this.popState(), E.getLogger().debug("Lex: (-"), "NODE_DEND";
          case 43:
            return this.popState(), E.getLogger().debug("Lex: -)"), "NODE_DEND";
          case 44:
            return this.popState(), E.getLogger().debug("Lex: (("), "NODE_DEND";
          case 45:
            return this.popState(), E.getLogger().debug("Lex: ]]"), "NODE_DEND";
          case 46:
            return this.popState(), E.getLogger().debug("Lex: ("), "NODE_DEND";
          case 47:
            return this.popState(), E.getLogger().debug("Lex: ])"), "NODE_DEND";
          case 48:
            return this.popState(), E.getLogger().debug("Lex: /]"), "NODE_DEND";
          case 49:
            return this.popState(), E.getLogger().debug("Lex: /]"), "NODE_DEND";
          case 50:
            return this.popState(), E.getLogger().debug("Lex: )]"), "NODE_DEND";
          case 51:
            return this.popState(), E.getLogger().debug("Lex: )"), "NODE_DEND";
          case 52:
            return this.popState(), E.getLogger().debug("Lex: ]>"), "NODE_DEND";
          case 53:
            return this.popState(), E.getLogger().debug("Lex: ]"), "NODE_DEND";
          case 54:
            return E.getLogger().debug("Lexa: -)"), this.pushState("NODE"), 35;
          case 55:
            return E.getLogger().debug("Lexa: (-"), this.pushState("NODE"), 35;
          case 56:
            return E.getLogger().debug("Lexa: ))"), this.pushState("NODE"), 35;
          case 57:
            return E.getLogger().debug("Lexa: )"), this.pushState("NODE"), 35;
          case 58:
            return E.getLogger().debug("Lex: ((("), this.pushState("NODE"), 35;
          case 59:
            return E.getLogger().debug("Lexa: )"), this.pushState("NODE"), 35;
          case 60:
            return E.getLogger().debug("Lexa: )"), this.pushState("NODE"), 35;
          case 61:
            return E.getLogger().debug("Lexa: )"), this.pushState("NODE"), 35;
          case 62:
            return E.getLogger().debug("Lexc: >"), this.pushState("NODE"), 35;
          case 63:
            return E.getLogger().debug("Lexa: (["), this.pushState("NODE"), 35;
          case 64:
            return E.getLogger().debug("Lexa: )"), this.pushState("NODE"), 35;
          case 65:
            return this.pushState("NODE"), 35;
          case 66:
            return this.pushState("NODE"), 35;
          case 67:
            return this.pushState("NODE"), 35;
          case 68:
            return this.pushState("NODE"), 35;
          case 69:
            return this.pushState("NODE"), 35;
          case 70:
            return this.pushState("NODE"), 35;
          case 71:
            return this.pushState("NODE"), 35;
          case 72:
            return E.getLogger().debug("Lexa: ["), this.pushState("NODE"), 35;
          case 73:
            return this.pushState("BLOCK_ARROW"), E.getLogger().debug("LEX ARR START"), 37;
          case 74:
            return E.getLogger().debug("Lex: NODE_ID", L.yytext), 31;
          case 75:
            return E.getLogger().debug("Lex: EOF", L.yytext), 8;
          case 76:
            this.pushState("md_string");
            break;
          case 77:
            this.pushState("md_string");
            break;
          case 78:
            return "NODE_DESCR";
          case 79:
            this.popState();
            break;
          case 80:
            E.getLogger().debug("Lex: Starting string"), this.pushState("string");
            break;
          case 81:
            E.getLogger().debug("LEX ARR: Starting string"), this.pushState("string");
            break;
          case 82:
            return E.getLogger().debug("LEX: NODE_DESCR:", L.yytext), "NODE_DESCR";
          case 83:
            E.getLogger().debug("LEX POPPING"), this.popState();
            break;
          case 84:
            E.getLogger().debug("Lex: =>BAE"), this.pushState("ARROW_DIR");
            break;
          case 85:
            return L.yytext = L.yytext.replace(/^,\s*/, ""), E.getLogger().debug("Lex (right): dir:", L.yytext), "DIR";
          case 86:
            return L.yytext = L.yytext.replace(/^,\s*/, ""), E.getLogger().debug("Lex (left):", L.yytext), "DIR";
          case 87:
            return L.yytext = L.yytext.replace(/^,\s*/, ""), E.getLogger().debug("Lex (x):", L.yytext), "DIR";
          case 88:
            return L.yytext = L.yytext.replace(/^,\s*/, ""), E.getLogger().debug("Lex (y):", L.yytext), "DIR";
          case 89:
            return L.yytext = L.yytext.replace(/^,\s*/, ""), E.getLogger().debug("Lex (up):", L.yytext), "DIR";
          case 90:
            return L.yytext = L.yytext.replace(/^,\s*/, ""), E.getLogger().debug("Lex (down):", L.yytext), "DIR";
          case 91:
            return L.yytext = "]>", E.getLogger().debug("Lex (ARROW_DIR end):", L.yytext), this.popState(), this.popState(), "BLOCK_ARROW_END";
          case 92:
            return E.getLogger().debug("Lex: LINK", "#" + L.yytext + "#"), 15;
          case 93:
            return E.getLogger().debug("Lex: LINK", L.yytext), 15;
          case 94:
            return E.getLogger().debug("Lex: LINK", L.yytext), 15;
          case 95:
            return E.getLogger().debug("Lex: LINK", L.yytext), 15;
          case 96:
            return E.getLogger().debug("Lex: START_LINK", L.yytext), this.pushState("LLABEL"), 16;
          case 97:
            return E.getLogger().debug("Lex: START_LINK", L.yytext), this.pushState("LLABEL"), 16;
          case 98:
            return E.getLogger().debug("Lex: START_LINK", L.yytext), this.pushState("LLABEL"), 16;
          case 99:
            this.pushState("md_string");
            break;
          case 100:
            return E.getLogger().debug("Lex: Starting string"), this.pushState("string"), "LINK_LABEL";
          case 101:
            return this.popState(), E.getLogger().debug("Lex: LINK", "#" + L.yytext + "#"), 15;
          case 102:
            return this.popState(), E.getLogger().debug("Lex: LINK", L.yytext), 15;
          case 103:
            return this.popState(), E.getLogger().debug("Lex: LINK", L.yytext), 15;
          case 104:
            return E.getLogger().debug("Lex: COLON", L.yytext), L.yytext = L.yytext.slice(1), 27;
        }
      }, "anonymous"),
      rules: [/^(?:block-beta\b)/, /^(?:block:)/, /^(?:block\b)/, /^(?:[\s]+)/, /^(?:[\n]+)/, /^(?:((\u000D\u000A)|(\u000A)))/, /^(?:columns\s+auto\b)/, /^(?:columns\s+[\d]+)/, /^(?:["][`])/, /^(?:[^`"]+)/, /^(?:[`]["])/, /^(?:["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:space[:]\d+)/, /^(?:space\b)/, /^(?:default\b)/, /^(?:linkStyle\b)/, /^(?:interpolate\b)/, /^(?:classDef\s+)/, /^(?:DEFAULT\s+)/, /^(?:\w+\s+)/, /^(?:[^\n]*)/, /^(?:class\s+)/, /^(?:(\w+)+((,\s*\w+)*))/, /^(?:[^\n]*)/, /^(?:style\s+)/, /^(?:(\w+)+((,\s*\w+)*))/, /^(?:[^\n]*)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:end\b\s*)/, /^(?:\(\(\()/, /^(?:\)\)\))/, /^(?:[\)]\))/, /^(?:\}\})/, /^(?:\})/, /^(?:\(-)/, /^(?:-\))/, /^(?:\(\()/, /^(?:\]\])/, /^(?:\()/, /^(?:\]\))/, /^(?:\\\])/, /^(?:\/\])/, /^(?:\)\])/, /^(?:[\)])/, /^(?:\]>)/, /^(?:[\]])/, /^(?:-\))/, /^(?:\(-)/, /^(?:\)\))/, /^(?:\))/, /^(?:\(\(\()/, /^(?:\(\()/, /^(?:\{\{)/, /^(?:\{)/, /^(?:>)/, /^(?:\(\[)/, /^(?:\()/, /^(?:\[\[)/, /^(?:\[\|)/, /^(?:\[\()/, /^(?:\)\)\))/, /^(?:\[\\)/, /^(?:\[\/)/, /^(?:\[\\)/, /^(?:\[)/, /^(?:<\[)/, /^(?:[^\(\[\n\-\)\{\}\s\<\>:]+)/, /^(?:$)/, /^(?:["][`])/, /^(?:["][`])/, /^(?:[^`"]+)/, /^(?:[`]["])/, /^(?:["])/, /^(?:["])/, /^(?:[^"]+)/, /^(?:["])/, /^(?:\]>\s*\()/, /^(?:,?\s*right\s*)/, /^(?:,?\s*left\s*)/, /^(?:,?\s*x\s*)/, /^(?:,?\s*y\s*)/, /^(?:,?\s*up\s*)/, /^(?:,?\s*down\s*)/, /^(?:\)\s*)/, /^(?:\s*[xo<]?--+[-xo>]\s*)/, /^(?:\s*[xo<]?==+[=xo>]\s*)/, /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/, /^(?:\s*~~[\~]+\s*)/, /^(?:\s*[xo<]?--\s*)/, /^(?:\s*[xo<]?==\s*)/, /^(?:\s*[xo<]?-\.\s*)/, /^(?:["][`])/, /^(?:["])/, /^(?:\s*[xo<]?--+[-xo>]\s*)/, /^(?:\s*[xo<]?==+[=xo>]\s*)/, /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/, /^(?::\d+)/],
      conditions: { STYLE_DEFINITION: { rules: [28], inclusive: !1 }, STYLE_STMNT: { rules: [27], inclusive: !1 }, CLASSDEFID: { rules: [22], inclusive: !1 }, CLASSDEF: { rules: [20, 21], inclusive: !1 }, CLASS_STYLE: { rules: [25], inclusive: !1 }, CLASS: { rules: [24], inclusive: !1 }, LLABEL: { rules: [99, 100, 101, 102, 103], inclusive: !1 }, ARROW_DIR: { rules: [85, 86, 87, 88, 89, 90, 91], inclusive: !1 }, BLOCK_ARROW: { rules: [76, 81, 84], inclusive: !1 }, NODE: { rules: [37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 77, 80], inclusive: !1 }, md_string: { rules: [9, 10, 78, 79], inclusive: !1 }, space: { rules: [], inclusive: !1 }, string: { rules: [12, 13, 82, 83], inclusive: !1 }, acc_descr_multiline: { rules: [34, 35], inclusive: !1 }, acc_descr: { rules: [32], inclusive: !1 }, acc_title: { rules: [30], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 11, 14, 15, 16, 17, 18, 19, 23, 26, 29, 31, 33, 36, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 92, 93, 94, 95, 96, 97, 98, 104], inclusive: !0 } }
    };
    return w;
  })();
  v.lexer = y;
  function b() {
    this.yy = {};
  }
  return x(b, "Parser"), b.prototype = v, v.Parser = b, new b();
})();
Z6.parser = Z6;
var CBe = Z6, ks = /* @__PURE__ */ new Map(), G7 = [], Q6 = /* @__PURE__ */ new Map(), nI = "color", iI = "fill", ABe = "bgFill", WX = ",", _Be = we(), E2 = /* @__PURE__ */ new Map(), LBe = /* @__PURE__ */ x((t) => at.sanitizeText(t, _Be), "sanitizeText"), RBe = /* @__PURE__ */ x(function(t, e = "") {
  let r = E2.get(t);
  r || (r = { id: t, styles: [], textStyles: [] }, E2.set(t, r)), e?.split(WX).forEach((n) => {
    const i = n.replace(/([^;]*);/, "$1").trim();
    if (RegExp(nI).exec(n)) {
      const s = i.replace(iI, ABe).replace(nI, iI);
      r.textStyles.push(s);
    }
    r.styles.push(i);
  });
}, "addStyleClass"), MBe = /* @__PURE__ */ x(function(t, e = "") {
  const r = ks.get(t);
  e != null && (r.styles = e.split(WX));
}, "addStyle2Node"), NBe = /* @__PURE__ */ x(function(t, e) {
  t.split(",").forEach(function(r) {
    let n = ks.get(r);
    if (n === void 0) {
      const i = r.trim();
      n = { id: i, type: "na", children: [] }, ks.set(i, n);
    }
    n.classes || (n.classes = []), n.classes.push(e);
  });
}, "setCssClass"), YX = /* @__PURE__ */ x((t, e) => {
  const r = t.flat(), n = [], a = r.find((s) => s?.type === "column-setting")?.columns ?? -1;
  for (const s of r) {
    if (typeof a == "number" && a > 0 && s.type !== "column-setting" && typeof s.widthInColumns == "number" && s.widthInColumns > a && ie.warn(
      `Block ${s.id} width ${s.widthInColumns} exceeds configured column width ${a}`
    ), s.label && (s.label = LBe(s.label)), s.type === "classDef") {
      RBe(s.id, s.css);
      continue;
    }
    if (s.type === "applyClass") {
      NBe(s.id, s?.styleClass ?? "");
      continue;
    }
    if (s.type === "applyStyles") {
      s?.stylesStr && MBe(s.id, s?.stylesStr);
      continue;
    }
    if (s.type === "column-setting")
      e.columns = s.columns ?? -1;
    else if (s.type === "edge") {
      const o = (Q6.get(s.id) ?? 0) + 1;
      Q6.set(s.id, o), s.id = o + "-" + s.id, G7.push(s);
    } else {
      s.label || (s.type === "composite" ? s.label = "" : s.label = s.id);
      const o = ks.get(s.id);
      if (o === void 0 ? ks.set(s.id, s) : (s.type !== "na" && (o.type = s.type), s.label !== s.id && (o.label = s.label)), s.children && YX(s.children, s), s.type === "space") {
        const l = s.width ?? 1;
        for (let u = 0; u < l; u++) {
          const h = MG(s);
          h.id = h.id + "-" + u, ks.set(h.id, h), n.push(h);
        }
      } else o === void 0 && n.push(s);
    }
  }
  e.children = n;
}, "populateBlockDatabase"), V7 = [], sp = { id: "root", type: "composite", children: [], columns: -1 }, IBe = /* @__PURE__ */ x(() => {
  ie.debug("Clear called"), _n(), sp = { id: "root", type: "composite", children: [], columns: -1 }, ks = /* @__PURE__ */ new Map([["root", sp]]), V7 = [], E2 = /* @__PURE__ */ new Map(), G7 = [], Q6 = /* @__PURE__ */ new Map();
}, "clear");
function XX(t) {
  switch (ie.debug("typeStr2Type", t), t) {
    case "[]":
      return "square";
    case "()":
      return ie.debug("we have a round"), "round";
    case "(())":
      return "circle";
    case ">]":
      return "rect_left_inv_arrow";
    case "{}":
      return "diamond";
    case "{{}}":
      return "hexagon";
    case "([])":
      return "stadium";
    case "[[]]":
      return "subroutine";
    case "[()]":
      return "cylinder";
    case "((()))":
      return "doublecircle";
    case "[//]":
      return "lean_right";
    case "[\\\\]":
      return "lean_left";
    case "[/\\]":
      return "trapezoid";
    case "[\\/]":
      return "inv_trapezoid";
    case "<[]>":
      return "block_arrow";
    default:
      return "na";
  }
}
x(XX, "typeStr2Type");
function jX(t) {
  return ie.debug("typeStr2Type", t), t === "==" ? "thick" : "normal";
}
x(jX, "edgeTypeStr2Type");
function KX(t) {
  switch (t.replace(/^[\s-]+|[\s-]+$/g, "")) {
    case "x":
      return "arrow_cross";
    case "o":
      return "arrow_circle";
    case ">":
      return "arrow_point";
    default:
      return "";
  }
}
x(KX, "edgeStrToEdgeData");
var aI = 0, DBe = /* @__PURE__ */ x(() => (aI++, "id-" + Math.random().toString(36).substr(2, 12) + "-" + aI), "generateId"), OBe = /* @__PURE__ */ x((t) => {
  sp.children = t, YX(t, sp), V7 = sp.children;
}, "setHierarchy"), PBe = /* @__PURE__ */ x((t) => {
  const e = ks.get(t);
  return e ? e.columns ? e.columns : e.children ? e.children.length : -1 : -1;
}, "getColumns"), BBe = /* @__PURE__ */ x(() => [...ks.values()], "getBlocksFlat"), FBe = /* @__PURE__ */ x(() => V7 || [], "getBlocks"), $Be = /* @__PURE__ */ x(() => G7, "getEdges"), zBe = /* @__PURE__ */ x((t) => ks.get(t), "getBlock"), GBe = /* @__PURE__ */ x((t) => {
  ks.set(t.id, t);
}, "setBlock"), VBe = /* @__PURE__ */ x(() => ie, "getLogger"), UBe = /* @__PURE__ */ x(function() {
  return E2;
}, "getClasses"), HBe = {
  getConfig: /* @__PURE__ */ x(() => pr().block, "getConfig"),
  typeStr2Type: XX,
  edgeTypeStr2Type: jX,
  edgeStrToEdgeData: KX,
  getLogger: VBe,
  getBlocksFlat: BBe,
  getBlocks: FBe,
  getEdges: $Be,
  setHierarchy: OBe,
  getBlock: zBe,
  setBlock: GBe,
  getColumns: PBe,
  getClasses: UBe,
  clear: IBe,
  generateId: DBe
}, qBe = HBe, fm = /* @__PURE__ */ x((t, e) => {
  const r = iE, n = r(t, "r"), i = r(t, "g"), a = r(t, "b");
  return Fl(n, i, a, e);
}, "fade"), WBe = /* @__PURE__ */ x((t) => `.label {
    font-family: ${t.fontFamily};
    color: ${t.nodeTextColor || t.textColor};
  }
  .cluster-label text {
    fill: ${t.titleColor};
  }
  .cluster-label span,p {
    color: ${t.titleColor};
  }



  .label text,span,p {
    fill: ${t.nodeTextColor || t.textColor};
    color: ${t.nodeTextColor || t.textColor};
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${t.mainBkg};
    stroke: ${t.nodeBorder};
    stroke-width: 1px;
  }
  .flowchart-label text {
    text-anchor: middle;
  }
  // .flowchart-label .text-outer-tspan {
  //   text-anchor: middle;
  // }
  // .flowchart-label .text-inner-tspan {
  //   text-anchor: start;
  // }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${t.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${t.lineColor};
    stroke-width: 2.0px;
  }

  .flowchart-link {
    stroke: ${t.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${t.edgeLabelBackground};
    rect {
      opacity: 0.5;
      background-color: ${t.edgeLabelBackground};
      fill: ${t.edgeLabelBackground};
    }
    text-align: center;
  }

  /* For html labels only */
  .labelBkg {
    background-color: ${fm(t.edgeLabelBackground, 0.5)};
    // background-color:
  }

  .node .cluster {
    // fill: ${fm(t.mainBkg, 0.5)};
    fill: ${fm(t.clusterBkg, 0.5)};
    stroke: ${fm(t.clusterBorder, 0.2)};
    box-shadow: rgba(50, 50, 93, 0.25) 0px 13px 27px -5px, rgba(0, 0, 0, 0.3) 0px 8px 16px -8px;
    stroke-width: 1px;
  }

  .cluster text {
    fill: ${t.titleColor};
  }

  .cluster span,p {
    color: ${t.titleColor};
  }
  /* .cluster div {
    color: ${t.titleColor};
  } */

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${t.fontFamily};
    font-size: 12px;
    background: ${t.tertiaryColor};
    border: 1px solid ${t.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .flowchartTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${t.textColor};
  }
  ${Dg()}
`, "getStyles"), YBe = WBe, XBe = /* @__PURE__ */ x((t, e, r, n) => {
  e.forEach((i) => {
    iFe[i](t, r, n);
  });
}, "insertMarkers"), jBe = /* @__PURE__ */ x((t, e, r) => {
  ie.trace("Making markers for ", r), t.append("defs").append("marker").attr("id", r + "_" + e + "-extensionStart").attr("class", "marker extension " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-extensionEnd").attr("class", "marker extension " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
}, "extension"), KBe = /* @__PURE__ */ x((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-compositionStart").attr("class", "marker composition " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-compositionEnd").attr("class", "marker composition " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "composition"), ZBe = /* @__PURE__ */ x((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-aggregationStart").attr("class", "marker aggregation " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-aggregationEnd").attr("class", "marker aggregation " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "aggregation"), QBe = /* @__PURE__ */ x((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-dependencyStart").attr("class", "marker dependency " + e).attr("refX", 6).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-dependencyEnd").attr("class", "marker dependency " + e).attr("refX", 13).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, "dependency"), JBe = /* @__PURE__ */ x((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-lollipopStart").attr("class", "marker lollipop " + e).attr("refX", 13).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6), t.append("defs").append("marker").attr("id", r + "_" + e + "-lollipopEnd").attr("class", "marker lollipop " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);
}, "lollipop"), eFe = /* @__PURE__ */ x((t, e, r) => {
  t.append("marker").attr("id", r + "_" + e + "-pointEnd").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 6).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", r + "_" + e + "-pointStart").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 4.5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "point"), tFe = /* @__PURE__ */ x((t, e, r) => {
  t.append("marker").attr("id", r + "_" + e + "-circleEnd").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", r + "_" + e + "-circleStart").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "circle"), rFe = /* @__PURE__ */ x((t, e, r) => {
  t.append("marker").attr("id", r + "_" + e + "-crossEnd").attr("class", "marker cross " + e).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", r + "_" + e + "-crossStart").attr("class", "marker cross " + e).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
}, "cross"), nFe = /* @__PURE__ */ x((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "strokeWidth").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
}, "barb"), iFe = {
  extension: jBe,
  composition: KBe,
  aggregation: ZBe,
  dependency: QBe,
  lollipop: JBe,
  point: eFe,
  circle: tFe,
  cross: rFe,
  barb: nFe
}, aFe = XBe, pn = we()?.block?.padding ?? 8;
function ZX(t, e) {
  if (t === 0 || !Number.isInteger(t))
    throw new Error("Columns must be an integer !== 0.");
  if (e < 0 || !Number.isInteger(e))
    throw new Error("Position must be a non-negative integer." + e);
  if (t < 0)
    return { px: e, py: 0 };
  if (t === 1)
    return { px: 0, py: e };
  const r = e % t, n = Math.floor(e / t);
  return { px: r, py: n };
}
x(ZX, "calculateBlockPosition");
var sFe = /* @__PURE__ */ x((t) => {
  let e = 0, r = 0;
  for (const n of t.children) {
    const { width: i, height: a, x: s, y: o } = n.size ?? { width: 0, height: 0, x: 0, y: 0 };
    ie.debug(
      "getMaxChildSize abc95 child:",
      n.id,
      "width:",
      i,
      "height:",
      a,
      "x:",
      s,
      "y:",
      o,
      n.type
    ), n.type !== "space" && (i > e && (e = i / (t.widthInColumns ?? 1)), a > r && (r = a));
  }
  return { width: e, height: r };
}, "getMaxChildSize");
function k2(t, e, r = 0, n = 0) {
  ie.debug(
    "setBlockSizes abc95 (start)",
    t.id,
    t?.size?.x,
    "block width =",
    t?.size,
    "siblingWidth",
    r
  ), t?.size?.width || (t.size = {
    width: r,
    height: n,
    x: 0,
    y: 0
  });
  let i = 0, a = 0;
  if (t.children?.length > 0) {
    for (const p of t.children)
      k2(p, e);
    const s = sFe(t);
    i = s.width, a = s.height, ie.debug("setBlockSizes abc95 maxWidth of", t.id, ":s children is ", i, a);
    for (const p of t.children)
      p.size && (ie.debug(
        `abc95 Setting size of children of ${t.id} id=${p.id} ${i} ${a} ${JSON.stringify(p.size)}`
      ), p.size.width = i * (p.widthInColumns ?? 1) + pn * ((p.widthInColumns ?? 1) - 1), p.size.height = a, p.size.x = 0, p.size.y = 0, ie.debug(
        `abc95 updating size of ${t.id} children child:${p.id} maxWidth:${i} maxHeight:${a}`
      ));
    for (const p of t.children)
      k2(p, e, i, a);
    const o = t.columns ?? -1;
    let l = 0;
    for (const p of t.children)
      l += p.widthInColumns ?? 1;
    let u = t.children.length;
    o > 0 && o < l && (u = o);
    const h = Math.ceil(l / u);
    let d = u * (i + pn) + pn, f = h * (a + pn) + pn;
    if (d < r) {
      ie.debug(
        `Detected to small sibling: abc95 ${t.id} siblingWidth ${r} siblingHeight ${n} width ${d}`
      ), d = r, f = n;
      const p = (r - u * pn - pn) / u, g = (n - h * pn - pn) / h;
      ie.debug("Size indata abc88", t.id, "childWidth", p, "maxWidth", i), ie.debug("Size indata abc88", t.id, "childHeight", g, "maxHeight", a), ie.debug("Size indata abc88 xSize", u, "padding", pn);
      for (const m of t.children)
        m.size && (m.size.width = p, m.size.height = g, m.size.x = 0, m.size.y = 0);
    }
    if (ie.debug(
      `abc95 (finale calc) ${t.id} xSize ${u} ySize ${h} columns ${o}${t.children.length} width=${Math.max(d, t.size?.width || 0)}`
    ), d < (t?.size?.width || 0)) {
      d = t?.size?.width || 0;
      const p = o > 0 ? Math.min(t.children.length, o) : t.children.length;
      if (p > 0) {
        const g = (d - p * pn - pn) / p;
        ie.debug("abc95 (growing to fit) width", t.id, d, t.size?.width, g);
        for (const m of t.children)
          m.size && (m.size.width = g);
      }
    }
    t.size = {
      width: d,
      height: f,
      x: 0,
      y: 0
    };
  }
  ie.debug(
    "setBlockSizes abc94 (done)",
    t.id,
    t?.size?.x,
    t?.size?.width,
    t?.size?.y,
    t?.size?.height
  );
}
x(k2, "setBlockSizes");
function U7(t, e) {
  ie.debug(
    `abc85 layout blocks (=>layoutBlocks) ${t.id} x: ${t?.size?.x} y: ${t?.size?.y} width: ${t?.size?.width}`
  );
  const r = t.columns ?? -1;
  if (ie.debug("layoutBlocks columns abc95", t.id, "=>", r, t), t.children && // find max width of children
  t.children.length > 0) {
    const n = t?.children[0]?.size?.width ?? 0, i = t.children.length * n + (t.children.length - 1) * pn;
    ie.debug("widthOfChildren 88", i, "posX");
    let a = 0;
    ie.debug("abc91 block?.size?.x", t.id, t?.size?.x);
    let s = t?.size?.x ? t?.size?.x + (-t?.size?.width / 2 || 0) : -pn, o = 0;
    for (const l of t.children) {
      const u = t;
      if (!l.size)
        continue;
      const { width: h, height: d } = l.size, { px: f, py: p } = ZX(r, a);
      if (p != o && (o = p, s = t?.size?.x ? t?.size?.x + (-t?.size?.width / 2 || 0) : -pn, ie.debug("New row in layout for block", t.id, " and child ", l.id, o)), ie.debug(
        `abc89 layout blocks (child) id: ${l.id} Pos: ${a} (px, py) ${f},${p} (${u?.size?.x},${u?.size?.y}) parent: ${u.id} width: ${h}${pn}`
      ), u.size) {
        const m = h / 2;
        l.size.x = s + pn + m, ie.debug(
          `abc91 layout blocks (calc) px, pyid:${l.id} startingPos=X${s} new startingPosX${l.size.x} ${m} padding=${pn} width=${h} halfWidth=${m} => x:${l.size.x} y:${l.size.y} ${l.widthInColumns} (width * (child?.w || 1)) / 2 ${h * (l?.widthInColumns ?? 1) / 2}`
        ), s = l.size.x + m, l.size.y = u.size.y - u.size.height / 2 + p * (d + pn) + d / 2 + pn, ie.debug(
          `abc88 layout blocks (calc) px, pyid:${l.id}startingPosX${s}${pn}${m}=>x:${l.size.x}y:${l.size.y}${l.widthInColumns}(width * (child?.w || 1)) / 2${h * (l?.widthInColumns ?? 1) / 2}`
        );
      }
      l.children && U7(l);
      let g = l?.widthInColumns ?? 1;
      r > 0 && (g = Math.min(g, r - a % r)), a += g, ie.debug("abc88 columnsPos", l, a);
    }
  }
  ie.debug(
    `layout blocks (<==layoutBlocks) ${t.id} x: ${t?.size?.x} y: ${t?.size?.y} width: ${t?.size?.width}`
  );
}
x(U7, "layoutBlocks");
function H7(t, { minX: e, minY: r, maxX: n, maxY: i } = { minX: 0, minY: 0, maxX: 0, maxY: 0 }) {
  if (t.size && t.id !== "root") {
    const { x: a, y: s, width: o, height: l } = t.size;
    a - o / 2 < e && (e = a - o / 2), s - l / 2 < r && (r = s - l / 2), a + o / 2 > n && (n = a + o / 2), s + l / 2 > i && (i = s + l / 2);
  }
  if (t.children)
    for (const a of t.children)
      ({ minX: e, minY: r, maxX: n, maxY: i } = H7(a, { minX: e, minY: r, maxX: n, maxY: i }));
  return { minX: e, minY: r, maxX: n, maxY: i };
}
x(H7, "findBounds");
function QX(t) {
  const e = t.getBlock("root");
  if (!e)
    return;
  k2(e, t, 0, 0), U7(e), ie.debug("getBlocks", JSON.stringify(e, null, 2));
  const { minX: r, minY: n, maxX: i, maxY: a } = H7(e), s = a - n, o = i - r;
  return { x: r, y: n, width: o, height: s };
}
x(QX, "layout");
function J6(t, e) {
  e && t.attr("style", e);
}
x(J6, "applyStyle");
function JX(t, e) {
  const r = Qe(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")), n = r.append("xhtml:div"), i = t.label, a = t.isNode ? "nodeLabel" : "edgeLabel", s = n.append("span");
  return s.html(dr(i, e)), J6(s, t.labelStyle), s.attr("class", a), J6(n, t.labelStyle), n.style("display", "inline-block"), n.style("white-space", "nowrap"), n.attr("xmlns", "http://www.w3.org/1999/xhtml"), r.node();
}
x(JX, "addHtmlLabel");
var oFe = /* @__PURE__ */ x(async (t, e, r, n) => {
  let i = t || "";
  typeof i == "object" && (i = i[0]);
  const a = we();
  if (Nr(a.flowchart.htmlLabels)) {
    i = i.replace(/\\n|\n/g, "<br />"), ie.debug("vertexText" + i);
    const s = await tk(ao(i)), o = {
      isNode: n,
      label: s,
      labelStyle: e.replace("fill:", "color:")
    };
    return JX(o, a);
  } else {
    const s = document.createElementNS("http://www.w3.org/2000/svg", "text");
    s.setAttribute("style", e.replace("color:", "fill:"));
    let o = [];
    typeof i == "string" ? o = i.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(i) ? o = i : o = [];
    for (const l of o) {
      const u = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      u.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), u.setAttribute("dy", "1em"), u.setAttribute("x", "0"), r ? u.setAttribute("class", "title-row") : u.setAttribute("class", "row"), u.textContent = l.trim(), s.appendChild(u);
    }
    return s;
  }
}, "createLabel"), qa = oFe, lFe = /* @__PURE__ */ x((t, e, r, n, i) => {
  e.arrowTypeStart && sI(t, "start", e.arrowTypeStart, r, n, i), e.arrowTypeEnd && sI(t, "end", e.arrowTypeEnd, r, n, i);
}, "addEdgeMarkers"), cFe = {
  arrow_cross: "cross",
  arrow_point: "point",
  arrow_barb: "barb",
  arrow_circle: "circle",
  aggregation: "aggregation",
  extension: "extension",
  composition: "composition",
  dependency: "dependency",
  lollipop: "lollipop"
}, sI = /* @__PURE__ */ x((t, e, r, n, i, a) => {
  const s = cFe[r];
  if (!s) {
    ie.warn(`Unknown arrow type: ${r}`);
    return;
  }
  const o = e === "start" ? "Start" : "End";
  t.attr(`marker-${e}`, `url(${n}#${i}_${a}-${s}${o})`);
}, "addEdgeMarker"), eE = {}, bi = {}, uFe = /* @__PURE__ */ x(async (t, e) => {
  const r = we(), n = Nr(r.flowchart.htmlLabels), i = e.labelType === "markdown" ? La(
    t,
    e.label,
    {
      style: e.labelStyle,
      useHtmlLabels: n,
      addSvgBackground: !0
    },
    r
  ) : await qa(e.label, e.labelStyle), a = t.insert("g").attr("class", "edgeLabel"), s = a.insert("g").attr("class", "label");
  s.node().appendChild(i);
  let o = i.getBBox();
  if (n) {
    const u = i.children[0], h = Qe(i);
    o = u.getBoundingClientRect(), h.attr("width", o.width), h.attr("height", o.height);
  }
  s.attr("transform", "translate(" + -o.width / 2 + ", " + -o.height / 2 + ")"), eE[e.id] = a, e.width = o.width, e.height = o.height;
  let l;
  if (e.startLabelLeft) {
    const u = await qa(e.startLabelLeft, e.labelStyle), h = t.insert("g").attr("class", "edgeTerminals"), d = h.insert("g").attr("class", "inner");
    l = d.node().appendChild(u);
    const f = u.getBBox();
    d.attr("transform", "translate(" + -f.width / 2 + ", " + -f.height / 2 + ")"), bi[e.id] || (bi[e.id] = {}), bi[e.id].startLeft = h, H0(l, e.startLabelLeft);
  }
  if (e.startLabelRight) {
    const u = await qa(e.startLabelRight, e.labelStyle), h = t.insert("g").attr("class", "edgeTerminals"), d = h.insert("g").attr("class", "inner");
    l = h.node().appendChild(u), d.node().appendChild(u);
    const f = u.getBBox();
    d.attr("transform", "translate(" + -f.width / 2 + ", " + -f.height / 2 + ")"), bi[e.id] || (bi[e.id] = {}), bi[e.id].startRight = h, H0(l, e.startLabelRight);
  }
  if (e.endLabelLeft) {
    const u = await qa(e.endLabelLeft, e.labelStyle), h = t.insert("g").attr("class", "edgeTerminals"), d = h.insert("g").attr("class", "inner");
    l = d.node().appendChild(u);
    const f = u.getBBox();
    d.attr("transform", "translate(" + -f.width / 2 + ", " + -f.height / 2 + ")"), h.node().appendChild(u), bi[e.id] || (bi[e.id] = {}), bi[e.id].endLeft = h, H0(l, e.endLabelLeft);
  }
  if (e.endLabelRight) {
    const u = await qa(e.endLabelRight, e.labelStyle), h = t.insert("g").attr("class", "edgeTerminals"), d = h.insert("g").attr("class", "inner");
    l = d.node().appendChild(u);
    const f = u.getBBox();
    d.attr("transform", "translate(" + -f.width / 2 + ", " + -f.height / 2 + ")"), h.node().appendChild(u), bi[e.id] || (bi[e.id] = {}), bi[e.id].endRight = h, H0(l, e.endLabelRight);
  }
  return i;
}, "insertEdgeLabel");
function H0(t, e) {
  we().flowchart.htmlLabels && t && (t.style.width = e.length * 9 + "px", t.style.height = "12px");
}
x(H0, "setTerminalWidth");
var hFe = /* @__PURE__ */ x((t, e) => {
  ie.debug("Moving label abc88 ", t.id, t.label, eE[t.id], e);
  let r = e.updatedPath ? e.updatedPath : e.originalPath;
  const n = we(), { subGraphTitleTotalMargin: i } = dg(n);
  if (t.label) {
    const a = eE[t.id];
    let s = t.x, o = t.y;
    if (r) {
      const l = Zt.calcLabelPosition(r);
      ie.debug(
        "Moving label " + t.label + " from (",
        s,
        ",",
        o,
        ") to (",
        l.x,
        ",",
        l.y,
        ") abc88"
      ), e.updatedPath && (s = l.x, o = l.y);
    }
    a.attr("transform", `translate(${s}, ${o + i / 2})`);
  }
  if (t.startLabelLeft) {
    const a = bi[t.id].startLeft;
    let s = t.x, o = t.y;
    if (r) {
      const l = Zt.calcTerminalLabelPosition(t.arrowTypeStart ? 10 : 0, "start_left", r);
      s = l.x, o = l.y;
    }
    a.attr("transform", `translate(${s}, ${o})`);
  }
  if (t.startLabelRight) {
    const a = bi[t.id].startRight;
    let s = t.x, o = t.y;
    if (r) {
      const l = Zt.calcTerminalLabelPosition(
        t.arrowTypeStart ? 10 : 0,
        "start_right",
        r
      );
      s = l.x, o = l.y;
    }
    a.attr("transform", `translate(${s}, ${o})`);
  }
  if (t.endLabelLeft) {
    const a = bi[t.id].endLeft;
    let s = t.x, o = t.y;
    if (r) {
      const l = Zt.calcTerminalLabelPosition(t.arrowTypeEnd ? 10 : 0, "end_left", r);
      s = l.x, o = l.y;
    }
    a.attr("transform", `translate(${s}, ${o})`);
  }
  if (t.endLabelRight) {
    const a = bi[t.id].endRight;
    let s = t.x, o = t.y;
    if (r) {
      const l = Zt.calcTerminalLabelPosition(t.arrowTypeEnd ? 10 : 0, "end_right", r);
      s = l.x, o = l.y;
    }
    a.attr("transform", `translate(${s}, ${o})`);
  }
}, "positionEdgeLabel"), dFe = /* @__PURE__ */ x((t, e) => {
  const r = t.x, n = t.y, i = Math.abs(e.x - r), a = Math.abs(e.y - n), s = t.width / 2, o = t.height / 2;
  return i >= s || a >= o;
}, "outsideNode"), fFe = /* @__PURE__ */ x((t, e, r) => {
  ie.debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(e)}
  insidePoint : ${JSON.stringify(r)}
  node        : x:${t.x} y:${t.y} w:${t.width} h:${t.height}`);
  const n = t.x, i = t.y, a = Math.abs(n - r.x), s = t.width / 2;
  let o = r.x < e.x ? s - a : s + a;
  const l = t.height / 2, u = Math.abs(e.y - r.y), h = Math.abs(e.x - r.x);
  if (Math.abs(i - e.y) * s > Math.abs(n - e.x) * l) {
    let d = r.y < e.y ? e.y - l - i : i - l - e.y;
    o = h * d / u;
    const f = {
      x: r.x < e.x ? r.x + o : r.x - h + o,
      y: r.y < e.y ? r.y + u - d : r.y - u + d
    };
    return o === 0 && (f.x = e.x, f.y = e.y), h === 0 && (f.x = e.x), u === 0 && (f.y = e.y), ie.debug(`abc89 topp/bott calc, Q ${u}, q ${d}, R ${h}, r ${o}`, f), f;
  } else {
    r.x < e.x ? o = e.x - s - n : o = n - s - e.x;
    let d = u * o / h, f = r.x < e.x ? r.x + h - o : r.x - h + o, p = r.y < e.y ? r.y + d : r.y - d;
    return ie.debug(`sides calc abc89, Q ${u}, q ${d}, R ${h}, r ${o}`, { _x: f, _y: p }), o === 0 && (f = e.x, p = e.y), h === 0 && (f = e.x), u === 0 && (p = e.y), { x: f, y: p };
  }
}, "intersection"), oI = /* @__PURE__ */ x((t, e) => {
  ie.debug("abc88 cutPathAtIntersect", t, e);
  let r = [], n = t[0], i = !1;
  return t.forEach((a) => {
    if (!dFe(e, a) && !i) {
      const s = fFe(e, n, a);
      let o = !1;
      r.forEach((l) => {
        o = o || l.x === s.x && l.y === s.y;
      }), r.some((l) => l.x === s.x && l.y === s.y) || r.push(s), i = !0;
    } else
      n = a, i || r.push(a);
  }), r;
}, "cutPathAtIntersect"), pFe = /* @__PURE__ */ x(function(t, e, r, n, i, a, s) {
  let o = r.points;
  ie.debug("abc88 InsertEdge: edge=", r, "e=", e);
  let l = !1;
  const u = a.node(e.v);
  var h = a.node(e.w);
  h?.intersect && u?.intersect && (o = o.slice(1, r.points.length - 1), o.unshift(u.intersect(o[0])), o.push(h.intersect(o[o.length - 1]))), r.toCluster && (ie.debug("to cluster abc88", n[r.toCluster]), o = oI(r.points, n[r.toCluster].node), l = !0), r.fromCluster && (ie.debug("from cluster abc88", n[r.fromCluster]), o = oI(o.reverse(), n[r.fromCluster].node).reverse(), l = !0);
  const d = o.filter((T) => !Number.isNaN(T.y));
  let f = jh;
  r.curve && (i === "graph" || i === "flowchart") && (f = r.curve);
  const { x: p, y: g } = $P(r), m = gp().x(p).y(g).curve(f);
  let v;
  switch (r.thickness) {
    case "normal":
      v = "edge-thickness-normal";
      break;
    case "thick":
      v = "edge-thickness-thick";
      break;
    case "invisible":
      v = "edge-thickness-thick";
      break;
    default:
      v = "";
  }
  switch (r.pattern) {
    case "solid":
      v += " edge-pattern-solid";
      break;
    case "dotted":
      v += " edge-pattern-dotted";
      break;
    case "dashed":
      v += " edge-pattern-dashed";
      break;
  }
  const y = t.append("path").attr("d", m(d)).attr("id", r.id).attr("class", " " + v + (r.classes ? " " + r.classes : "")).attr("style", r.style);
  let b = "";
  (we().flowchart.arrowMarkerAbsolute || we().state.arrowMarkerAbsolute) && (b = I2(!0)), lFe(y, r, b, s, i);
  let w = {};
  return l && (w.updatedPath = o), w.originalPath = r.points, w;
}, "insertEdge"), gFe = /* @__PURE__ */ x((t) => {
  const e = /* @__PURE__ */ new Set();
  for (const r of t)
    switch (r) {
      case "x":
        e.add("right"), e.add("left");
        break;
      case "y":
        e.add("up"), e.add("down");
        break;
      default:
        e.add(r);
        break;
    }
  return e;
}, "expandAndDeduplicateDirections"), mFe = /* @__PURE__ */ x((t, e, r) => {
  const n = gFe(t), i = 2, a = e.height + 2 * r.padding, s = a / i, o = e.width + 2 * s + r.padding, l = r.padding / 2;
  return n.has("right") && n.has("left") && n.has("up") && n.has("down") ? [
    // Bottom
    { x: 0, y: 0 },
    { x: s, y: 0 },
    { x: o / 2, y: 2 * l },
    { x: o - s, y: 0 },
    { x: o, y: 0 },
    // Right
    { x: o, y: -a / 3 },
    { x: o + 2 * l, y: -a / 2 },
    { x: o, y: -2 * a / 3 },
    { x: o, y: -a },
    // Top
    { x: o - s, y: -a },
    { x: o / 2, y: -a - 2 * l },
    { x: s, y: -a },
    // Left
    { x: 0, y: -a },
    { x: 0, y: -2 * a / 3 },
    { x: -2 * l, y: -a / 2 },
    { x: 0, y: -a / 3 }
  ] : n.has("right") && n.has("left") && n.has("up") ? [
    { x: s, y: 0 },
    { x: o - s, y: 0 },
    { x: o, y: -a / 2 },
    { x: o - s, y: -a },
    { x: s, y: -a },
    { x: 0, y: -a / 2 }
  ] : n.has("right") && n.has("left") && n.has("down") ? [
    { x: 0, y: 0 },
    { x: s, y: -a },
    { x: o - s, y: -a },
    { x: o, y: 0 }
  ] : n.has("right") && n.has("up") && n.has("down") ? [
    { x: 0, y: 0 },
    { x: o, y: -s },
    { x: o, y: -a + s },
    { x: 0, y: -a }
  ] : n.has("left") && n.has("up") && n.has("down") ? [
    { x: o, y: 0 },
    { x: 0, y: -s },
    { x: 0, y: -a + s },
    { x: o, y: -a }
  ] : n.has("right") && n.has("left") ? [
    { x: s, y: 0 },
    { x: s, y: -l },
    { x: o - s, y: -l },
    { x: o - s, y: 0 },
    { x: o, y: -a / 2 },
    { x: o - s, y: -a },
    { x: o - s, y: -a + l },
    { x: s, y: -a + l },
    { x: s, y: -a },
    { x: 0, y: -a / 2 }
  ] : n.has("up") && n.has("down") ? [
    // Bottom center
    { x: o / 2, y: 0 },
    // Left pont of bottom arrow
    { x: 0, y: -l },
    { x: s, y: -l },
    // Left top over vertical section
    { x: s, y: -a + l },
    { x: 0, y: -a + l },
    // Top of arrow
    { x: o / 2, y: -a },
    { x: o, y: -a + l },
    // Top of right vertical bar
    { x: o - s, y: -a + l },
    { x: o - s, y: -l },
    { x: o, y: -l }
  ] : n.has("right") && n.has("up") ? [
    { x: 0, y: 0 },
    { x: o, y: -s },
    { x: 0, y: -a }
  ] : n.has("right") && n.has("down") ? [
    { x: 0, y: 0 },
    { x: o, y: 0 },
    { x: 0, y: -a }
  ] : n.has("left") && n.has("up") ? [
    { x: o, y: 0 },
    { x: 0, y: -s },
    { x: o, y: -a }
  ] : n.has("left") && n.has("down") ? [
    { x: o, y: 0 },
    { x: 0, y: 0 },
    { x: o, y: -a }
  ] : n.has("right") ? [
    { x: s, y: -l },
    { x: s, y: -l },
    { x: o - s, y: -l },
    { x: o - s, y: 0 },
    { x: o, y: -a / 2 },
    { x: o - s, y: -a },
    { x: o - s, y: -a + l },
    // top left corner of arrow
    { x: s, y: -a + l },
    { x: s, y: -a + l }
  ] : n.has("left") ? [
    { x: s, y: 0 },
    { x: s, y: -l },
    // Two points, the right corners
    { x: o - s, y: -l },
    { x: o - s, y: -a + l },
    { x: s, y: -a + l },
    { x: s, y: -a },
    { x: 0, y: -a / 2 }
  ] : n.has("up") ? [
    // Bottom center
    { x: s, y: -l },
    // Left top over vertical section
    { x: s, y: -a + l },
    { x: 0, y: -a + l },
    // Top of arrow
    { x: o / 2, y: -a },
    { x: o, y: -a + l },
    // Top of right vertical bar
    { x: o - s, y: -a + l },
    { x: o - s, y: -l }
  ] : n.has("down") ? [
    // Bottom center
    { x: o / 2, y: 0 },
    // Left pont of bottom arrow
    { x: 0, y: -l },
    { x: s, y: -l },
    // Left top over vertical section
    { x: s, y: -a + l },
    { x: o - s, y: -a + l },
    { x: o - s, y: -l },
    { x: o, y: -l }
  ] : [{ x: 0, y: 0 }];
}, "getArrowPoints");
function ej(t, e) {
  return t.intersect(e);
}
x(ej, "intersectNode");
var vFe = ej;
function tj(t, e, r, n) {
  var i = t.x, a = t.y, s = i - n.x, o = a - n.y, l = Math.sqrt(e * e * o * o + r * r * s * s), u = Math.abs(e * r * s / l);
  n.x < i && (u = -u);
  var h = Math.abs(e * r * o / l);
  return n.y < a && (h = -h), { x: i + u, y: a + h };
}
x(tj, "intersectEllipse");
var rj = tj;
function nj(t, e, r) {
  return rj(t, e, e, r);
}
x(nj, "intersectCircle");
var yFe = nj;
function ij(t, e, r, n) {
  var i, a, s, o, l, u, h, d, f, p, g, m, v, y, b;
  if (i = e.y - t.y, s = t.x - e.x, l = e.x * t.y - t.x * e.y, f = i * r.x + s * r.y + l, p = i * n.x + s * n.y + l, !(f !== 0 && p !== 0 && tE(f, p)) && (a = n.y - r.y, o = r.x - n.x, u = n.x * r.y - r.x * n.y, h = a * t.x + o * t.y + u, d = a * e.x + o * e.y + u, !(h !== 0 && d !== 0 && tE(h, d)) && (g = i * o - a * s, g !== 0)))
    return m = Math.abs(g / 2), v = s * u - o * l, y = v < 0 ? (v - m) / g : (v + m) / g, v = a * l - i * u, b = v < 0 ? (v - m) / g : (v + m) / g, { x: y, y: b };
}
x(ij, "intersectLine");
function tE(t, e) {
  return t * e > 0;
}
x(tE, "sameSign");
var xFe = ij, bFe = aj;
function aj(t, e, r) {
  var n = t.x, i = t.y, a = [], s = Number.POSITIVE_INFINITY, o = Number.POSITIVE_INFINITY;
  typeof e.forEach == "function" ? e.forEach(function(g) {
    s = Math.min(s, g.x), o = Math.min(o, g.y);
  }) : (s = Math.min(s, e.x), o = Math.min(o, e.y));
  for (var l = n - t.width / 2 - s, u = i - t.height / 2 - o, h = 0; h < e.length; h++) {
    var d = e[h], f = e[h < e.length - 1 ? h + 1 : 0], p = xFe(
      t,
      r,
      { x: l + d.x, y: u + d.y },
      { x: l + f.x, y: u + f.y }
    );
    p && a.push(p);
  }
  return a.length ? (a.length > 1 && a.sort(function(g, m) {
    var v = g.x - r.x, y = g.y - r.y, b = Math.sqrt(v * v + y * y), w = m.x - r.x, T = m.y - r.y, E = Math.sqrt(w * w + T * T);
    return b < E ? -1 : b === E ? 0 : 1;
  }), a[0]) : t;
}
x(aj, "intersectPolygon");
var wFe = /* @__PURE__ */ x((t, e) => {
  var r = t.x, n = t.y, i = e.x - r, a = e.y - n, s = t.width / 2, o = t.height / 2, l, u;
  return Math.abs(a) * s > Math.abs(i) * o ? (a < 0 && (o = -o), l = a === 0 ? 0 : o * i / a, u = o) : (i < 0 && (s = -s), l = s, u = i === 0 ? 0 : s * a / i), { x: r + l, y: n + u };
}, "intersectRect"), TFe = wFe, Jr = {
  node: vFe,
  circle: yFe,
  ellipse: rj,
  polygon: bFe,
  rect: TFe
}, ei = /* @__PURE__ */ x(async (t, e, r, n) => {
  const i = we();
  let a;
  const s = e.useHtmlLabels || Nr(i.flowchart.htmlLabels);
  r ? a = r : a = "node default";
  const o = t.insert("g").attr("class", a).attr("id", e.domId || e.id), l = o.insert("g").attr("class", "label").attr("style", e.labelStyle);
  let u;
  e.labelText === void 0 ? u = "" : u = typeof e.labelText == "string" ? e.labelText : e.labelText[0];
  const h = l.node();
  let d;
  e.labelType === "markdown" ? d = La(
    l,
    dr(ao(u), i),
    {
      useHtmlLabels: s,
      width: e.width || i.flowchart.wrappingWidth,
      classes: "markdown-node-label"
    },
    i
  ) : d = h.appendChild(
    await qa(
      dr(ao(u), i),
      e.labelStyle,
      !1,
      n
    )
  );
  let f = d.getBBox();
  const p = e.padding / 2;
  if (Nr(i.flowchart.htmlLabels)) {
    const g = d.children[0], m = Qe(d), v = g.getElementsByTagName("img");
    if (v) {
      const y = u.replace(/<img[^>]*>/g, "").trim() === "";
      await Promise.all(
        [...v].map(
          (b) => new Promise((w) => {
            function T() {
              if (b.style.display = "flex", b.style.flexDirection = "column", y) {
                const E = i.fontSize ? i.fontSize : window.getComputedStyle(document.body).fontSize, k = parseInt(E, 10) * 5 + "px";
                b.style.minWidth = k, b.style.maxWidth = k;
              } else
                b.style.width = "100%";
              w(b);
            }
            x(T, "setupImage"), setTimeout(() => {
              b.complete && T();
            }), b.addEventListener("error", T), b.addEventListener("load", T);
          })
        )
      );
    }
    f = g.getBoundingClientRect(), m.attr("width", f.width), m.attr("height", f.height);
  }
  return s ? l.attr("transform", "translate(" + -f.width / 2 + ", " + -f.height / 2 + ")") : l.attr("transform", "translate(0, " + -f.height / 2 + ")"), e.centerLabel && l.attr("transform", "translate(" + -f.width / 2 + ", " + -f.height / 2 + ")"), l.insert("rect", ":first-child"), { shapeSvg: o, bbox: f, halfPadding: p, label: l };
}, "labelHelper"), dn = /* @__PURE__ */ x((t, e) => {
  const r = e.node().getBBox();
  t.width = r.width, t.height = r.height;
}, "updateNodeBounds");
function Is(t, e, r, n) {
  return t.insert("polygon", ":first-child").attr(
    "points",
    n.map(function(i) {
      return i.x + "," + i.y;
    }).join(" ")
  ).attr("class", "label-container").attr("transform", "translate(" + -e / 2 + "," + r / 2 + ")");
}
x(Is, "insertPolygonShape");
var EFe = /* @__PURE__ */ x(async (t, e) => {
  e.useHtmlLabels || we().flowchart.htmlLabels || (e.centerLabel = !0);
  const { shapeSvg: n, bbox: i, halfPadding: a } = await ei(
    t,
    e,
    "node " + e.classes,
    !0
  );
  ie.info("Classes = ", e.classes);
  const s = n.insert("rect", ":first-child");
  return s.attr("rx", e.rx).attr("ry", e.ry).attr("x", -i.width / 2 - a).attr("y", -i.height / 2 - a).attr("width", i.width + e.padding).attr("height", i.height + e.padding), dn(e, s), e.intersect = function(o) {
    return Jr.rect(e, o);
  }, n;
}, "note"), kFe = EFe, lI = /* @__PURE__ */ x((t) => t ? " " + t : "", "formatClass"), Da = /* @__PURE__ */ x((t, e) => `${e || "node default"}${lI(t.classes)} ${lI(
  t.class
)}`, "getClassesFromNode"), cI = /* @__PURE__ */ x(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ei(
    t,
    e,
    Da(e, void 0),
    !0
  ), i = n.width + e.padding, a = n.height + e.padding, s = i + a, o = [
    { x: s / 2, y: 0 },
    { x: s, y: -s / 2 },
    { x: s / 2, y: -s },
    { x: 0, y: -s / 2 }
  ];
  ie.info("Question main (Circle)");
  const l = Is(r, s, s, o);
  return l.attr("style", e.style), dn(e, l), e.intersect = function(u) {
    return ie.warn("Intersect called"), Jr.polygon(e, o, u);
  }, r;
}, "question"), SFe = /* @__PURE__ */ x((t, e) => {
  const r = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id), n = 28, i = [
    { x: 0, y: n / 2 },
    { x: n / 2, y: 0 },
    { x: 0, y: -n / 2 },
    { x: -n / 2, y: 0 }
  ];
  return r.insert("polygon", ":first-child").attr(
    "points",
    i.map(function(s) {
      return s.x + "," + s.y;
    }).join(" ")
  ).attr("class", "state-start").attr("r", 7).attr("width", 28).attr("height", 28), e.width = 28, e.height = 28, e.intersect = function(s) {
    return Jr.circle(e, 14, s);
  }, r;
}, "choice"), CFe = /* @__PURE__ */ x(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ei(
    t,
    e,
    Da(e, void 0),
    !0
  ), i = 4, a = n.height + e.padding, s = a / i, o = n.width + 2 * s + e.padding, l = [
    { x: s, y: 0 },
    { x: o - s, y: 0 },
    { x: o, y: -a / 2 },
    { x: o - s, y: -a },
    { x: s, y: -a },
    { x: 0, y: -a / 2 }
  ], u = Is(r, o, a, l);
  return u.attr("style", e.style), dn(e, u), e.intersect = function(h) {
    return Jr.polygon(e, l, h);
  }, r;
}, "hexagon"), AFe = /* @__PURE__ */ x(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ei(t, e, void 0, !0), i = 2, a = n.height + 2 * e.padding, s = a / i, o = n.width + 2 * s + e.padding, l = mFe(e.directions, n, e), u = Is(r, o, a, l);
  return u.attr("style", e.style), dn(e, u), e.intersect = function(h) {
    return Jr.polygon(e, l, h);
  }, r;
}, "block_arrow"), _Fe = /* @__PURE__ */ x(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ei(
    t,
    e,
    Da(e, void 0),
    !0
  ), i = n.width + e.padding, a = n.height + e.padding, s = [
    { x: -a / 2, y: 0 },
    { x: i, y: 0 },
    { x: i, y: -a },
    { x: -a / 2, y: -a },
    { x: 0, y: -a / 2 }
  ];
  return Is(r, i, a, s).attr("style", e.style), e.width = i + a, e.height = a, e.intersect = function(l) {
    return Jr.polygon(e, s, l);
  }, r;
}, "rect_left_inv_arrow"), LFe = /* @__PURE__ */ x(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ei(t, e, Da(e), !0), i = n.width + e.padding, a = n.height + e.padding, s = [
    { x: -2 * a / 6, y: 0 },
    { x: i - a / 6, y: 0 },
    { x: i + 2 * a / 6, y: -a },
    { x: a / 6, y: -a }
  ], o = Is(r, i, a, s);
  return o.attr("style", e.style), dn(e, o), e.intersect = function(l) {
    return Jr.polygon(e, s, l);
  }, r;
}, "lean_right"), RFe = /* @__PURE__ */ x(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ei(
    t,
    e,
    Da(e, void 0),
    !0
  ), i = n.width + e.padding, a = n.height + e.padding, s = [
    { x: 2 * a / 6, y: 0 },
    { x: i + a / 6, y: 0 },
    { x: i - 2 * a / 6, y: -a },
    { x: -a / 6, y: -a }
  ], o = Is(r, i, a, s);
  return o.attr("style", e.style), dn(e, o), e.intersect = function(l) {
    return Jr.polygon(e, s, l);
  }, r;
}, "lean_left"), MFe = /* @__PURE__ */ x(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ei(
    t,
    e,
    Da(e, void 0),
    !0
  ), i = n.width + e.padding, a = n.height + e.padding, s = [
    { x: -2 * a / 6, y: 0 },
    { x: i + 2 * a / 6, y: 0 },
    { x: i - a / 6, y: -a },
    { x: a / 6, y: -a }
  ], o = Is(r, i, a, s);
  return o.attr("style", e.style), dn(e, o), e.intersect = function(l) {
    return Jr.polygon(e, s, l);
  }, r;
}, "trapezoid"), NFe = /* @__PURE__ */ x(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ei(
    t,
    e,
    Da(e, void 0),
    !0
  ), i = n.width + e.padding, a = n.height + e.padding, s = [
    { x: a / 6, y: 0 },
    { x: i - a / 6, y: 0 },
    { x: i + 2 * a / 6, y: -a },
    { x: -2 * a / 6, y: -a }
  ], o = Is(r, i, a, s);
  return o.attr("style", e.style), dn(e, o), e.intersect = function(l) {
    return Jr.polygon(e, s, l);
  }, r;
}, "inv_trapezoid"), IFe = /* @__PURE__ */ x(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ei(
    t,
    e,
    Da(e, void 0),
    !0
  ), i = n.width + e.padding, a = n.height + e.padding, s = [
    { x: 0, y: 0 },
    { x: i + a / 2, y: 0 },
    { x: i, y: -a / 2 },
    { x: i + a / 2, y: -a },
    { x: 0, y: -a }
  ], o = Is(r, i, a, s);
  return o.attr("style", e.style), dn(e, o), e.intersect = function(l) {
    return Jr.polygon(e, s, l);
  }, r;
}, "rect_right_inv_arrow"), DFe = /* @__PURE__ */ x(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ei(
    t,
    e,
    Da(e, void 0),
    !0
  ), i = n.width + e.padding, a = i / 2, s = a / (2.5 + i / 50), o = n.height + s + e.padding, l = "M 0," + s + " a " + a + "," + s + " 0,0,0 " + i + " 0 a " + a + "," + s + " 0,0,0 " + -i + " 0 l 0," + o + " a " + a + "," + s + " 0,0,0 " + i + " 0 l 0," + -o, u = r.attr("label-offset-y", s).insert("path", ":first-child").attr("style", e.style).attr("d", l).attr("transform", "translate(" + -i / 2 + "," + -(o / 2 + s) + ")");
  return dn(e, u), e.intersect = function(h) {
    const d = Jr.rect(e, h), f = d.x - e.x;
    if (a != 0 && (Math.abs(f) < e.width / 2 || Math.abs(f) == e.width / 2 && Math.abs(d.y - e.y) > e.height / 2 - s)) {
      let p = s * s * (1 - f * f / (a * a));
      p != 0 && (p = Math.sqrt(p)), p = s - p, h.y - e.y > 0 && (p = -p), d.y += p;
    }
    return d;
  }, r;
}, "cylinder"), OFe = /* @__PURE__ */ x(async (t, e) => {
  const { shapeSvg: r, bbox: n, halfPadding: i } = await ei(
    t,
    e,
    "node " + e.classes + " " + e.class,
    !0
  ), a = r.insert("rect", ":first-child"), s = e.positioned ? e.width : n.width + e.padding, o = e.positioned ? e.height : n.height + e.padding, l = e.positioned ? -s / 2 : -n.width / 2 - i, u = e.positioned ? -o / 2 : -n.height / 2 - i;
  if (a.attr("class", "basic label-container").attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("x", l).attr("y", u).attr("width", s).attr("height", o), e.props) {
    const h = new Set(Object.keys(e.props));
    e.props.borders && (Cb(a, e.props.borders, s, o), h.delete("borders")), h.forEach((d) => {
      ie.warn(`Unknown node property ${d}`);
    });
  }
  return dn(e, a), e.intersect = function(h) {
    return Jr.rect(e, h);
  }, r;
}, "rect"), PFe = /* @__PURE__ */ x(async (t, e) => {
  const { shapeSvg: r, bbox: n, halfPadding: i } = await ei(
    t,
    e,
    "node " + e.classes,
    !0
  ), a = r.insert("rect", ":first-child"), s = e.positioned ? e.width : n.width + e.padding, o = e.positioned ? e.height : n.height + e.padding, l = e.positioned ? -s / 2 : -n.width / 2 - i, u = e.positioned ? -o / 2 : -n.height / 2 - i;
  if (a.attr("class", "basic cluster composite label-container").attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("x", l).attr("y", u).attr("width", s).attr("height", o), e.props) {
    const h = new Set(Object.keys(e.props));
    e.props.borders && (Cb(a, e.props.borders, s, o), h.delete("borders")), h.forEach((d) => {
      ie.warn(`Unknown node property ${d}`);
    });
  }
  return dn(e, a), e.intersect = function(h) {
    return Jr.rect(e, h);
  }, r;
}, "composite"), BFe = /* @__PURE__ */ x(async (t, e) => {
  const { shapeSvg: r } = await ei(t, e, "label", !0);
  ie.trace("Classes = ", e.class);
  const n = r.insert("rect", ":first-child"), i = 0, a = 0;
  if (n.attr("width", i).attr("height", a), r.attr("class", "label edgeLabel"), e.props) {
    const s = new Set(Object.keys(e.props));
    e.props.borders && (Cb(n, e.props.borders, i, a), s.delete("borders")), s.forEach((o) => {
      ie.warn(`Unknown node property ${o}`);
    });
  }
  return dn(e, n), e.intersect = function(s) {
    return Jr.rect(e, s);
  }, r;
}, "labelRect");
function Cb(t, e, r, n) {
  const i = [], a = /* @__PURE__ */ x((o) => {
    i.push(o, 0);
  }, "addBorder"), s = /* @__PURE__ */ x((o) => {
    i.push(0, o);
  }, "skipBorder");
  e.includes("t") ? (ie.debug("add top border"), a(r)) : s(r), e.includes("r") ? (ie.debug("add right border"), a(n)) : s(n), e.includes("b") ? (ie.debug("add bottom border"), a(r)) : s(r), e.includes("l") ? (ie.debug("add left border"), a(n)) : s(n), t.attr("stroke-dasharray", i.join(" "));
}
x(Cb, "applyNodePropertyBorders");
var FFe = /* @__PURE__ */ x(async (t, e) => {
  let r;
  e.classes ? r = "node " + e.classes : r = "node default";
  const n = t.insert("g").attr("class", r).attr("id", e.domId || e.id), i = n.insert("rect", ":first-child"), a = n.insert("line"), s = n.insert("g").attr("class", "label"), o = e.labelText.flat ? e.labelText.flat() : e.labelText;
  let l = "";
  typeof o == "object" ? l = o[0] : l = o, ie.info("Label text abc79", l, o, typeof o == "object");
  const u = s.node().appendChild(await qa(l, e.labelStyle, !0, !0));
  let h = { width: 0, height: 0 };
  if (Nr(we().flowchart.htmlLabels)) {
    const m = u.children[0], v = Qe(u);
    h = m.getBoundingClientRect(), v.attr("width", h.width), v.attr("height", h.height);
  }
  ie.info("Text 2", o);
  const d = o.slice(1, o.length);
  let f = u.getBBox();
  const p = s.node().appendChild(
    await qa(
      d.join ? d.join("<br/>") : d,
      e.labelStyle,
      !0,
      !0
    )
  );
  if (Nr(we().flowchart.htmlLabels)) {
    const m = p.children[0], v = Qe(p);
    h = m.getBoundingClientRect(), v.attr("width", h.width), v.attr("height", h.height);
  }
  const g = e.padding / 2;
  return Qe(p).attr(
    "transform",
    "translate( " + // (titleBox.width - bbox.width) / 2 +
    (h.width > f.width ? 0 : (f.width - h.width) / 2) + ", " + (f.height + g + 5) + ")"
  ), Qe(u).attr(
    "transform",
    "translate( " + // (titleBox.width - bbox.width) / 2 +
    (h.width < f.width ? 0 : -(f.width - h.width) / 2) + ", 0)"
  ), h = s.node().getBBox(), s.attr(
    "transform",
    "translate(" + -h.width / 2 + ", " + (-h.height / 2 - g + 3) + ")"
  ), i.attr("class", "outer title-state").attr("x", -h.width / 2 - g).attr("y", -h.height / 2 - g).attr("width", h.width + e.padding).attr("height", h.height + e.padding), a.attr("class", "divider").attr("x1", -h.width / 2 - g).attr("x2", h.width / 2 + g).attr("y1", -h.height / 2 - g + f.height + g).attr("y2", -h.height / 2 - g + f.height + g), dn(e, i), e.intersect = function(m) {
    return Jr.rect(e, m);
  }, n;
}, "rectWithTitle"), $Fe = /* @__PURE__ */ x(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ei(
    t,
    e,
    Da(e, void 0),
    !0
  ), i = n.height + e.padding, a = n.width + i / 4 + e.padding, s = r.insert("rect", ":first-child").attr("style", e.style).attr("rx", i / 2).attr("ry", i / 2).attr("x", -a / 2).attr("y", -i / 2).attr("width", a).attr("height", i);
  return dn(e, s), e.intersect = function(o) {
    return Jr.rect(e, o);
  }, r;
}, "stadium"), zFe = /* @__PURE__ */ x(async (t, e) => {
  const { shapeSvg: r, bbox: n, halfPadding: i } = await ei(
    t,
    e,
    Da(e, void 0),
    !0
  ), a = r.insert("circle", ":first-child");
  return a.attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("r", n.width / 2 + i).attr("width", n.width + e.padding).attr("height", n.height + e.padding), ie.info("Circle main"), dn(e, a), e.intersect = function(s) {
    return ie.info("Circle intersect", e, n.width / 2 + i, s), Jr.circle(e, n.width / 2 + i, s);
  }, r;
}, "circle"), GFe = /* @__PURE__ */ x(async (t, e) => {
  const { shapeSvg: r, bbox: n, halfPadding: i } = await ei(
    t,
    e,
    Da(e, void 0),
    !0
  ), a = 5, s = r.insert("g", ":first-child"), o = s.insert("circle"), l = s.insert("circle");
  return s.attr("class", e.class), o.attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("r", n.width / 2 + i + a).attr("width", n.width + e.padding + a * 2).attr("height", n.height + e.padding + a * 2), l.attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("r", n.width / 2 + i).attr("width", n.width + e.padding).attr("height", n.height + e.padding), ie.info("DoubleCircle main"), dn(e, o), e.intersect = function(u) {
    return ie.info("DoubleCircle intersect", e, n.width / 2 + i + a, u), Jr.circle(e, n.width / 2 + i + a, u);
  }, r;
}, "doublecircle"), VFe = /* @__PURE__ */ x(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ei(
    t,
    e,
    Da(e, void 0),
    !0
  ), i = n.width + e.padding, a = n.height + e.padding, s = [
    { x: 0, y: 0 },
    { x: i, y: 0 },
    { x: i, y: -a },
    { x: 0, y: -a },
    { x: 0, y: 0 },
    { x: -8, y: 0 },
    { x: i + 8, y: 0 },
    { x: i + 8, y: -a },
    { x: -8, y: -a },
    { x: -8, y: 0 }
  ], o = Is(r, i, a, s);
  return o.attr("style", e.style), dn(e, o), e.intersect = function(l) {
    return Jr.polygon(e, s, l);
  }, r;
}, "subroutine"), UFe = /* @__PURE__ */ x((t, e) => {
  const r = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id), n = r.insert("circle", ":first-child");
  return n.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14), dn(e, n), e.intersect = function(i) {
    return Jr.circle(e, 7, i);
  }, r;
}, "start"), uI = /* @__PURE__ */ x((t, e, r) => {
  const n = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id);
  let i = 70, a = 10;
  r === "LR" && (i = 10, a = 70);
  const s = n.append("rect").attr("x", -1 * i / 2).attr("y", -1 * a / 2).attr("width", i).attr("height", a).attr("class", "fork-join");
  return dn(e, s), e.height = e.height + e.padding / 2, e.width = e.width + e.padding / 2, e.intersect = function(o) {
    return Jr.rect(e, o);
  }, n;
}, "forkJoin"), HFe = /* @__PURE__ */ x((t, e) => {
  const r = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id), n = r.insert("circle", ":first-child"), i = r.insert("circle", ":first-child");
  return i.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14), n.attr("class", "state-end").attr("r", 5).attr("width", 10).attr("height", 10), dn(e, i), e.intersect = function(a) {
    return Jr.circle(e, 7, a);
  }, r;
}, "end"), qFe = /* @__PURE__ */ x(async (t, e) => {
  const r = e.padding / 2, n = 4, i = 8;
  let a;
  e.classes ? a = "node " + e.classes : a = "node default";
  const s = t.insert("g").attr("class", a).attr("id", e.domId || e.id), o = s.insert("rect", ":first-child"), l = s.insert("line"), u = s.insert("line");
  let h = 0, d = n;
  const f = s.insert("g").attr("class", "label");
  let p = 0;
  const g = e.classData.annotations?.[0], m = e.classData.annotations[0] ? "" + e.classData.annotations[0] + "" : "", v = f.node().appendChild(await qa(m, e.labelStyle, !0, !0));
  let y = v.getBBox();
  if (Nr(we().flowchart.htmlLabels)) {
    const C = v.children[0], A = Qe(v);
    y = C.getBoundingClientRect(), A.attr("width", y.width), A.attr("height", y.height);
  }
  e.classData.annotations[0] && (d += y.height + n, h += y.width);
  let b = e.classData.label;
  e.classData.type !== void 0 && e.classData.type !== "" && (we().flowchart.htmlLabels ? b += "&lt;" + e.classData.type + "&gt;" : b += "<" + e.classData.type + ">");
  const w = f.node().appendChild(await qa(b, e.labelStyle, !0, !0));
  Qe(w).attr("class", "classTitle");
  let T = w.getBBox();
  if (Nr(we().flowchart.htmlLabels)) {
    const C = w.children[0], A = Qe(w);
    T = C.getBoundingClientRect(), A.attr("width", T.width), A.attr("height", T.height);
  }
  d += T.height + n, T.width > h && (h = T.width);
  const E = [];
  e.classData.members.forEach(async (C) => {
    const A = C.getDisplayDetails();
    let R = A.displayText;
    we().flowchart.htmlLabels && (R = R.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
    const _ = f.node().appendChild(
      await qa(
        R,
        A.cssStyle ? A.cssStyle : e.labelStyle,
        !0,
        !0
      )
    );
    let O = _.getBBox();
    if (Nr(we().flowchart.htmlLabels)) {
      const P = _.children[0], S = Qe(_);
      O = P.getBoundingClientRect(), S.attr("width", O.width), S.attr("height", O.height);
    }
    O.width > h && (h = O.width), d += O.height + n, E.push(_);
  }), d += i;
  const L = [];
  if (e.classData.methods.forEach(async (C) => {
    const A = C.getDisplayDetails();
    let R = A.displayText;
    we().flowchart.htmlLabels && (R = R.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
    const _ = f.node().appendChild(
      await qa(
        R,
        A.cssStyle ? A.cssStyle : e.labelStyle,
        !0,
        !0
      )
    );
    let O = _.getBBox();
    if (Nr(we().flowchart.htmlLabels)) {
      const P = _.children[0], S = Qe(_);
      O = P.getBoundingClientRect(), S.attr("width", O.width), S.attr("height", O.height);
    }
    O.width > h && (h = O.width), d += O.height + n, L.push(_);
  }), d += i, g) {
    let C = (h - y.width) / 2;
    Qe(v).attr(
      "transform",
      "translate( " + (-1 * h / 2 + C) + ", " + -1 * d / 2 + ")"
    ), p = y.height + n;
  }
  let k = (h - T.width) / 2;
  return Qe(w).attr(
    "transform",
    "translate( " + (-1 * h / 2 + k) + ", " + (-1 * d / 2 + p) + ")"
  ), p += T.height + n, l.attr("class", "divider").attr("x1", -h / 2 - r).attr("x2", h / 2 + r).attr("y1", -d / 2 - r + i + p).attr("y2", -d / 2 - r + i + p), p += i, E.forEach((C) => {
    Qe(C).attr(
      "transform",
      "translate( " + -h / 2 + ", " + (-1 * d / 2 + p + i / 2) + ")"
    );
    const A = C?.getBBox();
    p += (A?.height ?? 0) + n;
  }), p += i, u.attr("class", "divider").attr("x1", -h / 2 - r).attr("x2", h / 2 + r).attr("y1", -d / 2 - r + i + p).attr("y2", -d / 2 - r + i + p), p += i, L.forEach((C) => {
    Qe(C).attr(
      "transform",
      "translate( " + -h / 2 + ", " + (-1 * d / 2 + p) + ")"
    );
    const A = C?.getBBox();
    p += (A?.height ?? 0) + n;
  }), o.attr("style", e.style).attr("class", "outer title-state").attr("x", -h / 2 - r).attr("y", -(d / 2) - r).attr("width", h + e.padding).attr("height", d + e.padding), dn(e, o), e.intersect = function(C) {
    return Jr.rect(e, C);
  }, s;
}, "class_box"), hI = {
  rhombus: cI,
  composite: PFe,
  question: cI,
  rect: OFe,
  labelRect: BFe,
  rectWithTitle: FFe,
  choice: SFe,
  circle: zFe,
  doublecircle: GFe,
  stadium: $Fe,
  hexagon: CFe,
  block_arrow: AFe,
  rect_left_inv_arrow: _Fe,
  lean_right: LFe,
  lean_left: RFe,
  trapezoid: MFe,
  inv_trapezoid: NFe,
  rect_right_inv_arrow: IFe,
  cylinder: DFe,
  start: UFe,
  end: HFe,
  note: kFe,
  subroutine: VFe,
  fork: uI,
  join: uI,
  class_box: qFe
}, bv = {}, sj = /* @__PURE__ */ x(async (t, e, r) => {
  let n, i;
  if (e.link) {
    let a;
    we().securityLevel === "sandbox" ? a = "_top" : e.linkTarget && (a = e.linkTarget || "_blank"), n = t.insert("svg:a").attr("xlink:href", e.link).attr("target", a), i = await hI[e.shape](n, e, r);
  } else
    i = await hI[e.shape](t, e, r), n = i;
  return e.tooltip && i.attr("title", e.tooltip), e.class && i.attr("class", "node default " + e.class), bv[e.id] = n, e.haveCallback && bv[e.id].attr("class", bv[e.id].attr("class") + " clickable"), n;
}, "insertNode"), WFe = /* @__PURE__ */ x((t) => {
  const e = bv[t.id];
  ie.trace(
    "Transforming node",
    t.diff,
    t,
    "translate(" + (t.x - t.width / 2 - 5) + ", " + t.width / 2 + ")"
  );
  const r = 8, n = t.diff || 0;
  return t.clusterNode ? e.attr(
    "transform",
    "translate(" + (t.x + n - t.width / 2) + ", " + (t.y - t.height / 2 - r) + ")"
  ) : e.attr("transform", "translate(" + t.x + ", " + t.y + ")"), n;
}, "positionNode");
function q7(t, e, r = !1) {
  const n = t;
  let i = "default";
  (n?.classes?.length || 0) > 0 && (i = (n?.classes ?? []).join(" ")), i = i + " flowchart-label";
  let a = 0, s = "", o;
  switch (n.type) {
    case "round":
      a = 5, s = "rect";
      break;
    case "composite":
      a = 0, s = "composite", o = 0;
      break;
    case "square":
      s = "rect";
      break;
    case "diamond":
      s = "question";
      break;
    case "hexagon":
      s = "hexagon";
      break;
    case "block_arrow":
      s = "block_arrow";
      break;
    case "odd":
      s = "rect_left_inv_arrow";
      break;
    case "lean_right":
      s = "lean_right";
      break;
    case "lean_left":
      s = "lean_left";
      break;
    case "trapezoid":
      s = "trapezoid";
      break;
    case "inv_trapezoid":
      s = "inv_trapezoid";
      break;
    case "rect_left_inv_arrow":
      s = "rect_left_inv_arrow";
      break;
    case "circle":
      s = "circle";
      break;
    case "ellipse":
      s = "ellipse";
      break;
    case "stadium":
      s = "stadium";
      break;
    case "subroutine":
      s = "subroutine";
      break;
    case "cylinder":
      s = "cylinder";
      break;
    case "group":
      s = "rect";
      break;
    case "doublecircle":
      s = "doublecircle";
      break;
    default:
      s = "rect";
  }
  const l = VE(n?.styles ?? []), u = n.label, h = n.size ?? { width: 0, height: 0, x: 0, y: 0 };
  return {
    labelStyle: l.labelStyle,
    shape: s,
    labelText: u,
    rx: a,
    ry: a,
    class: i,
    style: l.style,
    id: n.id,
    directions: n.directions,
    width: h.width,
    height: h.height,
    x: h.x,
    y: h.y,
    positioned: r,
    intersect: void 0,
    type: n.type,
    padding: o ?? pr()?.block?.padding ?? 0
  };
}
x(q7, "getNodeFromBlock");
async function oj(t, e, r) {
  const n = q7(e, r, !1);
  if (n.type === "group")
    return;
  const i = pr(), a = await sj(t, n, { config: i }), s = a.node().getBBox(), o = r.getBlock(n.id);
  o.size = { width: s.width, height: s.height, x: 0, y: 0, node: a }, r.setBlock(o), a.remove();
}
x(oj, "calculateBlockSize");
async function lj(t, e, r) {
  const n = q7(e, r, !0);
  if (r.getBlock(n.id).type !== "space") {
    const a = pr();
    await sj(t, n, { config: a }), e.intersect = n?.intersect, WFe(n);
  }
}
x(lj, "insertBlockPositioned");
async function Ab(t, e, r, n) {
  for (const i of e)
    await n(t, i, r), i.children && await Ab(t, i.children, r, n);
}
x(Ab, "performOperations");
async function cj(t, e, r) {
  await Ab(t, e, r, oj);
}
x(cj, "calculateBlockSizes");
async function uj(t, e, r) {
  await Ab(t, e, r, lj);
}
x(uj, "insertBlocks");
async function hj(t, e, r, n, i) {
  const a = new fa({
    multigraph: !0,
    compound: !0
  });
  a.setGraph({
    rankdir: "TB",
    nodesep: 10,
    ranksep: 10,
    marginx: 8,
    marginy: 8
  });
  for (const s of r)
    s.size && a.setNode(s.id, {
      width: s.size.width,
      height: s.size.height,
      intersect: s.intersect
    });
  for (const s of e)
    if (s.start && s.end) {
      const o = n.getBlock(s.start), l = n.getBlock(s.end);
      if (o?.size && l?.size) {
        const u = o.size, h = l.size, d = [
          { x: u.x, y: u.y },
          { x: u.x + (h.x - u.x) / 2, y: u.y + (h.y - u.y) / 2 },
          { x: h.x, y: h.y }
        ];
        pFe(
          t,
          { v: s.start, w: s.end, name: s.id },
          {
            ...s,
            arrowTypeEnd: s.arrowTypeEnd,
            arrowTypeStart: s.arrowTypeStart,
            points: d,
            classes: "edge-thickness-normal edge-pattern-solid flowchart-link LS-a1 LE-b1"
          },
          void 0,
          "block",
          a,
          i
        ), s.label && (await uFe(t, {
          ...s,
          label: s.label,
          labelStyle: "stroke: #333; stroke-width: 1.5px;fill:none;",
          arrowTypeEnd: s.arrowTypeEnd,
          arrowTypeStart: s.arrowTypeStart,
          points: d,
          classes: "edge-thickness-normal edge-pattern-solid flowchart-link LS-a1 LE-b1"
        }), hFe(
          { ...s, x: d[1].x, y: d[1].y },
          {
            originalPath: d
          }
        ));
      }
    }
}
x(hj, "insertEdges");
var YFe = /* @__PURE__ */ x(function(t, e) {
  return e.db.getClasses();
}, "getClasses"), XFe = /* @__PURE__ */ x(async function(t, e, r, n) {
  const { securityLevel: i, block: a } = pr(), s = n.db;
  let o;
  i === "sandbox" && (o = Qe("#i" + e));
  const l = Qe(i === "sandbox" ? o.nodes()[0].contentDocument.body : "body"), u = i === "sandbox" ? l.select(`[id="${e}"]`) : Qe(`[id="${e}"]`);
  aFe(u, ["point", "circle", "cross"], n.type, e);
  const d = s.getBlocks(), f = s.getBlocksFlat(), p = s.getEdges(), g = u.insert("g").attr("class", "block");
  await cj(g, d, s);
  const m = QX(s);
  if (await uj(g, d, s), await hj(g, p, f, s, e), m) {
    const v = m, y = Math.max(1, Math.round(0.125 * (v.width / v.height))), b = v.height + y + 10, w = v.width + 10, { useMaxWidth: T } = a;
    Xi(u, b, w, !!T), ie.debug("Here Bounds", m, v), u.attr(
      "viewBox",
      `${v.x - 5} ${v.y - 5} ${v.width + 10} ${v.height + 10}`
    );
  }
}, "draw"), jFe = {
  draw: XFe,
  getClasses: YFe
}, KFe = {
  parser: CBe,
  db: qBe,
  renderer: jFe,
  styles: YBe
};
const ZFe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: KFe
}, Symbol.toStringTag, { value: "Module" }));
var wv = { exports: {} }, Tv = { exports: {} }, Ev = { exports: {} }, QFe = Ev.exports, dI;
function JFe() {
  return dI || (dI = 1, (function(t, e) {
    (function(n, i) {
      t.exports = i();
    })(QFe, function() {
      return (
        /******/
        (function(r) {
          var n = {};
          function i(a) {
            if (n[a])
              return n[a].exports;
            var s = n[a] = {
              /******/
              i: a,
              /******/
              l: !1,
              /******/
              exports: {}
              /******/
            };
            return r[a].call(s.exports, s, s.exports, i), s.l = !0, s.exports;
          }
          return i.m = r, i.c = n, i.i = function(a) {
            return a;
          }, i.d = function(a, s, o) {
            i.o(a, s) || Object.defineProperty(a, s, {
              /******/
              configurable: !1,
              /******/
              enumerable: !0,
              /******/
              get: o
              /******/
            });
          }, i.n = function(a) {
            var s = a && a.__esModule ? (
              /******/
              function() {
                return a.default;
              }
            ) : (
              /******/
              function() {
                return a;
              }
            );
            return i.d(s, "a", s), s;
          }, i.o = function(a, s) {
            return Object.prototype.hasOwnProperty.call(a, s);
          }, i.p = "", i(i.s = 28);
        })([
          /* 0 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.QUALITY = 1, a.DEFAULT_CREATE_BENDS_AS_NEEDED = !1, a.DEFAULT_INCREMENTAL = !1, a.DEFAULT_ANIMATION_ON_LAYOUT = !0, a.DEFAULT_ANIMATION_DURING_LAYOUT = !1, a.DEFAULT_ANIMATION_PERIOD = 50, a.DEFAULT_UNIFORM_LEAF_NODE_SIZES = !1, a.DEFAULT_GRAPH_MARGIN = 15, a.NODE_DIMENSIONS_INCLUDE_LABELS = !1, a.SIMPLE_NODE_SIZE = 40, a.SIMPLE_NODE_HALF_SIZE = a.SIMPLE_NODE_SIZE / 2, a.EMPTY_COMPOUND_NODE_SIZE = 40, a.MIN_EDGE_LENGTH = 1, a.WORLD_BOUNDARY = 1e6, a.INITIAL_WORLD_BOUNDARY = a.WORLD_BOUNDARY / 1e3, a.WORLD_CENTER_X = 1200, a.WORLD_CENTER_Y = 900, r.exports = a;
          }),
          /* 1 */
          /***/
          (function(r, n, i) {
            var a = i(2), s = i(8), o = i(9);
            function l(h, d, f) {
              a.call(this, f), this.isOverlapingSourceAndTarget = !1, this.vGraphObject = f, this.bendpoints = [], this.source = h, this.target = d;
            }
            l.prototype = Object.create(a.prototype);
            for (var u in a)
              l[u] = a[u];
            l.prototype.getSource = function() {
              return this.source;
            }, l.prototype.getTarget = function() {
              return this.target;
            }, l.prototype.isInterGraph = function() {
              return this.isInterGraph;
            }, l.prototype.getLength = function() {
              return this.length;
            }, l.prototype.isOverlapingSourceAndTarget = function() {
              return this.isOverlapingSourceAndTarget;
            }, l.prototype.getBendpoints = function() {
              return this.bendpoints;
            }, l.prototype.getLca = function() {
              return this.lca;
            }, l.prototype.getSourceInLca = function() {
              return this.sourceInLca;
            }, l.prototype.getTargetInLca = function() {
              return this.targetInLca;
            }, l.prototype.getOtherEnd = function(h) {
              if (this.source === h)
                return this.target;
              if (this.target === h)
                return this.source;
              throw "Node is not incident with this edge";
            }, l.prototype.getOtherEndInGraph = function(h, d) {
              for (var f = this.getOtherEnd(h), p = d.getGraphManager().getRoot(); ; ) {
                if (f.getOwner() == d)
                  return f;
                if (f.getOwner() == p)
                  break;
                f = f.getOwner().getParent();
              }
              return null;
            }, l.prototype.updateLength = function() {
              var h = new Array(4);
              this.isOverlapingSourceAndTarget = s.getIntersection(this.target.getRect(), this.source.getRect(), h), this.isOverlapingSourceAndTarget || (this.lengthX = h[0] - h[2], this.lengthY = h[1] - h[3], Math.abs(this.lengthX) < 1 && (this.lengthX = o.sign(this.lengthX)), Math.abs(this.lengthY) < 1 && (this.lengthY = o.sign(this.lengthY)), this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY));
            }, l.prototype.updateLengthSimple = function() {
              this.lengthX = this.target.getCenterX() - this.source.getCenterX(), this.lengthY = this.target.getCenterY() - this.source.getCenterY(), Math.abs(this.lengthX) < 1 && (this.lengthX = o.sign(this.lengthX)), Math.abs(this.lengthY) < 1 && (this.lengthY = o.sign(this.lengthY)), this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);
            }, r.exports = l;
          }),
          /* 2 */
          /***/
          (function(r, n, i) {
            function a(s) {
              this.vGraphObject = s;
            }
            r.exports = a;
          }),
          /* 3 */
          /***/
          (function(r, n, i) {
            var a = i(2), s = i(10), o = i(13), l = i(0), u = i(16), h = i(5);
            function d(p, g, m, v) {
              m == null && v == null && (v = g), a.call(this, v), p.graphManager != null && (p = p.graphManager), this.estimatedSize = s.MIN_VALUE, this.inclusionTreeDepth = s.MAX_VALUE, this.vGraphObject = v, this.edges = [], this.graphManager = p, m != null && g != null ? this.rect = new o(g.x, g.y, m.width, m.height) : this.rect = new o();
            }
            d.prototype = Object.create(a.prototype);
            for (var f in a)
              d[f] = a[f];
            d.prototype.getEdges = function() {
              return this.edges;
            }, d.prototype.getChild = function() {
              return this.child;
            }, d.prototype.getOwner = function() {
              return this.owner;
            }, d.prototype.getWidth = function() {
              return this.rect.width;
            }, d.prototype.setWidth = function(p) {
              this.rect.width = p;
            }, d.prototype.getHeight = function() {
              return this.rect.height;
            }, d.prototype.setHeight = function(p) {
              this.rect.height = p;
            }, d.prototype.getCenterX = function() {
              return this.rect.x + this.rect.width / 2;
            }, d.prototype.getCenterY = function() {
              return this.rect.y + this.rect.height / 2;
            }, d.prototype.getCenter = function() {
              return new h(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);
            }, d.prototype.getLocation = function() {
              return new h(this.rect.x, this.rect.y);
            }, d.prototype.getRect = function() {
              return this.rect;
            }, d.prototype.getDiagonal = function() {
              return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);
            }, d.prototype.getHalfTheDiagonal = function() {
              return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;
            }, d.prototype.setRect = function(p, g) {
              this.rect.x = p.x, this.rect.y = p.y, this.rect.width = g.width, this.rect.height = g.height;
            }, d.prototype.setCenter = function(p, g) {
              this.rect.x = p - this.rect.width / 2, this.rect.y = g - this.rect.height / 2;
            }, d.prototype.setLocation = function(p, g) {
              this.rect.x = p, this.rect.y = g;
            }, d.prototype.moveBy = function(p, g) {
              this.rect.x += p, this.rect.y += g;
            }, d.prototype.getEdgeListToNode = function(p) {
              var g = [], m = this;
              return m.edges.forEach(function(v) {
                if (v.target == p) {
                  if (v.source != m) throw "Incorrect edge source!";
                  g.push(v);
                }
              }), g;
            }, d.prototype.getEdgesBetween = function(p) {
              var g = [], m = this;
              return m.edges.forEach(function(v) {
                if (!(v.source == m || v.target == m)) throw "Incorrect edge source and/or target";
                (v.target == p || v.source == p) && g.push(v);
              }), g;
            }, d.prototype.getNeighborsList = function() {
              var p = /* @__PURE__ */ new Set(), g = this;
              return g.edges.forEach(function(m) {
                if (m.source == g)
                  p.add(m.target);
                else {
                  if (m.target != g)
                    throw "Incorrect incidency!";
                  p.add(m.source);
                }
              }), p;
            }, d.prototype.withChildren = function() {
              var p = /* @__PURE__ */ new Set(), g, m;
              if (p.add(this), this.child != null)
                for (var v = this.child.getNodes(), y = 0; y < v.length; y++)
                  g = v[y], m = g.withChildren(), m.forEach(function(b) {
                    p.add(b);
                  });
              return p;
            }, d.prototype.getNoOfChildren = function() {
              var p = 0, g;
              if (this.child == null)
                p = 1;
              else
                for (var m = this.child.getNodes(), v = 0; v < m.length; v++)
                  g = m[v], p += g.getNoOfChildren();
              return p == 0 && (p = 1), p;
            }, d.prototype.getEstimatedSize = function() {
              if (this.estimatedSize == s.MIN_VALUE)
                throw "assert failed";
              return this.estimatedSize;
            }, d.prototype.calcEstimatedSize = function() {
              return this.child == null ? this.estimatedSize = (this.rect.width + this.rect.height) / 2 : (this.estimatedSize = this.child.calcEstimatedSize(), this.rect.width = this.estimatedSize, this.rect.height = this.estimatedSize, this.estimatedSize);
            }, d.prototype.scatter = function() {
              var p, g, m = -l.INITIAL_WORLD_BOUNDARY, v = l.INITIAL_WORLD_BOUNDARY;
              p = l.WORLD_CENTER_X + u.nextDouble() * (v - m) + m;
              var y = -l.INITIAL_WORLD_BOUNDARY, b = l.INITIAL_WORLD_BOUNDARY;
              g = l.WORLD_CENTER_Y + u.nextDouble() * (b - y) + y, this.rect.x = p, this.rect.y = g;
            }, d.prototype.updateBounds = function() {
              if (this.getChild() == null)
                throw "assert failed";
              if (this.getChild().getNodes().length != 0) {
                var p = this.getChild();
                if (p.updateBounds(!0), this.rect.x = p.getLeft(), this.rect.y = p.getTop(), this.setWidth(p.getRight() - p.getLeft()), this.setHeight(p.getBottom() - p.getTop()), l.NODE_DIMENSIONS_INCLUDE_LABELS) {
                  var g = p.getRight() - p.getLeft(), m = p.getBottom() - p.getTop();
                  this.labelWidth && (this.labelPosHorizontal == "left" ? (this.rect.x -= this.labelWidth, this.setWidth(g + this.labelWidth)) : this.labelPosHorizontal == "center" && this.labelWidth > g ? (this.rect.x -= (this.labelWidth - g) / 2, this.setWidth(this.labelWidth)) : this.labelPosHorizontal == "right" && this.setWidth(g + this.labelWidth)), this.labelHeight && (this.labelPosVertical == "top" ? (this.rect.y -= this.labelHeight, this.setHeight(m + this.labelHeight)) : this.labelPosVertical == "center" && this.labelHeight > m ? (this.rect.y -= (this.labelHeight - m) / 2, this.setHeight(this.labelHeight)) : this.labelPosVertical == "bottom" && this.setHeight(m + this.labelHeight));
                }
              }
            }, d.prototype.getInclusionTreeDepth = function() {
              if (this.inclusionTreeDepth == s.MAX_VALUE)
                throw "assert failed";
              return this.inclusionTreeDepth;
            }, d.prototype.transform = function(p) {
              var g = this.rect.x;
              g > l.WORLD_BOUNDARY ? g = l.WORLD_BOUNDARY : g < -l.WORLD_BOUNDARY && (g = -l.WORLD_BOUNDARY);
              var m = this.rect.y;
              m > l.WORLD_BOUNDARY ? m = l.WORLD_BOUNDARY : m < -l.WORLD_BOUNDARY && (m = -l.WORLD_BOUNDARY);
              var v = new h(g, m), y = p.inverseTransformPoint(v);
              this.setLocation(y.x, y.y);
            }, d.prototype.getLeft = function() {
              return this.rect.x;
            }, d.prototype.getRight = function() {
              return this.rect.x + this.rect.width;
            }, d.prototype.getTop = function() {
              return this.rect.y;
            }, d.prototype.getBottom = function() {
              return this.rect.y + this.rect.height;
            }, d.prototype.getParent = function() {
              return this.owner == null ? null : this.owner.getParent();
            }, r.exports = d;
          }),
          /* 4 */
          /***/
          (function(r, n, i) {
            var a = i(0);
            function s() {
            }
            for (var o in a)
              s[o] = a[o];
            s.MAX_ITERATIONS = 2500, s.DEFAULT_EDGE_LENGTH = 50, s.DEFAULT_SPRING_STRENGTH = 0.45, s.DEFAULT_REPULSION_STRENGTH = 4500, s.DEFAULT_GRAVITY_STRENGTH = 0.4, s.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1, s.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8, s.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5, s.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = !0, s.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = !0, s.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3, s.COOLING_ADAPTATION_FACTOR = 0.33, s.ADAPTATION_LOWER_NODE_LIMIT = 1e3, s.ADAPTATION_UPPER_NODE_LIMIT = 5e3, s.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100, s.MAX_NODE_DISPLACEMENT = s.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3, s.MIN_REPULSION_DIST = s.DEFAULT_EDGE_LENGTH / 10, s.CONVERGENCE_CHECK_PERIOD = 100, s.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1, s.MIN_EDGE_LENGTH = 1, s.GRID_CALCULATION_CHECK_PERIOD = 10, r.exports = s;
          }),
          /* 5 */
          /***/
          (function(r, n, i) {
            function a(s, o) {
              s == null && o == null ? (this.x = 0, this.y = 0) : (this.x = s, this.y = o);
            }
            a.prototype.getX = function() {
              return this.x;
            }, a.prototype.getY = function() {
              return this.y;
            }, a.prototype.setX = function(s) {
              this.x = s;
            }, a.prototype.setY = function(s) {
              this.y = s;
            }, a.prototype.getDifference = function(s) {
              return new DimensionD(this.x - s.x, this.y - s.y);
            }, a.prototype.getCopy = function() {
              return new a(this.x, this.y);
            }, a.prototype.translate = function(s) {
              return this.x += s.width, this.y += s.height, this;
            }, r.exports = a;
          }),
          /* 6 */
          /***/
          (function(r, n, i) {
            var a = i(2), s = i(10), o = i(0), l = i(7), u = i(3), h = i(1), d = i(13), f = i(12), p = i(11);
            function g(v, y, b) {
              a.call(this, b), this.estimatedSize = s.MIN_VALUE, this.margin = o.DEFAULT_GRAPH_MARGIN, this.edges = [], this.nodes = [], this.isConnected = !1, this.parent = v, y != null && y instanceof l ? this.graphManager = y : y != null && y instanceof Layout && (this.graphManager = y.graphManager);
            }
            g.prototype = Object.create(a.prototype);
            for (var m in a)
              g[m] = a[m];
            g.prototype.getNodes = function() {
              return this.nodes;
            }, g.prototype.getEdges = function() {
              return this.edges;
            }, g.prototype.getGraphManager = function() {
              return this.graphManager;
            }, g.prototype.getParent = function() {
              return this.parent;
            }, g.prototype.getLeft = function() {
              return this.left;
            }, g.prototype.getRight = function() {
              return this.right;
            }, g.prototype.getTop = function() {
              return this.top;
            }, g.prototype.getBottom = function() {
              return this.bottom;
            }, g.prototype.isConnected = function() {
              return this.isConnected;
            }, g.prototype.add = function(v, y, b) {
              if (y == null && b == null) {
                var w = v;
                if (this.graphManager == null)
                  throw "Graph has no graph mgr!";
                if (this.getNodes().indexOf(w) > -1)
                  throw "Node already in graph!";
                return w.owner = this, this.getNodes().push(w), w;
              } else {
                var T = v;
                if (!(this.getNodes().indexOf(y) > -1 && this.getNodes().indexOf(b) > -1))
                  throw "Source or target not in graph!";
                if (!(y.owner == b.owner && y.owner == this))
                  throw "Both owners must be this graph!";
                return y.owner != b.owner ? null : (T.source = y, T.target = b, T.isInterGraph = !1, this.getEdges().push(T), y.edges.push(T), b != y && b.edges.push(T), T);
              }
            }, g.prototype.remove = function(v) {
              var y = v;
              if (v instanceof u) {
                if (y == null)
                  throw "Node is null!";
                if (!(y.owner != null && y.owner == this))
                  throw "Owner graph is invalid!";
                if (this.graphManager == null)
                  throw "Owner graph manager is invalid!";
                for (var b = y.edges.slice(), w, T = b.length, E = 0; E < T; E++)
                  w = b[E], w.isInterGraph ? this.graphManager.remove(w) : w.source.owner.remove(w);
                var L = this.nodes.indexOf(y);
                if (L == -1)
                  throw "Node not in owner node list!";
                this.nodes.splice(L, 1);
              } else if (v instanceof h) {
                var w = v;
                if (w == null)
                  throw "Edge is null!";
                if (!(w.source != null && w.target != null))
                  throw "Source and/or target is null!";
                if (!(w.source.owner != null && w.target.owner != null && w.source.owner == this && w.target.owner == this))
                  throw "Source and/or target owner is invalid!";
                var k = w.source.edges.indexOf(w), C = w.target.edges.indexOf(w);
                if (!(k > -1 && C > -1))
                  throw "Source and/or target doesn't know this edge!";
                w.source.edges.splice(k, 1), w.target != w.source && w.target.edges.splice(C, 1);
                var L = w.source.owner.getEdges().indexOf(w);
                if (L == -1)
                  throw "Not in owner's edge list!";
                w.source.owner.getEdges().splice(L, 1);
              }
            }, g.prototype.updateLeftTop = function() {
              for (var v = s.MAX_VALUE, y = s.MAX_VALUE, b, w, T, E = this.getNodes(), L = E.length, k = 0; k < L; k++) {
                var C = E[k];
                b = C.getTop(), w = C.getLeft(), v > b && (v = b), y > w && (y = w);
              }
              return v == s.MAX_VALUE ? null : (E[0].getParent().paddingLeft != null ? T = E[0].getParent().paddingLeft : T = this.margin, this.left = y - T, this.top = v - T, new f(this.left, this.top));
            }, g.prototype.updateBounds = function(v) {
              for (var y = s.MAX_VALUE, b = -s.MAX_VALUE, w = s.MAX_VALUE, T = -s.MAX_VALUE, E, L, k, C, A, R = this.nodes, _ = R.length, O = 0; O < _; O++) {
                var P = R[O];
                v && P.child != null && P.updateBounds(), E = P.getLeft(), L = P.getRight(), k = P.getTop(), C = P.getBottom(), y > E && (y = E), b < L && (b = L), w > k && (w = k), T < C && (T = C);
              }
              var S = new d(y, w, b - y, T - w);
              y == s.MAX_VALUE && (this.left = this.parent.getLeft(), this.right = this.parent.getRight(), this.top = this.parent.getTop(), this.bottom = this.parent.getBottom()), R[0].getParent().paddingLeft != null ? A = R[0].getParent().paddingLeft : A = this.margin, this.left = S.x - A, this.right = S.x + S.width + A, this.top = S.y - A, this.bottom = S.y + S.height + A;
            }, g.calculateBounds = function(v) {
              for (var y = s.MAX_VALUE, b = -s.MAX_VALUE, w = s.MAX_VALUE, T = -s.MAX_VALUE, E, L, k, C, A = v.length, R = 0; R < A; R++) {
                var _ = v[R];
                E = _.getLeft(), L = _.getRight(), k = _.getTop(), C = _.getBottom(), y > E && (y = E), b < L && (b = L), w > k && (w = k), T < C && (T = C);
              }
              var O = new d(y, w, b - y, T - w);
              return O;
            }, g.prototype.getInclusionTreeDepth = function() {
              return this == this.graphManager.getRoot() ? 1 : this.parent.getInclusionTreeDepth();
            }, g.prototype.getEstimatedSize = function() {
              if (this.estimatedSize == s.MIN_VALUE)
                throw "assert failed";
              return this.estimatedSize;
            }, g.prototype.calcEstimatedSize = function() {
              for (var v = 0, y = this.nodes, b = y.length, w = 0; w < b; w++) {
                var T = y[w];
                v += T.calcEstimatedSize();
              }
              return v == 0 ? this.estimatedSize = o.EMPTY_COMPOUND_NODE_SIZE : this.estimatedSize = v / Math.sqrt(this.nodes.length), this.estimatedSize;
            }, g.prototype.updateConnected = function() {
              var v = this;
              if (this.nodes.length == 0) {
                this.isConnected = !0;
                return;
              }
              var y = new p(), b = /* @__PURE__ */ new Set(), w = this.nodes[0], T, E, L = w.withChildren();
              for (L.forEach(function(O) {
                y.push(O), b.add(O);
              }); y.length !== 0; ) {
                w = y.shift(), T = w.getEdges();
                for (var k = T.length, C = 0; C < k; C++) {
                  var A = T[C];
                  if (E = A.getOtherEndInGraph(w, this), E != null && !b.has(E)) {
                    var R = E.withChildren();
                    R.forEach(function(O) {
                      y.push(O), b.add(O);
                    });
                  }
                }
              }
              if (this.isConnected = !1, b.size >= this.nodes.length) {
                var _ = 0;
                b.forEach(function(O) {
                  O.owner == v && _++;
                }), _ == this.nodes.length && (this.isConnected = !0);
              }
            }, r.exports = g;
          }),
          /* 7 */
          /***/
          (function(r, n, i) {
            var a, s = i(1);
            function o(l) {
              a = i(6), this.layout = l, this.graphs = [], this.edges = [];
            }
            o.prototype.addRoot = function() {
              var l = this.layout.newGraph(), u = this.layout.newNode(null), h = this.add(l, u);
              return this.setRootGraph(h), this.rootGraph;
            }, o.prototype.add = function(l, u, h, d, f) {
              if (h == null && d == null && f == null) {
                if (l == null)
                  throw "Graph is null!";
                if (u == null)
                  throw "Parent node is null!";
                if (this.graphs.indexOf(l) > -1)
                  throw "Graph already in this graph mgr!";
                if (this.graphs.push(l), l.parent != null)
                  throw "Already has a parent!";
                if (u.child != null)
                  throw "Already has a child!";
                return l.parent = u, u.child = l, l;
              } else {
                f = h, d = u, h = l;
                var p = d.getOwner(), g = f.getOwner();
                if (!(p != null && p.getGraphManager() == this))
                  throw "Source not in this graph mgr!";
                if (!(g != null && g.getGraphManager() == this))
                  throw "Target not in this graph mgr!";
                if (p == g)
                  return h.isInterGraph = !1, p.add(h, d, f);
                if (h.isInterGraph = !0, h.source = d, h.target = f, this.edges.indexOf(h) > -1)
                  throw "Edge already in inter-graph edge list!";
                if (this.edges.push(h), !(h.source != null && h.target != null))
                  throw "Edge source and/or target is null!";
                if (!(h.source.edges.indexOf(h) == -1 && h.target.edges.indexOf(h) == -1))
                  throw "Edge already in source and/or target incidency list!";
                return h.source.edges.push(h), h.target.edges.push(h), h;
              }
            }, o.prototype.remove = function(l) {
              if (l instanceof a) {
                var u = l;
                if (u.getGraphManager() != this)
                  throw "Graph not in this graph mgr";
                if (!(u == this.rootGraph || u.parent != null && u.parent.graphManager == this))
                  throw "Invalid parent node!";
                var h = [];
                h = h.concat(u.getEdges());
                for (var d, f = h.length, p = 0; p < f; p++)
                  d = h[p], u.remove(d);
                var g = [];
                g = g.concat(u.getNodes());
                var m;
                f = g.length;
                for (var p = 0; p < f; p++)
                  m = g[p], u.remove(m);
                u == this.rootGraph && this.setRootGraph(null);
                var v = this.graphs.indexOf(u);
                this.graphs.splice(v, 1), u.parent = null;
              } else if (l instanceof s) {
                if (d = l, d == null)
                  throw "Edge is null!";
                if (!d.isInterGraph)
                  throw "Not an inter-graph edge!";
                if (!(d.source != null && d.target != null))
                  throw "Source and/or target is null!";
                if (!(d.source.edges.indexOf(d) != -1 && d.target.edges.indexOf(d) != -1))
                  throw "Source and/or target doesn't know this edge!";
                var v = d.source.edges.indexOf(d);
                if (d.source.edges.splice(v, 1), v = d.target.edges.indexOf(d), d.target.edges.splice(v, 1), !(d.source.owner != null && d.source.owner.getGraphManager() != null))
                  throw "Edge owner graph or owner graph manager is null!";
                if (d.source.owner.getGraphManager().edges.indexOf(d) == -1)
                  throw "Not in owner graph manager's edge list!";
                var v = d.source.owner.getGraphManager().edges.indexOf(d);
                d.source.owner.getGraphManager().edges.splice(v, 1);
              }
            }, o.prototype.updateBounds = function() {
              this.rootGraph.updateBounds(!0);
            }, o.prototype.getGraphs = function() {
              return this.graphs;
            }, o.prototype.getAllNodes = function() {
              if (this.allNodes == null) {
                for (var l = [], u = this.getGraphs(), h = u.length, d = 0; d < h; d++)
                  l = l.concat(u[d].getNodes());
                this.allNodes = l;
              }
              return this.allNodes;
            }, o.prototype.resetAllNodes = function() {
              this.allNodes = null;
            }, o.prototype.resetAllEdges = function() {
              this.allEdges = null;
            }, o.prototype.resetAllNodesToApplyGravitation = function() {
              this.allNodesToApplyGravitation = null;
            }, o.prototype.getAllEdges = function() {
              if (this.allEdges == null) {
                var l = [], u = this.getGraphs();
                u.length;
                for (var h = 0; h < u.length; h++)
                  l = l.concat(u[h].getEdges());
                l = l.concat(this.edges), this.allEdges = l;
              }
              return this.allEdges;
            }, o.prototype.getAllNodesToApplyGravitation = function() {
              return this.allNodesToApplyGravitation;
            }, o.prototype.setAllNodesToApplyGravitation = function(l) {
              if (this.allNodesToApplyGravitation != null)
                throw "assert failed";
              this.allNodesToApplyGravitation = l;
            }, o.prototype.getRoot = function() {
              return this.rootGraph;
            }, o.prototype.setRootGraph = function(l) {
              if (l.getGraphManager() != this)
                throw "Root not in this graph mgr!";
              this.rootGraph = l, l.parent == null && (l.parent = this.layout.newNode("Root node"));
            }, o.prototype.getLayout = function() {
              return this.layout;
            }, o.prototype.isOneAncestorOfOther = function(l, u) {
              if (!(l != null && u != null))
                throw "assert failed";
              if (l == u)
                return !0;
              var h = l.getOwner(), d;
              do {
                if (d = h.getParent(), d == null)
                  break;
                if (d == u)
                  return !0;
                if (h = d.getOwner(), h == null)
                  break;
              } while (!0);
              h = u.getOwner();
              do {
                if (d = h.getParent(), d == null)
                  break;
                if (d == l)
                  return !0;
                if (h = d.getOwner(), h == null)
                  break;
              } while (!0);
              return !1;
            }, o.prototype.calcLowestCommonAncestors = function() {
              for (var l, u, h, d, f, p = this.getAllEdges(), g = p.length, m = 0; m < g; m++) {
                if (l = p[m], u = l.source, h = l.target, l.lca = null, l.sourceInLca = u, l.targetInLca = h, u == h) {
                  l.lca = u.getOwner();
                  continue;
                }
                for (d = u.getOwner(); l.lca == null; ) {
                  for (l.targetInLca = h, f = h.getOwner(); l.lca == null; ) {
                    if (f == d) {
                      l.lca = f;
                      break;
                    }
                    if (f == this.rootGraph)
                      break;
                    if (l.lca != null)
                      throw "assert failed";
                    l.targetInLca = f.getParent(), f = l.targetInLca.getOwner();
                  }
                  if (d == this.rootGraph)
                    break;
                  l.lca == null && (l.sourceInLca = d.getParent(), d = l.sourceInLca.getOwner());
                }
                if (l.lca == null)
                  throw "assert failed";
              }
            }, o.prototype.calcLowestCommonAncestor = function(l, u) {
              if (l == u)
                return l.getOwner();
              var h = l.getOwner();
              do {
                if (h == null)
                  break;
                var d = u.getOwner();
                do {
                  if (d == null)
                    break;
                  if (d == h)
                    return d;
                  d = d.getParent().getOwner();
                } while (!0);
                h = h.getParent().getOwner();
              } while (!0);
              return h;
            }, o.prototype.calcInclusionTreeDepths = function(l, u) {
              l == null && u == null && (l = this.rootGraph, u = 1);
              for (var h, d = l.getNodes(), f = d.length, p = 0; p < f; p++)
                h = d[p], h.inclusionTreeDepth = u, h.child != null && this.calcInclusionTreeDepths(h.child, u + 1);
            }, o.prototype.includesInvalidEdge = function() {
              for (var l, u = [], h = this.edges.length, d = 0; d < h; d++)
                l = this.edges[d], this.isOneAncestorOfOther(l.source, l.target) && u.push(l);
              for (var d = 0; d < u.length; d++)
                this.remove(u[d]);
              return !1;
            }, r.exports = o;
          }),
          /* 8 */
          /***/
          (function(r, n, i) {
            var a = i(12);
            function s() {
            }
            s.calcSeparationAmount = function(o, l, u, h) {
              if (!o.intersects(l))
                throw "assert failed";
              var d = new Array(2);
              this.decideDirectionsForOverlappingNodes(o, l, d), u[0] = Math.min(o.getRight(), l.getRight()) - Math.max(o.x, l.x), u[1] = Math.min(o.getBottom(), l.getBottom()) - Math.max(o.y, l.y), o.getX() <= l.getX() && o.getRight() >= l.getRight() ? u[0] += Math.min(l.getX() - o.getX(), o.getRight() - l.getRight()) : l.getX() <= o.getX() && l.getRight() >= o.getRight() && (u[0] += Math.min(o.getX() - l.getX(), l.getRight() - o.getRight())), o.getY() <= l.getY() && o.getBottom() >= l.getBottom() ? u[1] += Math.min(l.getY() - o.getY(), o.getBottom() - l.getBottom()) : l.getY() <= o.getY() && l.getBottom() >= o.getBottom() && (u[1] += Math.min(o.getY() - l.getY(), l.getBottom() - o.getBottom()));
              var f = Math.abs((l.getCenterY() - o.getCenterY()) / (l.getCenterX() - o.getCenterX()));
              l.getCenterY() === o.getCenterY() && l.getCenterX() === o.getCenterX() && (f = 1);
              var p = f * u[0], g = u[1] / f;
              u[0] < g ? g = u[0] : p = u[1], u[0] = -1 * d[0] * (g / 2 + h), u[1] = -1 * d[1] * (p / 2 + h);
            }, s.decideDirectionsForOverlappingNodes = function(o, l, u) {
              o.getCenterX() < l.getCenterX() ? u[0] = -1 : u[0] = 1, o.getCenterY() < l.getCenterY() ? u[1] = -1 : u[1] = 1;
            }, s.getIntersection2 = function(o, l, u) {
              var h = o.getCenterX(), d = o.getCenterY(), f = l.getCenterX(), p = l.getCenterY();
              if (o.intersects(l))
                return u[0] = h, u[1] = d, u[2] = f, u[3] = p, !0;
              var g = o.getX(), m = o.getY(), v = o.getRight(), y = o.getX(), b = o.getBottom(), w = o.getRight(), T = o.getWidthHalf(), E = o.getHeightHalf(), L = l.getX(), k = l.getY(), C = l.getRight(), A = l.getX(), R = l.getBottom(), _ = l.getRight(), O = l.getWidthHalf(), P = l.getHeightHalf(), S = !1, M = !1;
              if (h === f) {
                if (d > p)
                  return u[0] = h, u[1] = m, u[2] = f, u[3] = R, !1;
                if (d < p)
                  return u[0] = h, u[1] = b, u[2] = f, u[3] = k, !1;
              } else if (d === p) {
                if (h > f)
                  return u[0] = g, u[1] = d, u[2] = C, u[3] = p, !1;
                if (h < f)
                  return u[0] = v, u[1] = d, u[2] = L, u[3] = p, !1;
              } else {
                var N = o.height / o.width, D = l.height / l.width, I = (p - d) / (f - h), B = void 0, z = void 0, F = void 0, V = void 0, H = void 0, J = void 0;
                if (-N === I ? h > f ? (u[0] = y, u[1] = b, S = !0) : (u[0] = v, u[1] = m, S = !0) : N === I && (h > f ? (u[0] = g, u[1] = m, S = !0) : (u[0] = w, u[1] = b, S = !0)), -D === I ? f > h ? (u[2] = A, u[3] = R, M = !0) : (u[2] = C, u[3] = k, M = !0) : D === I && (f > h ? (u[2] = L, u[3] = k, M = !0) : (u[2] = _, u[3] = R, M = !0)), S && M)
                  return !1;
                if (h > f ? d > p ? (B = this.getCardinalDirection(N, I, 4), z = this.getCardinalDirection(D, I, 2)) : (B = this.getCardinalDirection(-N, I, 3), z = this.getCardinalDirection(-D, I, 1)) : d > p ? (B = this.getCardinalDirection(-N, I, 1), z = this.getCardinalDirection(-D, I, 3)) : (B = this.getCardinalDirection(N, I, 2), z = this.getCardinalDirection(D, I, 4)), !S)
                  switch (B) {
                    case 1:
                      V = m, F = h + -E / I, u[0] = F, u[1] = V;
                      break;
                    case 2:
                      F = w, V = d + T * I, u[0] = F, u[1] = V;
                      break;
                    case 3:
                      V = b, F = h + E / I, u[0] = F, u[1] = V;
                      break;
                    case 4:
                      F = y, V = d + -T * I, u[0] = F, u[1] = V;
                      break;
                  }
                if (!M)
                  switch (z) {
                    case 1:
                      J = k, H = f + -P / I, u[2] = H, u[3] = J;
                      break;
                    case 2:
                      H = _, J = p + O * I, u[2] = H, u[3] = J;
                      break;
                    case 3:
                      J = R, H = f + P / I, u[2] = H, u[3] = J;
                      break;
                    case 4:
                      H = A, J = p + -O * I, u[2] = H, u[3] = J;
                      break;
                  }
              }
              return !1;
            }, s.getCardinalDirection = function(o, l, u) {
              return o > l ? u : 1 + u % 4;
            }, s.getIntersection = function(o, l, u, h) {
              if (h == null)
                return this.getIntersection2(o, l, u);
              var d = o.x, f = o.y, p = l.x, g = l.y, m = u.x, v = u.y, y = h.x, b = h.y, w = void 0, T = void 0, E = void 0, L = void 0, k = void 0, C = void 0, A = void 0, R = void 0, _ = void 0;
              return E = g - f, k = d - p, A = p * f - d * g, L = b - v, C = m - y, R = y * v - m * b, _ = E * C - L * k, _ === 0 ? null : (w = (k * R - C * A) / _, T = (L * A - E * R) / _, new a(w, T));
            }, s.angleOfVector = function(o, l, u, h) {
              var d = void 0;
              return o !== u ? (d = Math.atan((h - l) / (u - o)), u < o ? d += Math.PI : h < l && (d += this.TWO_PI)) : h < l ? d = this.ONE_AND_HALF_PI : d = this.HALF_PI, d;
            }, s.doIntersect = function(o, l, u, h) {
              var d = o.x, f = o.y, p = l.x, g = l.y, m = u.x, v = u.y, y = h.x, b = h.y, w = (p - d) * (b - v) - (y - m) * (g - f);
              if (w === 0)
                return !1;
              var T = ((b - v) * (y - d) + (m - y) * (b - f)) / w, E = ((f - g) * (y - d) + (p - d) * (b - f)) / w;
              return 0 < T && T < 1 && 0 < E && E < 1;
            }, s.findCircleLineIntersections = function(o, l, u, h, d, f, p) {
              var g = (u - o) * (u - o) + (h - l) * (h - l), m = 2 * ((o - d) * (u - o) + (l - f) * (h - l)), v = (o - d) * (o - d) + (l - f) * (l - f) - p * p, y = m * m - 4 * g * v;
              if (y >= 0) {
                var b = (-m + Math.sqrt(m * m - 4 * g * v)) / (2 * g), w = (-m - Math.sqrt(m * m - 4 * g * v)) / (2 * g), T = null;
                return b >= 0 && b <= 1 ? [b] : w >= 0 && w <= 1 ? [w] : T;
              } else return null;
            }, s.HALF_PI = 0.5 * Math.PI, s.ONE_AND_HALF_PI = 1.5 * Math.PI, s.TWO_PI = 2 * Math.PI, s.THREE_PI = 3 * Math.PI, r.exports = s;
          }),
          /* 9 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.sign = function(s) {
              return s > 0 ? 1 : s < 0 ? -1 : 0;
            }, a.floor = function(s) {
              return s < 0 ? Math.ceil(s) : Math.floor(s);
            }, a.ceil = function(s) {
              return s < 0 ? Math.floor(s) : Math.ceil(s);
            }, r.exports = a;
          }),
          /* 10 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.MAX_VALUE = 2147483647, a.MIN_VALUE = -2147483648, r.exports = a;
          }),
          /* 11 */
          /***/
          (function(r, n, i) {
            var a = /* @__PURE__ */ (function() {
              function d(f, p) {
                for (var g = 0; g < p.length; g++) {
                  var m = p[g];
                  m.enumerable = m.enumerable || !1, m.configurable = !0, "value" in m && (m.writable = !0), Object.defineProperty(f, m.key, m);
                }
              }
              return function(f, p, g) {
                return p && d(f.prototype, p), g && d(f, g), f;
              };
            })();
            function s(d, f) {
              if (!(d instanceof f))
                throw new TypeError("Cannot call a class as a function");
            }
            var o = function(f) {
              return { value: f, next: null, prev: null };
            }, l = function(f, p, g, m) {
              return f !== null ? f.next = p : m.head = p, g !== null ? g.prev = p : m.tail = p, p.prev = f, p.next = g, m.length++, p;
            }, u = function(f, p) {
              var g = f.prev, m = f.next;
              return g !== null ? g.next = m : p.head = m, m !== null ? m.prev = g : p.tail = g, f.prev = f.next = null, p.length--, f;
            }, h = (function() {
              function d(f) {
                var p = this;
                s(this, d), this.length = 0, this.head = null, this.tail = null, f?.forEach(function(g) {
                  return p.push(g);
                });
              }
              return a(d, [{
                key: "size",
                value: function() {
                  return this.length;
                }
              }, {
                key: "insertBefore",
                value: function(p, g) {
                  return l(g.prev, o(p), g, this);
                }
              }, {
                key: "insertAfter",
                value: function(p, g) {
                  return l(g, o(p), g.next, this);
                }
              }, {
                key: "insertNodeBefore",
                value: function(p, g) {
                  return l(g.prev, p, g, this);
                }
              }, {
                key: "insertNodeAfter",
                value: function(p, g) {
                  return l(g, p, g.next, this);
                }
              }, {
                key: "push",
                value: function(p) {
                  return l(this.tail, o(p), null, this);
                }
              }, {
                key: "unshift",
                value: function(p) {
                  return l(null, o(p), this.head, this);
                }
              }, {
                key: "remove",
                value: function(p) {
                  return u(p, this);
                }
              }, {
                key: "pop",
                value: function() {
                  return u(this.tail, this).value;
                }
              }, {
                key: "popNode",
                value: function() {
                  return u(this.tail, this);
                }
              }, {
                key: "shift",
                value: function() {
                  return u(this.head, this).value;
                }
              }, {
                key: "shiftNode",
                value: function() {
                  return u(this.head, this);
                }
              }, {
                key: "get_object_at",
                value: function(p) {
                  if (p <= this.length()) {
                    for (var g = 1, m = this.head; g < p; )
                      m = m.next, g++;
                    return m.value;
                  }
                }
              }, {
                key: "set_object_at",
                value: function(p, g) {
                  if (p <= this.length()) {
                    for (var m = 1, v = this.head; m < p; )
                      v = v.next, m++;
                    v.value = g;
                  }
                }
              }]), d;
            })();
            r.exports = h;
          }),
          /* 12 */
          /***/
          (function(r, n, i) {
            function a(s, o, l) {
              this.x = null, this.y = null, s == null && o == null && l == null ? (this.x = 0, this.y = 0) : typeof s == "number" && typeof o == "number" && l == null ? (this.x = s, this.y = o) : s.constructor.name == "Point" && o == null && l == null && (l = s, this.x = l.x, this.y = l.y);
            }
            a.prototype.getX = function() {
              return this.x;
            }, a.prototype.getY = function() {
              return this.y;
            }, a.prototype.getLocation = function() {
              return new a(this.x, this.y);
            }, a.prototype.setLocation = function(s, o, l) {
              s.constructor.name == "Point" && o == null && l == null ? (l = s, this.setLocation(l.x, l.y)) : typeof s == "number" && typeof o == "number" && l == null && (parseInt(s) == s && parseInt(o) == o ? this.move(s, o) : (this.x = Math.floor(s + 0.5), this.y = Math.floor(o + 0.5)));
            }, a.prototype.move = function(s, o) {
              this.x = s, this.y = o;
            }, a.prototype.translate = function(s, o) {
              this.x += s, this.y += o;
            }, a.prototype.equals = function(s) {
              if (s.constructor.name == "Point") {
                var o = s;
                return this.x == o.x && this.y == o.y;
              }
              return this == s;
            }, a.prototype.toString = function() {
              return new a().constructor.name + "[x=" + this.x + ",y=" + this.y + "]";
            }, r.exports = a;
          }),
          /* 13 */
          /***/
          (function(r, n, i) {
            function a(s, o, l, u) {
              this.x = 0, this.y = 0, this.width = 0, this.height = 0, s != null && o != null && l != null && u != null && (this.x = s, this.y = o, this.width = l, this.height = u);
            }
            a.prototype.getX = function() {
              return this.x;
            }, a.prototype.setX = function(s) {
              this.x = s;
            }, a.prototype.getY = function() {
              return this.y;
            }, a.prototype.setY = function(s) {
              this.y = s;
            }, a.prototype.getWidth = function() {
              return this.width;
            }, a.prototype.setWidth = function(s) {
              this.width = s;
            }, a.prototype.getHeight = function() {
              return this.height;
            }, a.prototype.setHeight = function(s) {
              this.height = s;
            }, a.prototype.getRight = function() {
              return this.x + this.width;
            }, a.prototype.getBottom = function() {
              return this.y + this.height;
            }, a.prototype.intersects = function(s) {
              return !(this.getRight() < s.x || this.getBottom() < s.y || s.getRight() < this.x || s.getBottom() < this.y);
            }, a.prototype.getCenterX = function() {
              return this.x + this.width / 2;
            }, a.prototype.getMinX = function() {
              return this.getX();
            }, a.prototype.getMaxX = function() {
              return this.getX() + this.width;
            }, a.prototype.getCenterY = function() {
              return this.y + this.height / 2;
            }, a.prototype.getMinY = function() {
              return this.getY();
            }, a.prototype.getMaxY = function() {
              return this.getY() + this.height;
            }, a.prototype.getWidthHalf = function() {
              return this.width / 2;
            }, a.prototype.getHeightHalf = function() {
              return this.height / 2;
            }, r.exports = a;
          }),
          /* 14 */
          /***/
          (function(r, n, i) {
            var a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
              return typeof o;
            } : function(o) {
              return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
            };
            function s() {
            }
            s.lastID = 0, s.createID = function(o) {
              return s.isPrimitive(o) ? o : (o.uniqueID != null || (o.uniqueID = s.getString(), s.lastID++), o.uniqueID);
            }, s.getString = function(o) {
              return o == null && (o = s.lastID), "Object#" + o;
            }, s.isPrimitive = function(o) {
              var l = typeof o > "u" ? "undefined" : a(o);
              return o == null || l != "object" && l != "function";
            }, r.exports = s;
          }),
          /* 15 */
          /***/
          (function(r, n, i) {
            function a(m) {
              if (Array.isArray(m)) {
                for (var v = 0, y = Array(m.length); v < m.length; v++)
                  y[v] = m[v];
                return y;
              } else
                return Array.from(m);
            }
            var s = i(0), o = i(7), l = i(3), u = i(1), h = i(6), d = i(5), f = i(17), p = i(29);
            function g(m) {
              p.call(this), this.layoutQuality = s.QUALITY, this.createBendsAsNeeded = s.DEFAULT_CREATE_BENDS_AS_NEEDED, this.incremental = s.DEFAULT_INCREMENTAL, this.animationOnLayout = s.DEFAULT_ANIMATION_ON_LAYOUT, this.animationDuringLayout = s.DEFAULT_ANIMATION_DURING_LAYOUT, this.animationPeriod = s.DEFAULT_ANIMATION_PERIOD, this.uniformLeafNodeSizes = s.DEFAULT_UNIFORM_LEAF_NODE_SIZES, this.edgeToDummyNodes = /* @__PURE__ */ new Map(), this.graphManager = new o(this), this.isLayoutFinished = !1, this.isSubLayout = !1, this.isRemoteUse = !1, m != null && (this.isRemoteUse = m);
            }
            g.RANDOM_SEED = 1, g.prototype = Object.create(p.prototype), g.prototype.getGraphManager = function() {
              return this.graphManager;
            }, g.prototype.getAllNodes = function() {
              return this.graphManager.getAllNodes();
            }, g.prototype.getAllEdges = function() {
              return this.graphManager.getAllEdges();
            }, g.prototype.getAllNodesToApplyGravitation = function() {
              return this.graphManager.getAllNodesToApplyGravitation();
            }, g.prototype.newGraphManager = function() {
              var m = new o(this);
              return this.graphManager = m, m;
            }, g.prototype.newGraph = function(m) {
              return new h(null, this.graphManager, m);
            }, g.prototype.newNode = function(m) {
              return new l(this.graphManager, m);
            }, g.prototype.newEdge = function(m) {
              return new u(null, null, m);
            }, g.prototype.checkLayoutSuccess = function() {
              return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();
            }, g.prototype.runLayout = function() {
              this.isLayoutFinished = !1, this.tilingPreLayout && this.tilingPreLayout(), this.initParameters();
              var m;
              return this.checkLayoutSuccess() ? m = !1 : m = this.layout(), s.ANIMATE === "during" ? !1 : (m && (this.isSubLayout || this.doPostLayout()), this.tilingPostLayout && this.tilingPostLayout(), this.isLayoutFinished = !0, m);
            }, g.prototype.doPostLayout = function() {
              this.incremental || this.transform(), this.update();
            }, g.prototype.update2 = function() {
              if (this.createBendsAsNeeded && (this.createBendpointsFromDummyNodes(), this.graphManager.resetAllEdges()), !this.isRemoteUse) {
                for (var m = this.graphManager.getAllEdges(), v = 0; v < m.length; v++)
                  m[v];
                for (var y = this.graphManager.getRoot().getNodes(), v = 0; v < y.length; v++)
                  y[v];
                this.update(this.graphManager.getRoot());
              }
            }, g.prototype.update = function(m) {
              if (m == null)
                this.update2();
              else if (m instanceof l) {
                var v = m;
                if (v.getChild() != null)
                  for (var y = v.getChild().getNodes(), b = 0; b < y.length; b++)
                    update(y[b]);
                if (v.vGraphObject != null) {
                  var w = v.vGraphObject;
                  w.update(v);
                }
              } else if (m instanceof u) {
                var T = m;
                if (T.vGraphObject != null) {
                  var E = T.vGraphObject;
                  E.update(T);
                }
              } else if (m instanceof h) {
                var L = m;
                if (L.vGraphObject != null) {
                  var k = L.vGraphObject;
                  k.update(L);
                }
              }
            }, g.prototype.initParameters = function() {
              this.isSubLayout || (this.layoutQuality = s.QUALITY, this.animationDuringLayout = s.DEFAULT_ANIMATION_DURING_LAYOUT, this.animationPeriod = s.DEFAULT_ANIMATION_PERIOD, this.animationOnLayout = s.DEFAULT_ANIMATION_ON_LAYOUT, this.incremental = s.DEFAULT_INCREMENTAL, this.createBendsAsNeeded = s.DEFAULT_CREATE_BENDS_AS_NEEDED, this.uniformLeafNodeSizes = s.DEFAULT_UNIFORM_LEAF_NODE_SIZES), this.animationDuringLayout && (this.animationOnLayout = !1);
            }, g.prototype.transform = function(m) {
              if (m == null)
                this.transform(new d(0, 0));
              else {
                var v = new f(), y = this.graphManager.getRoot().updateLeftTop();
                if (y != null) {
                  v.setWorldOrgX(m.x), v.setWorldOrgY(m.y), v.setDeviceOrgX(y.x), v.setDeviceOrgY(y.y);
                  for (var b = this.getAllNodes(), w, T = 0; T < b.length; T++)
                    w = b[T], w.transform(v);
                }
              }
            }, g.prototype.positionNodesRandomly = function(m) {
              if (m == null)
                this.positionNodesRandomly(this.getGraphManager().getRoot()), this.getGraphManager().getRoot().updateBounds(!0);
              else
                for (var v, y, b = m.getNodes(), w = 0; w < b.length; w++)
                  v = b[w], y = v.getChild(), y == null || y.getNodes().length == 0 ? v.scatter() : (this.positionNodesRandomly(y), v.updateBounds());
            }, g.prototype.getFlatForest = function() {
              for (var m = [], v = !0, y = this.graphManager.getRoot().getNodes(), b = !0, w = 0; w < y.length; w++)
                y[w].getChild() != null && (b = !1);
              if (!b)
                return m;
              var T = /* @__PURE__ */ new Set(), E = [], L = /* @__PURE__ */ new Map(), k = [];
              for (k = k.concat(y); k.length > 0 && v; ) {
                for (E.push(k[0]); E.length > 0 && v; ) {
                  var C = E[0];
                  E.splice(0, 1), T.add(C);
                  for (var A = C.getEdges(), w = 0; w < A.length; w++) {
                    var R = A[w].getOtherEnd(C);
                    if (L.get(C) != R)
                      if (!T.has(R))
                        E.push(R), L.set(R, C);
                      else {
                        v = !1;
                        break;
                      }
                  }
                }
                if (!v)
                  m = [];
                else {
                  var _ = [].concat(a(T));
                  m.push(_);
                  for (var w = 0; w < _.length; w++) {
                    var O = _[w], P = k.indexOf(O);
                    P > -1 && k.splice(P, 1);
                  }
                  T = /* @__PURE__ */ new Set(), L = /* @__PURE__ */ new Map();
                }
              }
              return m;
            }, g.prototype.createDummyNodesForBendpoints = function(m) {
              for (var v = [], y = m.source, b = this.graphManager.calcLowestCommonAncestor(m.source, m.target), w = 0; w < m.bendpoints.length; w++) {
                var T = this.newNode(null);
                T.setRect(new Point(0, 0), new Dimension(1, 1)), b.add(T);
                var E = this.newEdge(null);
                this.graphManager.add(E, y, T), v.add(T), y = T;
              }
              var E = this.newEdge(null);
              return this.graphManager.add(E, y, m.target), this.edgeToDummyNodes.set(m, v), m.isInterGraph() ? this.graphManager.remove(m) : b.remove(m), v;
            }, g.prototype.createBendpointsFromDummyNodes = function() {
              var m = [];
              m = m.concat(this.graphManager.getAllEdges()), m = [].concat(a(this.edgeToDummyNodes.keys())).concat(m);
              for (var v = 0; v < m.length; v++) {
                var y = m[v];
                if (y.bendpoints.length > 0) {
                  for (var b = this.edgeToDummyNodes.get(y), w = 0; w < b.length; w++) {
                    var T = b[w], E = new d(T.getCenterX(), T.getCenterY()), L = y.bendpoints.get(w);
                    L.x = E.x, L.y = E.y, T.getOwner().remove(T);
                  }
                  this.graphManager.add(y, y.source, y.target);
                }
              }
            }, g.transform = function(m, v, y, b) {
              if (y != null && b != null) {
                var w = v;
                if (m <= 50) {
                  var T = v / y;
                  w -= (v - T) / 50 * (50 - m);
                } else {
                  var E = v * b;
                  w += (E - v) / 50 * (m - 50);
                }
                return w;
              } else {
                var L, k;
                return m <= 50 ? (L = 9 * v / 500, k = v / 10) : (L = 9 * v / 50, k = -8 * v), L * m + k;
              }
            }, g.findCenterOfTree = function(m) {
              var v = [];
              v = v.concat(m);
              var y = [], b = /* @__PURE__ */ new Map(), w = !1, T = null;
              (v.length == 1 || v.length == 2) && (w = !0, T = v[0]);
              for (var E = 0; E < v.length; E++) {
                var L = v[E], k = L.getNeighborsList().size;
                b.set(L, L.getNeighborsList().size), k == 1 && y.push(L);
              }
              var C = [];
              for (C = C.concat(y); !w; ) {
                var A = [];
                A = A.concat(C), C = [];
                for (var E = 0; E < v.length; E++) {
                  var L = v[E], R = v.indexOf(L);
                  R >= 0 && v.splice(R, 1);
                  var _ = L.getNeighborsList();
                  _.forEach(function(S) {
                    if (y.indexOf(S) < 0) {
                      var M = b.get(S), N = M - 1;
                      N == 1 && C.push(S), b.set(S, N);
                    }
                  });
                }
                y = y.concat(C), (v.length == 1 || v.length == 2) && (w = !0, T = v[0]);
              }
              return T;
            }, g.prototype.setGraphManager = function(m) {
              this.graphManager = m;
            }, r.exports = g;
          }),
          /* 16 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.seed = 1, a.x = 0, a.nextDouble = function() {
              return a.x = Math.sin(a.seed++) * 1e4, a.x - Math.floor(a.x);
            }, r.exports = a;
          }),
          /* 17 */
          /***/
          (function(r, n, i) {
            var a = i(5);
            function s(o, l) {
              this.lworldOrgX = 0, this.lworldOrgY = 0, this.ldeviceOrgX = 0, this.ldeviceOrgY = 0, this.lworldExtX = 1, this.lworldExtY = 1, this.ldeviceExtX = 1, this.ldeviceExtY = 1;
            }
            s.prototype.getWorldOrgX = function() {
              return this.lworldOrgX;
            }, s.prototype.setWorldOrgX = function(o) {
              this.lworldOrgX = o;
            }, s.prototype.getWorldOrgY = function() {
              return this.lworldOrgY;
            }, s.prototype.setWorldOrgY = function(o) {
              this.lworldOrgY = o;
            }, s.prototype.getWorldExtX = function() {
              return this.lworldExtX;
            }, s.prototype.setWorldExtX = function(o) {
              this.lworldExtX = o;
            }, s.prototype.getWorldExtY = function() {
              return this.lworldExtY;
            }, s.prototype.setWorldExtY = function(o) {
              this.lworldExtY = o;
            }, s.prototype.getDeviceOrgX = function() {
              return this.ldeviceOrgX;
            }, s.prototype.setDeviceOrgX = function(o) {
              this.ldeviceOrgX = o;
            }, s.prototype.getDeviceOrgY = function() {
              return this.ldeviceOrgY;
            }, s.prototype.setDeviceOrgY = function(o) {
              this.ldeviceOrgY = o;
            }, s.prototype.getDeviceExtX = function() {
              return this.ldeviceExtX;
            }, s.prototype.setDeviceExtX = function(o) {
              this.ldeviceExtX = o;
            }, s.prototype.getDeviceExtY = function() {
              return this.ldeviceExtY;
            }, s.prototype.setDeviceExtY = function(o) {
              this.ldeviceExtY = o;
            }, s.prototype.transformX = function(o) {
              var l = 0, u = this.lworldExtX;
              return u != 0 && (l = this.ldeviceOrgX + (o - this.lworldOrgX) * this.ldeviceExtX / u), l;
            }, s.prototype.transformY = function(o) {
              var l = 0, u = this.lworldExtY;
              return u != 0 && (l = this.ldeviceOrgY + (o - this.lworldOrgY) * this.ldeviceExtY / u), l;
            }, s.prototype.inverseTransformX = function(o) {
              var l = 0, u = this.ldeviceExtX;
              return u != 0 && (l = this.lworldOrgX + (o - this.ldeviceOrgX) * this.lworldExtX / u), l;
            }, s.prototype.inverseTransformY = function(o) {
              var l = 0, u = this.ldeviceExtY;
              return u != 0 && (l = this.lworldOrgY + (o - this.ldeviceOrgY) * this.lworldExtY / u), l;
            }, s.prototype.inverseTransformPoint = function(o) {
              var l = new a(this.inverseTransformX(o.x), this.inverseTransformY(o.y));
              return l;
            }, r.exports = s;
          }),
          /* 18 */
          /***/
          (function(r, n, i) {
            function a(p) {
              if (Array.isArray(p)) {
                for (var g = 0, m = Array(p.length); g < p.length; g++)
                  m[g] = p[g];
                return m;
              } else
                return Array.from(p);
            }
            var s = i(15), o = i(4), l = i(0), u = i(8), h = i(9);
            function d() {
              s.call(this), this.useSmartIdealEdgeLengthCalculation = o.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION, this.gravityConstant = o.DEFAULT_GRAVITY_STRENGTH, this.compoundGravityConstant = o.DEFAULT_COMPOUND_GRAVITY_STRENGTH, this.gravityRangeFactor = o.DEFAULT_GRAVITY_RANGE_FACTOR, this.compoundGravityRangeFactor = o.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR, this.displacementThresholdPerNode = 3 * o.DEFAULT_EDGE_LENGTH / 100, this.coolingFactor = o.DEFAULT_COOLING_FACTOR_INCREMENTAL, this.initialCoolingFactor = o.DEFAULT_COOLING_FACTOR_INCREMENTAL, this.totalDisplacement = 0, this.oldTotalDisplacement = 0, this.maxIterations = o.MAX_ITERATIONS;
            }
            d.prototype = Object.create(s.prototype);
            for (var f in s)
              d[f] = s[f];
            d.prototype.initParameters = function() {
              s.prototype.initParameters.call(this, arguments), this.totalIterations = 0, this.notAnimatedIterations = 0, this.useFRGridVariant = o.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION, this.grid = [];
            }, d.prototype.calcIdealEdgeLengths = function() {
              for (var p, g, m, v, y, b, w, T = this.getGraphManager().getAllEdges(), E = 0; E < T.length; E++)
                p = T[E], g = p.idealLength, p.isInterGraph && (v = p.getSource(), y = p.getTarget(), b = p.getSourceInLca().getEstimatedSize(), w = p.getTargetInLca().getEstimatedSize(), this.useSmartIdealEdgeLengthCalculation && (p.idealLength += b + w - 2 * l.SIMPLE_NODE_SIZE), m = p.getLca().getInclusionTreeDepth(), p.idealLength += g * o.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (v.getInclusionTreeDepth() + y.getInclusionTreeDepth() - 2 * m));
            }, d.prototype.initSpringEmbedder = function() {
              var p = this.getAllNodes().length;
              this.incremental ? (p > o.ADAPTATION_LOWER_NODE_LIMIT && (this.coolingFactor = Math.max(this.coolingFactor * o.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (p - o.ADAPTATION_LOWER_NODE_LIMIT) / (o.ADAPTATION_UPPER_NODE_LIMIT - o.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - o.COOLING_ADAPTATION_FACTOR))), this.maxNodeDisplacement = o.MAX_NODE_DISPLACEMENT_INCREMENTAL) : (p > o.ADAPTATION_LOWER_NODE_LIMIT ? this.coolingFactor = Math.max(o.COOLING_ADAPTATION_FACTOR, 1 - (p - o.ADAPTATION_LOWER_NODE_LIMIT) / (o.ADAPTATION_UPPER_NODE_LIMIT - o.ADAPTATION_LOWER_NODE_LIMIT) * (1 - o.COOLING_ADAPTATION_FACTOR)) : this.coolingFactor = 1, this.initialCoolingFactor = this.coolingFactor, this.maxNodeDisplacement = o.MAX_NODE_DISPLACEMENT), this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations), this.displacementThresholdPerNode = 3 * o.DEFAULT_EDGE_LENGTH / 100, this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length, this.repulsionRange = this.calcRepulsionRange();
            }, d.prototype.calcSpringForces = function() {
              for (var p = this.getAllEdges(), g, m = 0; m < p.length; m++)
                g = p[m], this.calcSpringForce(g, g.idealLength);
            }, d.prototype.calcRepulsionForces = function() {
              var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, m, v, y, b, w = this.getAllNodes(), T;
              if (this.useFRGridVariant)
                for (this.totalIterations % o.GRID_CALCULATION_CHECK_PERIOD == 1 && p && this.updateGrid(), T = /* @__PURE__ */ new Set(), m = 0; m < w.length; m++)
                  y = w[m], this.calculateRepulsionForceOfANode(y, T, p, g), T.add(y);
              else
                for (m = 0; m < w.length; m++)
                  for (y = w[m], v = m + 1; v < w.length; v++)
                    b = w[v], y.getOwner() == b.getOwner() && this.calcRepulsionForce(y, b);
            }, d.prototype.calcGravitationalForces = function() {
              for (var p, g = this.getAllNodesToApplyGravitation(), m = 0; m < g.length; m++)
                p = g[m], this.calcGravitationalForce(p);
            }, d.prototype.moveNodes = function() {
              for (var p = this.getAllNodes(), g, m = 0; m < p.length; m++)
                g = p[m], g.move();
            }, d.prototype.calcSpringForce = function(p, g) {
              var m = p.getSource(), v = p.getTarget(), y, b, w, T;
              if (this.uniformLeafNodeSizes && m.getChild() == null && v.getChild() == null)
                p.updateLengthSimple();
              else if (p.updateLength(), p.isOverlapingSourceAndTarget)
                return;
              y = p.getLength(), y != 0 && (b = p.edgeElasticity * (y - g), w = b * (p.lengthX / y), T = b * (p.lengthY / y), m.springForceX += w, m.springForceY += T, v.springForceX -= w, v.springForceY -= T);
            }, d.prototype.calcRepulsionForce = function(p, g) {
              var m = p.getRect(), v = g.getRect(), y = new Array(2), b = new Array(4), w, T, E, L, k, C, A;
              if (m.intersects(v)) {
                u.calcSeparationAmount(m, v, y, o.DEFAULT_EDGE_LENGTH / 2), C = 2 * y[0], A = 2 * y[1];
                var R = p.noOfChildren * g.noOfChildren / (p.noOfChildren + g.noOfChildren);
                p.repulsionForceX -= R * C, p.repulsionForceY -= R * A, g.repulsionForceX += R * C, g.repulsionForceY += R * A;
              } else
                this.uniformLeafNodeSizes && p.getChild() == null && g.getChild() == null ? (w = v.getCenterX() - m.getCenterX(), T = v.getCenterY() - m.getCenterY()) : (u.getIntersection(m, v, b), w = b[2] - b[0], T = b[3] - b[1]), Math.abs(w) < o.MIN_REPULSION_DIST && (w = h.sign(w) * o.MIN_REPULSION_DIST), Math.abs(T) < o.MIN_REPULSION_DIST && (T = h.sign(T) * o.MIN_REPULSION_DIST), E = w * w + T * T, L = Math.sqrt(E), k = (p.nodeRepulsion / 2 + g.nodeRepulsion / 2) * p.noOfChildren * g.noOfChildren / E, C = k * w / L, A = k * T / L, p.repulsionForceX -= C, p.repulsionForceY -= A, g.repulsionForceX += C, g.repulsionForceY += A;
            }, d.prototype.calcGravitationalForce = function(p) {
              var g, m, v, y, b, w, T, E;
              g = p.getOwner(), m = (g.getRight() + g.getLeft()) / 2, v = (g.getTop() + g.getBottom()) / 2, y = p.getCenterX() - m, b = p.getCenterY() - v, w = Math.abs(y) + p.getWidth() / 2, T = Math.abs(b) + p.getHeight() / 2, p.getOwner() == this.graphManager.getRoot() ? (E = g.getEstimatedSize() * this.gravityRangeFactor, (w > E || T > E) && (p.gravitationForceX = -this.gravityConstant * y, p.gravitationForceY = -this.gravityConstant * b)) : (E = g.getEstimatedSize() * this.compoundGravityRangeFactor, (w > E || T > E) && (p.gravitationForceX = -this.gravityConstant * y * this.compoundGravityConstant, p.gravitationForceY = -this.gravityConstant * b * this.compoundGravityConstant));
            }, d.prototype.isConverged = function() {
              var p, g = !1;
              return this.totalIterations > this.maxIterations / 3 && (g = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2), p = this.totalDisplacement < this.totalDisplacementThreshold, this.oldTotalDisplacement = this.totalDisplacement, p || g;
            }, d.prototype.animate = function() {
              this.animationDuringLayout && !this.isSubLayout && (this.notAnimatedIterations == this.animationPeriod ? (this.update(), this.notAnimatedIterations = 0) : this.notAnimatedIterations++);
            }, d.prototype.calcNoOfChildrenForAllNodes = function() {
              for (var p, g = this.graphManager.getAllNodes(), m = 0; m < g.length; m++)
                p = g[m], p.noOfChildren = p.getNoOfChildren();
            }, d.prototype.calcGrid = function(p) {
              var g = 0, m = 0;
              g = parseInt(Math.ceil((p.getRight() - p.getLeft()) / this.repulsionRange)), m = parseInt(Math.ceil((p.getBottom() - p.getTop()) / this.repulsionRange));
              for (var v = new Array(g), y = 0; y < g; y++)
                v[y] = new Array(m);
              for (var y = 0; y < g; y++)
                for (var b = 0; b < m; b++)
                  v[y][b] = new Array();
              return v;
            }, d.prototype.addNodeToGrid = function(p, g, m) {
              var v = 0, y = 0, b = 0, w = 0;
              v = parseInt(Math.floor((p.getRect().x - g) / this.repulsionRange)), y = parseInt(Math.floor((p.getRect().width + p.getRect().x - g) / this.repulsionRange)), b = parseInt(Math.floor((p.getRect().y - m) / this.repulsionRange)), w = parseInt(Math.floor((p.getRect().height + p.getRect().y - m) / this.repulsionRange));
              for (var T = v; T <= y; T++)
                for (var E = b; E <= w; E++)
                  this.grid[T][E].push(p), p.setGridCoordinates(v, y, b, w);
            }, d.prototype.updateGrid = function() {
              var p, g, m = this.getAllNodes();
              for (this.grid = this.calcGrid(this.graphManager.getRoot()), p = 0; p < m.length; p++)
                g = m[p], this.addNodeToGrid(g, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());
            }, d.prototype.calculateRepulsionForceOfANode = function(p, g, m, v) {
              if (this.totalIterations % o.GRID_CALCULATION_CHECK_PERIOD == 1 && m || v) {
                var y = /* @__PURE__ */ new Set();
                p.surrounding = new Array();
                for (var b, w = this.grid, T = p.startX - 1; T < p.finishX + 2; T++)
                  for (var E = p.startY - 1; E < p.finishY + 2; E++)
                    if (!(T < 0 || E < 0 || T >= w.length || E >= w[0].length)) {
                      for (var L = 0; L < w[T][E].length; L++)
                        if (b = w[T][E][L], !(p.getOwner() != b.getOwner() || p == b) && !g.has(b) && !y.has(b)) {
                          var k = Math.abs(p.getCenterX() - b.getCenterX()) - (p.getWidth() / 2 + b.getWidth() / 2), C = Math.abs(p.getCenterY() - b.getCenterY()) - (p.getHeight() / 2 + b.getHeight() / 2);
                          k <= this.repulsionRange && C <= this.repulsionRange && y.add(b);
                        }
                    }
                p.surrounding = [].concat(a(y));
              }
              for (T = 0; T < p.surrounding.length; T++)
                this.calcRepulsionForce(p, p.surrounding[T]);
            }, d.prototype.calcRepulsionRange = function() {
              return 0;
            }, r.exports = d;
          }),
          /* 19 */
          /***/
          (function(r, n, i) {
            var a = i(1), s = i(4);
            function o(u, h, d) {
              a.call(this, u, h, d), this.idealLength = s.DEFAULT_EDGE_LENGTH, this.edgeElasticity = s.DEFAULT_SPRING_STRENGTH;
            }
            o.prototype = Object.create(a.prototype);
            for (var l in a)
              o[l] = a[l];
            r.exports = o;
          }),
          /* 20 */
          /***/
          (function(r, n, i) {
            var a = i(3), s = i(4);
            function o(u, h, d, f) {
              a.call(this, u, h, d, f), this.nodeRepulsion = s.DEFAULT_REPULSION_STRENGTH, this.springForceX = 0, this.springForceY = 0, this.repulsionForceX = 0, this.repulsionForceY = 0, this.gravitationForceX = 0, this.gravitationForceY = 0, this.displacementX = 0, this.displacementY = 0, this.startX = 0, this.finishX = 0, this.startY = 0, this.finishY = 0, this.surrounding = [];
            }
            o.prototype = Object.create(a.prototype);
            for (var l in a)
              o[l] = a[l];
            o.prototype.setGridCoordinates = function(u, h, d, f) {
              this.startX = u, this.finishX = h, this.startY = d, this.finishY = f;
            }, r.exports = o;
          }),
          /* 21 */
          /***/
          (function(r, n, i) {
            function a(s, o) {
              this.width = 0, this.height = 0, s !== null && o !== null && (this.height = o, this.width = s);
            }
            a.prototype.getWidth = function() {
              return this.width;
            }, a.prototype.setWidth = function(s) {
              this.width = s;
            }, a.prototype.getHeight = function() {
              return this.height;
            }, a.prototype.setHeight = function(s) {
              this.height = s;
            }, r.exports = a;
          }),
          /* 22 */
          /***/
          (function(r, n, i) {
            var a = i(14);
            function s() {
              this.map = {}, this.keys = [];
            }
            s.prototype.put = function(o, l) {
              var u = a.createID(o);
              this.contains(u) || (this.map[u] = l, this.keys.push(o));
            }, s.prototype.contains = function(o) {
              return a.createID(o), this.map[o] != null;
            }, s.prototype.get = function(o) {
              var l = a.createID(o);
              return this.map[l];
            }, s.prototype.keySet = function() {
              return this.keys;
            }, r.exports = s;
          }),
          /* 23 */
          /***/
          (function(r, n, i) {
            var a = i(14);
            function s() {
              this.set = {};
            }
            s.prototype.add = function(o) {
              var l = a.createID(o);
              this.contains(l) || (this.set[l] = o);
            }, s.prototype.remove = function(o) {
              delete this.set[a.createID(o)];
            }, s.prototype.clear = function() {
              this.set = {};
            }, s.prototype.contains = function(o) {
              return this.set[a.createID(o)] == o;
            }, s.prototype.isEmpty = function() {
              return this.size() === 0;
            }, s.prototype.size = function() {
              return Object.keys(this.set).length;
            }, s.prototype.addAllTo = function(o) {
              for (var l = Object.keys(this.set), u = l.length, h = 0; h < u; h++)
                o.push(this.set[l[h]]);
            }, s.prototype.size = function() {
              return Object.keys(this.set).length;
            }, s.prototype.addAll = function(o) {
              for (var l = o.length, u = 0; u < l; u++) {
                var h = o[u];
                this.add(h);
              }
            }, r.exports = s;
          }),
          /* 24 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.multMat = function(s, o) {
              for (var l = [], u = 0; u < s.length; u++) {
                l[u] = [];
                for (var h = 0; h < o[0].length; h++) {
                  l[u][h] = 0;
                  for (var d = 0; d < s[0].length; d++)
                    l[u][h] += s[u][d] * o[d][h];
                }
              }
              return l;
            }, a.transpose = function(s) {
              for (var o = [], l = 0; l < s[0].length; l++) {
                o[l] = [];
                for (var u = 0; u < s.length; u++)
                  o[l][u] = s[u][l];
              }
              return o;
            }, a.multCons = function(s, o) {
              for (var l = [], u = 0; u < s.length; u++)
                l[u] = s[u] * o;
              return l;
            }, a.minusOp = function(s, o) {
              for (var l = [], u = 0; u < s.length; u++)
                l[u] = s[u] - o[u];
              return l;
            }, a.dotProduct = function(s, o) {
              for (var l = 0, u = 0; u < s.length; u++)
                l += s[u] * o[u];
              return l;
            }, a.mag = function(s) {
              return Math.sqrt(this.dotProduct(s, s));
            }, a.normalize = function(s) {
              for (var o = [], l = this.mag(s), u = 0; u < s.length; u++)
                o[u] = s[u] / l;
              return o;
            }, a.multGamma = function(s) {
              for (var o = [], l = 0, u = 0; u < s.length; u++)
                l += s[u];
              l *= -1 / s.length;
              for (var h = 0; h < s.length; h++)
                o[h] = l + s[h];
              return o;
            }, a.multL = function(s, o, l) {
              for (var u = [], h = [], d = [], f = 0; f < o[0].length; f++) {
                for (var p = 0, g = 0; g < o.length; g++)
                  p += -0.5 * o[g][f] * s[g];
                h[f] = p;
              }
              for (var m = 0; m < l.length; m++) {
                for (var v = 0, y = 0; y < l.length; y++)
                  v += l[m][y] * h[y];
                d[m] = v;
              }
              for (var b = 0; b < o.length; b++) {
                for (var w = 0, T = 0; T < o[0].length; T++)
                  w += o[b][T] * d[T];
                u[b] = w;
              }
              return u;
            }, r.exports = a;
          }),
          /* 25 */
          /***/
          (function(r, n, i) {
            var a = /* @__PURE__ */ (function() {
              function u(h, d) {
                for (var f = 0; f < d.length; f++) {
                  var p = d[f];
                  p.enumerable = p.enumerable || !1, p.configurable = !0, "value" in p && (p.writable = !0), Object.defineProperty(h, p.key, p);
                }
              }
              return function(h, d, f) {
                return d && u(h.prototype, d), f && u(h, f), h;
              };
            })();
            function s(u, h) {
              if (!(u instanceof h))
                throw new TypeError("Cannot call a class as a function");
            }
            var o = i(11), l = (function() {
              function u(h, d) {
                s(this, u), (d !== null || d !== void 0) && (this.compareFunction = this._defaultCompareFunction);
                var f = void 0;
                h instanceof o ? f = h.size() : f = h.length, this._quicksort(h, 0, f - 1);
              }
              return a(u, [{
                key: "_quicksort",
                value: function(d, f, p) {
                  if (f < p) {
                    var g = this._partition(d, f, p);
                    this._quicksort(d, f, g), this._quicksort(d, g + 1, p);
                  }
                }
              }, {
                key: "_partition",
                value: function(d, f, p) {
                  for (var g = this._get(d, f), m = f, v = p; ; ) {
                    for (; this.compareFunction(g, this._get(d, v)); )
                      v--;
                    for (; this.compareFunction(this._get(d, m), g); )
                      m++;
                    if (m < v)
                      this._swap(d, m, v), m++, v--;
                    else return v;
                  }
                }
              }, {
                key: "_get",
                value: function(d, f) {
                  return d instanceof o ? d.get_object_at(f) : d[f];
                }
              }, {
                key: "_set",
                value: function(d, f, p) {
                  d instanceof o ? d.set_object_at(f, p) : d[f] = p;
                }
              }, {
                key: "_swap",
                value: function(d, f, p) {
                  var g = this._get(d, f);
                  this._set(d, f, this._get(d, p)), this._set(d, p, g);
                }
              }, {
                key: "_defaultCompareFunction",
                value: function(d, f) {
                  return f > d;
                }
              }]), u;
            })();
            r.exports = l;
          }),
          /* 26 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.svd = function(s) {
              this.U = null, this.V = null, this.s = null, this.m = 0, this.n = 0, this.m = s.length, this.n = s[0].length;
              var o = Math.min(this.m, this.n);
              this.s = (function(qe) {
                for (var rt = []; qe-- > 0; )
                  rt.push(0);
                return rt;
              })(Math.min(this.m + 1, this.n)), this.U = (function(qe) {
                var rt = function ct(ut) {
                  if (ut.length == 0)
                    return 0;
                  for (var nt = [], xt = 0; xt < ut[0]; xt++)
                    nt.push(ct(ut.slice(1)));
                  return nt;
                };
                return rt(qe);
              })([this.m, o]), this.V = (function(qe) {
                var rt = function ct(ut) {
                  if (ut.length == 0)
                    return 0;
                  for (var nt = [], xt = 0; xt < ut[0]; xt++)
                    nt.push(ct(ut.slice(1)));
                  return nt;
                };
                return rt(qe);
              })([this.n, this.n]);
              for (var l = (function(qe) {
                for (var rt = []; qe-- > 0; )
                  rt.push(0);
                return rt;
              })(this.n), u = (function(qe) {
                for (var rt = []; qe-- > 0; )
                  rt.push(0);
                return rt;
              })(this.m), h = !0, d = Math.min(this.m - 1, this.n), f = Math.max(0, Math.min(this.n - 2, this.m)), p = 0; p < Math.max(d, f); p++) {
                if (p < d) {
                  this.s[p] = 0;
                  for (var g = p; g < this.m; g++)
                    this.s[p] = a.hypot(this.s[p], s[g][p]);
                  if (this.s[p] !== 0) {
                    s[p][p] < 0 && (this.s[p] = -this.s[p]);
                    for (var m = p; m < this.m; m++)
                      s[m][p] /= this.s[p];
                    s[p][p] += 1;
                  }
                  this.s[p] = -this.s[p];
                }
                for (var v = p + 1; v < this.n; v++) {
                  if (/* @__PURE__ */ (function(qe, rt) {
                    return qe && rt;
                  })(p < d, this.s[p] !== 0)) {
                    for (var y = 0, b = p; b < this.m; b++)
                      y += s[b][p] * s[b][v];
                    y = -y / s[p][p];
                    for (var w = p; w < this.m; w++)
                      s[w][v] += y * s[w][p];
                  }
                  l[v] = s[p][v];
                }
                if (/* @__PURE__ */ (function(qe, rt) {
                  return rt;
                })(h, p < d))
                  for (var T = p; T < this.m; T++)
                    this.U[T][p] = s[T][p];
                if (p < f) {
                  l[p] = 0;
                  for (var E = p + 1; E < this.n; E++)
                    l[p] = a.hypot(l[p], l[E]);
                  if (l[p] !== 0) {
                    l[p + 1] < 0 && (l[p] = -l[p]);
                    for (var L = p + 1; L < this.n; L++)
                      l[L] /= l[p];
                    l[p + 1] += 1;
                  }
                  if (l[p] = -l[p], /* @__PURE__ */ (function(qe, rt) {
                    return qe && rt;
                  })(p + 1 < this.m, l[p] !== 0)) {
                    for (var k = p + 1; k < this.m; k++)
                      u[k] = 0;
                    for (var C = p + 1; C < this.n; C++)
                      for (var A = p + 1; A < this.m; A++)
                        u[A] += l[C] * s[A][C];
                    for (var R = p + 1; R < this.n; R++)
                      for (var _ = -l[R] / l[p + 1], O = p + 1; O < this.m; O++)
                        s[O][R] += _ * u[O];
                  }
                  for (var P = p + 1; P < this.n; P++)
                    this.V[P][p] = l[P];
                }
              }
              var S = Math.min(this.n, this.m + 1);
              d < this.n && (this.s[d] = s[d][d]), this.m < S && (this.s[S - 1] = 0), f + 1 < S && (l[f] = s[f][S - 1]), l[S - 1] = 0;
              {
                for (var M = d; M < o; M++) {
                  for (var N = 0; N < this.m; N++)
                    this.U[N][M] = 0;
                  this.U[M][M] = 1;
                }
                for (var D = d - 1; D >= 0; D--)
                  if (this.s[D] !== 0) {
                    for (var I = D + 1; I < o; I++) {
                      for (var B = 0, z = D; z < this.m; z++)
                        B += this.U[z][D] * this.U[z][I];
                      B = -B / this.U[D][D];
                      for (var F = D; F < this.m; F++)
                        this.U[F][I] += B * this.U[F][D];
                    }
                    for (var V = D; V < this.m; V++)
                      this.U[V][D] = -this.U[V][D];
                    this.U[D][D] = 1 + this.U[D][D];
                    for (var H = 0; H < D - 1; H++)
                      this.U[H][D] = 0;
                  } else {
                    for (var J = 0; J < this.m; J++)
                      this.U[J][D] = 0;
                    this.U[D][D] = 1;
                  }
              }
              for (var q = this.n - 1; q >= 0; q--) {
                if (/* @__PURE__ */ (function(qe, rt) {
                  return qe && rt;
                })(q < f, l[q] !== 0))
                  for (var ae = q + 1; ae < o; ae++) {
                    for (var re = 0, pe = q + 1; pe < this.n; pe++)
                      re += this.V[pe][q] * this.V[pe][ae];
                    re = -re / this.V[q + 1][q];
                    for (var K = q + 1; K < this.n; K++)
                      this.V[K][ae] += re * this.V[K][q];
                  }
                for (var Z = 0; Z < this.n; Z++)
                  this.V[Z][q] = 0;
                this.V[q][q] = 1;
              }
              for (var X = S - 1, Y = Math.pow(2, -52), ee = Math.pow(2, -966); S > 0; ) {
                var j = void 0, fe = void 0;
                for (j = S - 2; j >= -1 && j !== -1; j--)
                  if (Math.abs(l[j]) <= ee + Y * (Math.abs(this.s[j]) + Math.abs(this.s[j + 1]))) {
                    l[j] = 0;
                    break;
                  }
                if (j === S - 2)
                  fe = 4;
                else {
                  var te = void 0;
                  for (te = S - 1; te >= j && te !== j; te--) {
                    var Ae = (te !== S ? Math.abs(l[te]) : 0) + (te !== j + 1 ? Math.abs(l[te - 1]) : 0);
                    if (Math.abs(this.s[te]) <= ee + Y * Ae) {
                      this.s[te] = 0;
                      break;
                    }
                  }
                  te === j ? fe = 3 : te === S - 1 ? fe = 1 : (fe = 2, j = te);
                }
                switch (j++, fe) {
                  case 1:
                    {
                      var W = l[S - 2];
                      l[S - 2] = 0;
                      for (var De = S - 2; De >= j; De--) {
                        var ue = a.hypot(this.s[De], W), ze = this.s[De] / ue, Ge = W / ue;
                        this.s[De] = ue, De !== j && (W = -Ge * l[De - 1], l[De - 1] = ze * l[De - 1]);
                        for (var Ve = 0; Ve < this.n; Ve++)
                          ue = ze * this.V[Ve][De] + Ge * this.V[Ve][S - 1], this.V[Ve][S - 1] = -Ge * this.V[Ve][De] + ze * this.V[Ve][S - 1], this.V[Ve][De] = ue;
                      }
                    }
                    break;
                  case 2:
                    {
                      var ke = l[j - 1];
                      l[j - 1] = 0;
                      for (var Oe = j; Oe < S; Oe++) {
                        var Se = a.hypot(this.s[Oe], ke), _e = this.s[Oe] / Se, $e = ke / Se;
                        this.s[Oe] = Se, ke = -$e * l[Oe], l[Oe] = _e * l[Oe];
                        for (var me = 0; me < this.m; me++)
                          Se = _e * this.U[me][Oe] + $e * this.U[me][j - 1], this.U[me][j - 1] = -$e * this.U[me][Oe] + _e * this.U[me][j - 1], this.U[me][Oe] = Se;
                      }
                    }
                    break;
                  case 3:
                    {
                      var Ne = Math.max(Math.max(Math.max(Math.max(Math.abs(this.s[S - 1]), Math.abs(this.s[S - 2])), Math.abs(l[S - 2])), Math.abs(this.s[j])), Math.abs(l[j])), Q = this.s[S - 1] / Ne, ce = this.s[S - 2] / Ne, $ = l[S - 2] / Ne, oe = this.s[j] / Ne, se = l[j] / Ne, ge = ((ce + Q) * (ce - Q) + $ * $) / 2, he = Q * $ * (Q * $), be = 0;
                      /* @__PURE__ */ (function(qe, rt) {
                        return qe || rt;
                      })(ge !== 0, he !== 0) && (be = Math.sqrt(ge * ge + he), ge < 0 && (be = -be), be = he / (ge + be));
                      for (var Ce = (oe + Q) * (oe - Q) + be, Te = oe * se, Me = j; Me < S - 1; Me++) {
                        var Xe = a.hypot(Ce, Te), We = Ce / Xe, Ke = Te / Xe;
                        Me !== j && (l[Me - 1] = Xe), Ce = We * this.s[Me] + Ke * l[Me], l[Me] = We * l[Me] - Ke * this.s[Me], Te = Ke * this.s[Me + 1], this.s[Me + 1] = We * this.s[Me + 1];
                        for (var Ze = 0; Ze < this.n; Ze++)
                          Xe = We * this.V[Ze][Me] + Ke * this.V[Ze][Me + 1], this.V[Ze][Me + 1] = -Ke * this.V[Ze][Me] + We * this.V[Ze][Me + 1], this.V[Ze][Me] = Xe;
                        if (Xe = a.hypot(Ce, Te), We = Ce / Xe, Ke = Te / Xe, this.s[Me] = Xe, Ce = We * l[Me] + Ke * this.s[Me + 1], this.s[Me + 1] = -Ke * l[Me] + We * this.s[Me + 1], Te = Ke * l[Me + 1], l[Me + 1] = We * l[Me + 1], Me < this.m - 1)
                          for (var Pe = 0; Pe < this.m; Pe++)
                            Xe = We * this.U[Pe][Me] + Ke * this.U[Pe][Me + 1], this.U[Pe][Me + 1] = -Ke * this.U[Pe][Me] + We * this.U[Pe][Me + 1], this.U[Pe][Me] = Xe;
                      }
                      l[S - 2] = Ce;
                    }
                    break;
                  case 4:
                    {
                      if (this.s[j] <= 0) {
                        this.s[j] = this.s[j] < 0 ? -this.s[j] : 0;
                        for (var He = 0; He <= X; He++)
                          this.V[He][j] = -this.V[He][j];
                      }
                      for (; j < X && !(this.s[j] >= this.s[j + 1]); ) {
                        var ht = this.s[j];
                        if (this.s[j] = this.s[j + 1], this.s[j + 1] = ht, j < this.n - 1)
                          for (var st = 0; st < this.n; st++)
                            ht = this.V[st][j + 1], this.V[st][j + 1] = this.V[st][j], this.V[st][j] = ht;
                        if (j < this.m - 1)
                          for (var Ue = 0; Ue < this.m; Ue++)
                            ht = this.U[Ue][j + 1], this.U[Ue][j + 1] = this.U[Ue][j], this.U[Ue][j] = ht;
                        j++;
                      }
                      S--;
                    }
                    break;
                }
              }
              var Et = { U: this.U, V: this.V, S: this.s };
              return Et;
            }, a.hypot = function(s, o) {
              var l = void 0;
              return Math.abs(s) > Math.abs(o) ? (l = o / s, l = Math.abs(s) * Math.sqrt(1 + l * l)) : o != 0 ? (l = s / o, l = Math.abs(o) * Math.sqrt(1 + l * l)) : l = 0, l;
            }, r.exports = a;
          }),
          /* 27 */
          /***/
          (function(r, n, i) {
            var a = /* @__PURE__ */ (function() {
              function l(u, h) {
                for (var d = 0; d < h.length; d++) {
                  var f = h[d];
                  f.enumerable = f.enumerable || !1, f.configurable = !0, "value" in f && (f.writable = !0), Object.defineProperty(u, f.key, f);
                }
              }
              return function(u, h, d) {
                return h && l(u.prototype, h), d && l(u, d), u;
              };
            })();
            function s(l, u) {
              if (!(l instanceof u))
                throw new TypeError("Cannot call a class as a function");
            }
            var o = (function() {
              function l(u, h) {
                var d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, f = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1, p = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1;
                s(this, l), this.sequence1 = u, this.sequence2 = h, this.match_score = d, this.mismatch_penalty = f, this.gap_penalty = p, this.iMax = u.length + 1, this.jMax = h.length + 1, this.grid = new Array(this.iMax);
                for (var g = 0; g < this.iMax; g++) {
                  this.grid[g] = new Array(this.jMax);
                  for (var m = 0; m < this.jMax; m++)
                    this.grid[g][m] = 0;
                }
                this.tracebackGrid = new Array(this.iMax);
                for (var v = 0; v < this.iMax; v++) {
                  this.tracebackGrid[v] = new Array(this.jMax);
                  for (var y = 0; y < this.jMax; y++)
                    this.tracebackGrid[v][y] = [null, null, null];
                }
                this.alignments = [], this.score = -1, this.computeGrids();
              }
              return a(l, [{
                key: "getScore",
                value: function() {
                  return this.score;
                }
              }, {
                key: "getAlignments",
                value: function() {
                  return this.alignments;
                }
                // Main dynamic programming procedure
              }, {
                key: "computeGrids",
                value: function() {
                  for (var h = 1; h < this.jMax; h++)
                    this.grid[0][h] = this.grid[0][h - 1] + this.gap_penalty, this.tracebackGrid[0][h] = [!1, !1, !0];
                  for (var d = 1; d < this.iMax; d++)
                    this.grid[d][0] = this.grid[d - 1][0] + this.gap_penalty, this.tracebackGrid[d][0] = [!1, !0, !1];
                  for (var f = 1; f < this.iMax; f++)
                    for (var p = 1; p < this.jMax; p++) {
                      var g = void 0;
                      this.sequence1[f - 1] === this.sequence2[p - 1] ? g = this.grid[f - 1][p - 1] + this.match_score : g = this.grid[f - 1][p - 1] + this.mismatch_penalty;
                      var m = this.grid[f - 1][p] + this.gap_penalty, v = this.grid[f][p - 1] + this.gap_penalty, y = [g, m, v], b = this.arrayAllMaxIndexes(y);
                      this.grid[f][p] = y[b[0]], this.tracebackGrid[f][p] = [b.includes(0), b.includes(1), b.includes(2)];
                    }
                  this.score = this.grid[this.iMax - 1][this.jMax - 1];
                }
                // Gets all possible valid sequence combinations
              }, {
                key: "alignmentTraceback",
                value: function() {
                  var h = [];
                  for (h.push({
                    pos: [this.sequence1.length, this.sequence2.length],
                    seq1: "",
                    seq2: ""
                  }); h[0]; ) {
                    var d = h[0], f = this.tracebackGrid[d.pos[0]][d.pos[1]];
                    f[0] && h.push({
                      pos: [d.pos[0] - 1, d.pos[1] - 1],
                      seq1: this.sequence1[d.pos[0] - 1] + d.seq1,
                      seq2: this.sequence2[d.pos[1] - 1] + d.seq2
                    }), f[1] && h.push({
                      pos: [d.pos[0] - 1, d.pos[1]],
                      seq1: this.sequence1[d.pos[0] - 1] + d.seq1,
                      seq2: "-" + d.seq2
                    }), f[2] && h.push({
                      pos: [d.pos[0], d.pos[1] - 1],
                      seq1: "-" + d.seq1,
                      seq2: this.sequence2[d.pos[1] - 1] + d.seq2
                    }), d.pos[0] === 0 && d.pos[1] === 0 && this.alignments.push({
                      sequence1: d.seq1,
                      sequence2: d.seq2
                    }), h.shift();
                  }
                  return this.alignments;
                }
                // Helper Functions
              }, {
                key: "getAllIndexes",
                value: function(h, d) {
                  for (var f = [], p = -1; (p = h.indexOf(d, p + 1)) !== -1; )
                    f.push(p);
                  return f;
                }
              }, {
                key: "arrayAllMaxIndexes",
                value: function(h) {
                  return this.getAllIndexes(h, Math.max.apply(null, h));
                }
              }]), l;
            })();
            r.exports = o;
          }),
          /* 28 */
          /***/
          (function(r, n, i) {
            var a = function() {
            };
            a.FDLayout = i(18), a.FDLayoutConstants = i(4), a.FDLayoutEdge = i(19), a.FDLayoutNode = i(20), a.DimensionD = i(21), a.HashMap = i(22), a.HashSet = i(23), a.IGeometry = i(8), a.IMath = i(9), a.Integer = i(10), a.Point = i(12), a.PointD = i(5), a.RandomSeed = i(16), a.RectangleD = i(13), a.Transform = i(17), a.UniqueIDGeneretor = i(14), a.Quicksort = i(25), a.LinkedList = i(11), a.LGraphObject = i(2), a.LGraph = i(6), a.LEdge = i(1), a.LGraphManager = i(7), a.LNode = i(3), a.Layout = i(15), a.LayoutConstants = i(0), a.NeedlemanWunsch = i(27), a.Matrix = i(24), a.SVD = i(26), r.exports = a;
          }),
          /* 29 */
          /***/
          (function(r, n, i) {
            function a() {
              this.listeners = [];
            }
            var s = a.prototype;
            s.addListener = function(o, l) {
              this.listeners.push({
                event: o,
                callback: l
              });
            }, s.removeListener = function(o, l) {
              for (var u = this.listeners.length; u >= 0; u--) {
                var h = this.listeners[u];
                h.event === o && h.callback === l && this.listeners.splice(u, 1);
              }
            }, s.emit = function(o, l) {
              for (var u = 0; u < this.listeners.length; u++) {
                var h = this.listeners[u];
                o === h.event && h.callback(l);
              }
            }, r.exports = a;
          })
          /******/
        ])
      );
    });
  })(Ev)), Ev.exports;
}
var e$e = Tv.exports, fI;
function t$e() {
  return fI || (fI = 1, (function(t, e) {
    (function(n, i) {
      t.exports = i(JFe());
    })(e$e, function(r) {
      return (
        /******/
        (() => {
          var n = {
            /***/
            45: (
              /***/
              ((o, l, u) => {
                var h = {};
                h.layoutBase = u(551), h.CoSEConstants = u(806), h.CoSEEdge = u(767), h.CoSEGraph = u(880), h.CoSEGraphManager = u(578), h.CoSELayout = u(765), h.CoSENode = u(991), h.ConstraintHandler = u(902), o.exports = h;
              })
            ),
            /***/
            806: (
              /***/
              ((o, l, u) => {
                var h = u(551).FDLayoutConstants;
                function d() {
                }
                for (var f in h)
                  d[f] = h[f];
                d.DEFAULT_USE_MULTI_LEVEL_SCALING = !1, d.DEFAULT_RADIAL_SEPARATION = h.DEFAULT_EDGE_LENGTH, d.DEFAULT_COMPONENT_SEPERATION = 60, d.TILE = !0, d.TILING_PADDING_VERTICAL = 10, d.TILING_PADDING_HORIZONTAL = 10, d.TRANSFORM_ON_CONSTRAINT_HANDLING = !0, d.ENFORCE_CONSTRAINTS = !0, d.APPLY_LAYOUT = !0, d.RELAX_MOVEMENT_ON_CONSTRAINTS = !0, d.TREE_REDUCTION_ON_INCREMENTAL = !0, d.PURE_INCREMENTAL = d.DEFAULT_INCREMENTAL, o.exports = d;
              })
            ),
            /***/
            767: (
              /***/
              ((o, l, u) => {
                var h = u(551).FDLayoutEdge;
                function d(p, g, m) {
                  h.call(this, p, g, m);
                }
                d.prototype = Object.create(h.prototype);
                for (var f in h)
                  d[f] = h[f];
                o.exports = d;
              })
            ),
            /***/
            880: (
              /***/
              ((o, l, u) => {
                var h = u(551).LGraph;
                function d(p, g, m) {
                  h.call(this, p, g, m);
                }
                d.prototype = Object.create(h.prototype);
                for (var f in h)
                  d[f] = h[f];
                o.exports = d;
              })
            ),
            /***/
            578: (
              /***/
              ((o, l, u) => {
                var h = u(551).LGraphManager;
                function d(p) {
                  h.call(this, p);
                }
                d.prototype = Object.create(h.prototype);
                for (var f in h)
                  d[f] = h[f];
                o.exports = d;
              })
            ),
            /***/
            765: (
              /***/
              ((o, l, u) => {
                var h = u(551).FDLayout, d = u(578), f = u(880), p = u(991), g = u(767), m = u(806), v = u(902), y = u(551).FDLayoutConstants, b = u(551).LayoutConstants, w = u(551).Point, T = u(551).PointD, E = u(551).DimensionD, L = u(551).Layout, k = u(551).Integer, C = u(551).IGeometry, A = u(551).LGraph, R = u(551).Transform, _ = u(551).LinkedList;
                function O() {
                  h.call(this), this.toBeTiled = {}, this.constraints = {};
                }
                O.prototype = Object.create(h.prototype);
                for (var P in h)
                  O[P] = h[P];
                O.prototype.newGraphManager = function() {
                  var S = new d(this);
                  return this.graphManager = S, S;
                }, O.prototype.newGraph = function(S) {
                  return new f(null, this.graphManager, S);
                }, O.prototype.newNode = function(S) {
                  return new p(this.graphManager, S);
                }, O.prototype.newEdge = function(S) {
                  return new g(null, null, S);
                }, O.prototype.initParameters = function() {
                  h.prototype.initParameters.call(this, arguments), this.isSubLayout || (m.DEFAULT_EDGE_LENGTH < 10 ? this.idealEdgeLength = 10 : this.idealEdgeLength = m.DEFAULT_EDGE_LENGTH, this.useSmartIdealEdgeLengthCalculation = m.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION, this.gravityConstant = y.DEFAULT_GRAVITY_STRENGTH, this.compoundGravityConstant = y.DEFAULT_COMPOUND_GRAVITY_STRENGTH, this.gravityRangeFactor = y.DEFAULT_GRAVITY_RANGE_FACTOR, this.compoundGravityRangeFactor = y.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR, this.prunedNodesAll = [], this.growTreeIterations = 0, this.afterGrowthIterations = 0, this.isTreeGrowing = !1, this.isGrowthFinished = !1);
                }, O.prototype.initSpringEmbedder = function() {
                  h.prototype.initSpringEmbedder.call(this), this.coolingCycle = 0, this.maxCoolingCycle = this.maxIterations / y.CONVERGENCE_CHECK_PERIOD, this.finalTemperature = 0.04, this.coolingAdjuster = 1;
                }, O.prototype.layout = function() {
                  var S = b.DEFAULT_CREATE_BENDS_AS_NEEDED;
                  return S && (this.createBendpoints(), this.graphManager.resetAllEdges()), this.level = 0, this.classicLayout();
                }, O.prototype.classicLayout = function() {
                  if (this.nodesWithGravity = this.calculateNodesToApplyGravitationTo(), this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity), this.calcNoOfChildrenForAllNodes(), this.graphManager.calcLowestCommonAncestors(), this.graphManager.calcInclusionTreeDepths(), this.graphManager.getRoot().calcEstimatedSize(), this.calcIdealEdgeLengths(), this.incremental) {
                    if (m.TREE_REDUCTION_ON_INCREMENTAL) {
                      this.reduceTrees(), this.graphManager.resetAllNodesToApplyGravitation();
                      var M = new Set(this.getAllNodes()), N = this.nodesWithGravity.filter(function(B) {
                        return M.has(B);
                      });
                      this.graphManager.setAllNodesToApplyGravitation(N);
                    }
                  } else {
                    var S = this.getFlatForest();
                    if (S.length > 0)
                      this.positionNodesRadially(S);
                    else {
                      this.reduceTrees(), this.graphManager.resetAllNodesToApplyGravitation();
                      var M = new Set(this.getAllNodes()), N = this.nodesWithGravity.filter(function(D) {
                        return M.has(D);
                      });
                      this.graphManager.setAllNodesToApplyGravitation(N), this.positionNodesRandomly();
                    }
                  }
                  return Object.keys(this.constraints).length > 0 && (v.handleConstraints(this), this.initConstraintVariables()), this.initSpringEmbedder(), m.APPLY_LAYOUT && this.runSpringEmbedder(), !0;
                }, O.prototype.tick = function() {
                  if (this.totalIterations++, this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished)
                    if (this.prunedNodesAll.length > 0)
                      this.isTreeGrowing = !0;
                    else
                      return !0;
                  if (this.totalIterations % y.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {
                    if (this.isConverged())
                      if (this.prunedNodesAll.length > 0)
                        this.isTreeGrowing = !0;
                      else
                        return !0;
                    this.coolingCycle++, this.layoutQuality == 0 ? this.coolingAdjuster = this.coolingCycle : this.layoutQuality == 1 && (this.coolingAdjuster = this.coolingCycle / 3), this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature), this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));
                  }
                  if (this.isTreeGrowing) {
                    if (this.growTreeIterations % 10 == 0)
                      if (this.prunedNodesAll.length > 0) {
                        this.graphManager.updateBounds(), this.updateGrid(), this.growTree(this.prunedNodesAll), this.graphManager.resetAllNodesToApplyGravitation();
                        var S = new Set(this.getAllNodes()), M = this.nodesWithGravity.filter(function(I) {
                          return S.has(I);
                        });
                        this.graphManager.setAllNodesToApplyGravitation(M), this.graphManager.updateBounds(), this.updateGrid(), m.PURE_INCREMENTAL ? this.coolingFactor = y.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 : this.coolingFactor = y.DEFAULT_COOLING_FACTOR_INCREMENTAL;
                      } else
                        this.isTreeGrowing = !1, this.isGrowthFinished = !0;
                    this.growTreeIterations++;
                  }
                  if (this.isGrowthFinished) {
                    if (this.isConverged())
                      return !0;
                    this.afterGrowthIterations % 10 == 0 && (this.graphManager.updateBounds(), this.updateGrid()), m.PURE_INCREMENTAL ? this.coolingFactor = y.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 * ((100 - this.afterGrowthIterations) / 100) : this.coolingFactor = y.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100), this.afterGrowthIterations++;
                  }
                  var N = !this.isTreeGrowing && !this.isGrowthFinished, D = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;
                  return this.totalDisplacement = 0, this.graphManager.updateBounds(), this.calcSpringForces(), this.calcRepulsionForces(N, D), this.calcGravitationalForces(), this.moveNodes(), this.animate(), !1;
                }, O.prototype.getPositionsData = function() {
                  for (var S = this.graphManager.getAllNodes(), M = {}, N = 0; N < S.length; N++) {
                    var D = S[N].rect, I = S[N].id;
                    M[I] = {
                      id: I,
                      x: D.getCenterX(),
                      y: D.getCenterY(),
                      w: D.width,
                      h: D.height
                    };
                  }
                  return M;
                }, O.prototype.runSpringEmbedder = function() {
                  this.initialAnimationPeriod = 25, this.animationPeriod = this.initialAnimationPeriod;
                  var S = !1;
                  if (y.ANIMATE === "during")
                    this.emit("layoutstarted");
                  else {
                    for (; !S; )
                      S = this.tick();
                    this.graphManager.updateBounds();
                  }
                }, O.prototype.moveNodes = function() {
                  for (var S = this.getAllNodes(), M, N = 0; N < S.length; N++)
                    M = S[N], M.calculateDisplacement();
                  Object.keys(this.constraints).length > 0 && this.updateDisplacements();
                  for (var N = 0; N < S.length; N++)
                    M = S[N], M.move();
                }, O.prototype.initConstraintVariables = function() {
                  var S = this;
                  this.idToNodeMap = /* @__PURE__ */ new Map(), this.fixedNodeSet = /* @__PURE__ */ new Set();
                  for (var M = this.graphManager.getAllNodes(), N = 0; N < M.length; N++) {
                    var D = M[N];
                    this.idToNodeMap.set(D.id, D);
                  }
                  var I = function K(Z) {
                    for (var X = Z.getChild().getNodes(), Y, ee = 0, j = 0; j < X.length; j++)
                      Y = X[j], Y.getChild() == null ? S.fixedNodeSet.has(Y.id) && (ee += 100) : ee += K(Y);
                    return ee;
                  };
                  if (this.constraints.fixedNodeConstraint) {
                    this.constraints.fixedNodeConstraint.forEach(function(X) {
                      S.fixedNodeSet.add(X.nodeId);
                    });
                    for (var M = this.graphManager.getAllNodes(), D, N = 0; N < M.length; N++)
                      if (D = M[N], D.getChild() != null) {
                        var B = I(D);
                        B > 0 && (D.fixedNodeWeight = B);
                      }
                  }
                  if (this.constraints.relativePlacementConstraint) {
                    var z = /* @__PURE__ */ new Map(), F = /* @__PURE__ */ new Map();
                    if (this.dummyToNodeForVerticalAlignment = /* @__PURE__ */ new Map(), this.dummyToNodeForHorizontalAlignment = /* @__PURE__ */ new Map(), this.fixedNodesOnHorizontal = /* @__PURE__ */ new Set(), this.fixedNodesOnVertical = /* @__PURE__ */ new Set(), this.fixedNodeSet.forEach(function(K) {
                      S.fixedNodesOnHorizontal.add(K), S.fixedNodesOnVertical.add(K);
                    }), this.constraints.alignmentConstraint) {
                      if (this.constraints.alignmentConstraint.vertical)
                        for (var V = this.constraints.alignmentConstraint.vertical, N = 0; N < V.length; N++)
                          this.dummyToNodeForVerticalAlignment.set("dummy" + N, []), V[N].forEach(function(Z) {
                            z.set(Z, "dummy" + N), S.dummyToNodeForVerticalAlignment.get("dummy" + N).push(Z), S.fixedNodeSet.has(Z) && S.fixedNodesOnHorizontal.add("dummy" + N);
                          });
                      if (this.constraints.alignmentConstraint.horizontal)
                        for (var H = this.constraints.alignmentConstraint.horizontal, N = 0; N < H.length; N++)
                          this.dummyToNodeForHorizontalAlignment.set("dummy" + N, []), H[N].forEach(function(Z) {
                            F.set(Z, "dummy" + N), S.dummyToNodeForHorizontalAlignment.get("dummy" + N).push(Z), S.fixedNodeSet.has(Z) && S.fixedNodesOnVertical.add("dummy" + N);
                          });
                    }
                    if (m.RELAX_MOVEMENT_ON_CONSTRAINTS)
                      this.shuffle = function(K) {
                        var Z, X, Y;
                        for (Y = K.length - 1; Y >= 2 * K.length / 3; Y--)
                          Z = Math.floor(Math.random() * (Y + 1)), X = K[Y], K[Y] = K[Z], K[Z] = X;
                        return K;
                      }, this.nodesInRelativeHorizontal = [], this.nodesInRelativeVertical = [], this.nodeToRelativeConstraintMapHorizontal = /* @__PURE__ */ new Map(), this.nodeToRelativeConstraintMapVertical = /* @__PURE__ */ new Map(), this.nodeToTempPositionMapHorizontal = /* @__PURE__ */ new Map(), this.nodeToTempPositionMapVertical = /* @__PURE__ */ new Map(), this.constraints.relativePlacementConstraint.forEach(function(K) {
                        if (K.left) {
                          var Z = z.has(K.left) ? z.get(K.left) : K.left, X = z.has(K.right) ? z.get(K.right) : K.right;
                          S.nodesInRelativeHorizontal.includes(Z) || (S.nodesInRelativeHorizontal.push(Z), S.nodeToRelativeConstraintMapHorizontal.set(Z, []), S.dummyToNodeForVerticalAlignment.has(Z) ? S.nodeToTempPositionMapHorizontal.set(Z, S.idToNodeMap.get(S.dummyToNodeForVerticalAlignment.get(Z)[0]).getCenterX()) : S.nodeToTempPositionMapHorizontal.set(Z, S.idToNodeMap.get(Z).getCenterX())), S.nodesInRelativeHorizontal.includes(X) || (S.nodesInRelativeHorizontal.push(X), S.nodeToRelativeConstraintMapHorizontal.set(X, []), S.dummyToNodeForVerticalAlignment.has(X) ? S.nodeToTempPositionMapHorizontal.set(X, S.idToNodeMap.get(S.dummyToNodeForVerticalAlignment.get(X)[0]).getCenterX()) : S.nodeToTempPositionMapHorizontal.set(X, S.idToNodeMap.get(X).getCenterX())), S.nodeToRelativeConstraintMapHorizontal.get(Z).push({ right: X, gap: K.gap }), S.nodeToRelativeConstraintMapHorizontal.get(X).push({ left: Z, gap: K.gap });
                        } else {
                          var Y = F.has(K.top) ? F.get(K.top) : K.top, ee = F.has(K.bottom) ? F.get(K.bottom) : K.bottom;
                          S.nodesInRelativeVertical.includes(Y) || (S.nodesInRelativeVertical.push(Y), S.nodeToRelativeConstraintMapVertical.set(Y, []), S.dummyToNodeForHorizontalAlignment.has(Y) ? S.nodeToTempPositionMapVertical.set(Y, S.idToNodeMap.get(S.dummyToNodeForHorizontalAlignment.get(Y)[0]).getCenterY()) : S.nodeToTempPositionMapVertical.set(Y, S.idToNodeMap.get(Y).getCenterY())), S.nodesInRelativeVertical.includes(ee) || (S.nodesInRelativeVertical.push(ee), S.nodeToRelativeConstraintMapVertical.set(ee, []), S.dummyToNodeForHorizontalAlignment.has(ee) ? S.nodeToTempPositionMapVertical.set(ee, S.idToNodeMap.get(S.dummyToNodeForHorizontalAlignment.get(ee)[0]).getCenterY()) : S.nodeToTempPositionMapVertical.set(ee, S.idToNodeMap.get(ee).getCenterY())), S.nodeToRelativeConstraintMapVertical.get(Y).push({ bottom: ee, gap: K.gap }), S.nodeToRelativeConstraintMapVertical.get(ee).push({ top: Y, gap: K.gap });
                        }
                      });
                    else {
                      var J = /* @__PURE__ */ new Map(), q = /* @__PURE__ */ new Map();
                      this.constraints.relativePlacementConstraint.forEach(function(K) {
                        if (K.left) {
                          var Z = z.has(K.left) ? z.get(K.left) : K.left, X = z.has(K.right) ? z.get(K.right) : K.right;
                          J.has(Z) ? J.get(Z).push(X) : J.set(Z, [X]), J.has(X) ? J.get(X).push(Z) : J.set(X, [Z]);
                        } else {
                          var Y = F.has(K.top) ? F.get(K.top) : K.top, ee = F.has(K.bottom) ? F.get(K.bottom) : K.bottom;
                          q.has(Y) ? q.get(Y).push(ee) : q.set(Y, [ee]), q.has(ee) ? q.get(ee).push(Y) : q.set(ee, [Y]);
                        }
                      });
                      var ae = function(Z, X) {
                        var Y = [], ee = [], j = new _(), fe = /* @__PURE__ */ new Set(), te = 0;
                        return Z.forEach(function(Ae, W) {
                          if (!fe.has(W)) {
                            Y[te] = [], ee[te] = !1;
                            var De = W;
                            for (j.push(De), fe.add(De), Y[te].push(De); j.length != 0; ) {
                              De = j.shift(), X.has(De) && (ee[te] = !0);
                              var ue = Z.get(De);
                              ue.forEach(function(ze) {
                                fe.has(ze) || (j.push(ze), fe.add(ze), Y[te].push(ze));
                              });
                            }
                            te++;
                          }
                        }), { components: Y, isFixed: ee };
                      }, re = ae(J, S.fixedNodesOnHorizontal);
                      this.componentsOnHorizontal = re.components, this.fixedComponentsOnHorizontal = re.isFixed;
                      var pe = ae(q, S.fixedNodesOnVertical);
                      this.componentsOnVertical = pe.components, this.fixedComponentsOnVertical = pe.isFixed;
                    }
                  }
                }, O.prototype.updateDisplacements = function() {
                  var S = this;
                  if (this.constraints.fixedNodeConstraint && this.constraints.fixedNodeConstraint.forEach(function(pe) {
                    var K = S.idToNodeMap.get(pe.nodeId);
                    K.displacementX = 0, K.displacementY = 0;
                  }), this.constraints.alignmentConstraint) {
                    if (this.constraints.alignmentConstraint.vertical)
                      for (var M = this.constraints.alignmentConstraint.vertical, N = 0; N < M.length; N++) {
                        for (var D = 0, I = 0; I < M[N].length; I++) {
                          if (this.fixedNodeSet.has(M[N][I])) {
                            D = 0;
                            break;
                          }
                          D += this.idToNodeMap.get(M[N][I]).displacementX;
                        }
                        for (var B = D / M[N].length, I = 0; I < M[N].length; I++)
                          this.idToNodeMap.get(M[N][I]).displacementX = B;
                      }
                    if (this.constraints.alignmentConstraint.horizontal)
                      for (var z = this.constraints.alignmentConstraint.horizontal, N = 0; N < z.length; N++) {
                        for (var F = 0, I = 0; I < z[N].length; I++) {
                          if (this.fixedNodeSet.has(z[N][I])) {
                            F = 0;
                            break;
                          }
                          F += this.idToNodeMap.get(z[N][I]).displacementY;
                        }
                        for (var V = F / z[N].length, I = 0; I < z[N].length; I++)
                          this.idToNodeMap.get(z[N][I]).displacementY = V;
                      }
                  }
                  if (this.constraints.relativePlacementConstraint)
                    if (m.RELAX_MOVEMENT_ON_CONSTRAINTS)
                      this.totalIterations % 10 == 0 && (this.shuffle(this.nodesInRelativeHorizontal), this.shuffle(this.nodesInRelativeVertical)), this.nodesInRelativeHorizontal.forEach(function(pe) {
                        if (!S.fixedNodesOnHorizontal.has(pe)) {
                          var K = 0;
                          S.dummyToNodeForVerticalAlignment.has(pe) ? K = S.idToNodeMap.get(S.dummyToNodeForVerticalAlignment.get(pe)[0]).displacementX : K = S.idToNodeMap.get(pe).displacementX, S.nodeToRelativeConstraintMapHorizontal.get(pe).forEach(function(Z) {
                            if (Z.right) {
                              var X = S.nodeToTempPositionMapHorizontal.get(Z.right) - S.nodeToTempPositionMapHorizontal.get(pe) - K;
                              X < Z.gap && (K -= Z.gap - X);
                            } else {
                              var X = S.nodeToTempPositionMapHorizontal.get(pe) - S.nodeToTempPositionMapHorizontal.get(Z.left) + K;
                              X < Z.gap && (K += Z.gap - X);
                            }
                          }), S.nodeToTempPositionMapHorizontal.set(pe, S.nodeToTempPositionMapHorizontal.get(pe) + K), S.dummyToNodeForVerticalAlignment.has(pe) ? S.dummyToNodeForVerticalAlignment.get(pe).forEach(function(Z) {
                            S.idToNodeMap.get(Z).displacementX = K;
                          }) : S.idToNodeMap.get(pe).displacementX = K;
                        }
                      }), this.nodesInRelativeVertical.forEach(function(pe) {
                        if (!S.fixedNodesOnHorizontal.has(pe)) {
                          var K = 0;
                          S.dummyToNodeForHorizontalAlignment.has(pe) ? K = S.idToNodeMap.get(S.dummyToNodeForHorizontalAlignment.get(pe)[0]).displacementY : K = S.idToNodeMap.get(pe).displacementY, S.nodeToRelativeConstraintMapVertical.get(pe).forEach(function(Z) {
                            if (Z.bottom) {
                              var X = S.nodeToTempPositionMapVertical.get(Z.bottom) - S.nodeToTempPositionMapVertical.get(pe) - K;
                              X < Z.gap && (K -= Z.gap - X);
                            } else {
                              var X = S.nodeToTempPositionMapVertical.get(pe) - S.nodeToTempPositionMapVertical.get(Z.top) + K;
                              X < Z.gap && (K += Z.gap - X);
                            }
                          }), S.nodeToTempPositionMapVertical.set(pe, S.nodeToTempPositionMapVertical.get(pe) + K), S.dummyToNodeForHorizontalAlignment.has(pe) ? S.dummyToNodeForHorizontalAlignment.get(pe).forEach(function(Z) {
                            S.idToNodeMap.get(Z).displacementY = K;
                          }) : S.idToNodeMap.get(pe).displacementY = K;
                        }
                      });
                    else {
                      for (var N = 0; N < this.componentsOnHorizontal.length; N++) {
                        var H = this.componentsOnHorizontal[N];
                        if (this.fixedComponentsOnHorizontal[N])
                          for (var I = 0; I < H.length; I++)
                            this.dummyToNodeForVerticalAlignment.has(H[I]) ? this.dummyToNodeForVerticalAlignment.get(H[I]).forEach(function(Z) {
                              S.idToNodeMap.get(Z).displacementX = 0;
                            }) : this.idToNodeMap.get(H[I]).displacementX = 0;
                        else {
                          for (var J = 0, q = 0, I = 0; I < H.length; I++)
                            if (this.dummyToNodeForVerticalAlignment.has(H[I])) {
                              var ae = this.dummyToNodeForVerticalAlignment.get(H[I]);
                              J += ae.length * this.idToNodeMap.get(ae[0]).displacementX, q += ae.length;
                            } else
                              J += this.idToNodeMap.get(H[I]).displacementX, q++;
                          for (var re = J / q, I = 0; I < H.length; I++)
                            this.dummyToNodeForVerticalAlignment.has(H[I]) ? this.dummyToNodeForVerticalAlignment.get(H[I]).forEach(function(Z) {
                              S.idToNodeMap.get(Z).displacementX = re;
                            }) : this.idToNodeMap.get(H[I]).displacementX = re;
                        }
                      }
                      for (var N = 0; N < this.componentsOnVertical.length; N++) {
                        var H = this.componentsOnVertical[N];
                        if (this.fixedComponentsOnVertical[N])
                          for (var I = 0; I < H.length; I++)
                            this.dummyToNodeForHorizontalAlignment.has(H[I]) ? this.dummyToNodeForHorizontalAlignment.get(H[I]).forEach(function(X) {
                              S.idToNodeMap.get(X).displacementY = 0;
                            }) : this.idToNodeMap.get(H[I]).displacementY = 0;
                        else {
                          for (var J = 0, q = 0, I = 0; I < H.length; I++)
                            if (this.dummyToNodeForHorizontalAlignment.has(H[I])) {
                              var ae = this.dummyToNodeForHorizontalAlignment.get(H[I]);
                              J += ae.length * this.idToNodeMap.get(ae[0]).displacementY, q += ae.length;
                            } else
                              J += this.idToNodeMap.get(H[I]).displacementY, q++;
                          for (var re = J / q, I = 0; I < H.length; I++)
                            this.dummyToNodeForHorizontalAlignment.has(H[I]) ? this.dummyToNodeForHorizontalAlignment.get(H[I]).forEach(function(j) {
                              S.idToNodeMap.get(j).displacementY = re;
                            }) : this.idToNodeMap.get(H[I]).displacementY = re;
                        }
                      }
                    }
                }, O.prototype.calculateNodesToApplyGravitationTo = function() {
                  var S = [], M, N = this.graphManager.getGraphs(), D = N.length, I;
                  for (I = 0; I < D; I++)
                    M = N[I], M.updateConnected(), M.isConnected || (S = S.concat(M.getNodes()));
                  return S;
                }, O.prototype.createBendpoints = function() {
                  var S = [];
                  S = S.concat(this.graphManager.getAllEdges());
                  var M = /* @__PURE__ */ new Set(), N;
                  for (N = 0; N < S.length; N++) {
                    var D = S[N];
                    if (!M.has(D)) {
                      var I = D.getSource(), B = D.getTarget();
                      if (I == B)
                        D.getBendpoints().push(new T()), D.getBendpoints().push(new T()), this.createDummyNodesForBendpoints(D), M.add(D);
                      else {
                        var z = [];
                        if (z = z.concat(I.getEdgeListToNode(B)), z = z.concat(B.getEdgeListToNode(I)), !M.has(z[0])) {
                          if (z.length > 1) {
                            var F;
                            for (F = 0; F < z.length; F++) {
                              var V = z[F];
                              V.getBendpoints().push(new T()), this.createDummyNodesForBendpoints(V);
                            }
                          }
                          z.forEach(function(H) {
                            M.add(H);
                          });
                        }
                      }
                    }
                    if (M.size == S.length)
                      break;
                  }
                }, O.prototype.positionNodesRadially = function(S) {
                  for (var M = new w(0, 0), N = Math.ceil(Math.sqrt(S.length)), D = 0, I = 0, B = 0, z = new T(0, 0), F = 0; F < S.length; F++) {
                    F % N == 0 && (B = 0, I = D, F != 0 && (I += m.DEFAULT_COMPONENT_SEPERATION), D = 0);
                    var V = S[F], H = L.findCenterOfTree(V);
                    M.x = B, M.y = I, z = O.radialLayout(V, H, M), z.y > D && (D = Math.floor(z.y)), B = Math.floor(z.x + m.DEFAULT_COMPONENT_SEPERATION);
                  }
                  this.transform(new T(b.WORLD_CENTER_X - z.x / 2, b.WORLD_CENTER_Y - z.y / 2));
                }, O.radialLayout = function(S, M, N) {
                  var D = Math.max(this.maxDiagonalInTree(S), m.DEFAULT_RADIAL_SEPARATION);
                  O.branchRadialLayout(M, null, 0, 359, 0, D);
                  var I = A.calculateBounds(S), B = new R();
                  B.setDeviceOrgX(I.getMinX()), B.setDeviceOrgY(I.getMinY()), B.setWorldOrgX(N.x), B.setWorldOrgY(N.y);
                  for (var z = 0; z < S.length; z++) {
                    var F = S[z];
                    F.transform(B);
                  }
                  var V = new T(I.getMaxX(), I.getMaxY());
                  return B.inverseTransformPoint(V);
                }, O.branchRadialLayout = function(S, M, N, D, I, B) {
                  var z = (D - N + 1) / 2;
                  z < 0 && (z += 180);
                  var F = (z + N) % 360, V = F * C.TWO_PI / 360, H = I * Math.cos(V), J = I * Math.sin(V);
                  S.setCenter(H, J);
                  var q = [];
                  q = q.concat(S.getEdges());
                  var ae = q.length;
                  M != null && ae--;
                  for (var re = 0, pe = q.length, K, Z = S.getEdgesBetween(M); Z.length > 1; ) {
                    var X = Z[0];
                    Z.splice(0, 1);
                    var Y = q.indexOf(X);
                    Y >= 0 && q.splice(Y, 1), pe--, ae--;
                  }
                  M != null ? K = (q.indexOf(Z[0]) + 1) % pe : K = 0;
                  for (var ee = Math.abs(D - N) / ae, j = K; re != ae; j = ++j % pe) {
                    var fe = q[j].getOtherEnd(S);
                    if (fe != M) {
                      var te = (N + re * ee) % 360, Ae = (te + ee) % 360;
                      O.branchRadialLayout(fe, S, te, Ae, I + B, B), re++;
                    }
                  }
                }, O.maxDiagonalInTree = function(S) {
                  for (var M = k.MIN_VALUE, N = 0; N < S.length; N++) {
                    var D = S[N], I = D.getDiagonal();
                    I > M && (M = I);
                  }
                  return M;
                }, O.prototype.calcRepulsionRange = function() {
                  return 2 * (this.level + 1) * this.idealEdgeLength;
                }, O.prototype.groupZeroDegreeMembers = function() {
                  var S = this, M = {};
                  this.memberGroups = {}, this.idToDummyNode = {};
                  for (var N = [], D = this.graphManager.getAllNodes(), I = 0; I < D.length; I++) {
                    var B = D[I], z = B.getParent();
                    this.getNodeDegreeWithChildren(B) === 0 && (z.id == null || !this.getToBeTiled(z)) && N.push(B);
                  }
                  for (var I = 0; I < N.length; I++) {
                    var B = N[I], F = B.getParent().id;
                    typeof M[F] > "u" && (M[F] = []), M[F] = M[F].concat(B);
                  }
                  Object.keys(M).forEach(function(V) {
                    if (M[V].length > 1) {
                      var H = "DummyCompound_" + V;
                      S.memberGroups[H] = M[V];
                      var J = M[V][0].getParent(), q = new p(S.graphManager);
                      q.id = H, q.paddingLeft = J.paddingLeft || 0, q.paddingRight = J.paddingRight || 0, q.paddingBottom = J.paddingBottom || 0, q.paddingTop = J.paddingTop || 0, S.idToDummyNode[H] = q;
                      var ae = S.getGraphManager().add(S.newGraph(), q), re = J.getChild();
                      re.add(q);
                      for (var pe = 0; pe < M[V].length; pe++) {
                        var K = M[V][pe];
                        re.remove(K), ae.add(K);
                      }
                    }
                  });
                }, O.prototype.clearCompounds = function() {
                  var S = {}, M = {};
                  this.performDFSOnCompounds();
                  for (var N = 0; N < this.compoundOrder.length; N++)
                    M[this.compoundOrder[N].id] = this.compoundOrder[N], S[this.compoundOrder[N].id] = [].concat(this.compoundOrder[N].getChild().getNodes()), this.graphManager.remove(this.compoundOrder[N].getChild()), this.compoundOrder[N].child = null;
                  this.graphManager.resetAllNodes(), this.tileCompoundMembers(S, M);
                }, O.prototype.clearZeroDegreeMembers = function() {
                  var S = this, M = this.tiledZeroDegreePack = [];
                  Object.keys(this.memberGroups).forEach(function(N) {
                    var D = S.idToDummyNode[N];
                    if (M[N] = S.tileNodes(S.memberGroups[N], D.paddingLeft + D.paddingRight), D.rect.width = M[N].width, D.rect.height = M[N].height, D.setCenter(M[N].centerX, M[N].centerY), D.labelMarginLeft = 0, D.labelMarginTop = 0, m.NODE_DIMENSIONS_INCLUDE_LABELS) {
                      var I = D.rect.width, B = D.rect.height;
                      D.labelWidth && (D.labelPosHorizontal == "left" ? (D.rect.x -= D.labelWidth, D.setWidth(I + D.labelWidth), D.labelMarginLeft = D.labelWidth) : D.labelPosHorizontal == "center" && D.labelWidth > I ? (D.rect.x -= (D.labelWidth - I) / 2, D.setWidth(D.labelWidth), D.labelMarginLeft = (D.labelWidth - I) / 2) : D.labelPosHorizontal == "right" && D.setWidth(I + D.labelWidth)), D.labelHeight && (D.labelPosVertical == "top" ? (D.rect.y -= D.labelHeight, D.setHeight(B + D.labelHeight), D.labelMarginTop = D.labelHeight) : D.labelPosVertical == "center" && D.labelHeight > B ? (D.rect.y -= (D.labelHeight - B) / 2, D.setHeight(D.labelHeight), D.labelMarginTop = (D.labelHeight - B) / 2) : D.labelPosVertical == "bottom" && D.setHeight(B + D.labelHeight));
                    }
                  });
                }, O.prototype.repopulateCompounds = function() {
                  for (var S = this.compoundOrder.length - 1; S >= 0; S--) {
                    var M = this.compoundOrder[S], N = M.id, D = M.paddingLeft, I = M.paddingTop, B = M.labelMarginLeft, z = M.labelMarginTop;
                    this.adjustLocations(this.tiledMemberPack[N], M.rect.x, M.rect.y, D, I, B, z);
                  }
                }, O.prototype.repopulateZeroDegreeMembers = function() {
                  var S = this, M = this.tiledZeroDegreePack;
                  Object.keys(M).forEach(function(N) {
                    var D = S.idToDummyNode[N], I = D.paddingLeft, B = D.paddingTop, z = D.labelMarginLeft, F = D.labelMarginTop;
                    S.adjustLocations(M[N], D.rect.x, D.rect.y, I, B, z, F);
                  });
                }, O.prototype.getToBeTiled = function(S) {
                  var M = S.id;
                  if (this.toBeTiled[M] != null)
                    return this.toBeTiled[M];
                  var N = S.getChild();
                  if (N == null)
                    return this.toBeTiled[M] = !1, !1;
                  for (var D = N.getNodes(), I = 0; I < D.length; I++) {
                    var B = D[I];
                    if (this.getNodeDegree(B) > 0)
                      return this.toBeTiled[M] = !1, !1;
                    if (B.getChild() == null) {
                      this.toBeTiled[B.id] = !1;
                      continue;
                    }
                    if (!this.getToBeTiled(B))
                      return this.toBeTiled[M] = !1, !1;
                  }
                  return this.toBeTiled[M] = !0, !0;
                }, O.prototype.getNodeDegree = function(S) {
                  S.id;
                  for (var M = S.getEdges(), N = 0, D = 0; D < M.length; D++) {
                    var I = M[D];
                    I.getSource().id !== I.getTarget().id && (N = N + 1);
                  }
                  return N;
                }, O.prototype.getNodeDegreeWithChildren = function(S) {
                  var M = this.getNodeDegree(S);
                  if (S.getChild() == null)
                    return M;
                  for (var N = S.getChild().getNodes(), D = 0; D < N.length; D++) {
                    var I = N[D];
                    M += this.getNodeDegreeWithChildren(I);
                  }
                  return M;
                }, O.prototype.performDFSOnCompounds = function() {
                  this.compoundOrder = [], this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());
                }, O.prototype.fillCompexOrderByDFS = function(S) {
                  for (var M = 0; M < S.length; M++) {
                    var N = S[M];
                    N.getChild() != null && this.fillCompexOrderByDFS(N.getChild().getNodes()), this.getToBeTiled(N) && this.compoundOrder.push(N);
                  }
                }, O.prototype.adjustLocations = function(S, M, N, D, I, B, z) {
                  M += D + B, N += I + z;
                  for (var F = M, V = 0; V < S.rows.length; V++) {
                    var H = S.rows[V];
                    M = F;
                    for (var J = 0, q = 0; q < H.length; q++) {
                      var ae = H[q];
                      ae.rect.x = M, ae.rect.y = N, M += ae.rect.width + S.horizontalPadding, ae.rect.height > J && (J = ae.rect.height);
                    }
                    N += J + S.verticalPadding;
                  }
                }, O.prototype.tileCompoundMembers = function(S, M) {
                  var N = this;
                  this.tiledMemberPack = [], Object.keys(S).forEach(function(D) {
                    var I = M[D];
                    if (N.tiledMemberPack[D] = N.tileNodes(S[D], I.paddingLeft + I.paddingRight), I.rect.width = N.tiledMemberPack[D].width, I.rect.height = N.tiledMemberPack[D].height, I.setCenter(N.tiledMemberPack[D].centerX, N.tiledMemberPack[D].centerY), I.labelMarginLeft = 0, I.labelMarginTop = 0, m.NODE_DIMENSIONS_INCLUDE_LABELS) {
                      var B = I.rect.width, z = I.rect.height;
                      I.labelWidth && (I.labelPosHorizontal == "left" ? (I.rect.x -= I.labelWidth, I.setWidth(B + I.labelWidth), I.labelMarginLeft = I.labelWidth) : I.labelPosHorizontal == "center" && I.labelWidth > B ? (I.rect.x -= (I.labelWidth - B) / 2, I.setWidth(I.labelWidth), I.labelMarginLeft = (I.labelWidth - B) / 2) : I.labelPosHorizontal == "right" && I.setWidth(B + I.labelWidth)), I.labelHeight && (I.labelPosVertical == "top" ? (I.rect.y -= I.labelHeight, I.setHeight(z + I.labelHeight), I.labelMarginTop = I.labelHeight) : I.labelPosVertical == "center" && I.labelHeight > z ? (I.rect.y -= (I.labelHeight - z) / 2, I.setHeight(I.labelHeight), I.labelMarginTop = (I.labelHeight - z) / 2) : I.labelPosVertical == "bottom" && I.setHeight(z + I.labelHeight));
                    }
                  });
                }, O.prototype.tileNodes = function(S, M) {
                  var N = this.tileNodesByFavoringDim(S, M, !0), D = this.tileNodesByFavoringDim(S, M, !1), I = this.getOrgRatio(N), B = this.getOrgRatio(D), z;
                  return B < I ? z = D : z = N, z;
                }, O.prototype.getOrgRatio = function(S) {
                  var M = S.width, N = S.height, D = M / N;
                  return D < 1 && (D = 1 / D), D;
                }, O.prototype.calcIdealRowWidth = function(S, M) {
                  var N = m.TILING_PADDING_VERTICAL, D = m.TILING_PADDING_HORIZONTAL, I = S.length, B = 0, z = 0, F = 0;
                  S.forEach(function(pe) {
                    B += pe.getWidth(), z += pe.getHeight(), pe.getWidth() > F && (F = pe.getWidth());
                  });
                  var V = B / I, H = z / I, J = Math.pow(N - D, 2) + 4 * (V + D) * (H + N) * I, q = (D - N + Math.sqrt(J)) / (2 * (V + D)), ae;
                  M ? (ae = Math.ceil(q), ae == q && ae++) : ae = Math.floor(q);
                  var re = ae * (V + D) - D;
                  return F > re && (re = F), re += D * 2, re;
                }, O.prototype.tileNodesByFavoringDim = function(S, M, N) {
                  var D = m.TILING_PADDING_VERTICAL, I = m.TILING_PADDING_HORIZONTAL, B = m.TILING_COMPARE_BY, z = {
                    rows: [],
                    rowWidth: [],
                    rowHeight: [],
                    width: 0,
                    height: M,
                    // assume minHeight equals to minWidth
                    verticalPadding: D,
                    horizontalPadding: I,
                    centerX: 0,
                    centerY: 0
                  };
                  B && (z.idealRowWidth = this.calcIdealRowWidth(S, N));
                  var F = function(K) {
                    return K.rect.width * K.rect.height;
                  }, V = function(K, Z) {
                    return F(Z) - F(K);
                  };
                  S.sort(function(pe, K) {
                    var Z = V;
                    return z.idealRowWidth ? (Z = B, Z(pe.id, K.id)) : Z(pe, K);
                  });
                  for (var H = 0, J = 0, q = 0; q < S.length; q++) {
                    var ae = S[q];
                    H += ae.getCenterX(), J += ae.getCenterY();
                  }
                  z.centerX = H / S.length, z.centerY = J / S.length;
                  for (var q = 0; q < S.length; q++) {
                    var ae = S[q];
                    if (z.rows.length == 0)
                      this.insertNodeToRow(z, ae, 0, M);
                    else if (this.canAddHorizontal(z, ae.rect.width, ae.rect.height)) {
                      var re = z.rows.length - 1;
                      z.idealRowWidth || (re = this.getShortestRowIndex(z)), this.insertNodeToRow(z, ae, re, M);
                    } else
                      this.insertNodeToRow(z, ae, z.rows.length, M);
                    this.shiftToLastRow(z);
                  }
                  return z;
                }, O.prototype.insertNodeToRow = function(S, M, N, D) {
                  var I = D;
                  if (N == S.rows.length) {
                    var B = [];
                    S.rows.push(B), S.rowWidth.push(I), S.rowHeight.push(0);
                  }
                  var z = S.rowWidth[N] + M.rect.width;
                  S.rows[N].length > 0 && (z += S.horizontalPadding), S.rowWidth[N] = z, S.width < z && (S.width = z);
                  var F = M.rect.height;
                  N > 0 && (F += S.verticalPadding);
                  var V = 0;
                  F > S.rowHeight[N] && (V = S.rowHeight[N], S.rowHeight[N] = F, V = S.rowHeight[N] - V), S.height += V, S.rows[N].push(M);
                }, O.prototype.getShortestRowIndex = function(S) {
                  for (var M = -1, N = Number.MAX_VALUE, D = 0; D < S.rows.length; D++)
                    S.rowWidth[D] < N && (M = D, N = S.rowWidth[D]);
                  return M;
                }, O.prototype.getLongestRowIndex = function(S) {
                  for (var M = -1, N = Number.MIN_VALUE, D = 0; D < S.rows.length; D++)
                    S.rowWidth[D] > N && (M = D, N = S.rowWidth[D]);
                  return M;
                }, O.prototype.canAddHorizontal = function(S, M, N) {
                  if (S.idealRowWidth) {
                    var D = S.rows.length - 1, I = S.rowWidth[D];
                    return I + M + S.horizontalPadding <= S.idealRowWidth;
                  }
                  var B = this.getShortestRowIndex(S);
                  if (B < 0)
                    return !0;
                  var z = S.rowWidth[B];
                  if (z + S.horizontalPadding + M <= S.width) return !0;
                  var F = 0;
                  S.rowHeight[B] < N && B > 0 && (F = N + S.verticalPadding - S.rowHeight[B]);
                  var V;
                  S.width - z >= M + S.horizontalPadding ? V = (S.height + F) / (z + M + S.horizontalPadding) : V = (S.height + F) / S.width, F = N + S.verticalPadding;
                  var H;
                  return S.width < M ? H = (S.height + F) / M : H = (S.height + F) / S.width, H < 1 && (H = 1 / H), V < 1 && (V = 1 / V), V < H;
                }, O.prototype.shiftToLastRow = function(S) {
                  var M = this.getLongestRowIndex(S), N = S.rowWidth.length - 1, D = S.rows[M], I = D[D.length - 1], B = I.width + S.horizontalPadding;
                  if (S.width - S.rowWidth[N] > B && M != N) {
                    D.splice(-1, 1), S.rows[N].push(I), S.rowWidth[M] = S.rowWidth[M] - B, S.rowWidth[N] = S.rowWidth[N] + B, S.width = S.rowWidth[instance.getLongestRowIndex(S)];
                    for (var z = Number.MIN_VALUE, F = 0; F < D.length; F++)
                      D[F].height > z && (z = D[F].height);
                    M > 0 && (z += S.verticalPadding);
                    var V = S.rowHeight[M] + S.rowHeight[N];
                    S.rowHeight[M] = z, S.rowHeight[N] < I.height + S.verticalPadding && (S.rowHeight[N] = I.height + S.verticalPadding);
                    var H = S.rowHeight[M] + S.rowHeight[N];
                    S.height += H - V, this.shiftToLastRow(S);
                  }
                }, O.prototype.tilingPreLayout = function() {
                  m.TILE && (this.groupZeroDegreeMembers(), this.clearCompounds(), this.clearZeroDegreeMembers());
                }, O.prototype.tilingPostLayout = function() {
                  m.TILE && (this.repopulateZeroDegreeMembers(), this.repopulateCompounds());
                }, O.prototype.reduceTrees = function() {
                  for (var S = [], M = !0, N; M; ) {
                    var D = this.graphManager.getAllNodes(), I = [];
                    M = !1;
                    for (var B = 0; B < D.length; B++)
                      if (N = D[B], N.getEdges().length == 1 && !N.getEdges()[0].isInterGraph && N.getChild() == null) {
                        if (m.PURE_INCREMENTAL) {
                          var z = N.getEdges()[0].getOtherEnd(N), F = new E(N.getCenterX() - z.getCenterX(), N.getCenterY() - z.getCenterY());
                          I.push([N, N.getEdges()[0], N.getOwner(), F]);
                        } else
                          I.push([N, N.getEdges()[0], N.getOwner()]);
                        M = !0;
                      }
                    if (M == !0) {
                      for (var V = [], H = 0; H < I.length; H++)
                        I[H][0].getEdges().length == 1 && (V.push(I[H]), I[H][0].getOwner().remove(I[H][0]));
                      S.push(V), this.graphManager.resetAllNodes(), this.graphManager.resetAllEdges();
                    }
                  }
                  this.prunedNodesAll = S;
                }, O.prototype.growTree = function(S) {
                  for (var M = S.length, N = S[M - 1], D, I = 0; I < N.length; I++)
                    D = N[I], this.findPlaceforPrunedNode(D), D[2].add(D[0]), D[2].add(D[1], D[1].source, D[1].target);
                  S.splice(S.length - 1, 1), this.graphManager.resetAllNodes(), this.graphManager.resetAllEdges();
                }, O.prototype.findPlaceforPrunedNode = function(S) {
                  var M, N, D = S[0];
                  if (D == S[1].source ? N = S[1].target : N = S[1].source, m.PURE_INCREMENTAL)
                    D.setCenter(N.getCenterX() + S[3].getWidth(), N.getCenterY() + S[3].getHeight());
                  else {
                    var I = N.startX, B = N.finishX, z = N.startY, F = N.finishY, V = 0, H = 0, J = 0, q = 0, ae = [V, J, H, q];
                    if (z > 0)
                      for (var re = I; re <= B; re++)
                        ae[0] += this.grid[re][z - 1].length + this.grid[re][z].length - 1;
                    if (B < this.grid.length - 1)
                      for (var re = z; re <= F; re++)
                        ae[1] += this.grid[B + 1][re].length + this.grid[B][re].length - 1;
                    if (F < this.grid[0].length - 1)
                      for (var re = I; re <= B; re++)
                        ae[2] += this.grid[re][F + 1].length + this.grid[re][F].length - 1;
                    if (I > 0)
                      for (var re = z; re <= F; re++)
                        ae[3] += this.grid[I - 1][re].length + this.grid[I][re].length - 1;
                    for (var pe = k.MAX_VALUE, K, Z, X = 0; X < ae.length; X++)
                      ae[X] < pe ? (pe = ae[X], K = 1, Z = X) : ae[X] == pe && K++;
                    if (K == 3 && pe == 0)
                      ae[0] == 0 && ae[1] == 0 && ae[2] == 0 ? M = 1 : ae[0] == 0 && ae[1] == 0 && ae[3] == 0 ? M = 0 : ae[0] == 0 && ae[2] == 0 && ae[3] == 0 ? M = 3 : ae[1] == 0 && ae[2] == 0 && ae[3] == 0 && (M = 2);
                    else if (K == 2 && pe == 0) {
                      var Y = Math.floor(Math.random() * 2);
                      ae[0] == 0 && ae[1] == 0 ? Y == 0 ? M = 0 : M = 1 : ae[0] == 0 && ae[2] == 0 ? Y == 0 ? M = 0 : M = 2 : ae[0] == 0 && ae[3] == 0 ? Y == 0 ? M = 0 : M = 3 : ae[1] == 0 && ae[2] == 0 ? Y == 0 ? M = 1 : M = 2 : ae[1] == 0 && ae[3] == 0 ? Y == 0 ? M = 1 : M = 3 : Y == 0 ? M = 2 : M = 3;
                    } else if (K == 4 && pe == 0) {
                      var Y = Math.floor(Math.random() * 4);
                      M = Y;
                    } else
                      M = Z;
                    M == 0 ? D.setCenter(N.getCenterX(), N.getCenterY() - N.getHeight() / 2 - y.DEFAULT_EDGE_LENGTH - D.getHeight() / 2) : M == 1 ? D.setCenter(N.getCenterX() + N.getWidth() / 2 + y.DEFAULT_EDGE_LENGTH + D.getWidth() / 2, N.getCenterY()) : M == 2 ? D.setCenter(N.getCenterX(), N.getCenterY() + N.getHeight() / 2 + y.DEFAULT_EDGE_LENGTH + D.getHeight() / 2) : D.setCenter(N.getCenterX() - N.getWidth() / 2 - y.DEFAULT_EDGE_LENGTH - D.getWidth() / 2, N.getCenterY());
                  }
                }, o.exports = O;
              })
            ),
            /***/
            991: (
              /***/
              ((o, l, u) => {
                var h = u(551).FDLayoutNode, d = u(551).IMath;
                function f(g, m, v, y) {
                  h.call(this, g, m, v, y);
                }
                f.prototype = Object.create(h.prototype);
                for (var p in h)
                  f[p] = h[p];
                f.prototype.calculateDisplacement = function() {
                  var g = this.graphManager.getLayout();
                  this.getChild() != null && this.fixedNodeWeight ? (this.displacementX += g.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.fixedNodeWeight, this.displacementY += g.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.fixedNodeWeight) : (this.displacementX += g.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren, this.displacementY += g.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren), Math.abs(this.displacementX) > g.coolingFactor * g.maxNodeDisplacement && (this.displacementX = g.coolingFactor * g.maxNodeDisplacement * d.sign(this.displacementX)), Math.abs(this.displacementY) > g.coolingFactor * g.maxNodeDisplacement && (this.displacementY = g.coolingFactor * g.maxNodeDisplacement * d.sign(this.displacementY)), this.child && this.child.getNodes().length > 0 && this.propogateDisplacementToChildren(this.displacementX, this.displacementY);
                }, f.prototype.propogateDisplacementToChildren = function(g, m) {
                  for (var v = this.getChild().getNodes(), y, b = 0; b < v.length; b++)
                    y = v[b], y.getChild() == null ? (y.displacementX += g, y.displacementY += m) : y.propogateDisplacementToChildren(g, m);
                }, f.prototype.move = function() {
                  var g = this.graphManager.getLayout();
                  (this.child == null || this.child.getNodes().length == 0) && (this.moveBy(this.displacementX, this.displacementY), g.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY)), this.springForceX = 0, this.springForceY = 0, this.repulsionForceX = 0, this.repulsionForceY = 0, this.gravitationForceX = 0, this.gravitationForceY = 0, this.displacementX = 0, this.displacementY = 0;
                }, f.prototype.setPred1 = function(g) {
                  this.pred1 = g;
                }, f.prototype.getPred1 = function() {
                  return pred1;
                }, f.prototype.getPred2 = function() {
                  return pred2;
                }, f.prototype.setNext = function(g) {
                  this.next = g;
                }, f.prototype.getNext = function() {
                  return next;
                }, f.prototype.setProcessed = function(g) {
                  this.processed = g;
                }, f.prototype.isProcessed = function() {
                  return processed;
                }, o.exports = f;
              })
            ),
            /***/
            902: (
              /***/
              ((o, l, u) => {
                function h(v) {
                  if (Array.isArray(v)) {
                    for (var y = 0, b = Array(v.length); y < v.length; y++)
                      b[y] = v[y];
                    return b;
                  } else
                    return Array.from(v);
                }
                var d = u(806), f = u(551).LinkedList, p = u(551).Matrix, g = u(551).SVD;
                function m() {
                }
                m.handleConstraints = function(v) {
                  var y = {};
                  y.fixedNodeConstraint = v.constraints.fixedNodeConstraint, y.alignmentConstraint = v.constraints.alignmentConstraint, y.relativePlacementConstraint = v.constraints.relativePlacementConstraint;
                  for (var b = /* @__PURE__ */ new Map(), w = /* @__PURE__ */ new Map(), T = [], E = [], L = v.getAllNodes(), k = 0, C = 0; C < L.length; C++) {
                    var A = L[C];
                    A.getChild() == null && (w.set(A.id, k++), T.push(A.getCenterX()), E.push(A.getCenterY()), b.set(A.id, A));
                  }
                  y.relativePlacementConstraint && y.relativePlacementConstraint.forEach(function(ce) {
                    !ce.gap && ce.gap != 0 && (ce.left ? ce.gap = d.DEFAULT_EDGE_LENGTH + b.get(ce.left).getWidth() / 2 + b.get(ce.right).getWidth() / 2 : ce.gap = d.DEFAULT_EDGE_LENGTH + b.get(ce.top).getHeight() / 2 + b.get(ce.bottom).getHeight() / 2);
                  });
                  var R = function($, oe) {
                    return { x: $.x - oe.x, y: $.y - oe.y };
                  }, _ = function($) {
                    var oe = 0, se = 0;
                    return $.forEach(function(ge) {
                      oe += T[w.get(ge)], se += E[w.get(ge)];
                    }), { x: oe / $.size, y: se / $.size };
                  }, O = function($, oe, se, ge, he) {
                    function be(Pe, He) {
                      var ht = new Set(Pe), st = !0, Ue = !1, Et = void 0;
                      try {
                        for (var qe = He[Symbol.iterator](), rt; !(st = (rt = qe.next()).done); st = !0) {
                          var ct = rt.value;
                          ht.add(ct);
                        }
                      } catch (ut) {
                        Ue = !0, Et = ut;
                      } finally {
                        try {
                          !st && qe.return && qe.return();
                        } finally {
                          if (Ue)
                            throw Et;
                        }
                      }
                      return ht;
                    }
                    var Ce = /* @__PURE__ */ new Map();
                    $.forEach(function(Pe, He) {
                      Ce.set(He, 0);
                    }), $.forEach(function(Pe, He) {
                      Pe.forEach(function(ht) {
                        Ce.set(ht.id, Ce.get(ht.id) + 1);
                      });
                    });
                    var Te = /* @__PURE__ */ new Map(), Me = /* @__PURE__ */ new Map(), Xe = new f();
                    Ce.forEach(function(Pe, He) {
                      Pe == 0 ? (Xe.push(He), se || (oe == "horizontal" ? Te.set(He, w.has(He) ? T[w.get(He)] : ge.get(He)) : Te.set(He, w.has(He) ? E[w.get(He)] : ge.get(He)))) : Te.set(He, Number.NEGATIVE_INFINITY), se && Me.set(He, /* @__PURE__ */ new Set([He]));
                    }), se && he.forEach(function(Pe) {
                      var He = [];
                      if (Pe.forEach(function(Ue) {
                        se.has(Ue) && He.push(Ue);
                      }), He.length > 0) {
                        var ht = 0;
                        He.forEach(function(Ue) {
                          oe == "horizontal" ? (Te.set(Ue, w.has(Ue) ? T[w.get(Ue)] : ge.get(Ue)), ht += Te.get(Ue)) : (Te.set(Ue, w.has(Ue) ? E[w.get(Ue)] : ge.get(Ue)), ht += Te.get(Ue));
                        }), ht = ht / He.length, Pe.forEach(function(Ue) {
                          se.has(Ue) || Te.set(Ue, ht);
                        });
                      } else {
                        var st = 0;
                        Pe.forEach(function(Ue) {
                          oe == "horizontal" ? st += w.has(Ue) ? T[w.get(Ue)] : ge.get(Ue) : st += w.has(Ue) ? E[w.get(Ue)] : ge.get(Ue);
                        }), st = st / Pe.length, Pe.forEach(function(Ue) {
                          Te.set(Ue, st);
                        });
                      }
                    });
                    for (var We = function() {
                      var He = Xe.shift(), ht = $.get(He);
                      ht.forEach(function(st) {
                        if (Te.get(st.id) < Te.get(He) + st.gap)
                          if (se && se.has(st.id)) {
                            var Ue = void 0;
                            if (oe == "horizontal" ? Ue = w.has(st.id) ? T[w.get(st.id)] : ge.get(st.id) : Ue = w.has(st.id) ? E[w.get(st.id)] : ge.get(st.id), Te.set(st.id, Ue), Ue < Te.get(He) + st.gap) {
                              var Et = Te.get(He) + st.gap - Ue;
                              Me.get(He).forEach(function(qe) {
                                Te.set(qe, Te.get(qe) - Et);
                              });
                            }
                          } else
                            Te.set(st.id, Te.get(He) + st.gap);
                        Ce.set(st.id, Ce.get(st.id) - 1), Ce.get(st.id) == 0 && Xe.push(st.id), se && Me.set(st.id, be(Me.get(He), Me.get(st.id)));
                      });
                    }; Xe.length != 0; )
                      We();
                    if (se) {
                      var Ke = /* @__PURE__ */ new Set();
                      $.forEach(function(Pe, He) {
                        Pe.length == 0 && Ke.add(He);
                      });
                      var Ze = [];
                      Me.forEach(function(Pe, He) {
                        if (Ke.has(He)) {
                          var ht = !1, st = !0, Ue = !1, Et = void 0;
                          try {
                            for (var qe = Pe[Symbol.iterator](), rt; !(st = (rt = qe.next()).done); st = !0) {
                              var ct = rt.value;
                              se.has(ct) && (ht = !0);
                            }
                          } catch (xt) {
                            Ue = !0, Et = xt;
                          } finally {
                            try {
                              !st && qe.return && qe.return();
                            } finally {
                              if (Ue)
                                throw Et;
                            }
                          }
                          if (!ht) {
                            var ut = !1, nt = void 0;
                            Ze.forEach(function(xt, Qt) {
                              xt.has([].concat(h(Pe))[0]) && (ut = !0, nt = Qt);
                            }), ut ? Pe.forEach(function(xt) {
                              Ze[nt].add(xt);
                            }) : Ze.push(new Set(Pe));
                          }
                        }
                      }), Ze.forEach(function(Pe, He) {
                        var ht = Number.POSITIVE_INFINITY, st = Number.POSITIVE_INFINITY, Ue = Number.NEGATIVE_INFINITY, Et = Number.NEGATIVE_INFINITY, qe = !0, rt = !1, ct = void 0;
                        try {
                          for (var ut = Pe[Symbol.iterator](), nt; !(qe = (nt = ut.next()).done); qe = !0) {
                            var xt = nt.value, Qt = void 0;
                            oe == "horizontal" ? Qt = w.has(xt) ? T[w.get(xt)] : ge.get(xt) : Qt = w.has(xt) ? E[w.get(xt)] : ge.get(xt);
                            var Dt = Te.get(xt);
                            Qt < ht && (ht = Qt), Qt > Ue && (Ue = Qt), Dt < st && (st = Dt), Dt > Et && (Et = Dt);
                          }
                        } catch (Ee) {
                          rt = !0, ct = Ee;
                        } finally {
                          try {
                            !qe && ut.return && ut.return();
                          } finally {
                            if (rt)
                              throw ct;
                          }
                        }
                        var rr = (ht + Ue) / 2 - (st + Et) / 2, xr = !0, nr = !1, Ht = void 0;
                        try {
                          for (var lr = Pe[Symbol.iterator](), sn; !(xr = (sn = lr.next()).done); xr = !0) {
                            var dt = sn.value;
                            Te.set(dt, Te.get(dt) + rr);
                          }
                        } catch (Ee) {
                          nr = !0, Ht = Ee;
                        } finally {
                          try {
                            !xr && lr.return && lr.return();
                          } finally {
                            if (nr)
                              throw Ht;
                          }
                        }
                      });
                    }
                    return Te;
                  }, P = function($) {
                    var oe = 0, se = 0, ge = 0, he = 0;
                    if ($.forEach(function(Me) {
                      Me.left ? T[w.get(Me.left)] - T[w.get(Me.right)] >= 0 ? oe++ : se++ : E[w.get(Me.top)] - E[w.get(Me.bottom)] >= 0 ? ge++ : he++;
                    }), oe > se && ge > he)
                      for (var be = 0; be < w.size; be++)
                        T[be] = -1 * T[be], E[be] = -1 * E[be];
                    else if (oe > se)
                      for (var Ce = 0; Ce < w.size; Ce++)
                        T[Ce] = -1 * T[Ce];
                    else if (ge > he)
                      for (var Te = 0; Te < w.size; Te++)
                        E[Te] = -1 * E[Te];
                  }, S = function($) {
                    var oe = [], se = new f(), ge = /* @__PURE__ */ new Set(), he = 0;
                    return $.forEach(function(be, Ce) {
                      if (!ge.has(Ce)) {
                        oe[he] = [];
                        var Te = Ce;
                        for (se.push(Te), ge.add(Te), oe[he].push(Te); se.length != 0; ) {
                          Te = se.shift();
                          var Me = $.get(Te);
                          Me.forEach(function(Xe) {
                            ge.has(Xe.id) || (se.push(Xe.id), ge.add(Xe.id), oe[he].push(Xe.id));
                          });
                        }
                        he++;
                      }
                    }), oe;
                  }, M = function($) {
                    var oe = /* @__PURE__ */ new Map();
                    return $.forEach(function(se, ge) {
                      oe.set(ge, []);
                    }), $.forEach(function(se, ge) {
                      se.forEach(function(he) {
                        oe.get(ge).push(he), oe.get(he.id).push({ id: ge, gap: he.gap, direction: he.direction });
                      });
                    }), oe;
                  }, N = function($) {
                    var oe = /* @__PURE__ */ new Map();
                    return $.forEach(function(se, ge) {
                      oe.set(ge, []);
                    }), $.forEach(function(se, ge) {
                      se.forEach(function(he) {
                        oe.get(he.id).push({ id: ge, gap: he.gap, direction: he.direction });
                      });
                    }), oe;
                  }, D = [], I = [], B = !1, z = !1, F = /* @__PURE__ */ new Set(), V = /* @__PURE__ */ new Map(), H = /* @__PURE__ */ new Map(), J = [];
                  if (y.fixedNodeConstraint && y.fixedNodeConstraint.forEach(function(ce) {
                    F.add(ce.nodeId);
                  }), y.relativePlacementConstraint && (y.relativePlacementConstraint.forEach(function(ce) {
                    ce.left ? (V.has(ce.left) ? V.get(ce.left).push({ id: ce.right, gap: ce.gap, direction: "horizontal" }) : V.set(ce.left, [{ id: ce.right, gap: ce.gap, direction: "horizontal" }]), V.has(ce.right) || V.set(ce.right, [])) : (V.has(ce.top) ? V.get(ce.top).push({ id: ce.bottom, gap: ce.gap, direction: "vertical" }) : V.set(ce.top, [{ id: ce.bottom, gap: ce.gap, direction: "vertical" }]), V.has(ce.bottom) || V.set(ce.bottom, []));
                  }), H = M(V), J = S(H)), d.TRANSFORM_ON_CONSTRAINT_HANDLING) {
                    if (y.fixedNodeConstraint && y.fixedNodeConstraint.length > 1)
                      y.fixedNodeConstraint.forEach(function(ce, $) {
                        D[$] = [ce.position.x, ce.position.y], I[$] = [T[w.get(ce.nodeId)], E[w.get(ce.nodeId)]];
                      }), B = !0;
                    else if (y.alignmentConstraint)
                      (function() {
                        var ce = 0;
                        if (y.alignmentConstraint.vertical) {
                          for (var $ = y.alignmentConstraint.vertical, oe = function(Te) {
                            var Me = /* @__PURE__ */ new Set();
                            $[Te].forEach(function(Ke) {
                              Me.add(Ke);
                            });
                            var Xe = new Set([].concat(h(Me)).filter(function(Ke) {
                              return F.has(Ke);
                            })), We = void 0;
                            Xe.size > 0 ? We = T[w.get(Xe.values().next().value)] : We = _(Me).x, $[Te].forEach(function(Ke) {
                              D[ce] = [We, E[w.get(Ke)]], I[ce] = [T[w.get(Ke)], E[w.get(Ke)]], ce++;
                            });
                          }, se = 0; se < $.length; se++)
                            oe(se);
                          B = !0;
                        }
                        if (y.alignmentConstraint.horizontal) {
                          for (var ge = y.alignmentConstraint.horizontal, he = function(Te) {
                            var Me = /* @__PURE__ */ new Set();
                            ge[Te].forEach(function(Ke) {
                              Me.add(Ke);
                            });
                            var Xe = new Set([].concat(h(Me)).filter(function(Ke) {
                              return F.has(Ke);
                            })), We = void 0;
                            Xe.size > 0 ? We = T[w.get(Xe.values().next().value)] : We = _(Me).y, ge[Te].forEach(function(Ke) {
                              D[ce] = [T[w.get(Ke)], We], I[ce] = [T[w.get(Ke)], E[w.get(Ke)]], ce++;
                            });
                          }, be = 0; be < ge.length; be++)
                            he(be);
                          B = !0;
                        }
                        y.relativePlacementConstraint && (z = !0);
                      })();
                    else if (y.relativePlacementConstraint) {
                      for (var q = 0, ae = 0, re = 0; re < J.length; re++)
                        J[re].length > q && (q = J[re].length, ae = re);
                      if (q < H.size / 2)
                        P(y.relativePlacementConstraint), B = !1, z = !1;
                      else {
                        var pe = /* @__PURE__ */ new Map(), K = /* @__PURE__ */ new Map(), Z = [];
                        J[ae].forEach(function(ce) {
                          V.get(ce).forEach(function($) {
                            $.direction == "horizontal" ? (pe.has(ce) ? pe.get(ce).push($) : pe.set(ce, [$]), pe.has($.id) || pe.set($.id, []), Z.push({ left: ce, right: $.id })) : (K.has(ce) ? K.get(ce).push($) : K.set(ce, [$]), K.has($.id) || K.set($.id, []), Z.push({ top: ce, bottom: $.id }));
                          });
                        }), P(Z), z = !1;
                        var X = O(pe, "horizontal"), Y = O(K, "vertical");
                        J[ae].forEach(function(ce, $) {
                          I[$] = [T[w.get(ce)], E[w.get(ce)]], D[$] = [], X.has(ce) ? D[$][0] = X.get(ce) : D[$][0] = T[w.get(ce)], Y.has(ce) ? D[$][1] = Y.get(ce) : D[$][1] = E[w.get(ce)];
                        }), B = !0;
                      }
                    }
                    if (B) {
                      for (var ee = void 0, j = p.transpose(D), fe = p.transpose(I), te = 0; te < j.length; te++)
                        j[te] = p.multGamma(j[te]), fe[te] = p.multGamma(fe[te]);
                      var Ae = p.multMat(j, p.transpose(fe)), W = g.svd(Ae);
                      ee = p.multMat(W.V, p.transpose(W.U));
                      for (var De = 0; De < w.size; De++) {
                        var ue = [T[De], E[De]], ze = [ee[0][0], ee[1][0]], Ge = [ee[0][1], ee[1][1]];
                        T[De] = p.dotProduct(ue, ze), E[De] = p.dotProduct(ue, Ge);
                      }
                      z && P(y.relativePlacementConstraint);
                    }
                  }
                  if (d.ENFORCE_CONSTRAINTS) {
                    if (y.fixedNodeConstraint && y.fixedNodeConstraint.length > 0) {
                      var Ve = { x: 0, y: 0 };
                      y.fixedNodeConstraint.forEach(function(ce, $) {
                        var oe = { x: T[w.get(ce.nodeId)], y: E[w.get(ce.nodeId)] }, se = ce.position, ge = R(se, oe);
                        Ve.x += ge.x, Ve.y += ge.y;
                      }), Ve.x /= y.fixedNodeConstraint.length, Ve.y /= y.fixedNodeConstraint.length, T.forEach(function(ce, $) {
                        T[$] += Ve.x;
                      }), E.forEach(function(ce, $) {
                        E[$] += Ve.y;
                      }), y.fixedNodeConstraint.forEach(function(ce) {
                        T[w.get(ce.nodeId)] = ce.position.x, E[w.get(ce.nodeId)] = ce.position.y;
                      });
                    }
                    if (y.alignmentConstraint) {
                      if (y.alignmentConstraint.vertical)
                        for (var ke = y.alignmentConstraint.vertical, Oe = function($) {
                          var oe = /* @__PURE__ */ new Set();
                          ke[$].forEach(function(he) {
                            oe.add(he);
                          });
                          var se = new Set([].concat(h(oe)).filter(function(he) {
                            return F.has(he);
                          })), ge = void 0;
                          se.size > 0 ? ge = T[w.get(se.values().next().value)] : ge = _(oe).x, oe.forEach(function(he) {
                            F.has(he) || (T[w.get(he)] = ge);
                          });
                        }, Se = 0; Se < ke.length; Se++)
                          Oe(Se);
                      if (y.alignmentConstraint.horizontal)
                        for (var _e = y.alignmentConstraint.horizontal, $e = function($) {
                          var oe = /* @__PURE__ */ new Set();
                          _e[$].forEach(function(he) {
                            oe.add(he);
                          });
                          var se = new Set([].concat(h(oe)).filter(function(he) {
                            return F.has(he);
                          })), ge = void 0;
                          se.size > 0 ? ge = E[w.get(se.values().next().value)] : ge = _(oe).y, oe.forEach(function(he) {
                            F.has(he) || (E[w.get(he)] = ge);
                          });
                        }, me = 0; me < _e.length; me++)
                          $e(me);
                    }
                    y.relativePlacementConstraint && (function() {
                      var ce = /* @__PURE__ */ new Map(), $ = /* @__PURE__ */ new Map(), oe = /* @__PURE__ */ new Map(), se = /* @__PURE__ */ new Map(), ge = /* @__PURE__ */ new Map(), he = /* @__PURE__ */ new Map(), be = /* @__PURE__ */ new Set(), Ce = /* @__PURE__ */ new Set();
                      if (F.forEach(function(wt) {
                        be.add(wt), Ce.add(wt);
                      }), y.alignmentConstraint) {
                        if (y.alignmentConstraint.vertical)
                          for (var Te = y.alignmentConstraint.vertical, Me = function(lt) {
                            oe.set("dummy" + lt, []), Te[lt].forEach(function(je) {
                              ce.set(je, "dummy" + lt), oe.get("dummy" + lt).push(je), F.has(je) && be.add("dummy" + lt);
                            }), ge.set("dummy" + lt, T[w.get(Te[lt][0])]);
                          }, Xe = 0; Xe < Te.length; Xe++)
                            Me(Xe);
                        if (y.alignmentConstraint.horizontal)
                          for (var We = y.alignmentConstraint.horizontal, Ke = function(lt) {
                            se.set("dummy" + lt, []), We[lt].forEach(function(je) {
                              $.set(je, "dummy" + lt), se.get("dummy" + lt).push(je), F.has(je) && Ce.add("dummy" + lt);
                            }), he.set("dummy" + lt, E[w.get(We[lt][0])]);
                          }, Ze = 0; Ze < We.length; Ze++)
                            Ke(Ze);
                      }
                      var Pe = /* @__PURE__ */ new Map(), He = /* @__PURE__ */ new Map(), ht = function(lt) {
                        V.get(lt).forEach(function(je) {
                          var Kt = void 0, de = void 0;
                          je.direction == "horizontal" ? (Kt = ce.get(lt) ? ce.get(lt) : lt, ce.get(je.id) ? de = { id: ce.get(je.id), gap: je.gap, direction: je.direction } : de = je, Pe.has(Kt) ? Pe.get(Kt).push(de) : Pe.set(Kt, [de]), Pe.has(de.id) || Pe.set(de.id, [])) : (Kt = $.get(lt) ? $.get(lt) : lt, $.get(je.id) ? de = { id: $.get(je.id), gap: je.gap, direction: je.direction } : de = je, He.has(Kt) ? He.get(Kt).push(de) : He.set(Kt, [de]), He.has(de.id) || He.set(de.id, []));
                        });
                      }, st = !0, Ue = !1, Et = void 0;
                      try {
                        for (var qe = V.keys()[Symbol.iterator](), rt; !(st = (rt = qe.next()).done); st = !0) {
                          var ct = rt.value;
                          ht(ct);
                        }
                      } catch (wt) {
                        Ue = !0, Et = wt;
                      } finally {
                        try {
                          !st && qe.return && qe.return();
                        } finally {
                          if (Ue)
                            throw Et;
                        }
                      }
                      var ut = M(Pe), nt = M(He), xt = S(ut), Qt = S(nt), Dt = N(Pe), rr = N(He), xr = [], nr = [];
                      xt.forEach(function(wt, lt) {
                        xr[lt] = [], wt.forEach(function(je) {
                          Dt.get(je).length == 0 && xr[lt].push(je);
                        });
                      }), Qt.forEach(function(wt, lt) {
                        nr[lt] = [], wt.forEach(function(je) {
                          rr.get(je).length == 0 && nr[lt].push(je);
                        });
                      });
                      var Ht = O(Pe, "horizontal", be, ge, xr), lr = O(He, "vertical", Ce, he, nr), sn = function(lt) {
                        oe.get(lt) ? oe.get(lt).forEach(function(je) {
                          T[w.get(je)] = Ht.get(lt);
                        }) : T[w.get(lt)] = Ht.get(lt);
                      }, dt = !0, Ee = !1, Je = void 0;
                      try {
                        for (var bt = Ht.keys()[Symbol.iterator](), sr; !(dt = (sr = bt.next()).done); dt = !0) {
                          var Ur = sr.value;
                          sn(Ur);
                        }
                      } catch (wt) {
                        Ee = !0, Je = wt;
                      } finally {
                        try {
                          !dt && bt.return && bt.return();
                        } finally {
                          if (Ee)
                            throw Je;
                        }
                      }
                      var cr = function(lt) {
                        se.get(lt) ? se.get(lt).forEach(function(je) {
                          E[w.get(je)] = lr.get(lt);
                        }) : E[w.get(lt)] = lr.get(lt);
                      }, Xr = !0, gi = !1, bn = void 0;
                      try {
                        for (var wn = lr.keys()[Symbol.iterator](), ft; !(Xr = (ft = wn.next()).done); Xr = !0) {
                          var Ur = ft.value;
                          cr(Ur);
                        }
                      } catch (wt) {
                        gi = !0, bn = wt;
                      } finally {
                        try {
                          !Xr && wn.return && wn.return();
                        } finally {
                          if (gi)
                            throw bn;
                        }
                      }
                    })();
                  }
                  for (var Ne = 0; Ne < L.length; Ne++) {
                    var Q = L[Ne];
                    Q.getChild() == null && Q.setCenter(T[w.get(Q.id)], E[w.get(Q.id)]);
                  }
                }, o.exports = m;
              })
            ),
            /***/
            551: (
              /***/
              ((o) => {
                o.exports = r;
              })
            )
            /******/
          }, i = {};
          function a(o) {
            var l = i[o];
            if (l !== void 0)
              return l.exports;
            var u = i[o] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            return n[o](u, u.exports, a), u.exports;
          }
          var s = a(45);
          return s;
        })()
      );
    });
  })(Tv)), Tv.exports;
}
var r$e = wv.exports, pI;
function n$e() {
  return pI || (pI = 1, (function(t, e) {
    (function(n, i) {
      t.exports = i(t$e());
    })(r$e, function(r) {
      return (
        /******/
        (() => {
          var n = {
            /***/
            658: (
              /***/
              ((o) => {
                o.exports = Object.assign != null ? Object.assign.bind(Object) : function(l) {
                  for (var u = arguments.length, h = Array(u > 1 ? u - 1 : 0), d = 1; d < u; d++)
                    h[d - 1] = arguments[d];
                  return h.forEach(function(f) {
                    Object.keys(f).forEach(function(p) {
                      return l[p] = f[p];
                    });
                  }), l;
                };
              })
            ),
            /***/
            548: (
              /***/
              ((o, l, u) => {
                var h = /* @__PURE__ */ (function() {
                  function p(g, m) {
                    var v = [], y = !0, b = !1, w = void 0;
                    try {
                      for (var T = g[Symbol.iterator](), E; !(y = (E = T.next()).done) && (v.push(E.value), !(m && v.length === m)); y = !0)
                        ;
                    } catch (L) {
                      b = !0, w = L;
                    } finally {
                      try {
                        !y && T.return && T.return();
                      } finally {
                        if (b) throw w;
                      }
                    }
                    return v;
                  }
                  return function(g, m) {
                    if (Array.isArray(g))
                      return g;
                    if (Symbol.iterator in Object(g))
                      return p(g, m);
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                  };
                })(), d = u(140).layoutBase.LinkedList, f = {};
                f.getTopMostNodes = function(p) {
                  for (var g = {}, m = 0; m < p.length; m++)
                    g[p[m].id()] = !0;
                  var v = p.filter(function(y, b) {
                    typeof y == "number" && (y = b);
                    for (var w = y.parent()[0]; w != null; ) {
                      if (g[w.id()])
                        return !1;
                      w = w.parent()[0];
                    }
                    return !0;
                  });
                  return v;
                }, f.connectComponents = function(p, g, m, v) {
                  var y = new d(), b = /* @__PURE__ */ new Set(), w = [], T = void 0, E = void 0, L = void 0, k = !1, C = 1, A = [], R = [], _ = function() {
                    var P = p.collection();
                    R.push(P);
                    var S = m[0], M = p.collection();
                    M.merge(S).merge(S.descendants().intersection(g)), w.push(S), M.forEach(function(I) {
                      y.push(I), b.add(I), P.merge(I);
                    });
                    for (var N = function() {
                      S = y.shift();
                      var B = p.collection();
                      S.neighborhood().nodes().forEach(function(H) {
                        g.intersection(S.edgesWith(H)).length > 0 && B.merge(H);
                      });
                      for (var z = 0; z < B.length; z++) {
                        var F = B[z];
                        if (T = m.intersection(F.union(F.ancestors())), T != null && !b.has(T[0])) {
                          var V = T.union(T.descendants());
                          V.forEach(function(H) {
                            y.push(H), b.add(H), P.merge(H), m.has(H) && w.push(H);
                          });
                        }
                      }
                    }; y.length != 0; )
                      N();
                    if (P.forEach(function(I) {
                      g.intersection(I.connectedEdges()).forEach(function(B) {
                        P.has(B.source()) && P.has(B.target()) && P.merge(B);
                      });
                    }), w.length == m.length && (k = !0), !k || k && C > 1) {
                      E = w[0], L = E.connectedEdges().length, w.forEach(function(I) {
                        I.connectedEdges().length < L && (L = I.connectedEdges().length, E = I);
                      }), A.push(E.id());
                      var D = p.collection();
                      D.merge(w[0]), w.forEach(function(I) {
                        D.merge(I);
                      }), w = [], m = m.difference(D), C++;
                    }
                  };
                  do
                    _();
                  while (!k);
                  return v && A.length > 0 && v.set("dummy" + (v.size + 1), A), R;
                }, f.relocateComponent = function(p, g, m) {
                  if (!m.fixedNodeConstraint) {
                    var v = Number.POSITIVE_INFINITY, y = Number.NEGATIVE_INFINITY, b = Number.POSITIVE_INFINITY, w = Number.NEGATIVE_INFINITY;
                    if (m.quality == "draft") {
                      var T = !0, E = !1, L = void 0;
                      try {
                        for (var k = g.nodeIndexes[Symbol.iterator](), C; !(T = (C = k.next()).done); T = !0) {
                          var A = C.value, R = h(A, 2), _ = R[0], O = R[1], P = m.cy.getElementById(_);
                          if (P) {
                            var S = P.boundingBox(), M = g.xCoords[O] - S.w / 2, N = g.xCoords[O] + S.w / 2, D = g.yCoords[O] - S.h / 2, I = g.yCoords[O] + S.h / 2;
                            M < v && (v = M), N > y && (y = N), D < b && (b = D), I > w && (w = I);
                          }
                        }
                      } catch (H) {
                        E = !0, L = H;
                      } finally {
                        try {
                          !T && k.return && k.return();
                        } finally {
                          if (E)
                            throw L;
                        }
                      }
                      var B = p.x - (y + v) / 2, z = p.y - (w + b) / 2;
                      g.xCoords = g.xCoords.map(function(H) {
                        return H + B;
                      }), g.yCoords = g.yCoords.map(function(H) {
                        return H + z;
                      });
                    } else {
                      Object.keys(g).forEach(function(H) {
                        var J = g[H], q = J.getRect().x, ae = J.getRect().x + J.getRect().width, re = J.getRect().y, pe = J.getRect().y + J.getRect().height;
                        q < v && (v = q), ae > y && (y = ae), re < b && (b = re), pe > w && (w = pe);
                      });
                      var F = p.x - (y + v) / 2, V = p.y - (w + b) / 2;
                      Object.keys(g).forEach(function(H) {
                        var J = g[H];
                        J.setCenter(J.getCenterX() + F, J.getCenterY() + V);
                      });
                    }
                  }
                }, f.calcBoundingBox = function(p, g, m, v) {
                  for (var y = Number.MAX_SAFE_INTEGER, b = Number.MIN_SAFE_INTEGER, w = Number.MAX_SAFE_INTEGER, T = Number.MIN_SAFE_INTEGER, E = void 0, L = void 0, k = void 0, C = void 0, A = p.descendants().not(":parent"), R = A.length, _ = 0; _ < R; _++) {
                    var O = A[_];
                    E = g[v.get(O.id())] - O.width() / 2, L = g[v.get(O.id())] + O.width() / 2, k = m[v.get(O.id())] - O.height() / 2, C = m[v.get(O.id())] + O.height() / 2, y > E && (y = E), b < L && (b = L), w > k && (w = k), T < C && (T = C);
                  }
                  var P = {};
                  return P.topLeftX = y, P.topLeftY = w, P.width = b - y, P.height = T - w, P;
                }, f.calcParentsWithoutChildren = function(p, g) {
                  var m = p.collection();
                  return g.nodes(":parent").forEach(function(v) {
                    var y = !1;
                    v.children().forEach(function(b) {
                      b.css("display") != "none" && (y = !0);
                    }), y || m.merge(v);
                  }), m;
                }, o.exports = f;
              })
            ),
            /***/
            816: (
              /***/
              ((o, l, u) => {
                var h = u(548), d = u(140).CoSELayout, f = u(140).CoSENode, p = u(140).layoutBase.PointD, g = u(140).layoutBase.DimensionD, m = u(140).layoutBase.LayoutConstants, v = u(140).layoutBase.FDLayoutConstants, y = u(140).CoSEConstants, b = function(T, E) {
                  var L = T.cy, k = T.eles, C = k.nodes(), A = k.edges(), R = void 0, _ = void 0, O = void 0, P = {};
                  T.randomize && (R = E.nodeIndexes, _ = E.xCoords, O = E.yCoords);
                  var S = function(H) {
                    return typeof H == "function";
                  }, M = function(H, J) {
                    return S(H) ? H(J) : H;
                  }, N = h.calcParentsWithoutChildren(L, k), D = function V(H, J, q, ae) {
                    for (var re = J.length, pe = 0; pe < re; pe++) {
                      var K = J[pe], Z = null;
                      K.intersection(N).length == 0 && (Z = K.children());
                      var X = void 0, Y = K.layoutDimensions({
                        nodeDimensionsIncludeLabels: ae.nodeDimensionsIncludeLabels
                      });
                      if (K.outerWidth() != null && K.outerHeight() != null)
                        if (ae.randomize)
                          if (!K.isParent())
                            X = H.add(new f(q.graphManager, new p(_[R.get(K.id())] - Y.w / 2, O[R.get(K.id())] - Y.h / 2), new g(parseFloat(Y.w), parseFloat(Y.h))));
                          else {
                            var ee = h.calcBoundingBox(K, _, O, R);
                            K.intersection(N).length == 0 ? X = H.add(new f(q.graphManager, new p(ee.topLeftX, ee.topLeftY), new g(ee.width, ee.height))) : X = H.add(new f(q.graphManager, new p(ee.topLeftX, ee.topLeftY), new g(parseFloat(Y.w), parseFloat(Y.h))));
                          }
                        else
                          X = H.add(new f(q.graphManager, new p(K.position("x") - Y.w / 2, K.position("y") - Y.h / 2), new g(parseFloat(Y.w), parseFloat(Y.h))));
                      else
                        X = H.add(new f(this.graphManager));
                      if (X.id = K.data("id"), X.nodeRepulsion = M(ae.nodeRepulsion, K), X.paddingLeft = parseInt(K.css("padding")), X.paddingTop = parseInt(K.css("padding")), X.paddingRight = parseInt(K.css("padding")), X.paddingBottom = parseInt(K.css("padding")), ae.nodeDimensionsIncludeLabels && (X.labelWidth = K.boundingBox({ includeLabels: !0, includeNodes: !1, includeOverlays: !1 }).w, X.labelHeight = K.boundingBox({ includeLabels: !0, includeNodes: !1, includeOverlays: !1 }).h, X.labelPosVertical = K.css("text-valign"), X.labelPosHorizontal = K.css("text-halign")), P[K.data("id")] = X, isNaN(X.rect.x) && (X.rect.x = 0), isNaN(X.rect.y) && (X.rect.y = 0), Z != null && Z.length > 0) {
                        var j = void 0;
                        j = q.getGraphManager().add(q.newGraph(), X), V(j, Z, q, ae);
                      }
                    }
                  }, I = function(H, J, q) {
                    for (var ae = 0, re = 0, pe = 0; pe < q.length; pe++) {
                      var K = q[pe], Z = P[K.data("source")], X = P[K.data("target")];
                      if (Z && X && Z !== X && Z.getEdgesBetween(X).length == 0) {
                        var Y = J.add(H.newEdge(), Z, X);
                        Y.id = K.id(), Y.idealLength = M(T.idealEdgeLength, K), Y.edgeElasticity = M(T.edgeElasticity, K), ae += Y.idealLength, re++;
                      }
                    }
                    T.idealEdgeLength != null && (re > 0 ? y.DEFAULT_EDGE_LENGTH = v.DEFAULT_EDGE_LENGTH = ae / re : S(T.idealEdgeLength) ? y.DEFAULT_EDGE_LENGTH = v.DEFAULT_EDGE_LENGTH = 50 : y.DEFAULT_EDGE_LENGTH = v.DEFAULT_EDGE_LENGTH = T.idealEdgeLength, y.MIN_REPULSION_DIST = v.MIN_REPULSION_DIST = v.DEFAULT_EDGE_LENGTH / 10, y.DEFAULT_RADIAL_SEPARATION = v.DEFAULT_EDGE_LENGTH);
                  }, B = function(H, J) {
                    J.fixedNodeConstraint && (H.constraints.fixedNodeConstraint = J.fixedNodeConstraint), J.alignmentConstraint && (H.constraints.alignmentConstraint = J.alignmentConstraint), J.relativePlacementConstraint && (H.constraints.relativePlacementConstraint = J.relativePlacementConstraint);
                  };
                  T.nestingFactor != null && (y.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = v.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = T.nestingFactor), T.gravity != null && (y.DEFAULT_GRAVITY_STRENGTH = v.DEFAULT_GRAVITY_STRENGTH = T.gravity), T.numIter != null && (y.MAX_ITERATIONS = v.MAX_ITERATIONS = T.numIter), T.gravityRange != null && (y.DEFAULT_GRAVITY_RANGE_FACTOR = v.DEFAULT_GRAVITY_RANGE_FACTOR = T.gravityRange), T.gravityCompound != null && (y.DEFAULT_COMPOUND_GRAVITY_STRENGTH = v.DEFAULT_COMPOUND_GRAVITY_STRENGTH = T.gravityCompound), T.gravityRangeCompound != null && (y.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = v.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = T.gravityRangeCompound), T.initialEnergyOnIncremental != null && (y.DEFAULT_COOLING_FACTOR_INCREMENTAL = v.DEFAULT_COOLING_FACTOR_INCREMENTAL = T.initialEnergyOnIncremental), T.tilingCompareBy != null && (y.TILING_COMPARE_BY = T.tilingCompareBy), T.quality == "proof" ? m.QUALITY = 2 : m.QUALITY = 0, y.NODE_DIMENSIONS_INCLUDE_LABELS = v.NODE_DIMENSIONS_INCLUDE_LABELS = m.NODE_DIMENSIONS_INCLUDE_LABELS = T.nodeDimensionsIncludeLabels, y.DEFAULT_INCREMENTAL = v.DEFAULT_INCREMENTAL = m.DEFAULT_INCREMENTAL = !T.randomize, y.ANIMATE = v.ANIMATE = m.ANIMATE = T.animate, y.TILE = T.tile, y.TILING_PADDING_VERTICAL = typeof T.tilingPaddingVertical == "function" ? T.tilingPaddingVertical.call() : T.tilingPaddingVertical, y.TILING_PADDING_HORIZONTAL = typeof T.tilingPaddingHorizontal == "function" ? T.tilingPaddingHorizontal.call() : T.tilingPaddingHorizontal, y.DEFAULT_INCREMENTAL = v.DEFAULT_INCREMENTAL = m.DEFAULT_INCREMENTAL = !0, y.PURE_INCREMENTAL = !T.randomize, m.DEFAULT_UNIFORM_LEAF_NODE_SIZES = T.uniformNodeDimensions, T.step == "transformed" && (y.TRANSFORM_ON_CONSTRAINT_HANDLING = !0, y.ENFORCE_CONSTRAINTS = !1, y.APPLY_LAYOUT = !1), T.step == "enforced" && (y.TRANSFORM_ON_CONSTRAINT_HANDLING = !1, y.ENFORCE_CONSTRAINTS = !0, y.APPLY_LAYOUT = !1), T.step == "cose" && (y.TRANSFORM_ON_CONSTRAINT_HANDLING = !1, y.ENFORCE_CONSTRAINTS = !1, y.APPLY_LAYOUT = !0), T.step == "all" && (T.randomize ? y.TRANSFORM_ON_CONSTRAINT_HANDLING = !0 : y.TRANSFORM_ON_CONSTRAINT_HANDLING = !1, y.ENFORCE_CONSTRAINTS = !0, y.APPLY_LAYOUT = !0), T.fixedNodeConstraint || T.alignmentConstraint || T.relativePlacementConstraint ? y.TREE_REDUCTION_ON_INCREMENTAL = !1 : y.TREE_REDUCTION_ON_INCREMENTAL = !0;
                  var z = new d(), F = z.newGraphManager();
                  return D(F.addRoot(), h.getTopMostNodes(C), z, T), I(z, F, A), B(z, T), z.runLayout(), P;
                };
                o.exports = { coseLayout: b };
              })
            ),
            /***/
            212: (
              /***/
              ((o, l, u) => {
                var h = /* @__PURE__ */ (function() {
                  function T(E, L) {
                    for (var k = 0; k < L.length; k++) {
                      var C = L[k];
                      C.enumerable = C.enumerable || !1, C.configurable = !0, "value" in C && (C.writable = !0), Object.defineProperty(E, C.key, C);
                    }
                  }
                  return function(E, L, k) {
                    return L && T(E.prototype, L), k && T(E, k), E;
                  };
                })();
                function d(T, E) {
                  if (!(T instanceof E))
                    throw new TypeError("Cannot call a class as a function");
                }
                var f = u(658), p = u(548), g = u(657), m = g.spectralLayout, v = u(816), y = v.coseLayout, b = Object.freeze({
                  // 'draft', 'default' or 'proof' 
                  // - 'draft' only applies spectral layout 
                  // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)
                  // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) 
                  quality: "default",
                  // Use random node positions at beginning of layout
                  // if this is set to false, then quality option must be "proof"
                  randomize: !0,
                  // Whether or not to animate the layout
                  animate: !0,
                  // Duration of animation in ms, if enabled
                  animationDuration: 1e3,
                  // Easing of animation, if enabled
                  animationEasing: void 0,
                  // Fit the viewport to the repositioned nodes
                  fit: !0,
                  // Padding around layout
                  padding: 30,
                  // Whether to include labels in node dimensions. Valid in "proof" quality
                  nodeDimensionsIncludeLabels: !1,
                  // Whether or not simple nodes (non-compound nodes) are of uniform dimensions
                  uniformNodeDimensions: !1,
                  // Whether to pack disconnected components - valid only if randomize: true
                  packComponents: !0,
                  // Layout step - all, transformed, enforced, cose - for debug purpose only
                  step: "all",
                  /* spectral layout options */
                  // False for random, true for greedy
                  samplingType: !0,
                  // Sample size to construct distance matrix
                  sampleSize: 25,
                  // Separation amount between nodes
                  nodeSeparation: 75,
                  // Power iteration tolerance
                  piTol: 1e-7,
                  /* CoSE layout options */
                  // Node repulsion (non overlapping) multiplier
                  nodeRepulsion: function(E) {
                    return 4500;
                  },
                  // Ideal edge (non nested) length
                  idealEdgeLength: function(E) {
                    return 50;
                  },
                  // Divisor to compute edge forces
                  edgeElasticity: function(E) {
                    return 0.45;
                  },
                  // Nesting factor (multiplier) to compute ideal edge length for nested edges
                  nestingFactor: 0.1,
                  // Gravity force (constant)
                  gravity: 0.25,
                  // Maximum number of iterations to perform
                  numIter: 2500,
                  // For enabling tiling
                  tile: !0,
                  // The function that specifies the criteria for comparing nodes while sorting them during tiling operation.
                  // Takes the node id as a parameter and the default tiling operation is perfomed when this option is not set.
                  tilingCompareBy: void 0,
                  // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)
                  tilingPaddingVertical: 10,
                  // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)
                  tilingPaddingHorizontal: 10,
                  // Gravity range (constant) for compounds
                  gravityRangeCompound: 1.5,
                  // Gravity force (constant) for compounds
                  gravityCompound: 1,
                  // Gravity range (constant)
                  gravityRange: 3.8,
                  // Initial cooling factor for incremental layout  
                  initialEnergyOnIncremental: 0.3,
                  /* constraint options */
                  // Fix required nodes to predefined positions
                  // [{nodeId: 'n1', position: {x: 100, y: 200}, {...}]
                  fixedNodeConstraint: void 0,
                  // Align required nodes in vertical/horizontal direction
                  // {vertical: [['n1', 'n2')], ['n3', 'n4']], horizontal: ['n2', 'n4']}
                  alignmentConstraint: void 0,
                  // Place two nodes relatively in vertical/horizontal direction 
                  // [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}]
                  relativePlacementConstraint: void 0,
                  /* layout event callbacks */
                  ready: function() {
                  },
                  // on layoutready
                  stop: function() {
                  }
                  // on layoutstop
                }), w = (function() {
                  function T(E) {
                    d(this, T), this.options = f({}, b, E);
                  }
                  return h(T, [{
                    key: "run",
                    value: function() {
                      var L = this, k = this.options, C = k.cy, A = k.eles, R = [], _ = [], O = void 0, P = [];
                      k.fixedNodeConstraint && (!Array.isArray(k.fixedNodeConstraint) || k.fixedNodeConstraint.length == 0) && (k.fixedNodeConstraint = void 0), k.alignmentConstraint && (k.alignmentConstraint.vertical && (!Array.isArray(k.alignmentConstraint.vertical) || k.alignmentConstraint.vertical.length == 0) && (k.alignmentConstraint.vertical = void 0), k.alignmentConstraint.horizontal && (!Array.isArray(k.alignmentConstraint.horizontal) || k.alignmentConstraint.horizontal.length == 0) && (k.alignmentConstraint.horizontal = void 0)), k.relativePlacementConstraint && (!Array.isArray(k.relativePlacementConstraint) || k.relativePlacementConstraint.length == 0) && (k.relativePlacementConstraint = void 0);
                      var S = k.fixedNodeConstraint || k.alignmentConstraint || k.relativePlacementConstraint;
                      S && (k.tile = !1, k.packComponents = !1);
                      var M = void 0, N = !1;
                      if (C.layoutUtilities && k.packComponents && (M = C.layoutUtilities("get"), M || (M = C.layoutUtilities()), N = !0), A.nodes().length > 0)
                        if (N) {
                          var B = p.getTopMostNodes(k.eles.nodes());
                          if (O = p.connectComponents(C, k.eles, B), O.forEach(function(Ae) {
                            var W = Ae.boundingBox();
                            P.push({ x: W.x1 + W.w / 2, y: W.y1 + W.h / 2 });
                          }), k.randomize && O.forEach(function(Ae) {
                            k.eles = Ae, R.push(m(k));
                          }), k.quality == "default" || k.quality == "proof") {
                            var z = C.collection();
                            if (k.tile) {
                              var F = /* @__PURE__ */ new Map(), V = [], H = [], J = 0, q = { nodeIndexes: F, xCoords: V, yCoords: H }, ae = [];
                              if (O.forEach(function(Ae, W) {
                                Ae.edges().length == 0 && (Ae.nodes().forEach(function(De, ue) {
                                  z.merge(Ae.nodes()[ue]), De.isParent() || (q.nodeIndexes.set(Ae.nodes()[ue].id(), J++), q.xCoords.push(Ae.nodes()[0].position().x), q.yCoords.push(Ae.nodes()[0].position().y));
                                }), ae.push(W));
                              }), z.length > 1) {
                                var re = z.boundingBox();
                                P.push({ x: re.x1 + re.w / 2, y: re.y1 + re.h / 2 }), O.push(z), R.push(q);
                                for (var pe = ae.length - 1; pe >= 0; pe--)
                                  O.splice(ae[pe], 1), R.splice(ae[pe], 1), P.splice(ae[pe], 1);
                              }
                            }
                            O.forEach(function(Ae, W) {
                              k.eles = Ae, _.push(y(k, R[W])), p.relocateComponent(P[W], _[W], k);
                            });
                          } else
                            O.forEach(function(Ae, W) {
                              p.relocateComponent(P[W], R[W], k);
                            });
                          var K = /* @__PURE__ */ new Set();
                          if (O.length > 1) {
                            var Z = [], X = A.filter(function(Ae) {
                              return Ae.css("display") == "none";
                            });
                            O.forEach(function(Ae, W) {
                              var De = void 0;
                              if (k.quality == "draft" && (De = R[W].nodeIndexes), Ae.nodes().not(X).length > 0) {
                                var ue = {};
                                ue.edges = [], ue.nodes = [];
                                var ze = void 0;
                                Ae.nodes().not(X).forEach(function(Ge) {
                                  if (k.quality == "draft")
                                    if (!Ge.isParent())
                                      ze = De.get(Ge.id()), ue.nodes.push({ x: R[W].xCoords[ze] - Ge.boundingbox().w / 2, y: R[W].yCoords[ze] - Ge.boundingbox().h / 2, width: Ge.boundingbox().w, height: Ge.boundingbox().h });
                                    else {
                                      var Ve = p.calcBoundingBox(Ge, R[W].xCoords, R[W].yCoords, De);
                                      ue.nodes.push({ x: Ve.topLeftX, y: Ve.topLeftY, width: Ve.width, height: Ve.height });
                                    }
                                  else
                                    _[W][Ge.id()] && ue.nodes.push({ x: _[W][Ge.id()].getLeft(), y: _[W][Ge.id()].getTop(), width: _[W][Ge.id()].getWidth(), height: _[W][Ge.id()].getHeight() });
                                }), Ae.edges().forEach(function(Ge) {
                                  var Ve = Ge.source(), ke = Ge.target();
                                  if (Ve.css("display") != "none" && ke.css("display") != "none")
                                    if (k.quality == "draft") {
                                      var Oe = De.get(Ve.id()), Se = De.get(ke.id()), _e = [], $e = [];
                                      if (Ve.isParent()) {
                                        var me = p.calcBoundingBox(Ve, R[W].xCoords, R[W].yCoords, De);
                                        _e.push(me.topLeftX + me.width / 2), _e.push(me.topLeftY + me.height / 2);
                                      } else
                                        _e.push(R[W].xCoords[Oe]), _e.push(R[W].yCoords[Oe]);
                                      if (ke.isParent()) {
                                        var Ne = p.calcBoundingBox(ke, R[W].xCoords, R[W].yCoords, De);
                                        $e.push(Ne.topLeftX + Ne.width / 2), $e.push(Ne.topLeftY + Ne.height / 2);
                                      } else
                                        $e.push(R[W].xCoords[Se]), $e.push(R[W].yCoords[Se]);
                                      ue.edges.push({ startX: _e[0], startY: _e[1], endX: $e[0], endY: $e[1] });
                                    } else
                                      _[W][Ve.id()] && _[W][ke.id()] && ue.edges.push({ startX: _[W][Ve.id()].getCenterX(), startY: _[W][Ve.id()].getCenterY(), endX: _[W][ke.id()].getCenterX(), endY: _[W][ke.id()].getCenterY() });
                                }), ue.nodes.length > 0 && (Z.push(ue), K.add(W));
                              }
                            });
                            var Y = M.packComponents(Z, k.randomize).shifts;
                            if (k.quality == "draft")
                              R.forEach(function(Ae, W) {
                                var De = Ae.xCoords.map(function(ze) {
                                  return ze + Y[W].dx;
                                }), ue = Ae.yCoords.map(function(ze) {
                                  return ze + Y[W].dy;
                                });
                                Ae.xCoords = De, Ae.yCoords = ue;
                              });
                            else {
                              var ee = 0;
                              K.forEach(function(Ae) {
                                Object.keys(_[Ae]).forEach(function(W) {
                                  var De = _[Ae][W];
                                  De.setCenter(De.getCenterX() + Y[ee].dx, De.getCenterY() + Y[ee].dy);
                                }), ee++;
                              });
                            }
                          }
                        } else {
                          var D = k.eles.boundingBox();
                          if (P.push({ x: D.x1 + D.w / 2, y: D.y1 + D.h / 2 }), k.randomize) {
                            var I = m(k);
                            R.push(I);
                          }
                          k.quality == "default" || k.quality == "proof" ? (_.push(y(k, R[0])), p.relocateComponent(P[0], _[0], k)) : p.relocateComponent(P[0], R[0], k);
                        }
                      var j = function(W, De) {
                        if (k.quality == "default" || k.quality == "proof") {
                          typeof W == "number" && (W = De);
                          var ue = void 0, ze = void 0, Ge = W.data("id");
                          return _.forEach(function(ke) {
                            Ge in ke && (ue = { x: ke[Ge].getRect().getCenterX(), y: ke[Ge].getRect().getCenterY() }, ze = ke[Ge]);
                          }), k.nodeDimensionsIncludeLabels && (ze.labelWidth && (ze.labelPosHorizontal == "left" ? ue.x += ze.labelWidth / 2 : ze.labelPosHorizontal == "right" && (ue.x -= ze.labelWidth / 2)), ze.labelHeight && (ze.labelPosVertical == "top" ? ue.y += ze.labelHeight / 2 : ze.labelPosVertical == "bottom" && (ue.y -= ze.labelHeight / 2))), ue == null && (ue = { x: W.position("x"), y: W.position("y") }), {
                            x: ue.x,
                            y: ue.y
                          };
                        } else {
                          var Ve = void 0;
                          return R.forEach(function(ke) {
                            var Oe = ke.nodeIndexes.get(W.id());
                            Oe != null && (Ve = { x: ke.xCoords[Oe], y: ke.yCoords[Oe] });
                          }), Ve == null && (Ve = { x: W.position("x"), y: W.position("y") }), {
                            x: Ve.x,
                            y: Ve.y
                          };
                        }
                      };
                      if (k.quality == "default" || k.quality == "proof" || k.randomize) {
                        var fe = p.calcParentsWithoutChildren(C, A), te = A.filter(function(Ae) {
                          return Ae.css("display") == "none";
                        });
                        k.eles = A.not(te), A.nodes().not(":parent").not(te).layoutPositions(L, k, j), fe.length > 0 && fe.forEach(function(Ae) {
                          Ae.position(j(Ae));
                        });
                      } else
                        console.log("If randomize option is set to false, then quality option must be 'default' or 'proof'.");
                    }
                  }]), T;
                })();
                o.exports = w;
              })
            ),
            /***/
            657: (
              /***/
              ((o, l, u) => {
                var h = u(548), d = u(140).layoutBase.Matrix, f = u(140).layoutBase.SVD, p = function(m) {
                  var v = m.cy, y = m.eles, b = y.nodes(), w = y.nodes(":parent"), T = /* @__PURE__ */ new Map(), E = /* @__PURE__ */ new Map(), L = /* @__PURE__ */ new Map(), k = [], C = [], A = [], R = [], _ = [], O = [], P = [], S = [], M = void 0, N = 1e8, D = 1e-9, I = m.piTol, B = m.samplingType, z = m.nodeSeparation, F = void 0, V = function() {
                    for (var $ = 0, oe = 0, se = !1; oe < F; ) {
                      $ = Math.floor(Math.random() * M), se = !1;
                      for (var ge = 0; ge < oe; ge++)
                        if (R[ge] == $) {
                          se = !0;
                          break;
                        }
                      if (!se)
                        R[oe] = $, oe++;
                      else
                        continue;
                    }
                  }, H = function($, oe, se) {
                    for (var ge = [], he = 0, be = 0, Ce = 0, Te = void 0, Me = [], Xe = 0, We = 1, Ke = 0; Ke < M; Ke++)
                      Me[Ke] = N;
                    for (ge[be] = $, Me[$] = 0; be >= he; ) {
                      Ce = ge[he++];
                      for (var Ze = k[Ce], Pe = 0; Pe < Ze.length; Pe++)
                        Te = E.get(Ze[Pe]), Me[Te] == N && (Me[Te] = Me[Ce] + 1, ge[++be] = Te);
                      O[Ce][oe] = Me[Ce] * z;
                    }
                    if (se) {
                      for (var He = 0; He < M; He++)
                        O[He][oe] < _[He] && (_[He] = O[He][oe]);
                      for (var ht = 0; ht < M; ht++)
                        _[ht] > Xe && (Xe = _[ht], We = ht);
                    }
                    return We;
                  }, J = function($) {
                    var oe = void 0;
                    if ($) {
                      oe = Math.floor(Math.random() * M);
                      for (var ge = 0; ge < M; ge++)
                        _[ge] = N;
                      for (var he = 0; he < F; he++)
                        R[he] = oe, oe = H(oe, he, $);
                    } else {
                      V();
                      for (var se = 0; se < F; se++)
                        H(R[se], se, $);
                    }
                    for (var be = 0; be < M; be++)
                      for (var Ce = 0; Ce < F; Ce++)
                        O[be][Ce] *= O[be][Ce];
                    for (var Te = 0; Te < F; Te++)
                      P[Te] = [];
                    for (var Me = 0; Me < F; Me++)
                      for (var Xe = 0; Xe < F; Xe++)
                        P[Me][Xe] = O[R[Xe]][Me];
                  }, q = function() {
                    for (var $ = f.svd(P), oe = $.S, se = $.U, ge = $.V, he = oe[0] * oe[0] * oe[0], be = [], Ce = 0; Ce < F; Ce++) {
                      be[Ce] = [];
                      for (var Te = 0; Te < F; Te++)
                        be[Ce][Te] = 0, Ce == Te && (be[Ce][Te] = oe[Ce] / (oe[Ce] * oe[Ce] + he / (oe[Ce] * oe[Ce])));
                    }
                    S = d.multMat(d.multMat(ge, be), d.transpose(se));
                  }, ae = function() {
                    for (var $ = void 0, oe = void 0, se = [], ge = [], he = [], be = [], Ce = 0; Ce < M; Ce++)
                      se[Ce] = Math.random(), ge[Ce] = Math.random();
                    se = d.normalize(se), ge = d.normalize(ge);
                    for (var Te = D, Me = D, Xe = void 0; ; ) {
                      for (var We = 0; We < M; We++)
                        he[We] = se[We];
                      if (se = d.multGamma(d.multL(d.multGamma(he), O, S)), $ = d.dotProduct(he, se), se = d.normalize(se), Te = d.dotProduct(he, se), Xe = Math.abs(Te / Me), Xe <= 1 + I && Xe >= 1)
                        break;
                      Me = Te;
                    }
                    for (var Ke = 0; Ke < M; Ke++)
                      he[Ke] = se[Ke];
                    for (Me = D; ; ) {
                      for (var Ze = 0; Ze < M; Ze++)
                        be[Ze] = ge[Ze];
                      if (be = d.minusOp(be, d.multCons(he, d.dotProduct(he, be))), ge = d.multGamma(d.multL(d.multGamma(be), O, S)), oe = d.dotProduct(be, ge), ge = d.normalize(ge), Te = d.dotProduct(be, ge), Xe = Math.abs(Te / Me), Xe <= 1 + I && Xe >= 1)
                        break;
                      Me = Te;
                    }
                    for (var Pe = 0; Pe < M; Pe++)
                      be[Pe] = ge[Pe];
                    C = d.multCons(he, Math.sqrt(Math.abs($))), A = d.multCons(be, Math.sqrt(Math.abs(oe)));
                  };
                  h.connectComponents(v, y, h.getTopMostNodes(b), T), w.forEach(function(ce) {
                    h.connectComponents(v, y, h.getTopMostNodes(ce.descendants().intersection(y)), T);
                  });
                  for (var re = 0, pe = 0; pe < b.length; pe++)
                    b[pe].isParent() || E.set(b[pe].id(), re++);
                  var K = !0, Z = !1, X = void 0;
                  try {
                    for (var Y = T.keys()[Symbol.iterator](), ee; !(K = (ee = Y.next()).done); K = !0) {
                      var j = ee.value;
                      E.set(j, re++);
                    }
                  } catch (ce) {
                    Z = !0, X = ce;
                  } finally {
                    try {
                      !K && Y.return && Y.return();
                    } finally {
                      if (Z)
                        throw X;
                    }
                  }
                  for (var fe = 0; fe < E.size; fe++)
                    k[fe] = [];
                  w.forEach(function(ce) {
                    for (var $ = ce.children().intersection(y); $.nodes(":childless").length == 0; )
                      $ = $.nodes()[0].children().intersection(y);
                    var oe = 0, se = $.nodes(":childless")[0].connectedEdges().length;
                    $.nodes(":childless").forEach(function(ge, he) {
                      ge.connectedEdges().length < se && (se = ge.connectedEdges().length, oe = he);
                    }), L.set(ce.id(), $.nodes(":childless")[oe].id());
                  }), b.forEach(function(ce) {
                    var $ = void 0;
                    ce.isParent() ? $ = E.get(L.get(ce.id())) : $ = E.get(ce.id()), ce.neighborhood().nodes().forEach(function(oe) {
                      y.intersection(ce.edgesWith(oe)).length > 0 && (oe.isParent() ? k[$].push(L.get(oe.id())) : k[$].push(oe.id()));
                    });
                  });
                  var te = function($) {
                    var oe = E.get($), se = void 0;
                    T.get($).forEach(function(ge) {
                      v.getElementById(ge).isParent() ? se = L.get(ge) : se = ge, k[oe].push(se), k[E.get(se)].push($);
                    });
                  }, Ae = !0, W = !1, De = void 0;
                  try {
                    for (var ue = T.keys()[Symbol.iterator](), ze; !(Ae = (ze = ue.next()).done); Ae = !0) {
                      var Ge = ze.value;
                      te(Ge);
                    }
                  } catch (ce) {
                    W = !0, De = ce;
                  } finally {
                    try {
                      !Ae && ue.return && ue.return();
                    } finally {
                      if (W)
                        throw De;
                    }
                  }
                  M = E.size;
                  var Ve = void 0;
                  if (M > 2) {
                    F = M < m.sampleSize ? M : m.sampleSize;
                    for (var ke = 0; ke < M; ke++)
                      O[ke] = [];
                    for (var Oe = 0; Oe < F; Oe++)
                      S[Oe] = [];
                    return m.quality == "draft" || m.step == "all" ? (J(B), q(), ae(), Ve = { nodeIndexes: E, xCoords: C, yCoords: A }) : (E.forEach(function(ce, $) {
                      C.push(v.getElementById($).position("x")), A.push(v.getElementById($).position("y"));
                    }), Ve = { nodeIndexes: E, xCoords: C, yCoords: A }), Ve;
                  } else {
                    var Se = E.keys(), _e = v.getElementById(Se.next().value), $e = _e.position(), me = _e.outerWidth();
                    if (C.push($e.x), A.push($e.y), M == 2) {
                      var Ne = v.getElementById(Se.next().value), Q = Ne.outerWidth();
                      C.push($e.x + me / 2 + Q / 2 + m.idealEdgeLength), A.push($e.y);
                    }
                    return Ve = { nodeIndexes: E, xCoords: C, yCoords: A }, Ve;
                  }
                };
                o.exports = { spectralLayout: p };
              })
            ),
            /***/
            579: (
              /***/
              ((o, l, u) => {
                var h = u(212), d = function(p) {
                  p && p("layout", "fcose", h);
                };
                typeof cytoscape < "u" && d(cytoscape), o.exports = d;
              })
            ),
            /***/
            140: (
              /***/
              ((o) => {
                o.exports = r;
              })
            )
            /******/
          }, i = {};
          function a(o) {
            var l = i[o];
            if (l !== void 0)
              return l.exports;
            var u = i[o] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            return n[o](u, u.exports, a), u.exports;
          }
          var s = a(579);
          return s;
        })()
      );
    });
  })(wv)), wv.exports;
}
var i$e = n$e();
const a$e = /* @__PURE__ */ $u(i$e);
var gI = {
  L: "left",
  R: "right",
  T: "top",
  B: "bottom"
}, mI = {
  L: /* @__PURE__ */ x((t) => `${t},${t / 2} 0,${t} 0,0`, "L"),
  R: /* @__PURE__ */ x((t) => `0,${t / 2} ${t},0 ${t},${t}`, "R"),
  T: /* @__PURE__ */ x((t) => `0,0 ${t},0 ${t / 2},${t}`, "T"),
  B: /* @__PURE__ */ x((t) => `${t / 2},0 ${t},${t} 0,${t}`, "B")
}, pm = {
  L: /* @__PURE__ */ x((t, e) => t - e + 2, "L"),
  R: /* @__PURE__ */ x((t, e) => t - 2, "R"),
  T: /* @__PURE__ */ x((t, e) => t - e + 2, "T"),
  B: /* @__PURE__ */ x((t, e) => t - 2, "B")
}, s$e = /* @__PURE__ */ x(function(t) {
  return Oi(t) ? t === "L" ? "R" : "L" : t === "T" ? "B" : "T";
}, "getOppositeArchitectureDirection"), vI = /* @__PURE__ */ x(function(t) {
  const e = t;
  return e === "L" || e === "R" || e === "T" || e === "B";
}, "isArchitectureDirection"), Oi = /* @__PURE__ */ x(function(t) {
  const e = t;
  return e === "L" || e === "R";
}, "isArchitectureDirectionX"), uc = /* @__PURE__ */ x(function(t) {
  const e = t;
  return e === "T" || e === "B";
}, "isArchitectureDirectionY"), W7 = /* @__PURE__ */ x(function(t, e) {
  const r = Oi(t) && uc(e), n = uc(t) && Oi(e);
  return r || n;
}, "isArchitectureDirectionXY"), o$e = /* @__PURE__ */ x(function(t) {
  const e = t[0], r = t[1], n = Oi(e) && uc(r), i = uc(e) && Oi(r);
  return n || i;
}, "isArchitecturePairXY"), l$e = /* @__PURE__ */ x(function(t) {
  return t !== "LL" && t !== "RR" && t !== "TT" && t !== "BB";
}, "isValidArchitectureDirectionPair"), rE = /* @__PURE__ */ x(function(t, e) {
  const r = `${t}${e}`;
  return l$e(r) ? r : void 0;
}, "getArchitectureDirectionPair"), c$e = /* @__PURE__ */ x(function([t, e], r) {
  const n = r[0], i = r[1];
  return Oi(n) ? uc(i) ? [t + (n === "L" ? -1 : 1), e + (i === "T" ? 1 : -1)] : [t + (n === "L" ? -1 : 1), e] : Oi(i) ? [t + (i === "L" ? 1 : -1), e + (n === "T" ? 1 : -1)] : [t, e + (n === "T" ? 1 : -1)];
}, "shiftPositionByArchitectureDirectionPair"), u$e = /* @__PURE__ */ x(function(t) {
  return t === "LT" || t === "TL" ? [1, 1] : t === "BL" || t === "LB" ? [1, -1] : t === "BR" || t === "RB" ? [-1, -1] : [-1, 1];
}, "getArchitectureDirectionXYFactors"), h$e = /* @__PURE__ */ x(function(t, e) {
  return W7(t, e) ? "bend" : Oi(t) ? "horizontal" : "vertical";
}, "getArchitectureDirectionAlignment"), d$e = /* @__PURE__ */ x(function(t) {
  return t.type === "service";
}, "isArchitectureService"), f$e = /* @__PURE__ */ x(function(t) {
  return t.type === "junction";
}, "isArchitectureJunction"), dj = /* @__PURE__ */ x((t) => t.data(), "edgeData"), qh = /* @__PURE__ */ x((t) => t.data(), "nodeData"), p$e = ur.architecture, fj = class {
  constructor() {
    this.nodes = {}, this.groups = {}, this.edges = [], this.registeredIds = {}, this.elements = {}, this.setAccTitle = Cn, this.getAccTitle = Gn, this.setDiagramTitle = Zn, this.getDiagramTitle = Ln, this.getAccDescription = Un, this.setAccDescription = Vn, this.clear();
  }
  static {
    x(this, "ArchitectureDB");
  }
  clear() {
    this.nodes = {}, this.groups = {}, this.edges = [], this.registeredIds = {}, this.dataStructures = void 0, this.elements = {}, _n();
  }
  addService({
    id: t,
    icon: e,
    in: r,
    title: n,
    iconText: i
  }) {
    if (this.registeredIds[t] !== void 0)
      throw new Error(
        `The service id [${t}] is already in use by another ${this.registeredIds[t]}`
      );
    if (r !== void 0) {
      if (t === r)
        throw new Error(`The service [${t}] cannot be placed within itself`);
      if (this.registeredIds[r] === void 0)
        throw new Error(
          `The service [${t}]'s parent does not exist. Please make sure the parent is created before this service`
        );
      if (this.registeredIds[r] === "node")
        throw new Error(`The service [${t}]'s parent is not a group`);
    }
    this.registeredIds[t] = "node", this.nodes[t] = {
      id: t,
      type: "service",
      icon: e,
      iconText: i,
      title: n,
      edges: [],
      in: r
    };
  }
  getServices() {
    return Object.values(this.nodes).filter(d$e);
  }
  addJunction({ id: t, in: e }) {
    this.registeredIds[t] = "node", this.nodes[t] = {
      id: t,
      type: "junction",
      edges: [],
      in: e
    };
  }
  getJunctions() {
    return Object.values(this.nodes).filter(f$e);
  }
  getNodes() {
    return Object.values(this.nodes);
  }
  getNode(t) {
    return this.nodes[t] ?? null;
  }
  addGroup({ id: t, icon: e, in: r, title: n }) {
    if (this.registeredIds?.[t] !== void 0)
      throw new Error(
        `The group id [${t}] is already in use by another ${this.registeredIds[t]}`
      );
    if (r !== void 0) {
      if (t === r)
        throw new Error(`The group [${t}] cannot be placed within itself`);
      if (this.registeredIds?.[r] === void 0)
        throw new Error(
          `The group [${t}]'s parent does not exist. Please make sure the parent is created before this group`
        );
      if (this.registeredIds?.[r] === "node")
        throw new Error(`The group [${t}]'s parent is not a group`);
    }
    this.registeredIds[t] = "group", this.groups[t] = {
      id: t,
      icon: e,
      title: n,
      in: r
    };
  }
  getGroups() {
    return Object.values(this.groups);
  }
  addEdge({
    lhsId: t,
    rhsId: e,
    lhsDir: r,
    rhsDir: n,
    lhsInto: i,
    rhsInto: a,
    lhsGroup: s,
    rhsGroup: o,
    title: l
  }) {
    if (!vI(r))
      throw new Error(
        `Invalid direction given for left hand side of edge ${t}--${e}. Expected (L,R,T,B) got ${String(r)}`
      );
    if (!vI(n))
      throw new Error(
        `Invalid direction given for right hand side of edge ${t}--${e}. Expected (L,R,T,B) got ${String(n)}`
      );
    if (this.nodes[t] === void 0 && this.groups[t] === void 0)
      throw new Error(
        `The left-hand id [${t}] does not yet exist. Please create the service/group before declaring an edge to it.`
      );
    if (this.nodes[e] === void 0 && this.groups[e] === void 0)
      throw new Error(
        `The right-hand id [${e}] does not yet exist. Please create the service/group before declaring an edge to it.`
      );
    const u = this.nodes[t].in, h = this.nodes[e].in;
    if (s && u && h && u == h)
      throw new Error(
        `The left-hand id [${t}] is modified to traverse the group boundary, but the edge does not pass through two groups.`
      );
    if (o && u && h && u == h)
      throw new Error(
        `The right-hand id [${e}] is modified to traverse the group boundary, but the edge does not pass through two groups.`
      );
    const d = {
      lhsId: t,
      lhsDir: r,
      lhsInto: i,
      lhsGroup: s,
      rhsId: e,
      rhsDir: n,
      rhsInto: a,
      rhsGroup: o,
      title: l
    };
    this.edges.push(d), this.nodes[t] && this.nodes[e] && (this.nodes[t].edges.push(this.edges[this.edges.length - 1]), this.nodes[e].edges.push(this.edges[this.edges.length - 1]));
  }
  getEdges() {
    return this.edges;
  }
  /**
   * Returns the current diagram's adjacency list, spatial map, & group alignments.
   * If they have not been created, run the algorithms to generate them.
   * @returns
   */
  getDataStructures() {
    if (this.dataStructures === void 0) {
      const t = {}, e = Object.entries(this.nodes).reduce((o, [l, u]) => (o[l] = u.edges.reduce((h, d) => {
        const f = this.getNode(d.lhsId)?.in, p = this.getNode(d.rhsId)?.in;
        if (f && p && f !== p) {
          const g = h$e(d.lhsDir, d.rhsDir);
          g !== "bend" && (t[f] ??= {}, t[f][p] = g, t[p] ??= {}, t[p][f] = g);
        }
        if (d.lhsId === l) {
          const g = rE(d.lhsDir, d.rhsDir);
          g && (h[g] = d.rhsId);
        } else {
          const g = rE(d.rhsDir, d.lhsDir);
          g && (h[g] = d.lhsId);
        }
        return h;
      }, {}), o), {}), r = Object.keys(e)[0], n = { [r]: 1 }, i = Object.keys(e).reduce(
        (o, l) => l === r ? o : { ...o, [l]: 1 },
        {}
      ), a = /* @__PURE__ */ x((o) => {
        const l = { [o]: [0, 0] }, u = [o];
        for (; u.length > 0; ) {
          const h = u.shift();
          if (h) {
            n[h] = 1, delete i[h];
            const d = e[h], [f, p] = l[h];
            Object.entries(d).forEach(([g, m]) => {
              n[m] || (l[m] = c$e(
                [f, p],
                g
              ), u.push(m));
            });
          }
        }
        return l;
      }, "BFS"), s = [a(r)];
      for (; Object.keys(i).length > 0; )
        s.push(a(Object.keys(i)[0]));
      this.dataStructures = {
        adjList: e,
        spatialMaps: s,
        groupAlignments: t
      };
    }
    return this.dataStructures;
  }
  setElementForId(t, e) {
    this.elements[t] = e;
  }
  getElementById(t) {
    return this.elements[t];
  }
  getConfig() {
    return Hi({
      ...p$e,
      ...pr().architecture
    });
  }
  getConfigField(t) {
    return this.getConfig()[t];
  }
}, g$e = /* @__PURE__ */ x((t, e) => {
  nh(t, e), t.groups.map((r) => e.addGroup(r)), t.services.map((r) => e.addService({ ...r, type: "service" })), t.junctions.map((r) => e.addJunction({ ...r, type: "junction" })), t.edges.map((r) => e.addEdge(r));
}, "populateDb"), pj = {
  parser: {
    // @ts-expect-error - ArchitectureDB is not assignable to DiagramDB
    yy: void 0
  },
  parse: /* @__PURE__ */ x(async (t) => {
    const e = await Lc("architecture", t);
    ie.debug(e);
    const r = pj.parser?.yy;
    if (!(r instanceof fj))
      throw new Error(
        "parser.parser?.yy was not a ArchitectureDB. This is due to a bug within Mermaid, please report this issue at https://github.com/mermaid-js/mermaid/issues."
      );
    g$e(e, r);
  }, "parse")
}, m$e = /* @__PURE__ */ x((t) => `
  .edge {
    stroke-width: ${t.archEdgeWidth};
    stroke: ${t.archEdgeColor};
    fill: none;
  }

  .arrow {
    fill: ${t.archEdgeArrowColor};
  }

  .node-bkg {
    fill: none;
    stroke: ${t.archGroupBorderColor};
    stroke-width: ${t.archGroupBorderWidth};
    stroke-dasharray: 8;
  }
  .node-icon-text {
    display: flex; 
    align-items: center;
  }
  
  .node-icon-text > div {
    color: #fff;
    margin: 1px;
    height: fit-content;
    text-align: center;
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
  }
`, "getStyles"), v$e = m$e, _h = /* @__PURE__ */ x((t) => `<g><rect width="80" height="80" style="fill: #087ebf; stroke-width: 0px;"/>${t}</g>`, "wrapIcon"), ig = {
  prefix: "mermaid-architecture",
  height: 80,
  width: 80,
  icons: {
    database: {
      body: _h(
        '<path id="b" data-name="4" d="m20,57.86c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path id="c" data-name="3" d="m20,45.95c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path id="d" data-name="2" d="m20,34.05c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse id="e" data-name="1" cx="40" cy="22.14" rx="20" ry="7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="20" y1="57.86" x2="20" y2="22.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="60" y1="57.86" x2="60" y2="22.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/>'
      )
    },
    server: {
      body: _h(
        '<rect x="17.5" y="17.5" width="45" height="45" rx="2" ry="2" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="17.5" y1="32.5" x2="62.5" y2="32.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="17.5" y1="47.5" x2="62.5" y2="47.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><g><path d="m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: #fff; stroke-width: 0px;"/><path d="m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10;"/></g><g><path d="m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: #fff; stroke-width: 0px;"/><path d="m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10;"/></g><g><path d="m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: #fff; stroke-width: 0px;"/><path d="m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10;"/></g><g><circle cx="32.5" cy="25" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="27.5" cy="25" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="22.5" cy="25" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/></g><g><circle cx="32.5" cy="40" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="27.5" cy="40" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="22.5" cy="40" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/></g><g><circle cx="32.5" cy="55" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="27.5" cy="55" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="22.5" cy="55" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/></g>'
      )
    },
    disk: {
      body: _h(
        '<rect x="20" y="15" width="40" height="50" rx="1" ry="1" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="24" cy="19.17" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="56" cy="19.17" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="24" cy="60.83" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="56" cy="60.83" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="40" cy="33.75" rx="14" ry="14.58" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="40" cy="33.75" rx="4" ry="4.17" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path d="m37.51,42.52l-4.83,13.22c-.26.71-1.1,1.02-1.76.64l-4.18-2.42c-.66-.38-.81-1.26-.33-1.84l9.01-10.8c.88-1.05,2.56-.08,2.09,1.2Z" style="fill: #fff; stroke-width: 0px;"/>'
      )
    },
    internet: {
      body: _h(
        '<circle cx="40" cy="40" r="22.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="40" y1="17.5" x2="40" y2="62.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="17.5" y1="40" x2="62.5" y2="40" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path d="m39.99,17.51c-15.28,11.1-15.28,33.88,0,44.98" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path d="m40.01,17.51c15.28,11.1,15.28,33.88,0,44.98" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="19.75" y1="30.1" x2="60.25" y2="30.1" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="19.75" y1="49.9" x2="60.25" y2="49.9" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/>'
      )
    },
    cloud: {
      body: _h(
        '<path d="m65,47.5c0,2.76-2.24,5-5,5H20c-2.76,0-5-2.24-5-5,0-1.87,1.03-3.51,2.56-4.36-.04-.21-.06-.42-.06-.64,0-2.6,2.48-4.74,5.65-4.97,1.65-4.51,6.34-7.76,11.85-7.76.86,0,1.69.08,2.5.23,2.09-1.57,4.69-2.5,7.5-2.5,6.1,0,11.19,4.38,12.28,10.17,2.14.56,3.72,2.51,3.72,4.83,0,.03,0,.07-.01.1,2.29.46,4.01,2.48,4.01,4.9Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/>'
      )
    },
    unknown: AB,
    blank: {
      body: _h("")
    }
  }
}, y$e = /* @__PURE__ */ x(async function(t, e, r) {
  const n = r.getConfigField("padding"), i = r.getConfigField("iconSize"), a = i / 2, s = i / 6, o = s / 2;
  await Promise.all(
    e.edges().map(async (l) => {
      const {
        source: u,
        sourceDir: h,
        sourceArrow: d,
        sourceGroup: f,
        target: p,
        targetDir: g,
        targetArrow: m,
        targetGroup: v,
        label: y
      } = dj(l);
      let { x: b, y: w } = l[0].sourceEndpoint();
      const { x: T, y: E } = l[0].midpoint();
      let { x: L, y: k } = l[0].targetEndpoint();
      const C = n + 4;
      if (f && (Oi(h) ? b += h === "L" ? -C : C : w += h === "T" ? -C : C + 18), v && (Oi(g) ? L += g === "L" ? -C : C : k += g === "T" ? -C : C + 18), !f && r.getNode(u)?.type === "junction" && (Oi(h) ? b += h === "L" ? a : -a : w += h === "T" ? a : -a), !v && r.getNode(p)?.type === "junction" && (Oi(g) ? L += g === "L" ? a : -a : k += g === "T" ? a : -a), l[0]._private.rscratch) {
        const A = t.insert("g");
        if (A.insert("path").attr("d", `M ${b},${w} L ${T},${E} L${L},${k} `).attr("class", "edge").attr("id", Kh(u, p, { prefix: "L" })), d) {
          const R = Oi(h) ? pm[h](b, s) : b - o, _ = uc(h) ? pm[h](w, s) : w - o;
          A.insert("polygon").attr("points", mI[h](s)).attr("transform", `translate(${R},${_})`).attr("class", "arrow");
        }
        if (m) {
          const R = Oi(g) ? pm[g](L, s) : L - o, _ = uc(g) ? pm[g](k, s) : k - o;
          A.insert("polygon").attr("points", mI[g](s)).attr("transform", `translate(${R},${_})`).attr("class", "arrow");
        }
        if (y) {
          const R = W7(h, g) ? "XY" : Oi(h) ? "X" : "Y";
          let _ = 0;
          R === "X" ? _ = Math.abs(b - L) : R === "Y" ? _ = Math.abs(w - k) / 1.5 : _ = Math.abs(b - L) / 2;
          const O = A.append("g");
          if (await La(
            O,
            y,
            {
              useHtmlLabels: !1,
              width: _,
              classes: "architecture-service-label"
            },
            we()
          ), O.attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle"), R === "X")
            O.attr("transform", "translate(" + T + ", " + E + ")");
          else if (R === "Y")
            O.attr("transform", "translate(" + T + ", " + E + ") rotate(-90)");
          else if (R === "XY") {
            const P = rE(h, g);
            if (P && o$e(P)) {
              const S = O.node().getBoundingClientRect(), [M, N] = u$e(P);
              O.attr("dominant-baseline", "auto").attr("transform", `rotate(${-1 * M * N * 45})`);
              const D = O.node().getBoundingClientRect();
              O.attr(
                "transform",
                `
                translate(${T}, ${E - S.height / 2})
                translate(${M * D.width / 2}, ${N * D.height / 2})
                rotate(${-1 * M * N * 45}, 0, ${S.height / 2})
              `
              );
            }
          }
        }
      }
    })
  );
}, "drawEdges"), x$e = /* @__PURE__ */ x(async function(t, e, r) {
  const i = r.getConfigField("padding") * 0.75, a = r.getConfigField("fontSize"), o = r.getConfigField("iconSize") / 2;
  await Promise.all(
    e.nodes().map(async (l) => {
      const u = qh(l);
      if (u.type === "group") {
        const { h, w: d, x1: f, y1: p } = l.boundingBox(), g = t.append("rect");
        g.attr("id", `group-${u.id}`).attr("x", f + o).attr("y", p + o).attr("width", d).attr("height", h).attr("class", "node-bkg");
        const m = t.append("g");
        let v = f, y = p;
        if (u.icon) {
          const b = m.append("g");
          b.html(
            `<g>${await ql(u.icon, { height: i, width: i, fallbackPrefix: ig.prefix })}</g>`
          ), b.attr(
            "transform",
            "translate(" + (v + o + 1) + ", " + (y + o + 1) + ")"
          ), v += i, y += a / 2 - 1 - 2;
        }
        if (u.label) {
          const b = m.append("g");
          await La(
            b,
            u.label,
            {
              useHtmlLabels: !1,
              width: d,
              classes: "architecture-service-label"
            },
            we()
          ), b.attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "start").attr("text-anchor", "start"), b.attr(
            "transform",
            "translate(" + (v + o + 4) + ", " + (y + o + 2) + ")"
          );
        }
        r.setElementForId(u.id, g);
      }
    })
  );
}, "drawGroups"), b$e = /* @__PURE__ */ x(async function(t, e, r) {
  const n = we();
  for (const i of r) {
    const a = e.append("g"), s = t.getConfigField("iconSize");
    if (i.title) {
      const h = a.append("g");
      await La(
        h,
        i.title,
        {
          useHtmlLabels: !1,
          width: s * 1.5,
          classes: "architecture-service-label"
        },
        n
      ), h.attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle"), h.attr("transform", "translate(" + s / 2 + ", " + s + ")");
    }
    const o = a.append("g");
    if (i.icon)
      o.html(
        `<g>${await ql(i.icon, { height: s, width: s, fallbackPrefix: ig.prefix })}</g>`
      );
    else if (i.iconText) {
      o.html(
        `<g>${await ql("blank", { height: s, width: s, fallbackPrefix: ig.prefix })}</g>`
      );
      const f = o.append("g").append("foreignObject").attr("width", s).attr("height", s).append("div").attr("class", "node-icon-text").attr("style", `height: ${s}px;`).append("div").html(dr(i.iconText, n)), p = parseInt(
        window.getComputedStyle(f.node(), null).getPropertyValue("font-size").replace(/\D/g, "")
      ) ?? 16;
      f.attr("style", `-webkit-line-clamp: ${Math.floor((s - 2) / p)};`);
    } else
      o.append("path").attr("class", "node-bkg").attr("id", "node-" + i.id).attr(
        "d",
        `M0 ${s} v${-s} q0,-5 5,-5 h${s} q5,0 5,5 v${s} H0 Z`
      );
    a.attr("id", `service-${i.id}`).attr("class", "architecture-service");
    const { width: l, height: u } = a.node().getBBox();
    i.width = l, i.height = u, t.setElementForId(i.id, a);
  }
  return 0;
}, "drawServices"), w$e = /* @__PURE__ */ x(function(t, e, r) {
  r.forEach((n) => {
    const i = e.append("g"), a = t.getConfigField("iconSize");
    i.append("g").append("rect").attr("id", "node-" + n.id).attr("fill-opacity", "0").attr("width", a).attr("height", a), i.attr("class", "architecture-junction");
    const { width: o, height: l } = i._groups[0][0].getBBox();
    i.width = o, i.height = l, t.setElementForId(n.id, i);
  });
}, "drawJunctions");
LB([
  {
    name: ig.prefix,
    icons: ig
  }
]);
oo.use(a$e);
function gj(t, e, r) {
  t.forEach((n) => {
    e.add({
      group: "nodes",
      data: {
        type: "service",
        id: n.id,
        icon: n.icon,
        label: n.title,
        parent: n.in,
        width: r.getConfigField("iconSize"),
        height: r.getConfigField("iconSize")
      },
      classes: "node-service"
    });
  });
}
x(gj, "addServices");
function mj(t, e, r) {
  t.forEach((n) => {
    e.add({
      group: "nodes",
      data: {
        type: "junction",
        id: n.id,
        parent: n.in,
        width: r.getConfigField("iconSize"),
        height: r.getConfigField("iconSize")
      },
      classes: "node-junction"
    });
  });
}
x(mj, "addJunctions");
function vj(t, e) {
  e.nodes().map((r) => {
    const n = qh(r);
    if (n.type === "group")
      return;
    n.x = r.position().x, n.y = r.position().y, t.getElementById(n.id).attr("transform", "translate(" + (n.x || 0) + "," + (n.y || 0) + ")");
  });
}
x(vj, "positionNodes");
function yj(t, e) {
  t.forEach((r) => {
    e.add({
      group: "nodes",
      data: {
        type: "group",
        id: r.id,
        icon: r.icon,
        label: r.title,
        parent: r.in
      },
      classes: "node-group"
    });
  });
}
x(yj, "addGroups");
function xj(t, e) {
  t.forEach((r) => {
    const { lhsId: n, rhsId: i, lhsInto: a, lhsGroup: s, rhsInto: o, lhsDir: l, rhsDir: u, rhsGroup: h, title: d } = r, f = W7(r.lhsDir, r.rhsDir) ? "segments" : "straight", p = {
      id: `${n}-${i}`,
      label: d,
      source: n,
      sourceDir: l,
      sourceArrow: a,
      sourceGroup: s,
      sourceEndpoint: l === "L" ? "0 50%" : l === "R" ? "100% 50%" : l === "T" ? "50% 0" : "50% 100%",
      target: i,
      targetDir: u,
      targetArrow: o,
      targetGroup: h,
      targetEndpoint: u === "L" ? "0 50%" : u === "R" ? "100% 50%" : u === "T" ? "50% 0" : "50% 100%"
    };
    e.add({
      group: "edges",
      data: p,
      classes: f
    });
  });
}
x(xj, "addEdges");
function bj(t, e, r) {
  const n = /* @__PURE__ */ x((o, l) => Object.entries(o).reduce(
    (u, [h, d]) => {
      let f = 0;
      const p = Object.entries(d);
      if (p.length === 1)
        return u[h] = p[0][1], u;
      for (let g = 0; g < p.length - 1; g++)
        for (let m = g + 1; m < p.length; m++) {
          const [v, y] = p[g], [b, w] = p[m];
          if (r[v]?.[b] === l)
            u[h] ??= [], u[h] = [...u[h], ...y, ...w];
          else if (v === "default" || b === "default")
            u[h] ??= [], u[h] = [...u[h], ...y, ...w];
          else {
            const E = `${h}-${f++}`;
            u[E] = y;
            const L = `${h}-${f++}`;
            u[L] = w;
          }
        }
      return u;
    },
    {}
  ), "flattenAlignments"), i = e.map((o) => {
    const l = {}, u = {};
    return Object.entries(o).forEach(([h, [d, f]]) => {
      const p = t.getNode(h)?.in ?? "default";
      l[f] ??= {}, l[f][p] ??= [], l[f][p].push(h), u[d] ??= {}, u[d][p] ??= [], u[d][p].push(h);
    }), {
      horiz: Object.values(n(l, "horizontal")).filter(
        (h) => h.length > 1
      ),
      vert: Object.values(n(u, "vertical")).filter(
        (h) => h.length > 1
      )
    };
  }), [a, s] = i.reduce(
    ([o, l], { horiz: u, vert: h }) => [
      [...o, ...u],
      [...l, ...h]
    ],
    [[], []]
  );
  return {
    horizontal: a,
    vertical: s
  };
}
x(bj, "getAlignments");
function wj(t, e) {
  const r = [], n = /* @__PURE__ */ x((a) => `${a[0]},${a[1]}`, "posToStr"), i = /* @__PURE__ */ x((a) => a.split(",").map((s) => parseInt(s)), "strToPos");
  return t.forEach((a) => {
    const s = Object.fromEntries(
      Object.entries(a).map(([h, d]) => [n(d), h])
    ), o = [n([0, 0])], l = {}, u = {
      L: [-1, 0],
      R: [1, 0],
      T: [0, 1],
      B: [0, -1]
    };
    for (; o.length > 0; ) {
      const h = o.shift();
      if (h) {
        l[h] = 1;
        const d = s[h];
        if (d) {
          const f = i(h);
          Object.entries(u).forEach(([p, g]) => {
            const m = n([f[0] + g[0], f[1] + g[1]]), v = s[m];
            v && !l[m] && (o.push(m), r.push({
              [gI[p]]: v,
              [gI[s$e(p)]]: d,
              gap: 1.5 * e.getConfigField("iconSize")
            }));
          });
        }
      }
    }
  }), r;
}
x(wj, "getRelativeConstraints");
function Tj(t, e, r, n, i, { spatialMaps: a, groupAlignments: s }) {
  return new Promise((o) => {
    const l = Qe("body").append("div").attr("id", "cy").attr("style", "display:none"), u = oo({
      container: document.getElementById("cy"),
      style: [
        {
          selector: "edge",
          style: {
            "curve-style": "straight",
            label: "data(label)",
            "source-endpoint": "data(sourceEndpoint)",
            "target-endpoint": "data(targetEndpoint)"
          }
        },
        {
          selector: "edge.segments",
          style: {
            "curve-style": "segments",
            "segment-weights": "0",
            "segment-distances": [0.5],
            // @ts-ignore Incorrect library types
            "edge-distances": "endpoints",
            "source-endpoint": "data(sourceEndpoint)",
            "target-endpoint": "data(targetEndpoint)"
          }
        },
        {
          selector: "node",
          style: {
            // @ts-ignore Incorrect library types
            "compound-sizing-wrt-labels": "include"
          }
        },
        {
          selector: "node[label]",
          style: {
            "text-valign": "bottom",
            "text-halign": "center",
            "font-size": `${i.getConfigField("fontSize")}px`
          }
        },
        {
          selector: ".node-service",
          style: {
            label: "data(label)",
            width: "data(width)",
            height: "data(height)"
          }
        },
        {
          selector: ".node-junction",
          style: {
            width: "data(width)",
            height: "data(height)"
          }
        },
        {
          selector: ".node-group",
          style: {
            // @ts-ignore Incorrect library types
            padding: `${i.getConfigField("padding")}px`
          }
        }
      ],
      layout: {
        name: "grid",
        boundingBox: {
          x1: 0,
          x2: 100,
          y1: 0,
          y2: 100
        }
      }
    });
    l.remove(), yj(r, u), gj(t, u, i), mj(e, u, i), xj(n, u);
    const h = bj(i, a, s), d = wj(a, i), f = u.layout({
      name: "fcose",
      quality: "proof",
      styleEnabled: !1,
      animate: !1,
      nodeDimensionsIncludeLabels: !1,
      // Adjust the edge parameters if it passes through the border of a group
      // Hacky fix for: https://github.com/iVis-at-Bilkent/cytoscape.js-fcose/issues/67
      idealEdgeLength(p) {
        const [g, m] = p.connectedNodes(), { parent: v } = qh(g), { parent: y } = qh(m);
        return v === y ? 1.5 * i.getConfigField("iconSize") : 0.5 * i.getConfigField("iconSize");
      },
      edgeElasticity(p) {
        const [g, m] = p.connectedNodes(), { parent: v } = qh(g), { parent: y } = qh(m);
        return v === y ? 0.45 : 1e-3;
      },
      alignmentConstraint: h,
      relativePlacementConstraint: d
    });
    f.one("layoutstop", () => {
      function p(g, m, v, y) {
        let b, w;
        const { x: T, y: E } = g, { x: L, y: k } = m;
        w = (y - E + (T - v) * (E - k) / (T - L)) / Math.sqrt(1 + Math.pow((E - k) / (T - L), 2)), b = Math.sqrt(Math.pow(y - E, 2) + Math.pow(v - T, 2) - Math.pow(w, 2));
        const C = Math.sqrt(Math.pow(L - T, 2) + Math.pow(k - E, 2));
        b = b / C;
        let A = (L - T) * (y - E) - (k - E) * (v - T);
        switch (!0) {
          case A >= 0:
            A = 1;
            break;
          case A < 0:
            A = -1;
            break;
        }
        let R = (L - T) * (v - T) + (k - E) * (y - E);
        switch (!0) {
          case R >= 0:
            R = 1;
            break;
          case R < 0:
            R = -1;
            break;
        }
        return w = Math.abs(w) * A, b = b * R, {
          distances: w,
          weights: b
        };
      }
      x(p, "getSegmentWeights"), u.startBatch();
      for (const g of Object.values(u.edges()))
        if (g.data?.()) {
          const { x: m, y: v } = g.source().position(), { x: y, y: b } = g.target().position();
          if (m !== y && v !== b) {
            const w = g.sourceEndpoint(), T = g.targetEndpoint(), { sourceDir: E } = dj(g), [L, k] = uc(E) ? [w.x, T.y] : [T.x, w.y], { weights: C, distances: A } = p(w, T, L, k);
            g.style("segment-distances", A), g.style("segment-weights", C);
          }
        }
      u.endBatch(), f.run();
    }), f.run(), u.ready((p) => {
      ie.info("Ready", p), o(u);
    });
  });
}
x(Tj, "layoutArchitecture");
var T$e = /* @__PURE__ */ x(async (t, e, r, n) => {
  const i = n.db, a = i.getServices(), s = i.getJunctions(), o = i.getGroups(), l = i.getEdges(), u = i.getDataStructures(), h = ll(e), d = h.append("g");
  d.attr("class", "architecture-edges");
  const f = h.append("g");
  f.attr("class", "architecture-services");
  const p = h.append("g");
  p.attr("class", "architecture-groups"), await b$e(i, f, a), w$e(i, f, s);
  const g = await Tj(a, s, o, l, i, u);
  await y$e(d, g, i), await x$e(p, g, i), vj(i, g), og(void 0, h, i.getConfigField("padding"), i.getConfigField("useMaxWidth"));
}, "draw"), E$e = { draw: T$e }, k$e = {
  parser: pj,
  get db() {
    return new fj();
  },
  renderer: E$e,
  styles: v$e
};
const S$e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: k$e
}, Symbol.toStringTag, { value: "Module" }));
var Ej = class {
  constructor() {
    this.nodes = [], this.levels = /* @__PURE__ */ new Map(), this.outerNodes = [], this.classes = /* @__PURE__ */ new Map(), this.setAccTitle = Cn, this.getAccTitle = Gn, this.setDiagramTitle = Zn, this.getDiagramTitle = Ln, this.getAccDescription = Un, this.setAccDescription = Vn;
  }
  static {
    x(this, "TreeMapDB");
  }
  getNodes() {
    return this.nodes;
  }
  getConfig() {
    const t = ur, e = pr();
    return Hi({
      ...t.treemap,
      ...e.treemap ?? {}
    });
  }
  addNode(t, e) {
    this.nodes.push(t), this.levels.set(t, e), e === 0 && (this.outerNodes.push(t), this.root ??= t);
  }
  getRoot() {
    return { name: "", children: this.outerNodes };
  }
  addClass(t, e) {
    const r = this.classes.get(t) ?? { id: t, styles: [], textStyles: [] }, n = e.replace(/\\,/g, "").replace(/,/g, ";").replace(//g, ",").split(";");
    n && n.forEach((i) => {
      DE(i) && (r?.textStyles ? r.textStyles.push(i) : r.textStyles = [i]), r?.styles ? r.styles.push(i) : r.styles = [i];
    }), this.classes.set(t, r);
  }
  getClasses() {
    return this.classes;
  }
  getStylesForClass(t) {
    return this.classes.get(t)?.styles ?? [];
  }
  clear() {
    _n(), this.nodes = [], this.levels = /* @__PURE__ */ new Map(), this.outerNodes = [], this.classes = /* @__PURE__ */ new Map(), this.root = void 0;
  }
};
function kj(t) {
  if (!t.length)
    return [];
  const e = [], r = [];
  return t.forEach((n) => {
    const i = {
      name: n.name,
      children: n.type === "Leaf" ? void 0 : []
    };
    for (i.classSelector = n?.classSelector, n?.cssCompiledStyles && (i.cssCompiledStyles = [n.cssCompiledStyles]), n.type === "Leaf" && n.value !== void 0 && (i.value = n.value); r.length > 0 && r[r.length - 1].level >= n.level; )
      r.pop();
    if (r.length === 0)
      e.push(i);
    else {
      const a = r[r.length - 1].node;
      a.children ? a.children.push(i) : a.children = [i];
    }
    n.type !== "Leaf" && r.push({ node: i, level: n.level });
  }), e;
}
x(kj, "buildHierarchy");
var C$e = /* @__PURE__ */ x((t, e) => {
  nh(t, e);
  const r = [];
  for (const a of t.TreemapRows ?? [])
    a.$type === "ClassDefStatement" && e.addClass(a.className ?? "", a.styleText ?? "");
  for (const a of t.TreemapRows ?? []) {
    const s = a.item;
    if (!s)
      continue;
    const o = a.indent ? parseInt(a.indent) : 0, l = A$e(s), u = s.classSelector ? e.getStylesForClass(s.classSelector) : [], h = u.length > 0 ? u.join(";") : void 0, d = {
      level: o,
      name: l,
      type: s.$type,
      value: s.value,
      classSelector: s.classSelector,
      cssCompiledStyles: h
    };
    r.push(d);
  }
  const n = kj(r), i = /* @__PURE__ */ x((a, s) => {
    for (const o of a)
      e.addNode(o, s), o.children && o.children.length > 0 && i(o.children, s + 1);
  }, "addNodesRecursively");
  i(n, 0);
}, "populate"), A$e = /* @__PURE__ */ x((t) => t.name ? String(t.name) : "", "getItemName"), Sj = {
  // @ts-expect-error - TreeMapDB is not assignable to DiagramDB
  parser: { yy: void 0 },
  parse: /* @__PURE__ */ x(async (t) => {
    try {
      const r = await Lc("treemap", t);
      ie.debug("Treemap AST:", r);
      const n = Sj.parser?.yy;
      if (!(n instanceof Ej))
        throw new Error(
          "parser.parser?.yy was not a TreemapDB. This is due to a bug within Mermaid, please report this issue at https://github.com/mermaid-js/mermaid/issues."
        );
      C$e(r, n);
    } catch (e) {
      throw ie.error("Error parsing treemap:", e), e;
    }
  }, "parse")
}, _$e = 10, Lh = 10, Vf = 25, L$e = /* @__PURE__ */ x((t, e, r, n) => {
  const i = n.db, a = i.getConfig(), s = a.padding ?? _$e, o = i.getDiagramTitle(), l = i.getRoot(), { themeVariables: u } = pr();
  if (!l)
    return;
  const h = o ? 30 : 0, d = ll(e), f = a.nodeWidth ? a.nodeWidth * Lh : 960, p = a.nodeHeight ? a.nodeHeight * Lh : 500, g = f, m = p + h;
  d.attr("viewBox", `0 0 ${g} ${m}`), Xi(d, m, g, a.useMaxWidth);
  let v;
  try {
    const S = a.valueFormat || ",";
    if (S === "$0,0")
      v = /* @__PURE__ */ x((M) => "$" + jc(",")(M), "valueFormat");
    else if (S.startsWith("$") && S.includes(",")) {
      const M = /\.\d+/.exec(S), N = M ? M[0] : "";
      v = /* @__PURE__ */ x((D) => "$" + jc("," + N)(D), "valueFormat");
    } else if (S.startsWith("$")) {
      const M = S.substring(1);
      v = /* @__PURE__ */ x((N) => "$" + jc(M || "")(N), "valueFormat");
    } else
      v = jc(S);
  } catch (S) {
    ie.error("Error creating format function:", S), v = jc(",");
  }
  const y = hu().range([
    "transparent",
    u.cScale0,
    u.cScale1,
    u.cScale2,
    u.cScale3,
    u.cScale4,
    u.cScale5,
    u.cScale6,
    u.cScale7,
    u.cScale8,
    u.cScale9,
    u.cScale10,
    u.cScale11
  ]), b = hu().range([
    "transparent",
    u.cScalePeer0,
    u.cScalePeer1,
    u.cScalePeer2,
    u.cScalePeer3,
    u.cScalePeer4,
    u.cScalePeer5,
    u.cScalePeer6,
    u.cScalePeer7,
    u.cScalePeer8,
    u.cScalePeer9,
    u.cScalePeer10,
    u.cScalePeer11
  ]), w = hu().range([
    u.cScaleLabel0,
    u.cScaleLabel1,
    u.cScaleLabel2,
    u.cScaleLabel3,
    u.cScaleLabel4,
    u.cScaleLabel5,
    u.cScaleLabel6,
    u.cScaleLabel7,
    u.cScaleLabel8,
    u.cScaleLabel9,
    u.cScaleLabel10,
    u.cScaleLabel11
  ]);
  o && d.append("text").attr("x", g / 2).attr("y", h / 2).attr("class", "treemapTitle").attr("text-anchor", "middle").attr("dominant-baseline", "middle").text(o);
  const T = d.append("g").attr("transform", `translate(0, ${h})`).attr("class", "treemapContainer"), E = bE(l).sum((S) => S.value ?? 0).sort((S, M) => (M.value ?? 0) - (S.value ?? 0)), k = Rte().size([f, p]).paddingTop(
    (S) => S.children && S.children.length > 0 ? Vf + Lh : 0
  ).paddingInner(s).paddingLeft((S) => S.children && S.children.length > 0 ? Lh : 0).paddingRight((S) => S.children && S.children.length > 0 ? Lh : 0).paddingBottom((S) => S.children && S.children.length > 0 ? Lh : 0).round(!0)(E), C = k.descendants().filter((S) => S.children && S.children.length > 0), A = T.selectAll(".treemapSection").data(C).enter().append("g").attr("class", "treemapSection").attr("transform", (S) => `translate(${S.x0},${S.y0})`);
  A.append("rect").attr("width", (S) => S.x1 - S.x0).attr("height", Vf).attr("class", "treemapSectionHeader").attr("fill", "none").attr("fill-opacity", 0.6).attr("stroke-width", 0.6).attr("style", (S) => S.depth === 0 ? "display: none;" : ""), A.append("clipPath").attr("id", (S, M) => `clip-section-${e}-${M}`).append("rect").attr("width", (S) => Math.max(0, S.x1 - S.x0 - 12)).attr("height", Vf), A.append("rect").attr("width", (S) => S.x1 - S.x0).attr("height", (S) => S.y1 - S.y0).attr("class", (S, M) => `treemapSection section${M}`).attr("fill", (S) => y(S.data.name)).attr("fill-opacity", 0.6).attr("stroke", (S) => b(S.data.name)).attr("stroke-width", 2).attr("stroke-opacity", 0.4).attr("style", (S) => {
    if (S.depth === 0)
      return "display: none;";
    const M = St({ cssCompiledStyles: S.data.cssCompiledStyles });
    return M.nodeStyles + ";" + M.borderStyles.join(";");
  }), A.append("text").attr("class", "treemapSectionLabel").attr("x", 6).attr("y", Vf / 2).attr("dominant-baseline", "middle").text((S) => S.depth === 0 ? "" : S.data.name).attr("font-weight", "bold").attr("style", (S) => {
    if (S.depth === 0)
      return "display: none;";
    const M = "dominant-baseline: middle; font-size: 12px; fill:" + w(S.data.name) + "; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;", N = St({ cssCompiledStyles: S.data.cssCompiledStyles });
    return M + N.labelStyles.replace("color:", "fill:");
  }).each(function(S) {
    if (S.depth === 0)
      return;
    const M = Qe(this), N = S.data.name;
    M.text(N);
    const D = S.x1 - S.x0, I = 6;
    let B;
    a.showValues !== !1 && S.value ? B = D - 10 - 30 - 10 - I : B = D - I - 6;
    const F = Math.max(15, B), V = M.node();
    if (V.getComputedTextLength() > F) {
      let q = N;
      for (; q.length > 0; ) {
        if (q = N.substring(0, q.length - 1), q.length === 0) {
          M.text("..."), V.getComputedTextLength() > F && M.text("");
          break;
        }
        if (M.text(q + "..."), V.getComputedTextLength() <= F)
          break;
      }
    }
  }), a.showValues !== !1 && A.append("text").attr("class", "treemapSectionValue").attr("x", (S) => S.x1 - S.x0 - 10).attr("y", Vf / 2).attr("text-anchor", "end").attr("dominant-baseline", "middle").text((S) => S.value ? v(S.value) : "").attr("font-style", "italic").attr("style", (S) => {
    if (S.depth === 0)
      return "display: none;";
    const M = "text-anchor: end; dominant-baseline: middle; font-size: 10px; fill:" + w(S.data.name) + "; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;", N = St({ cssCompiledStyles: S.data.cssCompiledStyles });
    return M + N.labelStyles.replace("color:", "fill:");
  });
  const R = k.leaves(), _ = T.selectAll(".treemapLeafGroup").data(R).enter().append("g").attr("class", (S, M) => `treemapNode treemapLeafGroup leaf${M}${S.data.classSelector ? ` ${S.data.classSelector}` : ""}x`).attr("transform", (S) => `translate(${S.x0},${S.y0})`);
  _.append("rect").attr("width", (S) => S.x1 - S.x0).attr("height", (S) => S.y1 - S.y0).attr("class", "treemapLeaf").attr("fill", (S) => S.parent ? y(S.parent.data.name) : y(S.data.name)).attr("style", (S) => St({ cssCompiledStyles: S.data.cssCompiledStyles }).nodeStyles).attr("fill-opacity", 0.3).attr("stroke", (S) => S.parent ? y(S.parent.data.name) : y(S.data.name)).attr("stroke-width", 3), _.append("clipPath").attr("id", (S, M) => `clip-${e}-${M}`).append("rect").attr("width", (S) => Math.max(0, S.x1 - S.x0 - 4)).attr("height", (S) => Math.max(0, S.y1 - S.y0 - 4)), _.append("text").attr("class", "treemapLabel").attr("x", (S) => (S.x1 - S.x0) / 2).attr("y", (S) => (S.y1 - S.y0) / 2).attr("style", (S) => {
    const M = "text-anchor: middle; dominant-baseline: middle; font-size: 38px;fill:" + w(S.data.name) + ";", N = St({ cssCompiledStyles: S.data.cssCompiledStyles });
    return M + N.labelStyles.replace("color:", "fill:");
  }).attr("clip-path", (S, M) => `url(#clip-${e}-${M})`).text((S) => S.data.name).each(function(S) {
    const M = Qe(this), N = S.x1 - S.x0, D = S.y1 - S.y0, I = M.node(), B = 4, z = N - 2 * B, F = D - 2 * B;
    if (z < 10 || F < 10) {
      M.style("display", "none");
      return;
    }
    let V = parseInt(M.style("font-size"), 10);
    const H = 8, J = 28, q = 0.6, ae = 6, re = 2;
    for (; I.getComputedTextLength() > z && V > H; )
      V--, M.style("font-size", `${V}px`);
    let pe = Math.max(
      ae,
      Math.min(J, Math.round(V * q))
    ), K = V + re + pe;
    for (; K > F && V > H && (V--, pe = Math.max(
      ae,
      Math.min(J, Math.round(V * q))
    ), !(pe < ae && V === H)); )
      M.style("font-size", `${V}px`), K = V + re + pe;
    M.style("font-size", `${V}px`), (I.getComputedTextLength() > z || V < H || F < V) && M.style("display", "none");
  }), a.showValues !== !1 && _.append("text").attr("class", "treemapValue").attr("x", (M) => (M.x1 - M.x0) / 2).attr("y", function(M) {
    return (M.y1 - M.y0) / 2;
  }).attr("style", (M) => {
    const N = "text-anchor: middle; dominant-baseline: hanging; font-size: 28px;fill:" + w(M.data.name) + ";", D = St({ cssCompiledStyles: M.data.cssCompiledStyles });
    return N + D.labelStyles.replace("color:", "fill:");
  }).attr("clip-path", (M, N) => `url(#clip-${e}-${N})`).text((M) => M.value ? v(M.value) : "").each(function(M) {
    const N = Qe(this), D = this.parentNode;
    if (!D) {
      N.style("display", "none");
      return;
    }
    const I = Qe(D).select(".treemapLabel");
    if (I.empty() || I.style("display") === "none") {
      N.style("display", "none");
      return;
    }
    const B = parseFloat(I.style("font-size")), z = 28, F = 0.6, V = 6, H = 2, J = Math.max(
      V,
      Math.min(z, Math.round(B * F))
    );
    N.style("font-size", `${J}px`);
    const ae = (M.y1 - M.y0) / 2 + B / 2 + H;
    N.attr("y", ae);
    const re = M.x1 - M.x0, Z = M.y1 - M.y0 - 4, X = re - 8;
    N.node().getComputedTextLength() > X || ae + J > Z || J < V ? N.style("display", "none") : N.style("display", null);
  });
  const P = a.diagramPadding ?? 8;
  rh(d, P, "flowchart", a?.useMaxWidth || !1);
}, "draw"), R$e = /* @__PURE__ */ x(function(t, e) {
  return e.db.getClasses();
}, "getClasses"), M$e = { draw: L$e, getClasses: R$e }, N$e = {
  sectionStrokeColor: "black",
  sectionStrokeWidth: "1",
  sectionFillColor: "#efefef",
  leafStrokeColor: "black",
  leafStrokeWidth: "1",
  leafFillColor: "#efefef",
  labelColor: "black",
  labelFontSize: "12px",
  valueFontSize: "10px",
  valueColor: "black",
  titleColor: "black",
  titleFontSize: "14px"
}, I$e = /* @__PURE__ */ x(({
  treemap: t
} = {}) => {
  const e = Hi(N$e, t);
  return `
  .treemapNode.section {
    stroke: ${e.sectionStrokeColor};
    stroke-width: ${e.sectionStrokeWidth};
    fill: ${e.sectionFillColor};
  }
  .treemapNode.leaf {
    stroke: ${e.leafStrokeColor};
    stroke-width: ${e.leafStrokeWidth};
    fill: ${e.leafFillColor};
  }
  .treemapLabel {
    fill: ${e.labelColor};
    font-size: ${e.labelFontSize};
  }
  .treemapValue {
    fill: ${e.valueColor};
    font-size: ${e.valueFontSize};
  }
  .treemapTitle {
    fill: ${e.titleColor};
    font-size: ${e.titleFontSize};
  }
  `;
}, "getStyles"), D$e = I$e, O$e = {
  parser: Sj,
  get db() {
    return new Ej();
  },
  renderer: M$e,
  styles: D$e
};
const P$e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: O$e
}, Symbol.toStringTag, { value: "Module" })), B$e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  InfoModule: DW,
  createInfoServices: OW
}, Symbol.toStringTag, { value: "Module" })), F$e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PacketModule: PW,
  createPacketServices: BW
}, Symbol.toStringTag, { value: "Module" })), $$e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PieModule: FW,
  createPieServices: $W
}, Symbol.toStringTag, { value: "Module" })), z$e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArchitectureModule: zW,
  createArchitectureServices: GW
}, Symbol.toStringTag, { value: "Module" })), G$e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GitGraphModule: NW,
  createGitGraphServices: IW
}, Symbol.toStringTag, { value: "Module" })), V$e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RadarModule: VW,
  createRadarServices: UW
}, Symbol.toStringTag, { value: "Module" })), U$e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TreemapModule: qW,
  createTreemapServices: WW
}, Symbol.toStringTag, { value: "Module" }));
export {
  tze as Mermaid
};
